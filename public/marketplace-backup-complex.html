<!DOCTYPE html>
<html lang="he" dir="rtl">
    <!-- Updated: 2024-12-28 21:50:00 -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AutoPage Marketplace</title>
    <link rel="stylesheet" href="/css/tailwind.css">
    <style>
        .hero-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .page-card {
            transition: all 0.3s ease;
        }
        .page-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .ai-bot-bubble {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer !important;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            z-index: 1000;
            transition: all 0.3s ease;
            pointer-events: auto !important;
        }
        
        .ai-bot-bubble:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
        }
        
        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }
            100% {
                background-position: 200% 0;
            }
        }
        
        .ai-chat-window {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 350px;
            height: 500px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        
        .ai-chat-window.active {
            display: flex;
        }
        
        .ai-chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .ai-chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: #f8f9fa;
        }
        
        .page-preview{
            margin-top: 15px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            width: 100% !important;
            max-width: 100% !important;
            height: 300px !important;
            text-align: right !important;
            direction: rtl !important;
            display: block !important;
            align-self: flex-end !important;
        }
        
        .preview-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            font-weight: 600;
        }
        
        .preview-header h3 {
            margin: 0;
            font-size: 16px;
        }
        
        .preview-content {
            padding: 0;
            background: white;
        }
        
        .preview-content iframe {
            border: none;
            border-radius: 0 0 12px 12px;
        }
        
        .ai-message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 10px;
            max-width: 80%;
        }
        
        .ai-message.user {
            background: #667eea;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .ai-message.bot {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
            margin-left: auto;
            margin-right: 0;
            text-align: right !important;
            direction: rtl !important;
            display: block !important;
            width: 100% !important;
            padding: 12px 16px !important;
            text-align: right !important;
            align-self: flex-end !important;
            max-width: none !important;
        }
        
        .typing-text {
            display: inline-block;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .ai-chat-input {
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }
        
        .ai-chat-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
        }
        
        .ai-chat-input button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        
        .typing-dots {
            animation: typing 1.5s infinite;
        }
        
        @keyframes typing {
            0%, 60%, 100% { opacity: 0; }
            30% { opacity: 1; }
        }

        /* Stav typing animation with spinning loader */
        .stav-typing-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            font-style: italic;
            color: #6b7280;
        }
        
        .stav-loader {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            perspective: 300px;
            position: relative;
            flex-shrink: 0;
        }
        
        .stav-loader .inner {
            position: absolute;
            box-sizing: border-box;
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }
        
        .stav-loader .inner.one {
            left: 0%;
            top: 0%;
            animation: stav-rotate-one 1.5s linear infinite;
            border-bottom: 3px solid #8b5cf6;
        }
        
        .stav-loader .inner.two {
            right: 0%;
            top: 0%;
            animation: stav-rotate-two 1.5s linear infinite;
            border-right: 3px solid #ec4899;
        }
        
        .stav-loader .inner.three {
            right: 0%;
            bottom: 0%;
            animation: stav-rotate-three 1.5s linear infinite;
            border-top: 3px solid #3b82f6;
        }
        
        @keyframes stav-rotate-one {
            0% { transform: rotateX(35deg) rotateY(-45deg) rotateZ(0deg); }
            100% { transform: rotateX(35deg) rotateY(-45deg) rotateZ(360deg); }
        }
        
        @keyframes stav-rotate-two {
            0% { transform: rotateX(50deg) rotateY(10deg) rotateZ(0deg); }
            100% { transform: rotateX(50deg) rotateY(10deg) rotateZ(360deg); }
        }
        
        @keyframes stav-rotate-three {
            0% { transform: rotateX(35deg) rotateY(55deg) rotateZ(0deg); }
            100% { transform: rotateX(35deg) rotateY(55deg) rotateZ(360deg); }
        }

        /* === STAV CHAT WINDOW === */
        .stav-chat-window {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .stav-chat-window.active {
            display: flex;
        }
        
        .stav-chat-container {
            width: 95%;
            max-width: 1400px;
            height: 90%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .stav-chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stav-chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8fafc;
        }
        
        .stav-message {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
        }
        
        .stav-message.user {
            background: #667eea;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .stav-message.bot {
            background: white;
            color: #333;
            margin-left: auto;
            margin-right: 0;
            text-align: right !important;
            direction: rtl !important;
            display: block !important;
            width: 100% !important;
            border: 1px solid #e5e7eb;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 12px 16px !important;
            text-align: right !important;
            align-self: flex-end !important;
            max-width: none !important;
        }
        
        .typing-text {
            display: inline-block;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .stav-chat-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 10px;
        }
        
        .stav-chat-input input {
            flex: 1;
            padding: 15px;
            border: 2px solid #e5e7eb;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }
        
        .stav-chat-input input:focus {
            border-color: #667eea;
        }
        
        .stav-chat-input button {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .stav-chat-input button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Hero Header with Purple Background -->
    <div class="hero-gradient text-white">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
            <div class="text-center">
                <h1 class="text-4xl md:text-6xl font-bold mb-4">AutoPage Marketplace</h1>
                <p class="text-xl md:text-2xl mb-8 opacity-90">׳׳¦׳ ׳׳× ׳”׳“׳£ ׳”׳׳•׳©׳׳ ׳©׳׳</p>
                
                <!-- Search Bar -->
                <div class="max-w-2xl mx-auto mb-8">
                    <div class="relative">
                        <input type="text" id="search-input" placeholder="׳—׳₪׳© ׳“׳₪׳™׳, ׳¢׳¡׳§׳™׳, ׳©׳™׳¨׳•׳×׳™׳..." 
                               class="w-full px-6 py-4 text-gray-900 text-lg rounded-full focus:ring-4 focus:ring-white focus:ring-opacity-50 focus:outline-none">
                        <button onclick="searchPages()" class="absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- Create Page Button -->
                <div class="flex justify-center gap-4">
                    <button onclick="goToFullApp()" class="bg-white text-indigo-600 px-8 py-4 rounded-full font-bold text-lg hover:bg-gray-100 transition-all transform hover:scale-105 flex items-center gap-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                        </svg>
                        ׳¦׳•׳¨ ׳“׳£ ׳¢׳›׳©׳™׳•
                    </button>
                    <button onclick="if(typeof toggleStavChat === 'function') toggleStavChat(); else console.error('toggleStavChat not loaded yet');" class="bg-purple-600 text-white px-8 py-4 rounded-full font-bold text-lg hover:bg-purple-700 transition-all transform hover:scale-105 flex items-center gap-2">
                        נ₪– ׳¡׳×׳™׳•
                    </button>
                </div>
                
                <!-- View Toggle Buttons -->
                <div class="flex justify-center gap-2 mt-4">
                    <button id="grid-view-btn" onclick="setView('grid')" class="p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path>
                        </svg>
                    </button>
                    <button id="table-view-btn" onclick="setView('table')" class="p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Filter Buttons -->
    <div class="bg-white border-b">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
            <div class="flex flex-wrap justify-center gap-3">
                <button onclick="filterByType('all')" class="px-6 py-3 bg-indigo-500 text-white rounded-full hover:bg-indigo-600 transition-all">׳”׳›׳</button>
                <button onclick="filterByType('store')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">נ× ׳—׳ ׳•׳™׳•׳×</button>
                <button onclick="filterByType('event')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">נ‰ ׳׳™׳¨׳•׳¢׳™׳</button>
                <button onclick="filterByType('course')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">נ“ ׳§׳•׳¨׳¡׳™׳</button>
                <button onclick="filterByType('serviceProvider')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">נ”§ ׳‘׳¢׳׳™ ׳׳§׳¦׳•׳¢</button>
            </div>
            <div class="text-center mt-4">
                <p id="pages-count" class="text-gray-600">׳˜׳•׳¢׳ ׳“׳₪׳™׳...</p>
            </div>
        </div>
    </div>

    <!-- Loading State -->
    <div id="loading-state" class="text-center py-12">
        <div class="text-lg text-gray-600">׳˜׳•׳¢׳ ׳“׳₪׳™׳...</div>
    </div>

    <!-- Pages Grid -->
    <div id="pages-grid" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- Pages will be loaded here -->
    </div>
    
    <!-- Pages Table -->
    <div id="pages-table" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 hidden">
        <div class="bg-white shadow overflow-hidden sm:rounded-md">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">׳×׳׳•׳ ׳”</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">׳›׳•׳×׳¨׳×</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">׳¡׳•׳’</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">׳×׳™׳׳•׳¨</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">׳×׳׳¨׳™׳ ׳™׳¦׳™׳¨׳”</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">׳₪׳¢׳•׳׳•׳×</th>
                    </tr>
                </thead>
                <tbody id="table-body" class="bg-white divide-y divide-gray-200">
                    <!-- Table rows will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Stav Chat Window (Main Bot) -->
    <div class="stav-chat-window" id="stavChatWindow">
        <div class="stav-chat-container">
            <div class="stav-chat-header">
                <h2>נ₪– ׳¡׳×׳™׳•</h2>
                <button onclick="if(typeof toggleStavChat === 'function') toggleStavChat();" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">ֳ—</button>
            </div>
        <div class="stav-chat-messages" id="stavChatMessages">
            <div class="stav-message bot">
                ׳©׳׳•׳, ׳׳” ׳©׳׳•׳׳?
            </div>
        </div>
            <div class="stav-chat-input">
                <button id="micButton" onclick="toggleSpeechRecognition()" style="background: #667eea; color: white; border: none; padding: 15px; border-radius: 8px; margin-left: 10px; cursor: pointer; font-size: 20px;">נ₪</button>
                <input type="text" id="stavChatInput" placeholder="׳›׳×׳•׳‘ ׳”׳•׳“׳¢׳” ׳׳• ׳׳—׳¥ ׳¢׳ ׳”׳׳™׳§׳¨׳•׳₪׳•׳...">
                <button onclick="sendStavMessage()">׳©׳׳—</button>
            </div>
        </div>
    </div>

    <!-- Responsive overrides for Stav chat (marketplace) -->
    <style>
        .stav-chat-window { z-index: 9999; position: fixed; right: 24px; bottom: 24px; }
        .stav-chat-window.fullscreen { inset: 0 !important; right: 0 !important; left: 0 !important; top: 0 !important; bottom: 0 !important; width: 100vw !important; height: 100vh !important; margin: 0 !important; padding: 0 !important; }
        .stav-chat-container { display: flex !important; flex-direction: column !important; }
        .stav-chat-window.fullscreen .stav-chat-container { width: 100% !important; max-width: none !important; height: 100% !important; margin: 0 !important; border-radius: 0 !important; }
        .stav-chat-header { flex: 0 0 auto !important; }
        .stav-chat-messages { flex: 1 1 auto !important; overflow-y: auto !important; }
        .stav-chat-input { flex: 0 0 auto !important; }
        @media (max-width: 640px) {
            .stav-chat-window { left: 4vw; right: 4vw; bottom: calc(16px + env(safe-area-inset-bottom)); }
            .stav-chat-container { width: 100%; max-height: min(70vh, 560px); border-radius: 16px; overflow: hidden; }
            .stav-chat-messages { max-height: none !important; }
            .stav-chat-input { padding-bottom: max(8px, env(safe-area-inset-bottom)); }
        }
    </style>

    <!-- AI Search Bot (Old Marketplace Bot - Keep for legacy) -->
    <div class="ai-bot-bubble" id="aiBotBubble" title="׳¢׳–׳¨׳” ׳—׳›׳׳”" onclick="toggleAIChat()" style="cursor: pointer !important; pointer-events: auto !important; display: none;">
        נ₪–
    </div>

    <div class="ai-chat-window" id="aiChatWindow" style="display: none;">
        <div class="ai-chat-header">
            <span>נ₪– ׳”׳¢׳•׳–׳¨׳× ׳”׳—׳›׳׳”</span>
            <button id="closeAiChat" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">ֳ—</button>
        </div>
        <div class="ai-chat-messages" id="aiChatMessages">
        </div>
        <div class="ai-chat-input">
            <input type="text" id="aiChatInput" placeholder="׳›׳×׳•׳‘ ׳”׳•׳“׳¢׳”...">
            <button onclick="sendAIMessage()">׳©׳׳—</button>
        </div>
    </div>

    <script>
        // --- N8N Webhook URL (single source of truth) ---
        const N8N_WEBHOOK_URL = 'https://n8n-service-how4.onrender.com/webhook/jhfuhgufkhlkuho8erhf757754jhldkbsjkbmreketpg';
        
        // --- Local fallback logic to avoid repeating the same greeting and answer simple queries ---
        let stavFirstReplySent = false;
        function stavLocalFallbackReply(message) {
            // MINIMAL fallback - only for basic greetings when N8N completely fails
            // All other queries should be handled by N8N
            try {
                const raw = (message || '').toString();
                const msg = raw.trim();

                // Only handle basic greetings - everything else should go to N8N
                if (/^(׳”׳™׳™|׳”׳™|׳©׳׳•׳)[!\s\u200f\u200e]*$/i.test(msg)) {
                    return stavFirstReplySent
                        ? '׳”׳™׳™! נ˜'
                        : '׳”׳™׳™! נ˜';
                }

                // Minimal fallback for everything else - just acknowledge
                // All queries should be handled by N8N, not here
                return '׳ ׳¡׳”/׳™ ׳©׳•׳‘ ׳׳• ׳›׳×׳•׳‘/׳™ ׳׳” ׳׳×/׳” ׳׳—׳₪׳©/׳×.';
            } catch (_) {
                return '׳ ׳¡׳”/׳™ ׳©׳•׳‘ ׳׳• ׳›׳×׳•׳‘/׳™ ׳׳” ׳׳×/׳” ׳׳—׳₪׳©/׳×.';
            }
        }
        const AI_WEBHOOK = N8N_WEBHOOK_URL; // Use the same N8N webhook
        
        // Simple toggle function
        function toggleAIChat() {
            console.log('נ”§ toggleAIChat called');
            const chatWindow = document.getElementById('aiChatWindow');
            if (chatWindow) {
                chatWindow.classList.toggle('active');
                console.log('נ”§ Chat window toggled, active:', chatWindow.classList.contains('active'));
                
                if (chatWindow.classList.contains('active')) {
                    const input = document.getElementById('aiChatInput');
                    if (input) {
                        input.focus();
                    }
                }
            } else {
                console.error('ג Chat window not found');
            }
        }
        
        // Add event listener for AI bot bubble
        document.addEventListener('DOMContentLoaded', function() {
            const aiBotBubble = document.getElementById('aiBotBubble');
            if (aiBotBubble) {
                aiBotBubble.addEventListener('click', toggleAIChat);
                aiBotBubble.addEventListener('touchstart', toggleAIChat);
            }
            
            const closeAiChat = document.getElementById('closeAiChat');
            if (closeAiChat) {
                closeAiChat.addEventListener('click', toggleAIChat);
            }
        });
        
        // Also add click event directly to the bubble
        function addBotBubbleClick() {
            const aiBotBubble = document.getElementById('aiBotBubble');
            if (aiBotBubble) {
                aiBotBubble.onclick = toggleAIChat;
                aiBotBubble.addEventListener('click', toggleAIChat);
                aiBotBubble.addEventListener('touchstart', toggleAIChat);
            }
        }
        
        // Call the function after DOM is loaded
        setTimeout(addBotBubbleClick, 1000);
        
        // Also try to add click event after page loads
        window.addEventListener('load', function() {
            const aiBotBubble = document.getElementById('aiBotBubble');
            if (aiBotBubble) {
                aiBotBubble.onclick = toggleAIChat;
                aiBotBubble.addEventListener('click', toggleAIChat);
            }
        });
        
        function addAIMessage(message, isUser = false) {
            const messagesDiv = document.getElementById('aiChatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${isUser ? 'user' : 'bot'}`;
            
            if (isUser) {
                messageDiv.textContent = message;
            } else {
                // Convert markdown-style links to clickable links
                let processedMessage = message.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, text, url) => {
                    // Make sure URL is full URL (add origin if needed)
                    const fullUrl = url.startsWith('http') ? url : (url.startsWith('/') ? `${window.location.origin}${url}` : url);
                    return `<a href="${fullUrl}" target="_blank" onclick="event.preventDefault(); window.open('${fullUrl}', '_blank'); return false;" style="color: #667eea; text-decoration: underline; cursor: pointer;">${text}</a>`;
                });
                
                // נ¯ FIX: Also convert plain text links like "נ”— ׳¦׳₪׳” ׳‘׳“׳£: /users/..." to clickable links
                // Match patterns like "נ”— ׳¦׳₪׳” ׳‘׳“׳£: /users/..." or "׳¦׳₪׳” ׳‘׳“׳£: /users/..."
                processedMessage = processedMessage.replace(
                    /(נ”—\s*)?׳¦׳₪׳”\s+׳‘׳“׳£\s*:\s*(\/users\/[^\s\)<>]+)/g,
                    (match, emoji, url) => {
                        const fullUrl = url.startsWith('http') ? url : `${window.location.origin}${url}`;
                        return `<a href="${fullUrl}" target="_blank" onclick="event.preventDefault(); window.open('${fullUrl}', '_blank'); return false;" style="color: #667eea; text-decoration: underline; cursor: pointer;">נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£</a>`;
                    }
                );
                
                // Also match standalone URLs like "/users/..." at the end of sentences (but not already in links)
                processedMessage = processedMessage.replace(
                    /(\/users\/[^\s\)<>]+)(?![^<]*<\/a>)/g,
                    (match, url) => {
                        // Make sure it's not already a link
                        if (!processedMessage.includes(`<a href="${url}"`)) {
                            const fullUrl = url.startsWith('http') ? url : `${window.location.origin}${url}`;
                            return `<a href="${fullUrl}" target="_blank" onclick="event.preventDefault(); window.open('${fullUrl}', '_blank'); return false;" style="color: #667eea; text-decoration: underline; cursor: pointer;">נ”— ׳¦׳₪׳” ׳‘׳“׳£</a>`;
                        }
                        return match;
                    }
                );
                
                // Add animated typing effect for bot messages
                messageDiv.innerHTML = '<span class="typing-text"></span>';
                messagesDiv.appendChild(messageDiv);
                
                // Animate typing effect
                const typingSpan = messageDiv.querySelector('.typing-text');
                let i = 0;
                const typeMessage = () => {
                    if (i < processedMessage.length) {
                        // Get current position in HTML string
                        const htmlToAdd = processedMessage.substring(0, i + 1);
                        typingSpan.innerHTML = htmlToAdd;
                        
                        // נ¯ FIX: Re-attach click handlers to links after they're added
                        typingSpan.querySelectorAll('a').forEach(link => {
                            if (!link.dataset.handlerAttached) {
                                link.dataset.handlerAttached = 'true';
                                const href = link.getAttribute('href');
                                if (href) {
                                    link.addEventListener('click', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        window.open(href, '_blank');
                                        return false;
                                    });
                                }
                            }
                        });
                        
                        i++;
                        setTimeout(typeMessage, 50); // 50ms delay between characters
                    } else {
                        // After typing is complete, ensure all links have handlers
                        setTimeout(() => {
                            typingSpan.querySelectorAll('a').forEach(link => {
                                if (!link.dataset.handlerAttached) {
                                    link.dataset.handlerAttached = 'true';
                                    const href = link.getAttribute('href');
                                    if (href) {
                                        link.addEventListener('click', (e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            window.open(href, '_blank');
                                            return false;
                                        });
                                    }
                                }
                            });
                        }, 100);
                    }
                };
                typeMessage();
                
                // Fix image URLs to be absolute and add error handling
                processedMessage = processedMessage.replace(/src="([^"]+)"/g, (match, src) => {
                    let fullSrc = src;
                    if (src.startsWith('/')) {
                        fullSrc = `${window.location.origin}${src}`;
                    }
                    return `src="${fullSrc}" onerror="this.style.display='none'" onload="this.style.display='block'"`;
                });
                
                messageDiv.innerHTML = processedMessage;
            }
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function removeTypingIndicator() {
            const messagesDiv = document.getElementById('aiChatMessages');
            if (messagesDiv.lastChild && messagesDiv.lastChild.textContent.includes('׳׳§׳׳™׳“׳”')) {
                messagesDiv.removeChild(messagesDiv.lastChild);
            }
        }
        
        // Utility helpers
        function getNumericPrice(rawPrice) {
            if (rawPrice === null || rawPrice === undefined) return null;
            if (typeof rawPrice === 'number' && !Number.isNaN(rawPrice)) return rawPrice;
            const cleaned = rawPrice
                .toString()
                .replace(/[^0-9.,]/g, '')
                .replace(/,/g, '');
            if (!cleaned) return null;
            const value = parseFloat(cleaned);
            return Number.isNaN(value) ? null : value;
        }

        // Global variables
        let allPages = [];
        let filteredPages = [];
        let currentType = 'all';
        let currentView = 'grid';
        
        // Load pages on page load
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('נ€ Marketplace page loaded');
            try {
            await loadPages();
            } catch (error) {
                console.error('ג Error in DOMContentLoaded:', error);
                const loadingState = document.getElementById('loading-state');
                if (loadingState) {
                    loadingState.innerHTML = `
                        <div class="text-center py-12">
                            <div class="text-red-500 text-lg mb-4">ג ׳©׳’׳™׳׳” ׳‘׳˜׳¢׳™׳ ׳× ׳”׳“׳£</div>
                            <p class="text-gray-600 mb-4">${error.message || '׳©׳’׳™׳׳” ׳׳ ׳™׳“׳•׳¢׳”'}</p>
                            <button onclick="location.reload()" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition">
                                ׳¨׳¢׳ ׳ ׳“׳£
                            </button>
                        </div>
                    `;
                }
            }
        });
        
        // Error handling for unhandled errors
        window.addEventListener('error', function(e) {
            console.error('ג JavaScript error:', e.error);
            const loadingState = document.getElementById('loading-state');
            if (loadingState && loadingState.innerHTML.includes('׳˜׳•׳¢׳')) {
                loadingState.innerHTML = `
                    <div class="text-center py-12">
                        <div class="text-red-500 text-lg mb-4">ג ׳©׳’׳™׳׳× JavaScript</div>
                        <p class="text-gray-600 mb-4">${e.error?.message || '׳©׳’׳™׳׳” ׳׳ ׳™׳“׳•׳¢׳”'}</p>
                        <button onclick="location.reload()" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition">
                            ׳¨׳¢׳ ׳ ׳“׳£
                        </button>
                    </div>
                `;
            }
        });
        
        // Search functionality
        document.getElementById('search-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPages();
            }
        });
        
        async function loadPages() {
            const loadingState = document.getElementById('loading-state');
            const pagesGrid = document.getElementById('pages-grid');
            const pagesTable = document.getElementById('pages-table');
            
            try {
                console.log('נ”„ Loading pages from marketplace API...');
                const response = await fetch('/api/pages/all/marketplace');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('ג… Received data:', data);
                
                // Handle both array and object with pages property
                allPages = Array.isArray(data) ? data : (data.pages || []);
                filteredPages = [...allPages];
                
                console.log('נ“„ Loaded pages:', allPages.length);
                console.log('נ“‹ Page types:', [...new Set(allPages.map(p => p.pageType))]);
                
                if (allPages.length === 0) {
                    if (loadingState) {
                        loadingState.innerHTML = `
                            <div class="text-center py-12">
                                <div class="text-gray-600 text-lg mb-4">׳׳™׳ ׳“׳₪׳™׳ ׳–׳׳™׳ ׳™׳ ׳‘׳׳¨׳§׳˜</div>
                                <button onclick="goToFullApp()" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition">
                                    ׳¦׳•׳¨ ׳“׳£ ׳—׳“׳©
                                </button>
                            </div>
                        `;
                    }
                    return;
                }
                
                displayPages();
                updatePagesCount();
                
                // Hide loading state
                if (loadingState) {
                    loadingState.style.display = 'none';
                }
            } catch (error) {
                console.error('ג Error loading pages:', error);
                if (loadingState) {
                    loadingState.innerHTML = `
                        <div class="text-center py-12">
                            <div class="text-red-500 text-lg mb-4">ג ׳©׳’׳™׳׳” ׳‘׳˜׳¢׳™׳ ׳× ׳”׳“׳₪׳™׳</div>
                            <p class="text-gray-600 mb-4">${error.message || '׳©׳’׳™׳׳” ׳׳ ׳™׳“׳•׳¢׳”'}</p>
                            <button onclick="location.reload()" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition">
                                ׳¨׳¢׳ ׳ ׳“׳£
                            </button>
                        </div>
                    `;
                }
            }
        }
        
        function filterByType(type) {
            currentType = type;
            
            // Update button styles
            document.querySelectorAll('button[onclick^="filterByType"]').forEach(btn => {
                btn.className = 'px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all';
            });
            event.target.className = 'px-6 py-3 bg-indigo-500 text-white rounded-full hover:bg-indigo-600 transition-all';
            
            console.log('Filtering by type:', type);
            console.log('All pages:', allPages);
            console.log('Page types found:', [...new Set(allPages.map(p => p.pageType))]);
            
            if (type === 'all') {
                filteredPages = [...allPages];
            } else {
                filteredPages = allPages.filter(page => {
                    console.log(`Page: ${page.title}, pageType: ${page.pageType}, matches: ${page.pageType === type}`);
                    return page.pageType === type;
                });
            }
            
            console.log('Filtered pages:', filteredPages);
            displayPages();
            updatePagesCount();
        }
        
        async function searchPages() {
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            
            if (searchTerm === '') {
                filteredPages = [...allPages];
            } else {
                // Enhanced search that ALWAYS reads from live pages
                filteredPages = [];
                
                // Extract city and service/product from search term
                const cities = [
                    '׳×׳ ׳׳‘׳™׳‘', '׳™׳¨׳•׳©׳׳™׳', '׳—׳™׳₪׳”', '׳‘׳׳¨ ׳©׳‘׳¢', '׳ ׳×׳ ׳™׳”', '׳׳©׳“׳•׳“', '׳¨׳׳× ׳’׳', '׳₪׳×׳— ׳×׳§׳•׳•׳”', 
                    '׳‘׳ ׳™ ׳‘׳¨׳§', '׳—׳•׳׳•׳', '׳¨׳—׳•׳‘׳•׳×', '׳›׳₪׳¨ ׳¡׳‘׳', '׳׳™׳׳×', '׳¨׳¢׳ ׳ ׳”', '׳”׳¨׳¦׳׳™׳”', '׳—׳“׳¨׳”', 
                    '׳§׳¨׳™׳™׳× ׳‘׳™׳׳׳™׳§', '׳§׳¨׳™׳™׳× ׳׳•׳¦׳§׳™׳', '׳¨׳׳©׳•׳ ׳׳¦׳™׳•׳', '׳ ׳”׳¨׳™׳”', '׳”׳•׳“ ׳”׳©׳¨׳•׳', '׳’׳‘׳¢׳×׳™׳™׳', 
                    '׳§׳¨׳™׳™׳× ׳׳×׳', '׳§׳¨׳™׳™׳× ׳©׳׳•׳ ׳”', '׳‘׳™׳× ׳©׳׳', '׳¢׳₪׳•׳׳”'
                ];
                
                let requiredCity = null;
                let serviceOrProduct = searchTerm;
                
                // Try multiple patterns to extract city
                // Pattern 1: "׳ ׳’׳¨ ׳‘׳ ׳×׳ ׳™׳”" or "׳©׳™׳¨׳•׳× ׳‘׳ ׳×׳ ׳™׳”" (service ׳‘ city)
                const patternWithBe = /([׳-׳×\s]+)\s+׳‘([׳-׳×]+)/;
                const matchWithBe = searchTerm.match(patternWithBe);
                if (matchWithBe && matchWithBe[2]) {
                    const potentialCity = matchWithBe[2].trim();
                    // Check if it's a known city
                    for (const city of cities) {
                        if (city.toLowerCase() === potentialCity.toLowerCase() || 
                            city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                            potentialCity.toLowerCase().includes(city.toLowerCase())) {
                            requiredCity = city;
                            // Extract service/product (what comes before "׳‘")
                            serviceOrProduct = matchWithBe[1].trim();
                            serviceOrProduct = serviceOrProduct.replace(/^(׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”|׳©׳|׳׳×|׳¢׳)\s+/g, '').trim();
                            console.log(`נ™ן¸ Found city (׳‘ pattern): "${city}", service/product: "${serviceOrProduct}"`);
                            break;
                        }
                    }
                    // If no match but it looks like a city (Hebrew word 2-15 chars), use it
                    if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15 && /^[׳-׳×\s]+$/.test(potentialCity)) {
                        requiredCity = potentialCity;
                        serviceOrProduct = matchWithBe[1].trim();
                        serviceOrProduct = serviceOrProduct.replace(/^(׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”|׳©׳|׳׳×|׳¢׳)\s+/g, '').trim();
                        console.log(`נ™ן¸ Found city (new from ׳‘ pattern): "${potentialCity}", service/product: "${serviceOrProduct}"`);
                    }
                }
                if (priceListCategory) {
                    priceListCategory = priceListCategory
                        .replace(/^׳©׳\s+/i, '')
                        .replace(/^(?:׳”)?׳׳—׳™׳¨׳™׳\s+׳©׳\s+/i, '')
                        .replace(/^(?:׳›׳\s+)?(?:׳”)?/i, '')
                        .trim();
                    if (priceListCategory.endsWith('׳©׳')) {
                        priceListCategory = priceListCategory.slice(0, -2).trim();
                    }
                    console.log(`נ“‹ Normalized price list category: "${priceListCategory}"`);
                }

                // Pattern 2: Exact city name in query
                if (!requiredCity) {
                    for (const city of cities) {
                        if (searchTerm.includes(city.toLowerCase())) {
                            requiredCity = city;
                            // Remove city from search term to get service/product
                            serviceOrProduct = searchTerm.replace(city.toLowerCase(), '').trim();
                            // Remove common prepositions
                            serviceOrProduct = serviceOrProduct.replace(/^(׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”|׳©׳|׳׳×|׳¢׳)\s+/g, '').trim();
                            console.log(`נ™ן¸ Found city (exact): "${city}", service/product: "${serviceOrProduct}"`);
                            break;
                        }
                    }
                }
                
                // Pattern 3: "(׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”) ׳¢׳™׳¨" pattern
                if (!requiredCity) {
                    const cityPattern = /(?:׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”)\s+([׳-׳×]{2,})/;
                    const cityMatch = searchTerm.match(cityPattern);
                    if (cityMatch && cityMatch[1]) {
                        const potentialCity = cityMatch[1].trim();
                        // Check if it's a known city (partial match)
                        for (const city of cities) {
                            if (city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                                potentialCity.toLowerCase().includes(city.toLowerCase())) {
                                requiredCity = city;
                                serviceOrProduct = searchTerm.replace(/(?:׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”)\s*[׳-׳×]+/g, '').trim();
                                serviceOrProduct = serviceOrProduct.replace(/^(׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”|׳©׳|׳׳×|׳¢׳)\s+/g, '').trim();
                                console.log(`נ™ן¸ Found city (pattern): "${city}", service/product: "${serviceOrProduct}"`);
                                break;
                            }
                        }
                        // If no match but it looks like a city, use it
                        if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15) {
                            requiredCity = potentialCity;
                            serviceOrProduct = searchTerm.replace(/(?:׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”)\s*[׳-׳×]+/g, '').trim();
                            serviceOrProduct = serviceOrProduct.replace(/^(׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”|׳©׳|׳׳×|׳¢׳)\s+/g, '').trim();
                            console.log(`נ™ן¸ Found city (new): "${potentialCity}", service/product: "${serviceOrProduct}"`);
                        }
                    }
                }
                
                // If service/product is empty after removing city, use full search term
                if (!serviceOrProduct || serviceOrProduct.length < 2) {
                    serviceOrProduct = searchTerm;
                }
                
                // Check if this is a "׳—׳ ׳•׳™׳•׳× ׳‘..." or "׳ ׳•׳×׳ ׳™ ׳©׳¨׳•׳× ׳‘..." query
                const storeCityMatch = searchTerm.match(/׳—׳ ׳•׳™׳•׳×?\s+׳‘\s*([׳-׳×\s]{2,})/);
                const servicesCityMatch = searchTerm.match(/(?:׳ ׳•׳×׳ ׳™\s+׳©׳¨׳•׳×|׳ ׳•׳×׳ ׳™\s+׳©׳™׳¨׳•׳×|׳‘׳¢׳׳™\s+׳׳§׳¦׳•׳¢|׳©׳™׳¨׳•׳×׳™׳)\s+׳‘\s*([׳-׳×\s]{2,})/);
                const isStoresInCityQuery = !!storeCityMatch;
                const isServicesInCityQuery = !!servicesCityMatch;
                const isGeneralStoresQuery = hasStoreKeyword && !isStoresInCityQuery && !isServicesInCityQuery && !hasServiceKeywordInQuery;
                
                if (isStoresInCityQuery || isServicesInCityQuery) {
                    // For "׳—׳ ׳•׳™׳•׳× ׳‘׳ ׳×׳ ׳™׳”" or "׳ ׳•׳×׳ ׳™ ׳©׳¨׳•׳× ׳‘׳ ׳×׳ ׳™׳”" queries (with optional extra words)
                    const rawCityMatch = (storeCityMatch && storeCityMatch[1]) || (servicesCityMatch && servicesCityMatch[1]) || '';
                    if (rawCityMatch) {
                        const queryCity = rawCityMatch.trim().split(/\s+/)[0];
                        if (queryCity) {
                        // Find the city in the cities list
                        for (const city of cities) {
                            if (city.toLowerCase() === queryCity.toLowerCase() || 
                                city.toLowerCase().includes(queryCity.toLowerCase()) || 
                                queryCity.toLowerCase().includes(city.toLowerCase())) {
                                requiredCity = city;
                                // Set service/product based on query type
                                if (isStoresInCityQuery) {
                                    serviceOrProduct = '׳—׳ ׳•׳×'; // Filter for stores
                                } else if (isServicesInCityQuery) {
                                    serviceOrProduct = '׳©׳™׳¨׳•׳×'; // Filter for services
                                }
                                console.log(`נ™ן¸ Special query detected: "${isStoresInCityQuery ? '׳—׳ ׳•׳™׳•׳×' : '׳ ׳•׳×׳ ׳™ ׳©׳¨׳•׳×'}" in "${city}"`);
                                break;
                            }
                        }
                        // If city not found in list, use it as-is
                        if (!requiredCity && queryCity.length >= 2 && queryCity.length <= 15) {
                            requiredCity = queryCity;
                            if (isStoresInCityQuery) {
                                serviceOrProduct = '׳—׳ ׳•׳×';
                            } else if (isServicesInCityQuery) {
                                serviceOrProduct = '׳©׳™׳¨׳•׳×';
                            }
                            console.log(`נ™ן¸ Special query (new city): "${isStoresInCityQuery ? '׳—׳ ׳•׳™׳•׳×' : '׳ ׳•׳×׳ ׳™ ׳©׳¨׳•׳×'}" in "${queryCity}"`);
                            }
                        }
                    }
                }
                
                for (const page of allPages) {
                    let matches = false;
                    
                    // For "׳—׳ ׳•׳™׳•׳×" queries, check if page is a store
                    if ((isStoresInCityQuery || isGeneralStoresQuery) && page.pageType !== 'store') {
                        continue; // Skip non-store pages
                    }
                    
                    // For "׳ ׳•׳×׳ ׳™ ׳©׳¨׳•׳× ׳‘..." queries, check if page is a service provider
                    if (isServicesInCityQuery && page.pageType !== 'serviceProvider') {
                        continue; // Skip non-service pages
                    }
                    
                    // Check title and description for service/product
                    const titleMatch = page.title.toLowerCase().includes(serviceOrProduct);
                    const descriptionMatch = page.description && page.description.toLowerCase().includes(serviceOrProduct);
                    
                    // Check products from metadata (much faster!)
                    let productMatch = false;
                    if (page.products && Array.isArray(page.products) && page.products.length > 0) {
                        productMatch = page.products.some(product => 
                            product.name && product.name.toLowerCase().includes(serviceOrProduct)
                        );
                    }
                    
                    // For "׳—׳ ׳•׳™׳•׳× ׳‘..." queries, match any store in the city (service/product can be empty)
                    // For "׳ ׳•׳×׳ ׳™ ׳©׳¨׳•׳× ׳‘..." queries, match any service provider in the city
                    const serviceMatches = isStoresInCityQuery || isServicesInCityQuery || titleMatch || descriptionMatch || productMatch;
                    
                    // If city is required, must check both service AND city
                    if (requiredCity) {
                        // Check city from metadata first (much faster!)
                        let cityMatches = false;
                        if (page.city) {
                            cityMatches = page.city.toLowerCase().includes(requiredCity.toLowerCase()) || 
                                         requiredCity.toLowerCase().includes(page.city.toLowerCase());
                        }
                        
                        // If no city in metadata, check HTML (for old pages)
                        if (!cityMatches) {
                            cityMatches = await checkPageHasCity(page, requiredCity);
                        }
                        
                        // Both service AND city must match
                        if (serviceMatches && cityMatches) {
                            matches = true;
                        } else if (serviceMatches && !cityMatches) {
                            // Service matches but city doesn't - try live content (might have different city)
                            const liveContentMatch = await checkLivePageContentWithCity(page, serviceOrProduct, requiredCity);
                            if (liveContentMatch) {
                                matches = true;
                            }
                        }
                    } else {
                        // No city requirement - check service/product only
                        if (serviceMatches) {
                            matches = true;
                        } else {
                            // Check live page content (for old pages without metadata)
                            const liveContentMatch = await checkLivePageContent(page, serviceOrProduct);
                            if (liveContentMatch) {
                                matches = true;
                            }
                        }
                    }
                    
                    if (matches) {
                        filteredPages.push(page);
                    }
                }
            }
            
            displayPages();
            updatePagesCount();
        }
        
        // Check if page has specific city (using metadata first, fallback to HTML)
        async function checkPageHasCity(page, requiredCity) {
            // First check metadata (much faster!)
            if (page.city) {
                return page.city.toLowerCase().includes(requiredCity.toLowerCase()) || 
                       requiredCity.toLowerCase().includes(page.city.toLowerCase());
            }
            
            // Fallback: check HTML (for old pages without metadata)
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (response.ok) {
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    const cityLower = requiredCity.toLowerCase();
                    
                    // Check if city appears in page content
                    return htmlLower.includes(cityLower);
                }
            } catch (error) {
                console.error('Error checking page city:', error);
            }
            return false;
        }
        
        // Enhanced version that also checks for city
        async function checkLivePageContentWithCity(page, searchTerm, requiredCity) {
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (response.ok) {
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    
                    // Check if search term appears in page content
                    const found = htmlLower.includes(searchTerm.toLowerCase());
                    
                    // If city is required, verify it exists in page
                    if (requiredCity && found) {
                        const cityFound = htmlLower.includes(requiredCity.toLowerCase());
                        return cityFound;
                    }
                    
                    // Also check for price patterns
                    if (searchTerm.includes('ג‚×') || searchTerm.includes('׳©׳§׳')) {
                        const priceMatch = htmlLower.match(/ג‚×\d+/g);
                        if (priceMatch) {
                            console.log(`נ’° Found prices in ${page.title}:`, priceMatch);
                            return true;
                        }
                    }
                    
                    return found;
                }
            } catch (error) {
                console.error('Error checking live page content:', error);
            }
            return false;
        }
        
        // New function to check live page content
        async function checkLivePageContent(page, searchTerm) {
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (response.ok) {
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    
                    // Check if search term appears in page content
                    const found = htmlLower.includes(searchTerm.toLowerCase());
                    console.log(`נ” Live search for "${searchTerm}" in ${page.title}: ${found}`);
                    
                    // Also check for price patterns
                    if (searchTerm.includes('ג‚×') || searchTerm.includes('׳©׳§׳')) {
                        const priceMatch = htmlLower.match(/ג‚×\d+/g);
                        if (priceMatch) {
                            console.log(`נ’° Found prices in ${page.title}:`, priceMatch);
                            return true;
                        }
                    }
                    
                    return found;
                }
            } catch (error) {
                console.error('Error checking live page content:', error);
            }
            return false;
        }
        
        function displayPages() {
            if (currentView === 'grid') {
                displayGrid();
            } else {
                displayTable();
            }
        }
        
        function displayGrid() {
            const grid = document.getElementById('pages-grid');
            const table = document.getElementById('pages-table');
            
            grid.classList.remove('hidden');
            table.classList.add('hidden');
            
            grid.innerHTML = '';
            
            if (filteredPages.length === 0) {
                grid.innerHTML = '<div class="col-span-full text-center text-gray-500 py-8">׳׳ ׳ ׳׳¦׳׳• ׳“׳₪׳™׳</div>';
                return;
            }
            
            filteredPages.forEach(page => {
                const pageCard = createPageCard(page);
                grid.appendChild(pageCard);
            });
        }
        
        function displayTable() {
            const grid = document.getElementById('pages-grid');
            const table = document.getElementById('pages-table');
            const tbody = document.getElementById('table-body');
            
            grid.classList.add('hidden');
            table.classList.remove('hidden');
            
            tbody.innerHTML = '';
            
            if (filteredPages.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="px-6 py-4 text-center text-gray-500">׳׳ ׳ ׳׳¦׳׳• ׳“׳₪׳™׳</td></tr>';
                return;
            }
            
            filteredPages.forEach(page => {
                const row = createTableRow(page);
                tbody.appendChild(row);
            });
        }
        
        function setView(view) {
            currentView = view;
            
            // Update button styles
            document.getElementById('grid-view-btn').className = view === 'grid' ? 
                'p-3 rounded-full bg-white bg-opacity-30 text-white hover:bg-opacity-40 transition-all' :
                'p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all';
            document.getElementById('table-view-btn').className = view === 'table' ? 
                'p-3 rounded-full bg-white bg-opacity-30 text-white hover:bg-opacity-40 transition-all' :
                'p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all';
            
            displayPages();
        }
        
        function createPageCard(page) {
            const card = document.createElement('div');
            card.className = 'page-card bg-white rounded-lg shadow-md overflow-hidden';
            
            const typeIcons = {
                'store': 'נ×',
                'event': 'נ‰',
                'course': 'נ“',
                'serviceProvider': 'נ”§',
                'other': 'נ“„'
            };
            
            const icon = typeIcons[page.pageType] || 'נ“„';
            const typeName = getTypeName(page.pageType);
            
            // Fix image URL - convert relative paths to absolute
            let imageUrl = page.thumbnail || '';
            if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
                imageUrl = `/output/${page.userId}/${imageUrl}`;
            }
            
            
            // Use /users/ route like in the main interface
            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
            
            // Try to find a screenshot image - only for courses
            const screenshotUrl = page.pageType === 'course' ? page.thumbnail : null;
            
            card.innerHTML = `
                <!-- ׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳©׳ ׳”׳׳×׳¨ -->
                <div class="relative rounded-t-xl overflow-hidden bg-gradient-to-br from-gray-50 to-gray-100" style="height: 200px; flex-shrink: 0;">
                    ${screenshotUrl ? `
                        <!-- ׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳¢׳ ׳×׳׳•׳ ׳” -->
                        <img 
                            src="${screenshotUrl}" 
                            alt="${page.title}"
                            class="w-full h-full object-cover"
                            onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                        />
                        <div class="absolute inset-0 bg-gradient-to-br from-indigo-500/10 to-purple-500/10 hidden items-center justify-center">
                            <div class="text-center">
                                <div class="w-16 h-16 bg-white/90 rounded-full flex items-center justify-center mx-auto mb-3 shadow-lg border-2 border-indigo-200">
                                    <span class="text-2xl font-bold text-indigo-600">${icon}</span>
                                </div>
                                <div class="text-sm font-medium text-gray-700 bg-white/90 px-3 py-1 rounded-full shadow-sm border border-gray-200">
                                    ${typeName}
                                </div>
                            </div>
                        </div>
                    ` : `
                        <!-- ׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳¢׳ iframe -->
                        <div class="absolute inset-2 bg-white rounded-lg overflow-hidden shadow-lg border border-gray-300">
                            <iframe 
                                src="${window.location.origin}${pageUrl}" 
                                class="w-full h-full border-0"
                                style="pointer-events: none; transform: scale(0.6) translateX(65%); transform-origin: top left; width: 166.67%; height: 166.67%;"
                                title="׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳©׳ ${page.title}"
                                loading="lazy"
                                importance="low"
                                sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-downloads allow-modals allow-top-navigation allow-presentation">
                            </iframe>
                        </div>
                    `}
                </div>
                <div class="p-6">
                    <h3 class="text-xl font-semibold text-gray-900 mb-2">${page.title}</h3>
                    <p class="text-gray-600 mb-4">${page.description || '׳׳׳ ׳×׳™׳׳•׳¨'}</p>
                    <div class="flex items-center justify-between">
                        <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-indigo-100 text-indigo-800">
                            ${icon} ${typeName}
                        </span>
                        <a href="/view/${page.userId}/${page.pageId}_html" target="_blank" 
                           class="text-indigo-600 hover:text-indigo-800 font-medium">
                            ׳¦׳₪׳” ׳‘׳“׳£ ג†’
                        </a>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createTableRow(page) {
            const row = document.createElement('tr');
            row.className = 'hover:bg-gray-50';
            
            const typeIcons = {
                'store': 'נ×',
                'event': 'נ‰',
                'course': 'נ“',
                'serviceProvider': 'נ”§',
                'other': 'נ“„'
            };
            
            const icon = typeIcons[page.pageType] || 'נ“„';
            const typeName = getTypeName(page.pageType);
            
            // Fix image URL
            let imageUrl = page.thumbnail || '';
            if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
                imageUrl = `/output/${page.userId}/${imageUrl}`;
            }
            
            // Use /users/ route like in the main interface
            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
            
            const createdDate = new Date(page.created_at).toLocaleDateString('he-IL');
            
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap">
                    <div class="flex-shrink-0 h-16 w-16">
                        ${imageUrl ? `
                            <!-- ׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳¢׳ ׳×׳׳•׳ ׳” -->
                            <div class="h-16 w-16 rounded-lg overflow-hidden border border-gray-300 bg-white shadow-sm">
                                <img 
                                    src="${imageUrl}" 
                                    alt="${page.title}"
                                    class="w-full h-full object-cover"
                                    onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                />
                                <div class="h-16 w-16 rounded-lg bg-gradient-to-br from-indigo-100 to-purple-100 flex items-center justify-center text-2xl hidden">${icon}</div>
                            </div>
                        ` : `
                            <!-- Placeholder ׳¢׳ ׳׳™׳™׳§׳•׳ - ׳׳ iframe ׳›׳™ ׳–׳” ׳׳ ׳¢׳•׳‘׳“ ׳˜׳•׳‘ ׳‘׳˜׳‘׳׳” ׳§׳˜׳ ׳” -->
                            <div class="h-16 w-16 rounded-lg bg-gradient-to-br from-indigo-100 via-purple-50 to-pink-100 border-2 border-indigo-200 shadow-sm flex flex-col items-center justify-center">
                                <div class="text-3xl mb-1">${icon}</div>
                                <div class="text-[10px] font-medium text-indigo-700 text-center px-1 truncate w-full">${typeName}</div>
                            </div>
                        `}
                    </div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <div class="text-sm font-medium text-gray-900">${page.title}</div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800">
                        ${icon} ${typeName}
                    </span>
                </td>
                <td class="px-6 py-4">
                    <div class="text-sm text-gray-500 max-w-xs truncate">${page.description || '׳׳׳ ׳×׳™׳׳•׳¨'}</div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    ${createdDate}
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                    <a href="/view/${page.userId}/${page.pageId}_html" target="_blank" 
                       class="text-indigo-600 hover:text-indigo-900">
                        ׳¦׳₪׳” ׳‘׳“׳£
                    </a>
                </td>
            `;
            
            return row;
        }
        
        function getTypeName(type) {
            const names = {
                'store': '׳—׳ ׳•׳×',
                'event': '׳׳™׳¨׳•׳¢',
                'course': '׳§׳•׳¨׳¡',
                'serviceProvider': '׳‘׳¢׳ ׳׳§׳¦׳•׳¢',
                'other': '׳׳—׳¨'
            };
            return names[type] || '׳׳—׳¨';
        }
        
        function updatePagesCount() {
            const count = filteredPages.length;
            const total = allPages.length;
            document.getElementById('pages-count').textContent = 
                `׳׳¦׳™׳’ ${count} ׳׳×׳•׳ ${total} ׳“׳₪׳™׳`;
        }
        
        
        // Extract product info from description and HTML content
        async function extractProductInfo(description, keyword, pageUrl = null) {
            if (!description) return null;
            
            const desc = description.toLowerCase();
            const keywordLower = keyword.toLowerCase();
            
            // Look for price patterns - more comprehensive
            const pricePatterns = [
                /(\d+)\s*ג‚×/g,
                /(\d+)\s*׳©׳§׳/g,
                /(\d+)\s*׳©"׳—/g,
                /׳׳—׳™׳¨[:\s]*(\d+)/g,
                /(\d+)\s*-\s*(\d+)\s*ג‚×/g,
                /׳׳—׳™׳¨[:\s]*(\d+)\s*-\s*(\d+)/g,
                /(\d+)\s*׳׳׳׳”/g,
                /(\d+)\s*׳׳׳˜׳”/g,
                /(\d+)\s*׳׳׳¢׳׳”/g
            ];
            
            let price = null;
            for (const pattern of pricePatterns) {
                const match = pattern.exec(desc);
                if (match) {
                    if (match[2]) {
                        price = `${match[1]}-${match[2]}ג‚×`;
                    } else {
                        price = `${match[1]}ג‚×`;
                    }
                    break;
                }
            }
            
            // Look for location patterns
            const locationPatterns = [
                /׳׳™׳§׳•׳[:\s]*([^,.\n]{2,50})/g,
                /׳›׳×׳•׳‘׳×[:\s]*([^,.\n]{2,50})/g,
                /׳ ׳׳¦׳[:\s]*([^,.\n]{2,50})/g,
                /׳‘[:\s]*([^,.\n]{2,50})/g
            ];
            
            let location = null;
            for (const pattern of locationPatterns) {
                const match = pattern.exec(desc);
                if (match && match[1] && match[1].length > 2) {
                    location = match[1].trim();
                    break;
                }
            }
            
            // Look for product name patterns - more specific
            let productName = null;
            if (keywordLower === '׳©׳¢׳•׳') {
                const watchPatterns = [
                    /׳©׳¢׳•׳\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*׳©׳¢׳•׳/g,
                    /׳©׳¢׳•׳\s+([׳-׳×\s]{2,30})/g,
                    /([׳-׳×\s]{2,30})\s*׳©׳¢׳•׳\s+([׳-׳×\s]{2,30})/g
                ];
                for (const pattern of watchPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            } else if (keywordLower === '׳×׳›׳©׳™׳˜') {
                const jewelryPatterns = [
                    /׳×׳›׳©׳™׳˜\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*׳×׳›׳©׳™׳˜/g,
                    /([^,.\n]{2,30})\s*׳–׳”׳‘/g,
                    /([^,.\n]{2,30})\s*׳›׳¡׳£/g
                ];
                for (const pattern of jewelryPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            } else if (keywordLower === '׳¦׳¢׳¦׳•׳¢') {
                const toyPatterns = [
                    /׳¦׳¢׳¦׳•׳¢\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*׳¦׳¢׳¦׳•׳¢/g,
                    /([^,.\n]{2,30})\s*׳׳©׳—׳§/g
                ];
                for (const pattern of toyPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            }
            
            // If we have a page URL, try to fetch the HTML content to find more prices
            if (pageUrl && (!price || !productName)) {
                try {
                    console.log('נ” Fetching HTML for:', pageUrl);
                    const response = await fetch(pageUrl);
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    
                    console.log('נ“„ HTML length:', html.length);
                    
                    // Look for prices in HTML content
                    if (!price) {
                        console.log('נ’° Looking for prices in HTML...');
                        const htmlPricePatterns = [
                            /<p class="product-price[^"]*"[^>]*>ג‚×(\d+(?:,\d+)?)<\/p>/g,
                            /class="product-price[^"]*"[^>]*>ג‚×(\d+(?:,\d+)?)/g,
                            /ג‚×\s*(\d+(?:,\d+)?)/g,
                            /(\d+(?:,\d+)?)\s*ג‚×/g
                        ];
                        
                        for (const pattern of htmlPricePatterns) {
                            const matches = [...html.matchAll(pattern)];
                            console.log('נ” Pattern matches:', pattern, matches.length);
                            if (matches.length > 0) {
                                // Get the first price found
                                const firstPrice = matches[0][1] || matches[0][0].match(/(\d+(?:,\d+)?)/)?.[1];
                                console.log('נ’° Found price:', firstPrice);
                                if (firstPrice) {
                                    price = `ג‚×${firstPrice}`;
                                    break;
                                }
                            }
                        }
                        
                        // If still no price, try a simpler approach
                        if (!price) {
                            console.log('נ” Trying simple price search...');
                            const simplePriceMatch = html.match(/ג‚×\s*(\d+(?:,\d+)?)/);
                            console.log('נ’° Simple match result:', simplePriceMatch);
                            if (simplePriceMatch) {
                                price = `ג‚×${simplePriceMatch[1]}`;
                            }
                        }
                        
                        console.log('נ’° Final price found:', price);
                    }
                    
                    // Look for product names in HTML content
                    if (!productName && keywordLower === '׳©׳¢׳•׳') {
                        const watchPatterns = [
                            /׳©׳¢׳•׳\s+([^<>{}\n]{2,30})/g,
                            /([^<>{}\n]{2,30})\s*׳©׳¢׳•׳/g,
                            /<h[1-6][^>]*>.*?׳©׳¢׳•׳\s+([^<]{2,30})/g,
                            /class="[^"]*product-name[^"]*"[^>]*>([^<]+)/g,
                            /<h3[^>]*>([^<]*׳©׳¢׳•׳[^<]*)<\/h3>/g
                        ];
                        
                        for (const pattern of watchPatterns) {
                            const matches = [...html.matchAll(pattern)];
                            if (matches.length > 0) {
                                productName = matches[0][1].trim();
                                break;
                            }
                        }
                    }
                } catch (error) {
                    console.log('Could not fetch HTML content:', error);
                }
            }
            
            if (productName || price || location) {
                return {
                    name: productName || `${keyword} ׳׳™׳•׳—׳“`,
                    price: price || '׳׳—׳™׳¨ ׳׳₪׳™ ׳‘׳§׳©׳”',
                    location: location || '׳׳™׳§׳•׳ ׳׳ ׳¦׳•׳™׳'
                };
            }
            
            return null;
        }

        // Smart search functionality - copied from Stav the Great
        let lastSearchContext = null; // Remember last search context
        let lastSearchResults = []; // Remember last search results
        
        async function handleSmartSearch(message, allPages) {
            try {
                const lowerMessage = message.toLowerCase();
                
                // נ¯ FIX: Check if allPages exists and is an array
                if (!allPages || !Array.isArray(allPages) || allPages.length === 0) {
                    console.error('ג allPages is empty or invalid in handleSmartSearch');
                    return null; // Return null to continue with normal flow in processStavMessage
                }
                
                console.log('נ” handleSmartSearch processing:', message);
            
            // Handle greetings - respond locally with friendly greeting
            if (lowerMessage.includes('׳©׳׳•׳') || lowerMessage.includes('׳”׳™׳™') || lowerMessage.includes('׳”׳™')) {
                const greetingResponses = [
                    '׳©׳׳•׳! ׳׳™׳ ׳׳₪׳©׳¨ ׳׳¢׳–׳•׳¨?',
                    '׳”׳™׳™! ׳‘׳׳” ׳׳•׳›׳ ׳׳¢׳–׳•׳¨ ׳׳?',
                    '׳©׳׳•׳! ׳׳—׳₪׳© ׳׳©׳”׳• ׳׳™׳•׳—׳“?'
                ];
                return greetingResponses[Math.floor(Math.random() * greetingResponses.length)];
            }
            
            // Handle personal questions - send to N8N for conversational response
            if (lowerMessage.includes('׳©׳׳™') || lowerMessage.includes('׳§׳•׳¨׳׳™׳ ׳׳™') || lowerMessage.includes('׳׳ ׳™') ||
                lowerMessage.includes('׳׳” ׳©׳׳•׳׳') || lowerMessage.includes('׳׳™׳ ׳׳×׳”') || lowerMessage.includes('׳׳™׳ ׳׳×')) {
                return null; // Send to N8N instead of fixed message
            }
            
            // Handle context switching (e.g., "׳•׳׳’׳‘׳¨" after "׳׳×׳ ׳” ׳׳™׳׳“")
            if (lowerMessage.includes('׳•׳׳’׳‘׳¨') || lowerMessage.includes('׳•׳׳׳™׳©׳”') || lowerMessage.includes('׳•׳׳™׳׳“') || 
                lowerMessage.includes('׳•׳׳’׳‘׳¨׳™׳') || lowerMessage.includes('׳•׳׳ ׳©׳™׳') || lowerMessage.includes('׳•׳׳™׳׳“׳™׳')) {
                // Extract the gift type from context
                let giftType = '׳׳×׳ ׳”';
                if (lowerMessage.includes('׳’׳‘׳¨') || lowerMessage.includes('׳’׳‘׳¨׳™׳')) giftType = '׳׳×׳ ׳” ׳׳’׳‘׳¨';
                else if (lowerMessage.includes('׳׳™׳©׳”') || lowerMessage.includes('׳ ׳©׳™׳')) giftType = '׳׳×׳ ׳” ׳׳׳™׳©׳”';
                else if (lowerMessage.includes('׳™׳׳“') || lowerMessage.includes('׳™׳׳“׳™׳')) giftType = '׳׳×׳ ׳” ׳׳™׳׳“';
                
                // Process as gift search
                const giftResult = await handleSmartSearch(giftType, allPages);
                if (giftResult) return giftResult;
            }
            
            // Handle greetings and personal questions - NO FIXED MESSAGES
            if (lowerMessage.includes('׳©׳׳•׳') || lowerMessage.includes('׳”׳™׳™') || lowerMessage.includes('׳”׳™') || 
                lowerMessage.includes('׳׳” ׳©׳׳•׳׳') || lowerMessage.includes('׳׳™׳ ׳׳×׳”') || lowerMessage.includes('׳׳™׳ ׳׳×') ||
                lowerMessage.includes('׳©׳׳™') || lowerMessage.includes('׳§׳•׳¨׳׳™׳ ׳׳™') || lowerMessage.includes('׳׳ ׳™ ׳™׳ ׳™׳‘') || lowerMessage.includes('׳׳ ׳™ ׳™׳׳—׳×')) {
                return null; // Send to N8N instead of fixed message
            }
            
            // נ¯ FIX: FIRST check if this is a marketplace query - handle locally, don't send to N8N!
            const isMarketplacePriceQuery = lowerMessage.includes('׳׳” ׳”׳׳•׳¦׳¨') || lowerMessage.includes('׳׳” ׳׳—׳™׳¨') || 
                                            lowerMessage.includes('׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳™׳§׳¨') ||
                                            lowerMessage.includes('׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳ ׳‘׳׳¨׳§׳˜') || lowerMessage.includes('׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳ ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡') ||
                                            (lowerMessage.includes('׳׳”') && (lowerMessage.includes('׳‘׳׳¨׳§׳˜') || lowerMessage.includes('׳¨׳§׳˜׳₪׳׳™׳™׳¡') || lowerMessage.includes('׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳”׳›׳™ ׳™׳§׳¨')));
            
            // Handle knowledge questions - send to N8N (but NOT marketplace queries!)
            // נ¯ FIX: "׳׳” ׳’׳•׳“׳ ׳™׳₪׳", "׳׳” ׳–׳” X" are general knowledge, NOT marketplace!
            // BUT: "׳׳” ׳׳—׳™׳¨", "׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳" ARE marketplace!
            // נ¯ NEW: Also catch general conversation requests like "׳×׳’׳™׳“׳™ ׳×׳¡׳₪׳¨׳™ ׳׳™ ׳׳©׳”׳• ׳׳¢׳ ׳™׳™׳", "׳׳× ׳™׳•׳“׳¢׳× ׳׳¡׳₪׳¨ ׳¡׳™׳₪׳•׳¨׳™׳"
            // נ¯ IMPROVED: Add more conversational patterns - "׳‘׳•׳ ׳ ׳“׳‘׳¨", "׳׳” ׳§׳•׳¨׳”", "׳׳” ׳ ׳©׳׳¢", etc.
            const isGeneralKnowledgeQuery = (lowerMessage.includes('׳׳” ׳’׳•׳“׳') ||  // "׳׳” ׳’׳•׳“׳ ׳™׳₪׳"
                                             lowerMessage.includes('׳׳” ׳”׳’׳•׳“׳') || // Handle '׳׳” ׳”׳’׳•׳“׳ ...'
                                             lowerMessage.includes('׳׳” ׳–׳”') ||    // "׳׳” ׳–׳” X"
                                             lowerMessage === '׳׳”' ||             // Just "׳׳”"
                                             lowerMessage.includes('׳×׳’׳™׳“׳™') || lowerMessage.includes('׳×׳’׳™׳“') || // "׳×׳’׳™׳“׳™ ׳×׳¡׳₪׳¨׳™ ׳׳™"
                                             (lowerMessage.includes('׳×׳¡׳₪׳¨׳™') || lowerMessage.includes('׳×׳¡׳₪׳¨')) && (lowerMessage.includes('׳¡׳™׳₪׳•׳¨') || lowerMessage.includes('׳¢׳')) || // "׳×׳¡׳₪׳¨׳™ ׳׳™ ׳¡׳™׳₪׳•׳¨ ׳¢׳"
                                             lowerMessage.includes('׳׳¡׳₪׳¨ ׳¡׳™׳₪׳•׳¨׳™׳') || lowerMessage.includes('׳׳¡׳₪׳¨ ׳¡׳™׳₪׳•׳¨') || // "׳׳× ׳™׳•׳“׳¢׳× ׳׳¡׳₪׳¨ ׳¡׳™׳₪׳•׳¨׳™׳"
                                             lowerMessage.includes('׳×׳¡׳₪׳¨׳™ ׳׳™ ׳¡׳™׳₪׳•׳¨') || lowerMessage.includes('׳×׳¡׳₪׳¨ ׳׳™ ׳¡׳™׳₪׳•׳¨') || // "׳×׳¡׳₪׳¨׳™ ׳׳™ ׳¡׳™׳₪׳•׳¨ ׳¢׳"
                                             lowerMessage.includes('׳‘׳׳™ ׳©׳×׳¡׳₪׳¨׳™') || lowerMessage.includes('׳‘׳׳™ ׳©׳×׳¡׳₪׳¨') || // "׳‘׳׳™ ׳©׳×׳¡׳₪׳¨׳™ ׳׳™ ׳¡׳™׳₪׳•׳¨"
                                             lowerMessage.includes('׳׳©׳”׳• ׳׳¢׳ ׳™׳™׳') || lowerMessage.includes('׳׳©׳”׳• ׳—׳“׳©') || // "׳׳©׳”׳• ׳׳¢׳ ׳™׳™׳"
                                             lowerMessage.includes('׳—׳“׳©׳•׳×') || lowerMessage.includes('׳—׳“׳©׳”') || // "׳™׳© ׳׳©׳”׳• ׳—׳“׳© ׳‘׳—׳“׳©׳•׳×"
                                             lowerMessage.includes('׳‘׳•׳ ׳ ׳“׳‘׳¨') || lowerMessage.includes('׳‘׳•׳׳™ ׳ ׳“׳‘׳¨') || // "׳‘׳•׳ ׳ ׳“׳‘׳¨"
                                             lowerMessage.includes('׳׳” ׳§׳•׳¨׳”') || lowerMessage.includes('׳׳” ׳ ׳©׳׳¢') || // "׳׳” ׳§׳•׳¨׳”", "׳׳” ׳ ׳©׳׳¢"
                                             lowerMessage.includes('׳×׳©׳¢׳׳') || lowerMessage.includes('׳׳©׳¢׳׳') || // "׳׳©׳¢׳׳ ׳׳™"
                                             lowerMessage.includes('׳‘׳“׳™׳—׳”') || lowerMessage.includes('׳‘׳“׳™׳—׳•׳×') || // "׳×׳¡׳₪׳¨׳™ ׳‘׳“׳™׳—׳”"
                                             (lowerMessage.includes('׳¡׳×׳') && !lowerMessage.includes('׳—׳ ׳•׳×') && !lowerMessage.includes('׳׳•׳¦׳¨')) || // "׳¡׳×׳ ׳׳©׳•׳—׳—"
                                             lowerMessage.includes('׳׳©׳•׳—׳—') || lowerMessage.includes('׳©׳™׳—׳”') || // "׳¨׳•׳¦׳” ׳׳©׳•׳—׳—"
                                             (lowerMessage.includes('׳׳”') &&      // "׳׳” X" where X is NOT marketplace-related
                                              !lowerMessage.includes('׳׳—׳™׳¨') && 
                                              !lowerMessage.includes('׳׳•׳¦׳¨') && 
                                              !lowerMessage.includes('׳׳×׳ ׳”') && 
                                              !lowerMessage.includes('׳‘׳׳¨׳§׳˜') &&
                                              !lowerMessage.includes('׳¨׳§׳˜׳₪׳׳™׳™׳¡') &&
                                              !lowerMessage.includes('׳—׳ ׳•׳×') &&
                                              !lowerMessage.includes('׳©׳™׳¨׳•׳×') &&
                                              !lowerMessage.includes('׳׳§') &&
                                              !lowerMessage.includes('׳©׳¢׳•׳') &&
                                              !lowerMessage.includes('׳¦׳¢׳¦׳•׳¢'))) &&
                                             !isMarketplacePriceQuery;
            
            if (isGeneralKnowledgeQuery || 
                (!isMarketplacePriceQuery && (lowerMessage.includes('׳׳™׳') || 
                 lowerMessage.includes('׳׳×׳™') || 
                 (lowerMessage.includes('׳׳™׳₪׳”') && !lowerMessage.includes('׳—׳ ׳•׳×') && !lowerMessage.includes('׳׳§') && !lowerMessage.includes('׳©׳¢׳•׳')) ||
                 lowerMessage.includes('׳׳׳”') ||
                 (lowerMessage.includes('׳›׳׳”') && !lowerMessage.includes('׳׳—׳™׳¨') && !lowerMessage.includes('׳׳•׳¦׳¨') && !lowerMessage.includes('׳¢׳•׳׳”')) ||
                 lowerMessage.includes('׳׳™') || 
                 lowerMessage.includes('׳׳™׳–׳”')))) {
                console.log('נ“ General knowledge query detected - sending to N8N');
                return null; // Send to N8N for general knowledge questions
            }
            
            // Only search for pages if user is specifically looking for something
            // נ¯ FIX: Also catch "׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳ ׳‘׳׳¨׳§׳˜" variations - handle locally, don't send to N8N!
            // נ¯ NEW: Add "׳×׳׳׳™׳¦׳™", "׳׳×׳ ׳” ׳", "׳׳•׳¦׳¨ ׳" as marketplace queries
            const isMarketplaceQuery = isMarketplacePriceQuery || 
                lowerMessage.includes('׳׳×׳ ׳”') || lowerMessage.includes('׳׳§') || (lowerMessage.includes('׳©׳¢׳•׳') && !lowerMessage.includes('׳©׳¢׳¨')) || 
                lowerMessage.includes('׳¦׳¢׳¦׳•׳¢') || lowerMessage.includes('׳§׳•׳¨׳¡') || lowerMessage.includes('׳—׳ ׳•׳×') || 
                lowerMessage.includes('׳©׳™׳¨׳•׳×') || lowerMessage.includes('׳׳™׳¨׳•׳¢') || lowerMessage.includes('׳׳—׳™׳¨') ||
                lowerMessage.includes('׳׳¡׳₪׳¨׳”') || lowerMessage.includes('׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨') || lowerMessage.includes('׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨') || (lowerMessage.includes('׳¡׳₪׳¨') && !lowerMessage.includes('׳¡׳₪׳¨׳™׳')) || 
                lowerMessage.includes('׳›׳׳”') || lowerMessage.includes('׳¢׳•׳׳”') || lowerMessage.includes('ג‚×') || 
                lowerMessage.includes('׳©׳§׳') || lowerMessage.includes('׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳”׳›׳™ ׳™׳§׳¨') || 
                lowerMessage.includes('׳”׳©׳•׳•׳׳”') || lowerMessage.includes('׳ ׳’׳™׳“') || lowerMessage.includes('׳•׳׳§') || 
                lowerMessage.includes('׳•׳©׳¢׳•׳') || lowerMessage.includes('׳•׳¦׳¢׳¦׳•׳¢') || lowerMessage.includes('׳¦׳¢׳¦׳•׳¢׳™׳') || 
                lowerMessage.includes('׳©׳¢׳•׳ ׳™׳') || lowerMessage.includes('׳‘׳׳¨׳§׳˜') || lowerMessage.includes('׳¨׳§׳˜׳₪׳׳™׳™׳¡') ||
                // נ¯ NEW: Handle "׳×׳׳׳™׳¦׳™", "׳׳×׳ ׳” ׳", "׳׳•׳¦׳¨ ׳", "׳×׳¨׳׳™ ׳׳•׳¦׳¨׳™׳" queries
                // נ¯ FIX: Also handle "׳×׳׳׳™׳¦׳™ ׳׳™ ׳׳•׳¦׳¨ ׳¢׳“ X ׳©"׳—" - recommendation with budget
                lowerMessage.includes('׳×׳׳׳™׳¦׳™') || lowerMessage.includes('׳×׳׳׳™׳¥') || lowerMessage.includes('׳”׳׳׳¦') ||
                (lowerMessage.includes('׳×׳׳׳™׳¦׳™') && (lowerMessage.includes('׳׳•׳¦׳¨') || lowerMessage.includes('׳׳×׳ ׳”') || lowerMessage.includes('׳¢׳“'))) ||
                lowerMessage.includes('׳×׳¨׳׳™ ׳׳•׳¦׳¨׳™׳') || lowerMessage.includes('׳×׳¨׳׳™ ׳׳—׳™׳¨׳™׳') ||
                lowerMessage.includes('׳׳•׳¦׳¨׳™׳ ׳•׳׳—׳™׳¨׳™׳') ||
                (lowerMessage.includes('׳×׳¨׳׳™') && (lowerMessage.includes('׳׳•׳¦׳¨') || lowerMessage.includes('׳׳—׳™׳¨'))) ||
                (lowerMessage.includes('׳¢׳“') && (lowerMessage.includes('׳©"׳—') || lowerMessage.includes('ג‚×') || lowerMessage.includes('׳©׳§׳'))) ||
                (lowerMessage.includes('׳׳×׳ ׳”') && (lowerMessage.includes('׳') || lowerMessage.includes('׳׳׳™׳©׳”') || 
                 lowerMessage.includes('׳׳‘׳—׳•׳¨׳”') || lowerMessage.includes('׳׳׳©׳”') ||
                 lowerMessage.includes('׳׳’׳‘׳¨') || lowerMessage.includes('׳׳‘׳—׳•׳¨') || 
                 lowerMessage.includes('׳׳‘׳¢׳') || lowerMessage.includes('׳׳‘׳¢׳׳™') ||
                 lowerMessage.includes('׳׳™׳׳“'))) ||
                (lowerMessage.includes('׳׳•׳¦׳¨') && (lowerMessage.includes('׳') || lowerMessage.includes('׳׳׳™׳©׳”') || 
                 lowerMessage.includes('׳׳‘׳—׳•׳¨׳”') || lowerMessage.includes('׳׳׳©׳”') ||
                 lowerMessage.includes('׳׳’׳‘׳¨') || lowerMessage.includes('׳׳‘׳—׳•׳¨') ||
                 lowerMessage.includes('׳׳‘׳¢׳') || lowerMessage.includes('׳׳‘׳¢׳׳™') ||
                 lowerMessage.includes('׳׳™׳׳“'))) ||
                (lowerMessage.includes('׳׳¨׳§׳˜') || lowerMessage.includes('׳׳¨׳§׳˜׳₪׳׳™׳™׳¡')) && 
                 (lowerMessage.includes('׳×׳׳׳™׳¦׳™') || lowerMessage.includes('׳×׳׳׳™׳¥') || lowerMessage.includes('׳׳•׳¦׳¨') || 
                  lowerMessage.includes('׳׳×׳ ׳”') || lowerMessage.includes('׳”׳׳׳¦'));
            
            if (!isMarketplaceQuery) {
                // For other general questions, send to N8N
                return null; // Let N8N handle general questions
            }
            
            // Reset search context if user is searching for something new
            if (lowerMessage.includes('׳׳—׳₪׳©') || lowerMessage.includes('׳”׳׳׳¦') || lowerMessage.includes('׳׳') || lowerMessage.includes('׳׳ ') || lowerMessage.includes('׳ ׳’׳™׳“') || lowerMessage.includes('׳•׳׳§') || lowerMessage.includes('׳•׳©׳¢׳•׳') || lowerMessage.includes('׳•׳¦׳¢׳¦׳•׳¢') || lowerMessage.includes('׳¦׳¢׳¦׳•׳¢׳™׳') || lowerMessage.includes('׳¦׳¢׳¦׳•׳¢') || lowerMessage.includes('׳©׳¢׳•׳ ׳™׳') || lowerMessage.includes('׳©׳¢׳•׳')) {
                lastSearchContext = null;
                lastSearchResults = [];
                console.log('נ”„ Reset search context for new search or rejection');
            }
            
            // Special handling for "cheapest" or "most expensive" across all pages
            // ג… Added more variations like "׳׳•׳¦׳¨ ׳–׳•׳", "׳׳•׳¦׳¨ ׳”׳–׳•׳", "׳”׳׳•׳¦׳¨ ׳”׳–׳•׳"
            // נ¯ FIX: Also handle "׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳ ׳‘׳׳¨׳§׳˜" and variations
            if (lowerMessage.includes('׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳”׳›׳™ ׳™׳§׳¨') || lowerMessage.includes('׳”׳©׳•׳•׳׳”') || 
                lowerMessage.includes('׳׳•׳¦׳¨ ׳–׳•׳') || lowerMessage.includes('׳׳•׳¦׳¨ ׳”׳–׳•׳') || lowerMessage.includes('׳”׳׳•׳¦׳¨ ׳”׳–׳•׳') ||
                lowerMessage.includes('׳׳•׳¦׳¨ ׳™׳§׳¨') || lowerMessage.includes('׳׳•׳¦׳¨ ׳”׳™׳§׳¨') || lowerMessage.includes('׳”׳׳•׳¦׳¨ ׳”׳™׳§׳¨') ||
                lowerMessage.includes('׳׳” ׳”׳–׳•׳') || lowerMessage.includes('׳׳” ׳”׳™׳§׳¨') || lowerMessage.includes('׳–׳•׳ ׳‘׳™׳•׳×׳¨') || lowerMessage.includes('׳™׳§׳¨ ׳‘׳™׳•׳×׳¨') ||
                lowerMessage.includes('׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳™׳§׳¨') ||
                lowerMessage.includes('׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳ ׳‘׳׳¨׳§׳˜') || lowerMessage.includes('׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳ ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡') ||
                lowerMessage.includes('׳׳—׳™׳¨׳™׳') || lowerMessage.includes('׳׳—׳™׳¨') || lowerMessage.includes('׳›׳׳” ׳¢׳•׳׳”') || 
                lowerMessage.includes('׳”׳©׳•׳•׳') || lowerMessage.includes('׳”׳©׳•׳•׳™׳”')) {
                console.log('נ” Price comparison search triggered:', lowerMessage);
                
                // Determine what product they're looking for
                let searchKeyword = '';
                
                // נ§  FIRST: Check conversation context (if user already said what they want)
                if (window.marketplaceConversationContext && window.marketplaceConversationContext.lastSearchCategory) {
                    const lastCategory = window.marketplaceConversationContext.lastSearchCategory.toLowerCase();
                    // If last search was for a specific category, use it!
                    if (lastCategory.includes('׳¦׳¢׳¦׳•׳¢')) searchKeyword = '׳¦׳¢׳¦׳•׳¢';
                    else if (lastCategory.includes('׳©׳¢׳•׳')) searchKeyword = '׳©׳¢׳•׳';
                    else if (lastCategory.includes('׳׳§')) searchKeyword = '׳׳§';
                    else if (lastCategory.includes('׳×׳›׳©׳™׳˜')) searchKeyword = '׳×׳›׳©׳™׳˜';
                    else if (lastCategory.includes('׳˜׳›׳ ׳•׳׳•׳’׳™׳”')) searchKeyword = '׳˜׳›׳ ׳•׳׳•׳’׳™׳”';
                    
                    console.log('נ§  Using last search context:', searchKeyword);
                }
                
                // If no context, check the current message
                if (!searchKeyword) {
                    // ג… Check for product keywords (including "׳”" prefix like "׳”׳¦׳¢׳¦׳•׳¢", "׳”׳×׳›׳©׳™׳˜")
                    // נ¯ FIX: Also check for synonyms like "׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨", "׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨" ג†’ "׳׳¡׳₪׳¨׳”"
                    if (lowerMessage.includes('׳©׳¢׳•׳') || lowerMessage.includes('׳©׳¢׳•׳ ׳™׳') || lowerMessage.includes('׳”׳©׳¢׳•׳')) searchKeyword = '׳©׳¢׳•׳';
                    else if (lowerMessage.includes('׳¦׳¢׳¦׳•׳¢') || lowerMessage.includes('׳¦׳¢׳¦׳•׳¢׳™׳') || lowerMessage.includes('׳”׳¦׳¢׳¦׳•׳¢')) searchKeyword = '׳¦׳¢׳¦׳•׳¢';
                    else if (lowerMessage.includes('׳׳§') || lowerMessage.includes('׳”׳׳§')) searchKeyword = '׳׳§';
                    else if (lowerMessage.includes('׳×׳›׳©׳™׳˜') || lowerMessage.includes('׳×׳›׳©׳™׳˜׳™׳') || lowerMessage.includes('׳”׳×׳›׳©׳™׳˜')) searchKeyword = '׳×׳›׳©׳™׳˜';
                    else if (lowerMessage.includes('׳˜׳›׳ ׳•׳׳•׳’׳™׳”') || lowerMessage.includes('׳”׳˜׳›׳ ׳•׳׳•׳’׳™׳”')) searchKeyword = '׳˜׳›׳ ׳•׳׳•׳’׳™׳”';
                    else if (lowerMessage.includes('׳ ׳§׳™׳•׳') || lowerMessage.includes('׳ ׳§׳”') || lowerMessage.includes('׳ ׳™׳§׳•׳™')) searchKeyword = '׳ ׳§׳™׳•׳';
                    else if (lowerMessage.includes('׳׳¡׳₪׳¨׳”') || lowerMessage.includes('׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨') || lowerMessage.includes('׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨') || 
                             lowerMessage.includes('׳×׳¡׳₪׳•׳¨׳×') || (lowerMessage.includes('׳¡׳₪׳¨') && !lowerMessage.includes('׳¡׳₪׳¨׳™׳'))) searchKeyword = '׳׳¡׳₪׳¨׳”';
                    else if (lowerMessage.includes('׳ ׳’׳¨') || lowerMessage.includes('׳×׳™׳§׳•׳') || lowerMessage.includes('׳‘׳¢׳™׳•׳× ׳׳™׳')) searchKeyword = '׳©׳™׳¨׳•׳×׳™׳';
                    else searchKeyword = '׳׳•׳¦׳¨';
                }
                
                console.log('נ” Search keyword for comparison:', searchKeyword);
                console.log('נ“ Original message:', userMessage);
                console.log('נ“ Lowercase message:', lowerMessage);
                
                // נ’¾ SAVE the search category for future reference
                window.marketplaceConversationContext.lastSearchCategory = searchKeyword;
                console.log('נ’¾ Saved search category:', searchKeyword);
                
                // נ”¥ NEW APPROACH: Filter pages AFTER reading their live content!
                let relevantPages = [];
                
                if (searchKeyword === '׳׳•׳¦׳¨') {
                    // For general "׳׳•׳¦׳¨" - include all store pages AND messageInBottle
                    relevantPages = allPages.filter(page => page.pageType === 'store' || page.pageType === 'messageInBottle');
                } else {
                    // נ”¥ FOR SPECIFIC CATEGORIES - Read LIVE HTML and check!
                    const pluralKeyword = searchKeyword + '׳™׳';
                    
                    for (const page of allPages) {
                        // Include both store pages AND messageInBottle pages
                        if (page.pageType !== 'store' && page.pageType !== 'messageInBottle') continue;
                        
                        const titleLower = page.title.toLowerCase();
                        const descLower = (page.description || '').toLowerCase();
                        const requestLower = (page.request || '').toLowerCase();
                        
                        // נ¯ FIX: Use synonyms for search - e.g., "׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨" should match "׳׳¡׳₪׳¨׳”"
                        const synonymMap = {
                            '׳׳¡׳₪׳¨׳”': ['׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳×׳¡׳₪׳•׳¨׳•׳×', '׳׳¡׳₪׳¨', '׳¡׳₪׳¨ ׳’׳‘׳¨׳™׳', '׳¡׳₪׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨'],
                            '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                            '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨']
                        };
                        
                        // Get synonyms for search keyword
                        const synonyms = synonymMap[searchKeyword] || [];
                        const allSearchTerms = [searchKeyword, pluralKeyword, ...synonyms];
                        
                        // Quick check: Title, description, or request match (including synonyms)
                        const hasMatch = allSearchTerms.some(term => 
                            titleLower.includes(term) || descLower.includes(term) || requestLower.includes(term)
                        );
                        
                        if (hasMatch) {
                            relevantPages.push(page);
                            console.log(`ג… Page "${page.title}" matched by title/description/request (with synonyms)`);
                            continue;
                        }
                        
                        // נ”¥ If not in title/desc, check LIVE products!
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            
                            // נ”¥ Extract LIVE products and check if ANY product matches the keyword!
                            const liveProducts = extractLiveProducts(html);
                            const hasMatchingProduct = liveProducts.some(product => {
                                const productName = product.name.toLowerCase();
                                // נ¯ FIX: Use synonyms for product search too
                                const synonymMap = {
                                    '׳׳¡׳₪׳¨׳”': ['׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳×׳¡׳₪׳•׳¨׳•׳×', '׳׳¡׳₪׳¨', '׳¡׳₪׳¨ ׳’׳‘׳¨׳™׳', '׳¡׳₪׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨'],
                                    '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                                    '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨']
                                };
                                const synonyms = synonymMap[searchKeyword] || [];
                                const allSearchTerms = [searchKeyword, pluralKeyword, ...synonyms];
                                return allSearchTerms.some(term => productName.includes(term));
                            });
                            
                            if (hasMatchingProduct) {
                                relevantPages.push(page);
                                console.log(`ג… Page "${page.title}" matched by LIVE products`);
                            } else {
                                console.log(`ג Page "${page.title}" has NO products matching "${searchKeyword}"`);
                            }
                        } catch (error) {
                            console.error('Error checking page:', page.title, error);
                        }
                    }
                }
                
                console.log(`נ” Found ${relevantPages.length} pages matching "${searchKeyword}":`, relevantPages.map(p => p.title));
                
                if (relevantPages.length > 0) {
                    // Check if we have messageInBottle pages
                    const messageInBottlePages = relevantPages.filter(page => page.pageType === 'messageInBottle');
                    const storePages = relevantPages.filter(page => page.pageType === 'store');
                    
                    // Handle messageInBottle pages differently
                    if (messageInBottlePages.length > 0) {
                        let response = '';
                        
                        if (messageInBottlePages.length === 1) {
                            const page = messageInBottlePages[0];
                            response = `נ¾ **׳׳¦׳׳×׳™ ׳׳¡׳¨ ׳‘׳‘׳§׳‘׳•׳§ ׳¨׳׳•׳•׳ ׳˜׳™!**\n\n`;
                            response += `**${page.name}** - ${page.request}\n`;
                            response += `נ“ **׳׳–׳•׳¨:** ${page.area}\n`;
                            if (page.phone) {
                                response += `נ“ **׳˜׳׳₪׳•׳:** ${page.phone}\n`;
                            }
                            if (page.price) {
                                response += `נ’° **׳׳—׳™׳¨:** ג‚×${page.price} ${page.priceType || '׳›׳׳׳™'}\n`;
                            }
                            response += `\nנ”— [׳¦׳₪׳” ׳‘׳“׳£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                            response += `נ’¬ **׳”׳©׳׳¨ ׳₪׳¨׳˜׳™׳ ׳•׳׳ ׳™ ׳׳׳¡׳•׳¨ ׳׳•׳×׳!**`;
                        } else {
                            response = `נ¾ **׳׳¦׳׳×׳™ ${messageInBottlePages.length} ׳׳¡׳¨׳™׳ ׳‘׳‘׳§׳‘׳•׳§ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳!**\n\n`;
                            
                            messageInBottlePages.forEach((page, index) => {
                                response += `**${index + 1}. ${page.name}** - ${page.request}\n`;
                                response += `נ“ **׳׳–׳•׳¨:** ${page.area}\n`;
                                if (page.phone) {
                                    response += `נ“ **׳˜׳׳₪׳•׳:** ${page.phone}\n`;
                                }
                                if (page.price) {
                                    response += `נ’° **׳׳—׳™׳¨:** ג‚×${page.price} ${page.priceType || '׳›׳׳׳™'}\n`;
                                }
                                response += `נ”— [׳¦׳₪׳” ׳‘׳“׳£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                            });
                            
                            response += `נ’¬ **׳”׳©׳׳¨ ׳₪׳¨׳˜׳™׳ ׳•׳׳ ׳™ ׳׳׳¡׳•׳¨ ׳׳•׳×׳ ׳׳׳™ ׳©׳׳×׳׳™׳!**`;
                        }
                        
                        return response;
                    }
                    
                    // Handle store pages (existing logic)
                    let allProducts = [];
                    
                    // נ”¥ READ LIVE PRODUCTS FROM EACH PAGE (not from old metadata)!
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        
                        try {
                            // נ”¥ Fetch the LIVE HTML page
                            const response = await fetch(pageUrl);
                            if (!response.ok) {
                                console.warn('Failed to fetch page:', pageUrl);
                                continue;
                            }
                            
                            const html = await response.text();
                            
                            // נ”¥ Extract LIVE products from HTML
                            const liveProducts = extractLiveProducts(html);
                            console.log(`נ”¥ Extracted ${liveProducts.length} LIVE products from ${page.title}:`, liveProducts);
                            
                            if (liveProducts.length > 0) {
                                // נ¯ FOR SPECIFIC CATEGORIES: Include ALL products from relevant pages!
                                // The page itself is already filtered by category, so we trust the products in it
                                if (searchKeyword !== '׳׳•׳¦׳¨') {
                                    console.log(`נ¯ Including ALL ${liveProducts.length} products from "${page.title}" (category: ${searchKeyword})`);
                                    liveProducts.forEach(product => {
                                        allProducts.push({
                                            ...product,
                                            pageTitle: page.title,
                                            pageUrl: pageUrl,
                                            pageName: page.title
                                        });
                                    });
                                } else {
                                    // For general "׳׳•׳¦׳¨", include all products
                                    liveProducts.forEach(product => {
                                        allProducts.push({
                                            ...product,
                                            pageTitle: page.title,
                                            pageUrl: pageUrl,
                                            pageName: page.title
                                        });
                                    });
                                }
                            }
                        } catch (error) {
                            console.error('Error extracting live products from', pageUrl, ':', error);
                        }
                    }
                    
                    // If we have both messageInBottle pages and store products, combine them
                    if (messageInBottlePages.length > 0 && allProducts.length > 0) {
                        let response = '';
                        
                        // Add messageInBottle pages
                        response += `נ¾ **׳׳¦׳׳×׳™ ${messageInBottlePages.length} ׳׳¡׳¨׳™׳ ׳‘׳‘׳§׳‘׳•׳§ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳!**\n\n`;
                        
                        messageInBottlePages.forEach((page, index) => {
                            response += `**${index + 1}. ${page.name}** - ${page.request}\n`;
                            response += `נ“ **׳׳–׳•׳¨:** ${page.area}\n`;
                            if (page.phone) {
                                response += `נ“ **׳˜׳׳₪׳•׳:** ${page.phone}\n`;
                            }
                            if (page.price) {
                                response += `נ’° **׳׳—׳™׳¨:** ג‚×${page.price} ${page.priceType || '׳›׳׳׳™'}\n`;
                            }
                            response += `נ”— [׳¦׳₪׳” ׳‘׳“׳£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                        });
                        
                        response += `\nנ›ן¸ **׳•׳’׳ ׳™׳© ׳׳™ ${allProducts.length} ׳׳•׳¦׳¨׳™׳ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳:**\n\n`;
                        
                        // Add store products
                        allProducts.slice(0, 3).forEach((product, index) => {
                            response += `**${index + 1}. ${product.name}** - ג‚×${product.price}\n`;
                            response += `נ× **׳—׳ ׳•׳×:** ${product.pageTitle}\n`;
                            response += `נ”— [׳¦׳₪׳” ׳‘׳“׳£](${product.pageUrl})\n\n`;
                        });
                        
                        if (allProducts.length > 3) {
                            response += `... ׳•׳¢׳•׳“ ${allProducts.length - 3} ׳׳•׳¦׳¨׳™׳ ׳ ׳•׳¡׳₪׳™׳!\n\n`;
                        }
                        
                        response += `נ’¬ **׳”׳©׳׳¨ ׳₪׳¨׳˜׳™׳ ׳•׳׳ ׳™ ׳׳׳¡׳•׳¨ ׳׳•׳×׳ ׳׳׳™ ׳©׳׳×׳׳™׳!**`;
                        
                        return response;
                    }
                    
                    // If we only have store products, continue with existing logic
                    if (allProducts.length > 0) {
                        // Sort by price
                        allProducts.sort((a, b) => {
                            const priceA = getNumericPrice(a?.price);
                            const priceB = getNumericPrice(b?.price);
                            if (priceA === null && priceB === null) return 0;
                            if (priceA === null) return 1;
                            if (priceB === null) return -1;
                            return priceA - priceB;
                        });
                        
                        const cheapest = allProducts[0];
                        const mostExpensive = allProducts[allProducts.length - 1];
                        
                        // נ¯ FIX: Ensure we only use REAL products, not invented ones
                        if (!cheapest || !cheapest.name || !cheapest.price) {
                            console.error('ג Invalid cheapest product:', cheapest);
                            return `׳׳¦׳˜׳¢׳¨, ׳׳ ׳׳¦׳׳×׳™ ׳׳™׳“׳¢ ׳¢׳ ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳ ׳›׳¨׳’׳¢ ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡. ׳ ׳¡׳” ׳׳—׳₪׳© ׳׳•׳¦׳¨ ׳¡׳₪׳¦׳™׳₪׳™ ׳׳• ׳‘׳“׳•׳§ ׳׳× ׳”׳“׳₪׳™׳ ׳”׳–׳׳™׳ ׳™׳.`;
                        }
                        
                        // נ₪– CONVERSATIONAL RESPONSE - Talk like a friend!
                        let response = '';
                        
                        // נ¯ FIX: Also handle "׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳ ׳‘׳׳¨׳§׳˜" variations
                        if (lowerMessage.includes('׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳ ׳‘׳׳¨׳§׳˜')) {
                            // נ¯ FIX: Use REAL product name and price only
                            const productName = cheapest.name || '׳׳•׳¦׳¨';
                            const productPrice = cheapest.price || '׳׳—׳™׳¨ ׳׳₪׳™ ׳‘׳§׳©׳”';
                            const pageTitle = cheapest.pageTitle || cheapest.pageName || '׳—׳ ׳•׳×';
                            
                            // נ¯ FIX: Get page URL for link - find the page from allPages
                            const cleanPageTitle = pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                            let pageUrl = '';
                            
                            // Try to find page from allPages using userId and pageId if available
                            if (cheapest.userId && cheapest.pageId) {
                                pageUrl = `/users/${cheapest.userId}/${cheapest.pageId}_html`;
                            } else if (cheapest.pageUrl) {
                                pageUrl = cheapest.pageUrl;
                            } else {
                                // Fallback: find page from allPages by title
                                for (const page of allPages) {
                                    if (page.title === pageTitle || page.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === cleanPageTitle) {
                                        pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        break;
                                    }
                                }
                            }
                            
                            response += `נ₪– **׳™׳© ׳׳™ "${productName}" ׳‘׳׳—׳™׳¨ ג‚×${productPrice}** - ׳–׳” ${searchKeyword === '׳׳•׳¦׳¨' ? '׳”׳׳•׳¦׳¨' : `׳”${searchKeyword}`} ׳”׳›׳™ ׳–׳•׳ ׳‘׳׳¨׳§׳˜!\n\n`;
                            response += `נ“ ׳”׳•׳ ׳ ׳׳¦׳ ׳‘**${cleanPageTitle}**\n`;
                            if (pageUrl) {
                                response += `נ”— **׳¦׳₪׳” ׳‘׳“׳£:** ${pageUrl}\n\n`;
                            }
                            response += `נ’¡ **׳¨׳•׳¦׳” ׳©׳׳—׳₪׳© ׳׳ ׳¢׳•׳“ ׳׳©׳”׳•?** ׳׳• ׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳׳× ׳”׳“׳£?`;
                            
                            console.log('ג… Returning REAL cheapest product:', {
                                name: productName,
                                price: productPrice,
                                pageTitle: cleanPageTitle,
                                pageUrl: pageUrl
                            });
                        } else if (lowerMessage.includes('׳”׳›׳™ ׳™׳§׳¨') || lowerMessage.includes('׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳™׳§׳¨')) {
                            // נ¯ FIX: Use REAL product name and price only, with link
                            const productName = mostExpensive.name || '׳׳•׳¦׳¨';
                            const productPrice = mostExpensive.price || '׳׳—׳™׳¨ ׳׳₪׳™ ׳‘׳§׳©׳”';
                            const pageTitle = mostExpensive.pageTitle || mostExpensive.pageName || '׳—׳ ׳•׳×';
                            const cleanPageTitle = pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                            
                            // נ¯ FIX: Get page URL for link
                            let pageUrl = '';
                            if (mostExpensive.userId && mostExpensive.pageId) {
                                pageUrl = `/users/${mostExpensive.userId}/${mostExpensive.pageId}_html`;
                            } else if (mostExpensive.pageUrl) {
                                pageUrl = mostExpensive.pageUrl;
                            } else {
                                // Fallback: find page from allPages by title
                                for (const page of allPages) {
                                    if (page.title === pageTitle || page.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === cleanPageTitle) {
                                        pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        break;
                                    }
                                }
                            }
                            
                            response += `נ₪– **׳™׳© ׳׳™ "${productName}" ׳‘׳׳—׳™׳¨ ג‚×${productPrice}** - ׳–׳” ${searchKeyword === '׳׳•׳¦׳¨' ? '׳”׳׳•׳¦׳¨' : `׳”${searchKeyword}`} ׳”׳›׳™ ׳™׳§׳¨ ׳‘׳׳¨׳§׳˜!\n\n`;
                            response += `נ“ ׳”׳•׳ ׳ ׳׳¦׳ ׳‘**${cleanPageTitle}**\n`;
                            if (pageUrl) {
                                response += `נ”— **׳¦׳₪׳” ׳‘׳“׳£:** ${pageUrl}\n\n`;
                            }
                            response += `נ’¡ **׳¨׳•׳¦׳” ׳©׳׳—׳₪׳© ׳׳ ׳¢׳•׳“ ׳׳©׳”׳•?** ׳׳• ׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳׳× ׳”׳“׳£?`;
                        } else {
                            response += `נ₪– **׳׳¦׳׳×׳™ ${allProducts.length} ׳׳•׳¦׳¨׳™׳ ׳‘-${relevantPages.length} ׳—׳ ׳•׳™׳•׳×!**\n\n`;
                            response += `נ¥‡ **׳”׳›׳™ ׳–׳•׳:** ${cheapest.name} - ג‚×${cheapest.price}\n`;
                            response += `נ’ **׳”׳›׳™ ׳™׳§׳¨:** ${mostExpensive.name} - ג‚×${mostExpensive.price}\n\n`;
                            response += `נ’¡ **׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳׳× ׳”׳׳•׳¦׳¨׳™׳? ׳׳• ׳©׳׳—׳₪׳© ׳׳ ׳׳©׳”׳• ׳׳—׳¨?**`;
                        }
                        
                        // נ’¾ SAVE the recommended page in context so we can open it if user says "yes"
                        const recommendedProduct = lowerMessage.includes('׳”׳›׳™ ׳–׳•׳') ? cheapest : (lowerMessage.includes('׳”׳›׳™ ׳™׳§׳¨') ? mostExpensive : cheapest);
                        const firstRelevantPage = relevantPages[0];
                        
                        // נ¯ CLEAN the title - remove timestamp (e.g., "1761023899504")
                        const cleanTitle = firstRelevantPage.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                        
                        window.marketplaceConversationContext.recommendedPage = {
                            title: cleanTitle,
                            url: firstRelevantPage.url,
                            pageId: firstRelevantPage.pageId
                        };
                        console.log('נ’¾ Saved recommended page (Marketplace):', window.marketplaceConversationContext.recommendedPage);
                        
                        addAIMessage(response, false);
                        return; // STOP HERE - We showed price comparison
                        
                        // OLD CODE - Remove automatic preview:
                        // Add page preview after comparison
                        if (false && lowerMessage.includes('׳”׳›׳™ ׳–׳•׳')) {
                            response += `\n\nנ“± **׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳©׳ ׳”׳“׳£ ׳”׳–׳•׳ ׳‘׳™׳•׳×׳¨:**\n`;
                            response += `![${cheapest.pageTitle}](${cheapest.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>נ“± ׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳”: ${cheapest.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${cheapest.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        } else if (lowerMessage.includes('׳”׳›׳™ ׳™׳§׳¨')) {
                            response += `\n\nנ“± **׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳©׳ ׳”׳“׳£ ׳”׳™׳§׳¨ ׳‘׳™׳•׳×׳¨:**\n`;
                            response += `![${mostExpensive.pageTitle}](${mostExpensive.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>נ“± ׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳”: ${mostExpensive.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${mostExpensive.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        } else {
                            response += `\n\nנ“± **׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳©׳ ׳”׳“׳£ ׳”׳–׳•׳ ׳‘׳™׳•׳×׳¨:**\n`;
                            response += `![${cheapest.pageTitle}](${cheapest.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>נ“± ׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳”: ${cheapest.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${cheapest.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        }
                        
                        return response;
                    }
                }
                
                return `ג **׳׳ ׳׳¦׳׳×׳™ ׳×׳•׳¦׳׳•׳× ׳¨׳׳•׳•׳ ׳˜׳™׳•׳× ׳‘׳׳¢׳¨׳›׳× ׳©׳׳ ׳•.**\n\nנ’¡ **׳׳” ׳©׳™׳© ׳׳ ׳•:**\n${allPages.slice(0, 4).map(page => `ג€¢ ${page.title} - ${page.pageType === 'store' ? '׳—׳ ׳•׳×' : page.pageType === 'course' ? '׳§׳•׳¨׳¡' : page.pageType === 'event' ? '׳׳™׳¨׳•׳¢' : page.pageType === 'messageInBottle' ? '׳׳¡׳¨ ׳‘׳‘׳§׳‘׳•׳§' : '׳©׳™׳¨׳•׳×'}`).join('\n')}\n\nנ” **׳ ׳¡׳”:** "׳׳—׳™׳¨׳™׳", "׳׳” ׳™׳© ׳׳›׳", ׳׳• "׳׳—׳₪׳© ׳©׳™׳¨׳•׳×"`;
            }
            
            
            
            // Price search - look for specific products
            if (lowerMessage.includes('׳׳—׳™׳¨') || lowerMessage.includes('׳›׳׳”') || lowerMessage.includes('׳¢׳•׳׳”') || lowerMessage.includes('ג‚×') || lowerMessage.includes('׳©׳§׳')) {
                console.log('נ’° Price search triggered:', lowerMessage);
                
                // Determine what product they're looking for
                let searchKeyword = '';
                if (lowerMessage.includes('׳©׳¢׳•׳') || lowerMessage.includes('׳©׳¢׳•׳ ׳™׳')) {
                    searchKeyword = '׳©׳¢׳•׳';
                    console.log('נ” Detected watch search');
                }
                else if (lowerMessage.includes('׳׳§')) searchKeyword = '׳׳§';
                else if (lowerMessage.includes('׳¦׳¢׳¦׳•׳¢') || lowerMessage.includes('׳¦׳¢׳¦׳•׳¢׳™׳')) searchKeyword = '׳¦׳¢׳¦׳•׳¢';
                else if (lowerMessage.includes('׳×׳›׳©׳™׳˜') || lowerMessage.includes('׳×׳›׳©׳™׳˜׳™׳')) searchKeyword = '׳×׳›׳©׳™׳˜';
                else if (lastSearchContext) {
                    searchKeyword = lastSearchContext;
                    console.log('נ” Using last search context:', lastSearchContext);
                }
                else if (lastSearchResults.length > 0) {
                    // Use last search results if available
                    relevantPages = lastSearchResults;
                    searchKeyword = lastSearchContext || '׳׳•׳¦׳¨';
                    console.log('נ” Using last search results:', relevantPages.length, 'pages');
                }
                else searchKeyword = '׳׳•׳¦׳¨';
                
                console.log('נ” Final search keyword:', searchKeyword);
                
                // Filter pages by specific keyword if mentioned - STRICT FILTERING
                let relevantPages = [];
                
                // Only search if we don't have results from previous search
                if (lastSearchResults.length === 0) {
                    relevantPages = allPages.filter(page => {
                    if (searchKeyword === '׳׳•׳¦׳¨') {
                        return page.pageType === 'store' || page.pageType === 'messageInBottle';
                    }
                    
                    const titleLower = page.title.toLowerCase();
                    const descLower = (page.description || '').toLowerCase();
                    const requestLower = (page.request || '').toLowerCase();
                    
                    // Check for both singular and plural forms
                    const pluralKeyword = searchKeyword + '׳™׳'; // e.g., ׳©׳¢׳•׳ -> ׳©׳¢׳•׳ ׳™׳
                    
                    // נ¯ FIX: Use synonyms for search - e.g., "׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨" should match "׳׳¡׳₪׳¨׳”"
                    const synonymMap = {
                        '׳׳¡׳₪׳¨׳”': ['׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳×׳¡׳₪׳•׳¨׳•׳×', '׳׳¡׳₪׳¨', '׳¡׳₪׳¨ ׳’׳‘׳¨׳™׳', '׳¡׳₪׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨'],
                        '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                        '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨']
                    };
                    
                    // Get synonyms for search keyword
                    const synonyms = synonymMap[searchKeyword] || [];
                    const allSearchTerms = [searchKeyword, pluralKeyword, ...synonyms];
                    
                    // Only show pages that actually contain the keyword in title OR description OR request OR products (including synonyms)
                    const hasKeywordInTitle = allSearchTerms.some(term => titleLower.includes(term));
                    const hasKeywordInDesc = allSearchTerms.some(term => descLower.includes(term));
                    const hasKeywordInRequest = allSearchTerms.some(term => requestLower.includes(term));
                    
                    // Check if keyword exists in any product name (including synonyms)
                    let hasKeywordInProducts = false;
                    if (page.products && page.products.length > 0) {
                        hasKeywordInProducts = page.products.some(product => 
                            allSearchTerms.some(term => product.name.toLowerCase().includes(term))
                        );
                    }
                    
                    // Search in all page types, not just stores
                    const matches = (hasKeywordInTitle || hasKeywordInDesc || hasKeywordInProducts);
                    
                    if (matches) {
                        console.log('ג… Found matching page:', page.title, '(searching for:', searchKeyword, 'or', pluralKeyword + ')');
                    }
                    
                    return matches;
                    });
                } else {
                    // Use previous search results
                    relevantPages = lastSearchResults;
                }
                
                // If no specific keyword found, show all stores and messageInBottle
                if (relevantPages.length === 0 && searchKeyword === '׳׳•׳¦׳¨') {
                    relevantPages = allPages.filter(page => page.pageType === 'store' || page.pageType === 'messageInBottle');
                }
                
                console.log(`נ” Searching for "${searchKeyword}" - found ${relevantPages.length} pages`);
                
                    if (relevantPages.length > 0) {
                        // Save search results for context
                        lastSearchResults = relevantPages;
                        
                        let response = `נ’° **׳׳—׳™׳¨׳™׳ ׳¢׳‘׳•׳¨ ${searchKeyword}:**\n\n`;
                        
                        // Add smart recommendations before showing prices
                        if (searchKeyword === '׳׳×׳ ׳”' || searchKeyword === '׳׳×׳ ׳•׳×') {
                            response += `נ **׳”׳׳׳¦׳•׳× ׳׳×׳ ׳•׳× ׳׳•׳©׳׳׳•׳×:**\n\n`;
                            
                            // Categorize pages by type for better recommendations
                            const storePages = relevantPages.filter(p => p.pageType === 'store');
                            const servicePages = relevantPages.filter(p => p.pageType === 'serviceProvider');
                            const coursePages = relevantPages.filter(p => p.pageType === 'course');
                            const eventPages = relevantPages.filter(p => p.pageType === 'event');
                            const messageInBottlePages = relevantPages.filter(p => p.pageType === 'messageInBottle');
                            
                            if (storePages.length > 0) {
                                response += `נ›ן¸ **׳׳×׳ ׳•׳× ׳׳—׳ ׳•׳™׳•׳×:**\n`;
                                storePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `ג€¢ **${page.title}** - ׳׳×׳ ׳•׳× ׳׳™׳›׳•׳×׳™׳•׳×! נ×\n`;
                                    response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (servicePages.length > 0) {
                                response += `נ’… **׳׳×׳ ׳•׳× ׳—׳•׳•׳™׳”:**\n`;
                                servicePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `ג€¢ **${page.title}** - ׳—׳•׳•׳™׳” ׳׳₪׳ ׳§׳×! נ’…\n`;
                                    response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (coursePages.length > 0) {
                                response += `נ“ **׳׳×׳ ׳•׳× ׳”׳¢׳©׳¨׳”:**\n`;
                                coursePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `ג€¢ **${page.title}** - ׳׳×׳ ׳” ׳©׳×׳©׳ ׳” ׳—׳™׳™׳! נ“\n`;
                                    response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (eventPages.length > 0) {
                                response += `נ‰ **׳׳×׳ ׳•׳× ׳׳™׳¨׳•׳¢׳™׳:**\n`;
                                eventPages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `ג€¢ **${page.title}** - ׳—׳•׳•׳™׳” ׳‘׳׳×׳™ ׳ ׳©׳›׳—׳×! נ‰\n`;
                                    response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (messageInBottlePages.length > 0) {
                                response += `נ¾ **׳׳¡׳¨׳™׳ ׳‘׳‘׳§׳‘׳•׳§:**\n`;
                                messageInBottlePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `ג€¢ **${page.name}** - ${page.request} נ¾\n`;
                                    if (page.price) {
                                        response += `  נ’° **׳׳—׳™׳¨:** ג‚×${page.price} ${page.priceType || '׳›׳׳׳™'}\n`;
                                    }
                                    response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            response += `נ’¡ **׳˜׳™׳₪:** ׳׳›׳ ׳׳×׳ ׳” ׳™׳© ׳׳—׳™׳¨׳™׳ ׳©׳•׳ ׳™׳ - ׳›׳×׳•׳‘ "׳׳—׳™׳¨׳™׳" ׳›׳“׳™ ׳׳¨׳׳•׳× ׳׳× ׳›׳ ׳”׳׳—׳™׳¨׳™׳!\n\n`;
                        }
                        
                        for (const page of relevantPages.slice(0, 3)) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        
                        if (page.pageType === 'messageInBottle') {
                            response += `ג€¢ **${page.name}** נ¾\n`;
                            response += `  **${page.request}**\n`;
                            response += `  נ“ **׳׳–׳•׳¨:** ${page.area}\n`;
                            if (page.price) {
                                response += `  נ’° **׳׳—׳™׳¨:** ג‚×${page.price} ${page.priceType || '׳›׳׳׳™'}\n`;
                            }
                            response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n\n`;
                        } else {
                        response += `ג€¢ **${page.title}** נ×\n`;
                        response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                        
                        // Use products from metadata if available - ENHANCED PRODUCT INFO
                        if (page.products && page.products.length > 0) {
                            response += `\n  **נ›ן¸ ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳:**\n`;
                            
                            // Sort products by price for better recommendations
                            const sortedProducts = [...page.products].sort((a, b) => {
                                const priceA = getNumericPrice(a?.price);
                                const priceB = getNumericPrice(b?.price);
                                if (priceA === null && priceB === null) return 0;
                                if (priceA === null) return 1;
                                if (priceB === null) return -1;
                                return priceA - priceB;
                            });
                            
                            sortedProducts.slice(0, 5).forEach((product, index) => {
                                const price = getNumericPrice(product?.price);
                                let priceEmoji = 'נ’°';
                                if (price !== null) {
                                    if (price < 100) priceEmoji = 'נ’';
                                    else if (price < 500) priceEmoji = 'נ’›';
                                    else if (price < 1000) priceEmoji = 'נ§¡';
                                    else priceEmoji = 'ג₪ן¸';
                                }
                                
                                response += `  ${priceEmoji} **${product.name}** - ג‚×${product.price}`;
                                
                                // Add availability status
                                if (index === 0) response += ` ג­ **׳”׳›׳™ ׳–׳•׳!**`;
                                if (index === sortedProducts.length - 1) response += ` נ’ **׳₪׳¨׳™׳׳™׳•׳**`;
                                
                                response += `\n`;
                            });
                            
                            // Smart recommendations based on user intent
                            if (lowerMessage.includes('׳–׳•׳') || lowerMessage.includes('׳”׳›׳™ ׳–׳•׳')) {
                                const cheapest = sortedProducts[0];
                                response += `\n  נ¯ **׳”׳׳׳¦׳” ׳—׳›׳׳”:** ${cheapest.name} - ׳”׳›׳™ ׳׳©׳×׳׳! ג‚×${cheapest.price}\n`;
                            } else if (lowerMessage.includes('׳™׳§׳¨') || lowerMessage.includes('׳™׳•׳§׳¨׳”')) {
                                const mostExpensive = sortedProducts[sortedProducts.length - 1];
                                response += `\n  נ’ **׳”׳׳׳¦׳” ׳™׳•׳§׳¨׳”:** ${mostExpensive.name} - ׳”׳›׳™ ׳׳™׳›׳•׳×׳™! ג‚×${mostExpensive.price}\n`;
                            } else if (lowerMessage.includes('׳׳×׳ ׳”') || lowerMessage.includes('׳׳×׳ ׳×')) {
                                const midRange = sortedProducts[Math.floor(sortedProducts.length / 2)];
                                response += `\n  נ **׳׳×׳ ׳” ׳׳•׳©׳׳׳×:** ${midRange.name} - ׳׳™׳–׳•׳ ׳׳•׳©׳׳! ג‚×${midRange.price}\n`;
                            }
                            
                            // Add total products count
                            if (page.products.length > 5) {
                                response += `\n  נ“ **׳¡׳”"׳› ${page.products.length} ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳** - [נ‘ן¸ ׳¦׳₪׳” ׳‘׳›׳•׳׳](${pageUrl})\n`;
                            }
                            
                            response += `\n`;
                            }
                        }
                        
                        response += `\nנ’¡ **׳˜׳™׳₪:** ׳›׳×׳•׳‘ "׳׳—׳™׳¨׳™׳" ׳›׳“׳™ ׳׳¨׳׳•׳× ׳׳× ׳›׳ ׳”׳׳—׳™׳¨׳™׳ ׳׳• "׳”׳›׳™ ׳–׳•׳" ׳׳׳—׳™׳¨ ׳”׳˜׳•׳‘ ׳‘׳™׳•׳×׳¨!\n`;
                    }
                    
                    if (searchKeyword !== '׳׳•׳¦׳¨') {
                        response += `נ” **׳¨׳•׳¦׳” ׳—׳™׳₪׳•׳© ׳¡׳₪׳¦׳™׳₪׳™?** ׳›׳×׳•׳‘ "׳©׳¢׳•׳" ׳׳• "׳×׳›׳©׳™׳˜" ׳•׳׳ ׳™ ׳׳—׳₪׳© ׳¢׳‘׳•׳¨׳!`;
                    }
                    
                    // Add page preview after recommendations
                    if (relevantPages.length > 0) {
                        const firstPage = relevantPages[0];
                        const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                        response += `\n\nנ“± **׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳”:**\n`;
                        response += `![${firstPage.title}](${pageUrl})\n`;
                        
                        // Add delay and then show preview
                        setTimeout(() => {
                            const chatContainer = document.querySelector('.ai-chat-messages');
                            if (chatContainer) {
                                const previewDiv = document.createElement('div');
                                previewDiv.className = 'page-preview';
                                previewDiv.innerHTML = `
                                    <div class="preview-header">
                                        <h3>נ“± ׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳”: ${firstPage.title}</h3>
                                    </div>
                                    <div class="preview-content">
                                        <iframe src="${pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                    </div>
                                `;
                                chatContainer.appendChild(previewDiv);
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                                
                                // Add animation
                                previewDiv.style.opacity = '0';
                                previewDiv.style.transform = 'translateY(20px)';
                                setTimeout(() => {
                                    previewDiv.style.transition = 'all 0.5s ease';
                                    previewDiv.style.opacity = '1';
                                    previewDiv.style.transform = 'translateY(0)';
                                }, 100);
                            }
                        }, 2000); // Wait 2 seconds before showing preview
                    }
                    
                    return response;
                }
                
                return `ג **׳׳ ׳׳¦׳׳×׳™ ׳×׳•׳¦׳׳•׳× ׳¨׳׳•׳•׳ ׳˜׳™׳•׳× ׳‘׳׳¢׳¨׳›׳× ׳©׳׳ ׳•.**\n\nנ’¡ **׳׳” ׳©׳™׳© ׳׳ ׳•:**\n${allPages.slice(0, 4).map(page => `ג€¢ ${page.title} - ${page.pageType === 'store' ? '׳—׳ ׳•׳×' : page.pageType === 'course' ? '׳§׳•׳¨׳¡' : page.pageType === 'event' ? '׳׳™׳¨׳•׳¢' : page.pageType === 'messageInBottle' ? '׳׳¡׳¨ ׳‘׳‘׳§׳‘׳•׳§' : '׳©׳™׳¨׳•׳×'}`).join('\n')}\n\nנ” **׳ ׳¡׳”:** "׳׳—׳™׳¨׳™׳", "׳׳” ׳™׳© ׳׳›׳", ׳׳• "׳׳—׳₪׳© ׳©׳™׳¨׳•׳×"`;
            }
            
            
            // Check for specific keywords and search
            const keywords = {
                '׳׳×׳ ׳”': 'store',
                '׳׳×׳ ׳•׳×': 'store',
                '׳׳§': 'serviceProvider',
                '׳׳ ׳™׳§׳•׳¨': 'serviceProvider', 
                '׳₪׳“׳™׳§׳•׳¨': 'serviceProvider',
                '׳¦׳¢׳¦׳•׳¢': 'store',
                '׳™׳׳“': 'store',
                '׳—׳ ׳•׳×': 'store',
                '׳§׳•׳¨׳¡': 'course',
                '׳׳™׳׳•׳“': 'course',
                '׳׳™׳¨׳•׳¢': 'event',
                '׳—׳×׳•׳ ׳”': 'event',
                '׳©׳¢׳•׳': 'store',
                '׳©׳¢׳•׳ ׳™׳': 'store',
                '׳×׳›׳©׳™׳˜': 'store',
                '׳×׳›׳©׳™׳˜׳™׳': 'store',
                '׳–׳”׳‘': 'store',
                '׳›׳¡׳£': 'store',
                '׳™׳”׳׳•׳': 'store',
                '׳™׳”׳׳•׳׳™׳': 'store',
                '׳¢׳’׳™׳': 'store',
                '׳¢׳’׳™׳׳™׳': 'store',
                '׳¦׳׳™׳“': 'store',
                '׳¦׳׳™׳“׳™׳': 'store',
                '׳©׳¨׳©׳¨׳×': 'store',
                '׳©׳¨׳©׳¨׳׳•׳×': 'store',
                '׳˜׳‘׳¢׳×': 'store',
                '׳˜׳‘׳¢׳•׳×': 'store'
            };
            
            // Check for specific needs and provide focused recommendations
            const specificNeeds = {
                '׳–׳•׳': { type: 'price', focus: 'cheapest' },
                '׳™׳§׳¨': { type: 'price', focus: 'expensive' },
                '׳׳×׳ ׳” ׳׳™׳׳“': { type: 'gift', focus: 'child' },
                '׳׳×׳ ׳” ׳׳׳™׳©׳”': { type: 'gift', focus: 'woman' },
                '׳׳×׳ ׳” ׳׳’׳‘׳¨': { type: 'gift', focus: 'man' },
                '׳׳×׳ ׳” ׳׳–׳•׳’': { type: 'gift', focus: 'couple' },
                '׳׳×׳ ׳” ׳׳™׳•׳ ׳”׳•׳׳“׳×': { type: 'gift', focus: 'birthday' },
                '׳׳×׳ ׳” ׳׳—׳’': { type: 'gift', focus: 'holiday' },
                '׳׳×׳ ׳” ׳׳™׳•׳—׳“׳×': { type: 'gift', focus: 'special' },
                '׳׳×׳׳‘׳˜': { type: 'help', focus: 'undecided' },
                '׳׳ ׳™׳•׳“׳¢': { type: 'help', focus: 'undecided' },
                '׳׳” ׳׳‘׳—׳•׳¨': { type: 'help', focus: 'undecided' },
                '׳׳™׳–׳”': { type: 'help', focus: 'choice' },
                '׳׳™׳ ׳׳‘׳—׳•׳¨': { type: 'help', focus: 'choice' }
            };
            
            // Smart keyword matching - find related words
            const smartKeywords = {
                '׳׳×׳ ׳”': ['׳׳×׳ ׳”', '׳׳×׳ ׳•׳×', '׳׳×׳ ׳×', '׳׳×׳ ׳•׳×', '׳׳×׳ ׳” ׳', '׳׳×׳ ׳” ׳׳™׳׳“', '׳׳×׳ ׳” ׳׳׳™׳©׳”', '׳׳×׳ ׳” ׳׳’׳‘׳¨', '׳׳×׳ ׳” ׳׳™׳•׳ ׳”׳•׳׳“׳×', '׳׳×׳ ׳” ׳׳—׳’', '׳׳×׳ ׳” ׳׳™׳•׳—׳“׳×'],
                '׳©׳¢׳•׳': ['׳©׳¢׳•׳', '׳©׳¢׳•׳ ׳™׳', '׳–׳׳', '׳–׳׳ ׳™׳', '׳™׳“', '׳™׳“׳™׳™׳', '׳׳‘׳•׳’׳¨', '׳׳‘׳•׳’׳¨׳™׳', '׳§׳׳׳¡׳™', '׳¡׳₪׳•׳¨׳˜', '׳™׳•׳§׳¨׳”', '׳¡׳׳׳¨׳˜'],
                '׳×׳›׳©׳™׳˜': ['׳×׳›׳©׳™׳˜', '׳×׳›׳©׳™׳˜׳™׳', '׳–׳”׳‘', '׳›׳¡׳£', '׳™׳”׳׳•׳', '׳™׳”׳׳•׳׳™׳', '׳¢׳’׳™׳', '׳¢׳’׳™׳׳™׳', '׳¦׳׳™׳“', '׳¦׳׳™׳“׳™׳', '׳©׳¨׳©׳¨׳×', '׳©׳¨׳©׳¨׳׳•׳×', '׳˜׳‘׳¢׳×', '׳˜׳‘׳¢׳•׳×'],
                '׳¦׳¢׳¦׳•׳¢': ['׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳™׳׳“', '׳™׳׳“׳™׳', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳‘׳•׳‘׳”', '׳‘׳•׳‘׳•׳×', '׳¨׳›׳‘', '׳׳›׳•׳ ׳™׳×'],
                '׳׳§': ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳™׳•׳₪׳™', '׳™׳•׳₪׳™', '׳¡׳₪׳', '׳˜׳™׳₪׳•׳—'],
                '׳§׳•׳¨׳¡': ['׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳׳™׳׳•׳“', '׳׳™׳׳•׳“׳™׳', '׳”׳“׳¨׳›׳”', '׳”׳“׳¨׳›׳•׳×', '׳¡׳׳™׳ ׳¨', '׳¡׳׳™׳ ׳¨׳™׳']
            };
            
            // Check for specific needs first - DISABLED TO PREVENT INVENTING
            let specificNeed = null;
            // for (const [need, config] of Object.entries(specificNeeds)) {
            //     if (lowerMessage.includes(need)) {
            //         specificNeed = config;
            //         break;
            //     }
            // }
            
            // Smart search - check for any related keywords
            for (const [mainKeyword, relatedWords] of Object.entries(smartKeywords)) {
                const hasRelatedWord = relatedWords.some(word => lowerMessage.includes(word));
                if (hasRelatedWord) {
                    const type = keywords[mainKeyword] || 'store';
                    
                    // Remember search context for future price queries
                    lastSearchContext = mainKeyword;
                    
                    // More precise search - look in title and description with better matching
                    let matchingPages = allPages.filter(page => {
                        const titleLower = page.title.toLowerCase();
                        const descLower = (page.description || '').toLowerCase();
                        
                        // Check if any related word appears in title or description
                        const titleMatch = relatedWords.some(word => titleLower.includes(word));
                        const descMatch = relatedWords.some(word => descLower.includes(word));
                        
                        // Also check for partial matches and synonyms
                        const partialMatch = relatedWords.some(word => {
                            const wordParts = word.split(' ');
                            return wordParts.some(part => 
                                titleLower.includes(part) || descLower.includes(part)
                            );
                        });
                        
                        return page.pageType === type && (titleMatch || descMatch || partialMatch);
                    });
                    
                    // DISABLED - No more inventing recommendations
                    // Apply specific filtering based on user needs
                    // if (specificNeed) { ... }
                    
                    console.log(`נ” Searching for "${mainKeyword}" in type "${type}"`, { matchingPages: matchingPages.length, allPages: allPages.length });
                    
                    if (matchingPages.length > 0) {
                        let response = '';
                        
                        // Simple response - no more inventing
                        response = `נ¯ **׳׳¦׳׳×׳™ ${matchingPages.length} ׳“׳₪׳™׳ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳ ׳"${mainKeyword}":**\n\n`;
                        
                        // Add smart recommendations for gifts
                        if (mainKeyword === '׳׳×׳ ׳”' || mainKeyword === '׳׳×׳ ׳•׳×') {
                            response += `נ **׳׳×׳ ׳•׳× ׳׳•׳©׳׳׳•׳×! ׳‘׳•׳׳• ׳ ׳׳¦׳ ׳׳× ׳”׳׳×׳ ׳” ׳”׳׳•׳©׳׳׳×:**\n\n`;
                            
                            // Show specific products with prices for children
                            if (lowerMessage.includes('׳™׳׳“') || lowerMessage.includes('׳™׳׳“׳™׳') || lowerMessage.includes('׳™׳׳“׳”') || lowerMessage.includes('׳™׳׳“׳•׳×')) {
                                response += `נ‘¶ **׳׳×׳ ׳•׳× ׳׳•׳©׳׳׳•׳× ׳׳™׳׳“׳™׳ - ׳”׳ ׳” ׳”׳׳׳¦׳” ׳¡׳₪׳¦׳™׳₪׳™׳×:**\n\n`;
                                
                                // Find toy pages specifically - exclude services
                                const toyPages = matchingPages.filter(p => 
                                    p.pageType === 'store' && 
                                    p.pageType !== 'serviceProvider' &&
                                    (p.title.toLowerCase().includes('׳¦׳¢׳¦׳•׳¢') || 
                                     p.title.toLowerCase().includes('toy') ||
                                     p.description?.toLowerCase().includes('׳¦׳¢׳¦׳•׳¢') ||
                                     p.title.toLowerCase().includes('׳׳©׳—׳§') ||
                                     p.description?.toLowerCase().includes('׳׳©׳—׳§') ||
                                     p.title.toLowerCase().includes('׳‘׳•׳‘׳”') ||
                                     p.description?.toLowerCase().includes('׳‘׳•׳‘׳”') ||
                                     p.title.toLowerCase().includes('׳¨׳›׳‘') ||
                                     p.description?.toLowerCase().includes('׳¨׳›׳‘') ||
                                     p.title.toLowerCase().includes('׳™׳ ׳™׳‘') ||
                                     p.description?.toLowerCase().includes('׳™׳׳“׳™׳') ||
                                     p.description?.toLowerCase().includes('׳™׳׳“')) &&
                                    !p.title.toLowerCase().includes('׳׳§') &&
                                    !p.title.toLowerCase().includes('׳’׳') &&
                                    !p.title.toLowerCase().includes('׳©׳¢׳•׳') &&
                                    !p.title.toLowerCase().includes('׳×׳›׳©׳™׳˜')
                                );
                                
                                if (toyPages.length > 0) {
                                    // Show ONLY ONE specific product with price
                                    const firstPage = toyPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `נ§¸ **${firstPage.title}**\n`;
                                    
                                    // Try to get real product info - only show if we have real data
                                    if (firstPage.products && firstPage.products.length > 0) {
                                        const sortedProducts = [...firstPage.products].sort((a, b) => {
                                            const priceA = getNumericPrice(a?.price);
                                            const priceB = getNumericPrice(b?.price);
                                            if (priceA === null && priceB === null) return 0;
                                            if (priceA === null) return 1;
                                            if (priceB === null) return -1;
                                            return priceA - priceB;
                                        });
                                        
                                        // Show only the cheapest product as recommendation
                                        const cheapestProduct = sortedProducts[0];
                                        const price = getNumericPrice(cheapestProduct?.price);
                                        let priceEmoji = 'נ’°';
                                        if (price !== null) {
                                            if (price < 100) priceEmoji = 'נ’';
                                            else if (price < 500) priceEmoji = 'נ’›';
                                            else if (price < 1000) priceEmoji = 'נ§¡';
                                            else priceEmoji = 'ג₪ן¸';
                                        }
                                        
                                        response += `נ¯ **׳”׳׳׳¦׳” ׳©׳׳™ - ׳׳•׳¦׳¨ ׳׳—׳“ ׳׳•׳©׳׳:**\n`;
                                        response += `  ${priceEmoji} **${cheapestProduct.name}** - ג‚×${cheapestProduct.price} ג­ **׳”׳›׳™ ׳–׳•׳!**\n`;
                                        response += `  נ“ **׳¡׳”"׳› ${sortedProducts.length} ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳**\n`;
                                    } else if (firstPage.description) {
                                        // Try to extract product info from description
                                        const productInfo = await extractProductInfo(firstPage.description, '׳¦׳¢׳¦׳•׳¢', pageUrl);
                                        if (productInfo && productInfo.price) {
                                            response += `נ¯ **׳”׳׳׳¦׳” ׳©׳׳™ - ׳׳•׳¦׳¨ ׳׳—׳“ ׳׳•׳©׳׳:**\n`;
                                            response += `  נ’° **${productInfo.name || '׳¦׳¢׳¦׳•׳¢ ׳׳™׳•׳—׳“'}** - ${productInfo.price}\n`;
                                        } else {
                                            response += `נ¯ **׳”׳׳׳¦׳” ׳©׳׳™ - ׳׳•׳¦׳¨ ׳׳—׳“ ׳׳•׳©׳׳:**\n`;
                                            response += `  נ§¸ **׳¦׳¢׳¦׳•׳¢׳™׳ ׳—׳›׳׳™׳ ׳•׳׳”׳ ׳™׳** - ׳׳—׳™׳¨ ׳׳₪׳™ ׳‘׳§׳©׳”\n`;
                                        }
                                    } else {
                                        response += `נ¯ **׳”׳׳׳¦׳” ׳©׳׳™ - ׳׳•׳¦׳¨ ׳׳—׳“ ׳׳•׳©׳׳:**\n`;
                                        response += `  נ§¸ **׳¦׳¢׳¦׳•׳¢׳™׳ ׳—׳›׳׳™׳ ׳•׳׳”׳ ׳™׳** - ׳׳—׳™׳¨ ׳׳₪׳™ ׳‘׳§׳©׳”\n`;
                                    }
                                    
                                    response += `נ× **׳—׳ ׳•׳×:** ${firstPage.title}\n`;
                                    response += `נ”— [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n\n`;
                                    
                                    response += `נ’¡ **׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳¢׳•׳“?** ׳›׳×׳•׳‘ "׳׳—׳™׳¨׳™׳" ׳׳• "׳”׳›׳™ ׳–׳•׳"!\n\n`;
                                    
                                    // Add iframe preview after recommendations
                                    response += `נ“± **׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳©׳ ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                } else {
                                    // Fallback to general pages
                                    response += `נ¯ **׳”׳׳׳¦׳•׳× ׳›׳׳׳™׳•׳× ׳׳™׳׳“׳™׳:**\n`;
                                    matchingPages.slice(0, 2).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `ג€¢ **${page.title}** - ׳׳×׳ ׳” ׳׳•׳©׳׳׳×! נ\n`;
                                        response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                                    });
                                }
                                
                            } else if (lowerMessage.includes('׳׳™׳©׳”') || lowerMessage.includes('׳ ׳©׳™׳') || lowerMessage.includes('׳׳™׳©׳”') || lowerMessage.includes('׳ ׳©׳™׳')) {
                                response += `נ‘© **׳׳×׳ ׳•׳× ׳׳•׳©׳׳׳•׳× ׳׳ ׳©׳™׳ - ׳”׳ ׳” ׳”׳׳׳¦׳•׳× ׳¡׳₪׳¦׳™׳₪׳™׳•׳×:**\n\n`;
                                
                                // Find beauty/service pages
                                const beautyPages = matchingPages.filter(p => 
                                    p.pageType === 'serviceProvider' || 
                                    (p.title.toLowerCase().includes('׳׳§') || 
                                     p.title.toLowerCase().includes('׳’׳') ||
                                     p.title.toLowerCase().includes('׳™׳•׳₪׳™') ||
                                     p.title.toLowerCase().includes('׳©׳™׳¢׳¨') ||
                                     p.title.toLowerCase().includes('׳¢׳™׳¦׳•׳‘') ||
                                     p.title.toLowerCase().includes('׳—׳’׳™׳×') ||
                                     p.title.toLowerCase().includes('׳ ׳™׳™׳׳¡') ||
                                     p.description?.toLowerCase().includes('׳™׳•׳₪׳™') ||
                                     p.description?.toLowerCase().includes('׳©׳™׳¢׳¨') ||
                                     p.description?.toLowerCase().includes('׳׳§') ||
                                     p.description?.toLowerCase().includes('׳’׳'))
                                );
                                
                                if (beautyPages.length > 0) {
                                    // Show specific services with prices
                                    for (const page of beautyPages.slice(0, 2)) {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `נ’… **${page.title}**\n`;
                                        
                                        // Try to extract service info
                                        if (page.description) {
                                            const serviceInfo = await extractProductInfo(page.description, '׳׳§', pageUrl);
                                            if (serviceInfo && serviceInfo.price) {
                                                response += `נ¯ **׳”׳׳׳¦׳” ׳©׳׳™:**\n`;
                                                response += `  נ’° **${serviceInfo.name || '׳©׳™׳¨׳•׳× ׳™׳•׳₪׳™'}** - ${serviceInfo.price}\n`;
                                            } else {
                                                response += `נ¯ **׳”׳׳׳¦׳” ׳©׳׳™:**\n`;
                                                response += `  נ’… **׳©׳™׳¨׳•׳×׳™ ׳™׳•׳₪׳™ ׳׳₪׳ ׳§׳™׳** - ׳׳—׳™׳¨ ׳׳₪׳™ ׳‘׳§׳©׳”\n`;
                                            }
                                        } else {
                                            response += `נ¯ **׳”׳׳׳¦׳” ׳©׳׳™:**\n`;
                                            response += `  נ’… **׳©׳™׳¨׳•׳×׳™ ׳™׳•׳₪׳™ ׳׳₪׳ ׳§׳™׳** - ׳׳—׳™׳¨ ׳׳₪׳™ ׳‘׳§׳©׳”\n`;
                                        }
                                        
                                        response += `נ× **׳—׳ ׳•׳×:** ${page.title}\n`;
                                        response += `נ”— [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n\n`;
                                    }
                                } else {
                                    // Fallback to general pages
                                    response += `נ¯ **׳”׳׳׳¦׳•׳× ׳›׳׳׳™׳•׳× ׳׳ ׳©׳™׳:**\n`;
                                    matchingPages.slice(0, 2).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `ג€¢ **${page.title}** - ׳׳×׳ ׳” ׳׳•׳©׳׳׳×! נ\n`;
                                        response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                                    });
                                }
                                
                                response += `נ’¡ **׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳¢׳•׳“?** ׳›׳×׳•׳‘ "׳׳—׳™׳¨׳™׳" ׳׳• "׳”׳›׳™ ׳–׳•׳"!\n\n`;
                                
                            } else if (lowerMessage.includes('׳’׳‘׳¨') || lowerMessage.includes('׳’׳‘׳¨׳™׳') || lowerMessage.includes('׳׳‘') || lowerMessage.includes('׳׳‘׳')) {
                                response += `נ‘¨ **׳׳×׳ ׳•׳× ׳׳•׳©׳׳׳•׳× ׳׳’׳‘׳¨׳™׳ - ׳”׳ ׳” ׳”׳׳׳¦׳” ׳¡׳₪׳¦׳™׳₪׳™׳×:**\n\n`;
                                
                                // Find tech/accessory pages
                                const techPages = matchingPages.filter(p => 
                                    p.pageType === 'store' && 
                                    (p.title.toLowerCase().includes('׳˜׳›׳ ׳•׳׳•׳’׳™׳”') || 
                                     p.title.toLowerCase().includes('׳©׳¢׳•׳') ||
                                     p.title.toLowerCase().includes('׳×׳›׳©׳™׳˜') ||
                                     p.title.toLowerCase().includes('׳’׳׳“׳’\'׳˜') ||
                                     p.title.toLowerCase().includes('׳¨׳•׳‘׳•׳˜') ||
                                     p.title.toLowerCase().includes('red') ||
                                     p.title.toLowerCase().includes('׳¦׳™׳₪׳™') ||
                                     p.description?.toLowerCase().includes('׳©׳¢׳•׳') ||
                                     p.description?.toLowerCase().includes('׳×׳›׳©׳™׳˜') ||
                                     p.description?.toLowerCase().includes('׳¨׳•׳‘׳•׳˜') ||
                                     p.description?.toLowerCase().includes('׳˜׳›׳ ׳•׳׳•׳’׳™׳”'))
                                );
                                
                                if (techPages.length > 0) {
                                    // Show ONLY ONE specific product with price
                                    const firstPage = techPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    response += `ג **${firstPage.title}**\n`;
                                    
                                    // Try to get real product info - only show if we have real data
                                    if (firstPage.products && firstPage.products.length > 0) {
                                        const sortedProducts = [...firstPage.products].sort((a, b) => {
                                            const priceA = getNumericPrice(a?.price);
                                            const priceB = getNumericPrice(b?.price);
                                            if (priceA === null && priceB === null) return 0;
                                            if (priceA === null) return 1;
                                            if (priceB === null) return -1;
                                            return priceA - priceB;
                                        });
                                        
                                        // Show only the cheapest product as recommendation
                                        const cheapestProduct = sortedProducts[0];
                                        const price = getNumericPrice(cheapestProduct?.price);
                                        let priceEmoji = 'נ’°';
                                        if (price !== null) {
                                            if (price < 100) priceEmoji = 'נ’';
                                            else if (price < 500) priceEmoji = 'נ’›';
                                            else if (price < 1000) priceEmoji = 'נ§¡';
                                            else priceEmoji = 'ג₪ן¸';
                                        }
                                        
                                        response += `נ¯ **׳”׳׳׳¦׳” ׳©׳׳™ - ׳׳•׳¦׳¨ ׳׳—׳“ ׳׳•׳©׳׳:**\n`;
                                        response += `  ${priceEmoji} **${cheapestProduct.name}** - ג‚×${cheapestProduct.price} ג­ **׳”׳›׳™ ׳–׳•׳!**\n`;
                                        response += `  נ“ **׳¡׳”"׳› ${sortedProducts.length} ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳**\n`;
                                    } else if (firstPage.description) {
                                        // Try to extract product info from description
                                        const productInfo = await extractProductInfo(firstPage.description, '׳©׳¢׳•׳', pageUrl);
                                        if (productInfo && productInfo.price) {
                                            response += `נ¯ **׳”׳׳׳¦׳” ׳©׳׳™ - ׳׳•׳¦׳¨ ׳׳—׳“ ׳׳•׳©׳׳:**\n`;
                                            response += `  נ’° **${productInfo.name || '׳’׳׳“׳’\'׳˜ ׳׳™׳•׳—׳“'}** - ${productInfo.price}\n`;
                                        } else {
                                            response += `נ¯ **׳”׳׳׳¦׳” ׳©׳׳™ - ׳׳•׳¦׳¨ ׳׳—׳“ ׳׳•׳©׳׳:**\n`;
                                            response += `  ג **׳’׳׳“׳’\'׳˜׳™׳ ׳•׳˜׳›׳ ׳•׳׳•׳’׳™׳” ׳׳×׳§׳“׳׳×** - ׳׳—׳™׳¨ ׳׳₪׳™ ׳‘׳§׳©׳”\n`;
                                        }
                                    } else {
                                        response += `נ¯ **׳”׳׳׳¦׳” ׳©׳׳™ - ׳׳•׳¦׳¨ ׳׳—׳“ ׳׳•׳©׳׳:**\n`;
                                        response += `  ג **׳’׳׳“׳’\'׳˜׳™׳ ׳•׳˜׳›׳ ׳•׳׳•׳’׳™׳” ׳׳×׳§׳“׳׳×** - ׳׳—׳™׳¨ ׳׳₪׳™ ׳‘׳§׳©׳”\n`;
                                    }
                                    
                                    response += `נ× **׳—׳ ׳•׳×:** ${firstPage.title}\n`;
                                    response += `נ”— [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n\n`;
                                    
                                    response += `נ’¡ **׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳¢׳•׳“?** ׳›׳×׳•׳‘ "׳׳—׳™׳¨׳™׳" ׳׳• "׳”׳›׳™ ׳–׳•׳"!\n\n`;
                                } else {
                                    // Fallback to general pages
                                    response += `נ¯ **׳”׳׳׳¦׳•׳× ׳›׳׳׳™׳•׳× ׳׳’׳‘׳¨׳™׳:**\n`;
                                    matchingPages.slice(0, 3).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `ג€¢ **${page.title}** - ׳׳×׳ ׳” ׳׳•׳©׳׳׳×! נ\n`;
                                        response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                                    });
                                }
                                
                                response += `נ’¡ **׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳¢׳•׳“?** ׳›׳×׳•׳‘ "׳׳—׳™׳¨׳™׳" ׳׳• "׳”׳›׳™ ׳–׳•׳"!\n\n`;
                                
                                // Add iframe preview after recommendations
                                if (techPages.length > 0) {
                                    const firstPage = techPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `נ“± **׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳©׳ ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                    
                                    // Add delayed iframe preview
                                    setTimeout(() => {
                                        const chatContainer = document.querySelector('.ai-chat-messages');
                                        if (chatContainer) {
                                            const previewDiv = document.createElement('div');
                                            previewDiv.className = 'page-preview';
                                            previewDiv.style.cssText = `
                                                margin: 16px 0;
                                                border: 2px solid #e5e7eb;
                                                border-radius: 12px;
                                                overflow: hidden;
                                                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                                                position: relative;
                                                width: 100vw !important;
                                                position: absolute !important;
                                                left: 0 !important;
                                                right: 0 !important;
                                                max-width: 100% !important;
                                                margin-left: calc(-50vw + 50%) !important;
                                                text-align: right !important;
                                                direction: rtl !important;
                                                height: 300px;
                                                opacity: 0;
                                                transform: translateY(20px);
                                                transition: all 0.5s ease;
                                            `;
                                            previewDiv.innerHTML = `
                                                <div class="preview-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                                    <span>נ</span>
                                                    <span>${firstPage.title}</span>
                                                </div>
                                                <div class="preview-content" style="position: relative; height: 276px; overflow: hidden;">
                                                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c);"></div>
                                                    <iframe src="${pageUrl}" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top left; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>
                                                </div>
                                            `;
                                            chatContainer.appendChild(previewDiv);
                                            chatContainer.scrollTop = chatContainer.scrollHeight;
                                            
                                            // Animate in gradually
                                            setTimeout(() => {
                                                previewDiv.style.opacity = '1';
                                                previewDiv.style.transform = 'translateY(0)';
                                            }, 200);
                                        }
                                    }, 2000);
                                }
                                
                            } else {
                                // General gift recommendations - only show real pages
                                response += `נ¯ **׳׳™׳–׳” ׳¡׳•׳’ ׳׳×׳ ׳” ׳׳×׳ ׳׳—׳₪׳©׳™׳?**\n\n`;
                                
                                // Show only real pages from matchingPages
                                if (matchingPages.length > 0) {
                                    response += `נ **׳”׳“׳₪׳™׳ ׳”׳–׳׳™׳ ׳™׳ ׳‘׳׳¢׳¨׳›׳×:**\n`;
                                    matchingPages.slice(0, 5).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        const emoji = page.pageType === 'store' ? 'נ›ן¸' : page.pageType === 'event' ? 'נ‰' : page.pageType === 'course' ? 'נ“' : page.pageType === 'serviceProvider' ? 'נ”§' : 'נ“„';
                                        response += `ג€¢ **${page.title}** ${emoji} - ${page.description || '׳׳×׳ ׳” ׳׳•׳©׳׳׳×'}\n`;
                                        response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                                    });
                                    response += `\n`;
                                    
                                    // Add iframe preview for first page
                                    const firstPage = matchingPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `נ“± **׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳©׳ ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                    
                                    // Add delayed iframe preview
                                    setTimeout(() => {
                                        const chatContainer = document.querySelector('.ai-chat-messages');
                                        if (chatContainer) {
                                            const previewDiv = document.createElement('div');
                                            previewDiv.className = 'page-preview';
                                            previewDiv.style.cssText = `
                                                margin: 16px 0;
                                                border: 2px solid #e5e7eb;
                                                border-radius: 12px;
                                                overflow: hidden;
                                                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                                                position: relative;
                                                width: 100vw !important;
                                                position: absolute !important;
                                                left: 0 !important;
                                                right: 0 !important;
                                                max-width: 100% !important;
                                                margin-left: calc(-50vw + 50%) !important;
                                                text-align: right !important;
                                                direction: rtl !important;
                                                height: 300px;
                                                opacity: 0;
                                                transform: translateY(20px);
                                                transition: all 0.5s ease;
                                            `;
                                            previewDiv.innerHTML = `
                                                <div class="preview-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                                    <span>נ</span>
                                                    <span>${firstPage.title}</span>
                                                </div>
                                                <div class="preview-content" style="position: relative; height: 276px; overflow: hidden;">
                                                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c);"></div>
                                                    <iframe src="${pageUrl}" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top left; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>
                                                </div>
                                            `;
                                            chatContainer.appendChild(previewDiv);
                                            chatContainer.scrollTop = chatContainer.scrollHeight;
                                            
                                            // Animate in gradually
                                            setTimeout(() => {
                                                previewDiv.style.opacity = '1';
                                                previewDiv.style.transform = 'translateY(0)';
                                            }, 200);
                                        }
                                    }, 2000);
                                } else {
                                    response += `ג **׳׳ ׳׳¦׳׳×׳™ ׳“׳₪׳™׳ ׳‘׳׳¢׳¨׳›׳× ׳©׳׳ ׳•.**\n\n`;
                                }
                                
                                response += `ג“ **׳¢׳–׳•׳¨ ׳׳™ ׳׳”׳׳׳™׳¥ ׳׳:**\n`;
                                response += `ג€¢ **׳׳׳™ ׳”׳׳×׳ ׳”?** (׳™׳׳“, ׳׳™׳©׳”, ׳’׳‘׳¨, ׳–׳•׳’) נ‘¥\n`;
                                response += `ג€¢ **׳׳™׳–׳” ׳¡׳•׳’?** (׳¦׳¢׳¦׳•׳¢׳™׳, ׳™׳•׳₪׳™, ׳˜׳›׳ ׳•׳׳•׳’׳™׳”, ׳§׳•׳¨׳¡׳™׳) נ¯\n`;
                                response += `ג€¢ **׳×׳§׳¦׳™׳‘?** (׳–׳•׳, ׳‘׳™׳ ׳•׳ ׳™, ׳₪׳¨׳™׳׳™׳•׳) נ’°\n\n`;
                            }
                            
                            response += `נ’¡ **׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳׳—׳™׳¨׳™׳?** ׳›׳×׳•׳‘ "׳׳—׳™׳¨׳™׳" ׳׳• "׳›׳׳” ׳–׳” ׳¢׳•׳׳”"!\n`;
                            response += `נ **׳¨׳•׳¦׳” ׳”׳׳׳¦׳” ׳¡׳₪׳¦׳™׳₪׳™׳×?** ׳×׳’׳™׳“ ׳׳™ ׳™׳•׳×׳¨ ׳₪׳¨׳˜׳™׳!\n\n`;
                            
                        } else {
                            // Show actual available pages with specific recommendations
                            response += `נ“‹ **׳”׳׳׳¦׳•׳× ׳¡׳₪׳¦׳™׳₪׳™׳•׳×:**\n\n`;
                        }
                        
                        // Only show pages if it's not a gift search (gift search shows questions instead)
                        if (mainKeyword !== '׳׳×׳ ׳”' && mainKeyword !== '׳׳×׳ ׳•׳×') {
                            // Show more results if user asks for specific number
                            let maxResults = 3;
                            if (lowerMessage.includes('׳›׳׳”') || lowerMessage.includes('׳”׳¨׳‘׳”') || lowerMessage.includes('׳›׳')) {
                                maxResults = Math.min(matchingPages.length, 5);
                            }
                            
                            for (const page of matchingPages.slice(0, maxResults)) {
                            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                            // Use real page preview with iframe
                            const emoji = page.pageType === 'store' ? 'נ×' : page.pageType === 'event' ? 'נ‰' : page.pageType === 'course' ? 'נ“' : page.pageType === 'serviceProvider' ? 'נ”§' : 'נ“„';
                            response += `ג€¢ **${page.title}** ${emoji}\n`;
                            response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                            
                            // Add specific product info if available
                            if (page.pageType === 'store' && page.products && page.products.length > 0) {
                                response += `\n  **נ›ן¸ ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳:**\n`;
                                
                                // Sort products by price for better recommendations
                                const sortedProducts = [...page.products].sort((a, b) => {
                                    const priceA = getNumericPrice(a?.price);
                                    const priceB = getNumericPrice(b?.price);
                                    if (priceA === null && priceB === null) return 0;
                                    if (priceA === null) return 1;
                                    if (priceB === null) return -1;
                                    return priceA - priceB;
                                });
                                
                                sortedProducts.slice(0, 3).forEach((product, index) => {
                                    const price = getNumericPrice(product?.price);
                                    let priceEmoji = 'נ’°';
                                    if (price !== null) {
                                        if (price < 100) priceEmoji = 'נ’';
                                        else if (price < 500) priceEmoji = 'נ’›';
                                        else if (price < 1000) priceEmoji = 'נ§¡';
                                        else priceEmoji = 'ג₪ן¸';
                                    }
                                    
                                    response += `  ${priceEmoji} **${product.name}** - ג‚×${product.price}`;
                                    
                                    if (index === 0) response += ` ג­ **׳”׳›׳™ ׳–׳•׳!**`;
                                    if (index === sortedProducts.length - 1) response += ` נ’ **׳₪׳¨׳™׳׳™׳•׳**`;
                                    
                                    response += `\n`;
                                });
                                
                                // Smart recommendations
                                if (lowerMessage.includes('׳–׳•׳') || lowerMessage.includes('׳”׳›׳™ ׳–׳•׳')) {
                                    const cheapest = sortedProducts[0];
                                    response += `\n  נ¯ **׳”׳׳׳¦׳” ׳—׳›׳׳”:** ${cheapest.name} - ׳”׳›׳™ ׳׳©׳×׳׳! ג‚×${cheapest.price}\n`;
                                }
                                
                                response += `\n`;
                            } else if (page.pageType === 'serviceProvider') {
                                // Enhanced service provider info
                                response += `\n  **נ”§ ׳©׳™׳¨׳•׳×׳™׳ ׳–׳׳™׳ ׳™׳:**\n`;
                                
                                // Check for appointment availability
                                if (page.description && page.description.includes('׳×׳•׳¨')) {
                                    response += `  נ“… **׳×׳•׳¨׳™׳ ׳₪׳ ׳•׳™׳™׳** - ׳–׳׳™׳ ׳׳”׳–׳׳ ׳”!\n`;
                                }
                                
                                // Check for pricing info
                                if (page.description && page.description.includes('ג‚×')) {
                                    const priceMatch = page.description.match(/ג‚×(\d+)/);
                                    if (priceMatch) {
                                        response += `  נ’° **׳׳—׳™׳¨:** ג‚×${priceMatch[1]}\n`;
                                    }
                                }
                                
                                // Check for location
                                if (page.description && (page.description.includes('׳¨׳—׳•׳‘') || page.description.includes('׳¢׳™׳¨') || page.description.includes('׳›׳×׳•׳‘׳×'))) {
                                    response += `  נ“ **׳׳™׳§׳•׳:** ׳–׳׳™׳ ׳‘׳׳–׳•׳¨\n`;
                                }
                                
                                // Add service description
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  נ“ **׳×׳™׳׳•׳¨:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  נ¯ **׳¨׳•׳¦׳” ׳׳”׳–׳׳™׳?** [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl}) ׳׳• ׳”׳×׳§׳©׳¨ ׳™׳©׳™׳¨׳•׳×!\n\n`;
                            } else if (page.pageType === 'event') {
                                // Enhanced event info
                                response += `\n  **נ‰ ׳₪׳¨׳˜׳™ ׳”׳׳™׳¨׳•׳¢:**\n`;
                                
                                if (page.expectedGuests && page.expectedGuests > 0) {
                                    response += `  נ‘¥ **׳׳§׳•׳׳•׳× ׳₪׳ ׳•׳™׳™׳:** ${page.expectedGuests} ׳׳§׳•׳׳•׳×\n`;
                                }
                                
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  נ“ **׳×׳™׳׳•׳¨:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  נ¯ **׳¨׳•׳¦׳” ׳׳”׳¦׳˜׳¨׳£?** [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl}) ׳•׳”׳¨׳©׳!\n\n`;
                            } else if (page.pageType === 'course') {
                                // Enhanced course info
                                response += `\n  **נ“ ׳₪׳¨׳˜׳™ ׳”׳§׳•׳¨׳¡:**\n`;
                                
                                if (page.expectedGuests && page.expectedGuests > 0) {
                                    response += `  נ‘¥ **׳׳§׳•׳׳•׳× ׳₪׳ ׳•׳™׳™׳:** ${page.expectedGuests} ׳׳§׳•׳׳•׳×\n`;
                                }
                                
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  נ“ **׳×׳™׳׳•׳¨:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  נ¯ **׳¨׳•׳¦׳” ׳׳”׳™׳¨׳©׳?** [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl}) ׳•׳”׳×׳—׳ ׳׳׳׳•׳“!\n\n`;
                            } else if (page.pageType === 'store' && page.description) {
                                const productInfo = await extractProductInfo(page.description, mainKeyword, pageUrl);
                                if (productInfo) {
                                    if (productInfo.price) {
                                        response += `  נ’° **׳׳—׳™׳¨:** ${productInfo.price}\n`;
                                    }
                                    if (productInfo.name) {
                                        response += `  נ·ן¸ **׳׳•׳¦׳¨:** ${productInfo.name}\n`;
                                    }
                                    if (productInfo.location) {
                                        response += `  נ“ **׳׳™׳§׳•׳:** ${productInfo.location}\n`;
                                    }
                                }
                            }
                            
                            response += `  <div style="margin: 8px 0; border: 2px solid #e5e7eb; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1); position: relative; width: 100vw !important; max-width: 100% !important; height: 300px !important; margin-left: calc(-50vw + 50%) !important; text-align: right !important; direction: rtl !important;">`;
                            response += `    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c);"></div>`;
                            response += `    <iframe src="${pageUrl}" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top left; position: absolute; top: 0; left: 0;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>`;
                            response += `  </div>\n\n`;
                        }
                        } // Close the if statement for non-gift searches
                        
                        if (matchingPages.length > 3) {
                            response += `׳•׳¢׳•׳“ ${matchingPages.length - 3} ׳“׳₪׳™׳...`;
                        }
                        
                        // DISABLED - No more inventing help messages
                        
                        // Add price information request
                        if (type === 'store') {
                            response += `\nנ’° **׳¨׳•׳¦׳” ׳׳“׳¢׳× ׳¢׳ ׳׳—׳™׳¨׳™׳?** ׳›׳×׳•׳‘ "׳׳—׳™׳¨׳™׳" ׳׳• "׳›׳׳” ׳–׳” ׳¢׳•׳׳”" ׳•׳׳ ׳™ ׳׳—׳₪׳© ׳¢׳‘׳•׳¨׳!`;
                        }
                        
                        return {
                            message: response,
                            action: { type: 'change_category_and_highlight', category: type, highlight_pages: matchingPages.slice(0, 3).map(p => p.pageId) }
                        };
                    } else {
                        // NO PAGES FOUND - Don't invent pages!
                        return {
                            message: `נ˜” **׳׳ ׳׳¦׳׳×׳™ ׳“׳₪׳™׳ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳ ׳"${mainKeyword}".**\n\n׳׳‘׳ ׳™׳© ׳׳ ׳• ׳“׳₪׳™׳ ׳׳—׳¨׳™׳ ׳©׳™׳›׳•׳׳™׳ ׳׳¢׳ ׳™׳™׳ ׳׳•׳×׳:\n\nנ× **׳—׳ ׳•׳™׳•׳×:** ${allPages.filter(p => p.pageType === 'store').length} ׳“׳₪׳™׳\nנ“ **׳§׳•׳¨׳¡׳™׳:** ${allPages.filter(p => p.pageType === 'course').length} ׳“׳₪׳™׳\nנ”§ **׳©׳™׳¨׳•׳×׳™׳:** ${allPages.filter(p => p.pageType === 'serviceProvider').length} ׳“׳₪׳™׳\nנ‰ **׳׳™׳¨׳•׳¢׳™׳:** ${allPages.filter(p => p.pageType === 'event').length} ׳“׳₪׳™׳\n\n**׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳”׳›׳?** ׳׳—׳¥ ׳¢׳ "׳”׳›׳" ׳׳׳¢׳׳”!`,
                            action: { type: 'none' }
                        };
                    }
                }
            }
            
            // Search by title
            const matchingPages = allPages.filter(page => 
                page.title.toLowerCase().includes(lowerMessage)
            );
            
            if (matchingPages.length > 0) {
                let response = `׳׳¦׳׳×׳™ ${matchingPages.length} ׳“׳₪׳™׳ ׳¢׳ "${message}":\n\n`;
                
                matchingPages.slice(0, 3).forEach(page => {
                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                    // Use real page preview with iframe
                    const emoji = page.pageType === 'store' ? 'נ×' : page.pageType === 'event' ? 'נ‰' : page.pageType === 'course' ? 'נ“' : page.pageType === 'serviceProvider' ? 'נ”§' : 'נ“„';
                    response += `ג€¢ **${page.title}** ${emoji}\n`;
                    response += `  [נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})\n`;
                    response += `  <div style="margin: 8px 0; border: 2px solid #e5e7eb; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1); animation: fadeInUp 0.6s ease-out, pulse 2s infinite; position: relative; width: 100vw !important; max-width: 100% !important; height: 200px !important; margin-left: calc(-50vw + 50%) !important; text-align: right !important; direction: rtl !important;">`;
                    response += `    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c); animation: shimmer 2s infinite;"></div>`;
                    response += `    <iframe src="${pageUrl}" style="width: 200%; height: 400px; border: none; transform: scale(0.5); transform-origin: top left; transition: all 0.3s ease; position: absolute; top: 0; left: 0;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>`;
                    response += `  </div>\n\n`;
                });
                
                if (matchingPages.length > 3) {
                    response += `׳•׳¢׳•׳“ ${matchingPages.length - 3} ׳“׳₪׳™׳...`;
                }
                
                return {
                    message: response,
                    action: { type: 'change_category_and_highlight', category: matchingPages[0].pageType, highlight_pages: matchingPages.slice(0, 3).map(p => p.pageId) }
                };
            }
            
            // If no local match, prepare real data for N8N
            const realData = {
                availablePages: allPages.map(p => ({
                    title: p.title,
                    type: p.pageType,
                    products: p.products || []
                }))
            };
            
            return null; // No quick response, send to N8N with real data
            } catch (error) {
                console.error('ג Error in handleSmartSearch:', error);
                console.error('ג Error stack:', error.stack);
                return null;
            }
        }
        
        // Function to extract product info from page content
        async function extractProductInfo(description, keyword, pageUrl) {
            console.log('נ” extractProductInfo called with:', { description: description?.substring(0, 100), keyword, pageUrl });
            
            if (!description && !pageUrl) return null;
            
            const lowerKeyword = keyword.toLowerCase();
            
            // If we have a page URL, fetch the actual content
            if (pageUrl) {
                console.log('נ” Fetching HTML for:', pageUrl);
                try {
                    const response = await fetch(pageUrl);
                    if (response.ok) {
                        const html = await response.text();
                        console.log('נ“„ HTML fetched, length:', html.length);
                        
                        // Extract all prices from HTML
                        const pricePatterns = [
                            /ג‚×\s*(\d+(?:[.,]\d+)?)/g,
                            /׳-?\s*(\d+(?:[.,]\d+)?)\s*ג‚×/g,
                            /(\d+(?:[.,]\d+)?)\s*ג‚×/g,
                            /׳׳—׳™׳¨[^<]*?(\d+(?:[.,]\d+)?)/gi
                        ];
                        
                        let allPrices = [];
                        pricePatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            allPrices.push(...matches.map(m => m[1] || m[0]));
                        });
                        
                        // Remove duplicates and sort
                        allPrices = [...new Set(allPrices)].sort((a, b) => parseFloat(a) - parseFloat(b));
                        
                        console.log('נ’° All prices found:', allPrices);
                        
                        // Extract service/product names
                        const namePatterns = [
                            /<h[1-6][^>]*>([^<]+)<\/h[1-6]>/gi,
                            /<div[^>]*class="[^"]*title[^"]*"[^>]*>([^<]+)<\/div>/gi,
                            /<span[^>]*class="[^"]*name[^"]*"[^>]*>([^<]+)<\/span>/gi
                        ];
                        
                        let allNames = [];
                        namePatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            allNames.push(...matches.map(m => m[1].trim()));
                        });
                        
                        // Filter names that contain the keyword
                        const relevantNames = allNames.filter(name => 
                            name.toLowerCase().includes(lowerKeyword)
                        );
                        
                        console.log('נ·ן¸ Relevant names found:', relevantNames);
                        
                        // Extract location
                        const locationPatterns = [
                            /(?:׳‘׳›׳×׳•׳‘׳×|׳›׳×׳•׳‘׳×|׳׳™׳§׳•׳|׳‘׳׳–׳•׳¨|׳‘׳ ׳×׳ ׳™׳”|׳‘׳×׳ ׳׳‘׳™׳‘|׳‘׳™׳¨׳•׳©׳׳™׳)[^<]*?([׳-׳×\s]+)/gi,
                            /<meta[^>]*name="[^"]*location[^"]*"[^>]*content="([^"]+)"/gi
                        ];
                        
                        let location = null;
                        locationPatterns.forEach(pattern => {
                            const match = html.match(pattern);
                            if (match && !location) {
                                location = match[1].trim();
                            }
                        });
                        
                        // Extract descriptions
                        const descPatterns = [
                            /<p[^>]*class="[^"]*desc[^"]*"[^>]*>([^<]+)<\/p>/gi,
                            /<div[^>]*class="[^"]*description[^"]*"[^>]*>([^<]+)<\/div>/gi
                        ];
                        
                        let descriptions = [];
                        descPatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            descriptions.push(...matches.map(m => m[1].trim()));
                        });
                        
                        return {
                            prices: allPrices.length > 0 ? allPrices : null,
                            names: relevantNames.length > 0 ? relevantNames : null,
                            location: location,
                            descriptions: descriptions.length > 0 ? descriptions : null,
                            allNames: allNames.length > 0 ? allNames : null
                        };
                    }
                } catch (error) {
                    console.error('ג Error fetching HTML:', error);
                }
            }
            
            // Fallback to description parsing
            if (description) {
                const lowerDesc = description.toLowerCase();
                
                // Look for price patterns in description
                const priceRegex = /[\d,]+ג‚×|[\d,]+ ׳©"׳—|[\d,]+ ׳©׳§׳|[\d,]+ ג‚×/g;
                const prices = [];
                let match;
                while ((match = priceRegex.exec(description)) !== null) {
                    prices.push(match[0]);
                }
                
                console.log('נ’° Prices found in description:', prices);
                
                if (prices.length > 0) {
                    // Try to find product name near the keyword
                    const keywordIndex = lowerDesc.indexOf(lowerKeyword);
                    if (keywordIndex !== -1) {
                        const start = Math.max(0, keywordIndex - 50);
                        const end = Math.min(description.length, keywordIndex + 50);
                        const context = description.substring(start, end);
                        
                        return {
                            name: context.trim(),
                            price: prices[0]
                        };
                    }
                }
            }
            
            return null;
        }
        
        // נ§  CONVERSATION CONTEXT MEMORY for Marketplace (global variable)
        if (!window.marketplaceConversationContext) {
            window.marketplaceConversationContext = {
                lastSearchCategory: null,      // Last category user searched for (e.g., "׳¦׳¢׳¦׳•׳¢")
                lastShownPages: [],            // Last pages we showed
                rejectedCategories: [],        // Categories user said "no" to
                conversationHistory: [],       // Full conversation history
                recommendedPage: null          // Page we recommended for user to visit
            };
        }

        // Enhanced sendAIMessage with smart search
        async function sendAIMessageEnhanced() {
            try {
                const input = document.getElementById('aiChatInput');
                const userMessage = input.value.trim();
                
                if (!userMessage) return;
                
                // ג… CHECK if user is confirming to visit a recommended page (e.g., "׳›׳", "׳׳•׳§׳™׳™", "׳‘׳˜׳—")
                const confirmations = ['׳›׳', '׳‘׳˜׳—', '׳׳•׳§׳™׳™', '׳׳•׳§׳™', 'ok', 'yes', '׳™׳׳׳׳”', '׳‘׳•׳', '׳×׳¨׳׳”', '׳×׳¨׳׳™', '׳”׳¦׳’', '׳”׳¦׳™׳’׳™'];
                const isConfirmation = confirmations.some(c => userMessage.toLowerCase().trim() === c || userMessage.toLowerCase().includes(c));
                
                // נ IF USER CONFIRMED and we have a recommended page - OPEN IT!
                if (isConfirmation && window.marketplaceConversationContext.recommendedPage) {
                    console.log('ג… USER CONFIRMED - Opening recommended page:', window.marketplaceConversationContext.recommendedPage);
                    
                    const recommendedPage = window.marketplaceConversationContext.recommendedPage;
                    
                    // Display user message
                    addAIMessage(userMessage, true);
                    input.value = '';
                    
                    // Show a confirmation message
                    addAIMessage(`ג… **׳₪׳•׳×׳— ׳׳× "${recommendedPage.title}"...**`, false);
                    
                    // Show the preview with animation
                    const chatMessages = document.getElementById('aiChatMessages');
                    if (chatMessages) {
                        const previewDiv = document.createElement('div');
                        previewDiv.className = 'ai-message bot';
                        previewDiv.style.cssText = `
                            margin: 16px 0;
                            border: 2px solid #e5e7eb;
                            border-radius: 12px;
                            overflow: hidden;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            width: 100%;
                            max-width: 100%;
                            height: 500px;
                            opacity: 0;
                            transform: translateY(20px);
                            transition: all 0.5s ease;
                        `;
                        
                        previewDiv.innerHTML = `
                            <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                <span>נ</span>
                                <span>${recommendedPage.title}</span>
                            </div>
                            <div style="position: relative; height: 450px; overflow: hidden;">
                                <iframe src="` + recommendedPage.url + `" style="width: 200%; height: 900px; border: none; transform: scale(0.5); transform-origin: top right; position: absolute; top: 0; right: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';"></iframe>
                            </div>
                        `;
                        
                        chatMessages.appendChild(previewDiv);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        
                        setTimeout(() => {
                            previewDiv.style.opacity = '1';
                            previewDiv.style.transform = 'translateY(0)';
                        }, 100);
                    }
                    
                    // Clear the recommended page from context
                    window.marketplaceConversationContext.recommendedPage = null;
                    
                    return; // STOP HERE
                }
                
                // Display user message
                addAIMessage(userMessage, true);
                input.value = '';
                
                // Show typing indicator
                addAIMessage('נ₪– ׳¡׳×׳™׳• ׳׳§׳׳™׳“׳”<span class="typing-dots">...</span>', false);
                
                // Always reload pages to get latest pages
                console.log('נ”„ Reloading pages to get latest...');
                await loadPages();
                
                // Try smart search first for real page results
                try {
                    // נ¯ FIX: Check if user only mentioned a city (e.g., "׳‘׳ ׳×׳ ׳™׳”") without category
                    // If so, combine with last search category from context
                    let searchQuery = userMessage;
                    const onlyCityPattern = /^(?:׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”)\s*([׳-׳×\s]{2,20})$/;
                    const onlyCityMatch = userMessage.match(onlyCityPattern);
                    
                    if (onlyCityMatch && onlyCityMatch[1]) {
                        const city = onlyCityMatch[1].trim();
                        console.log(`נ™ן¸ User mentioned only city: "${city}"`);
                        
                        // Check if we have a last search category in context
                        const lastCategory = window.marketplaceConversationContext?.lastSearchCategory || window.lastSearchCategory;
                        
                        if (lastCategory && lastCategory.trim()) {
                            searchQuery = `${lastCategory} ׳‘${city}`;
                            console.log(`ג… Combined with last search category: "${searchQuery}"`);
                        } else {
                            console.log(`ג ן¸ No last search category found - searching for all services in ${city}`);
                        }
                    }
                    
                    // נ¯ FIX: Check if this is a price list query (e.g., "׳׳—׳™׳¨׳™׳ ׳©׳ ׳¦׳¢׳¦׳•׳¢׳™׳")
                    // If so, search for the category only (not "׳׳—׳™׳¨׳™׳ ׳©׳ X")
                    const priceListPattern = /(?:׳”)?(?:׳׳—׳™׳¨׳™׳|׳™׳©\s+׳׳—׳™׳¨׳™׳)\s+׳©׳\s+([׳-׳×\s]{2,20})/i;
                    const priceListMatch = userMessage.match(priceListPattern);
                    
                    if (priceListMatch && priceListMatch[1]) {
                        const category = priceListMatch[1].trim();
                        console.log(`נ’° Price list query detected - searching for category: "${category}"`);
                        searchQuery = category; // Search for category only, not "׳׳—׳™׳¨׳™׳ ׳©׳ category"
                    }
                    
                    // FORCE LIVE DATA SEARCH - NO FIXED MESSAGES
                    console.log('נ” FORCING LIVE SEARCH for:', searchQuery);
                    const liveResults = await searchLivePages(searchQuery);
                    
                    if (liveResults.length > 0) {
                        // Remove typing indicator
                        removeTypingIndicator();

                        const lowerUserMessage = userMessage.toLowerCase();
                        const isPriceQuery =
                            lowerUserMessage.includes('׳׳—׳™׳¨') ||
                            lowerUserMessage.includes('׳›׳׳”') ||
                            lowerUserMessage.includes('׳¢׳•׳׳”') ||
                            lowerUserMessage.includes('ג‚×') ||
                            lowerUserMessage.includes('׳©׳§׳') ||
                            lowerUserMessage.includes('׳”׳›׳™ ׳–׳•׳') ||
                            lowerUserMessage.includes('׳–׳•׳');

                        if (isPriceQuery) {
                            const productEntries = [];

                            const keywordCandidates = new Set();
                            if (typeof lastSearchContext === 'string' && lastSearchContext.trim()) {
                                keywordCandidates.add(lastSearchContext.toLowerCase());
                            }

                            if (window?.marketplaceConversationContext?.lastSearchCategory) {
                                keywordCandidates.add(window.marketplaceConversationContext.lastSearchCategory.toLowerCase());
                            }

                            const ignoredTokens = new Set(['׳׳ ׳™','׳¨׳•׳¦׳”','׳׳—׳™׳¨׳™׳','׳׳—׳™׳¨','׳›׳׳”','׳”׳›׳™','׳–׳•׳','׳©׳׳ ׳™','׳©׳׳™','׳×׳‘׳™׳','׳׳™','׳›׳','׳׳','׳׳×','׳¢׳','׳¢׳','׳™׳©','׳©׳׳•׳','׳׳”','׳©׳׳•׳׳','׳‘׳‘׳§׳©׳”','׳‘׳‘׳§׳©׳”,','׳”׳׳—׳™׳¨','׳”׳׳—׳™׳¨׳™׳']);
                            lowerUserMessage.split(/[\s,;.!?]+/).forEach(token => {
                                const cleanToken = token.trim();
                                if (cleanToken.length < 2) return;
                                if (ignoredTokens.has(cleanToken)) return;
                                keywordCandidates.add(cleanToken);
                            });

                            const keywordsArray = Array.from(keywordCandidates).filter(Boolean);

                            liveResults.forEach(page => {
                                const pageUrl = page.pageUrl || `/users/${page.userId}/${page.pageId}_html`;
                                const sourceProducts = [
                                    ...(page.liveProducts || []),
                                    ...(page.products || [])
                                ];

                                const pageTextBank = [
                                    page.title?.toLowerCase() || '',
                                    page.description?.toLowerCase() || ''
                                ];

                                sourceProducts.forEach(product => {
                                    if (!product) return;
                                    const priceValue = getNumericPrice(product.price);
                                    if (priceValue === null) return;

                                    const productNameLower = product.name?.toLowerCase() || '';
                                    const matchesKeyword = keywordsArray.length === 0 ||
                                        keywordsArray.some(keyword =>
                                            keyword &&
                                            (
                                                pageTextBank.some(text => text.includes(keyword)) ||
                                                productNameLower.includes(keyword)
                                            )
                                        );
                                    if (!matchesKeyword) return;

                                    const displayPrice =
                                        typeof product.price === 'number'
                                            ? `ג‚×${product.price}`
                                            : product.price?.toString().includes('ג‚×')
                                                ? product.price
                                                : `ג‚×${product.price}`;

                                    productEntries.push({
                                        pageTitle: page.title,
                                        pageUrl,
                                        productName: product.name || '׳׳•׳¦׳¨',
                                        priceValue,
                                        displayPrice
                                    });
                                });
                            });

                            if (productEntries.length > 0) {
                                productEntries.sort((a, b) => a.priceValue - b.priceValue);
                                const cheapest = productEntries[0];
                                const midRange = productEntries[Math.min(1, productEntries.length - 1)];
                                const premium = productEntries[Math.min(productEntries.length - 1, 2)];

                                let response = `נ’° **׳”׳׳—׳™׳¨׳™׳ ׳”׳›׳™ ׳׳©׳×׳׳׳™׳ ׳©׳׳¦׳׳×׳™:**\n\n`;
                                response += `נ¥‡ **׳”׳›׳™ ׳–׳•׳:** ${cheapest.productName} - ${cheapest.displayPrice}\n`;
                                response += `   נ× ${cheapest.pageTitle}\n`;
                                response += `   נ”— [׳₪׳×׳— ׳“׳£](${cheapest.pageUrl})\n\n`;

                                if (productEntries.length > 1 && midRange && midRange !== cheapest) {
                                    response += `נ¥ˆ **׳‘׳—׳™׳¨׳” ׳ ׳•׳¡׳₪׳×:** ${midRange.productName} - ${midRange.displayPrice}\n`;
                                    response += `   נ× ${midRange.pageTitle}\n`;
                                    response += `   נ”— [׳₪׳×׳— ׳“׳£](${midRange.pageUrl})\n\n`;
                                }

                                if (productEntries.length > 2 && premium && premium !== cheapest && premium !== midRange) {
                                    response += `נ¥‰ **׳₪׳¨׳™׳׳™׳•׳:** ${premium.productName} - ${premium.displayPrice}\n`;
                                    response += `   נ× ${premium.pageTitle}\n`;
                                    response += `   נ”— [׳₪׳×׳— ׳“׳£](${premium.pageUrl})\n\n`;
                                }

                                if (productEntries.length > 3) {
                                    const additionalCount = productEntries.length - 3;
                                    if (additionalCount > 0) {
                                        response += `׳•׳¢׳•׳“ ${additionalCount} ׳׳•׳¦׳¨׳™׳ ׳¢׳ ׳׳—׳™׳¨׳™׳.\n`;
                                    }
                                }

                                window.marketplaceConversationContext.recommendedPage = {
                                    title: cheapest.pageTitle,
                                    url: cheapest.pageUrl
                                };

                                addAIMessage(response, false);
                                return;
                            }
                        }

                        // Default display of live results (non-price queries or no price data)
                        let response = `׳׳¦׳׳×׳™ ${liveResults.length} ׳“׳₪׳™׳ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳:\n\n`;
                        liveResults.forEach(page => {
                            response += `נ× **${page.title}**\n`;
                            if (page.description) {
                                response += `${page.description}\n`;
                            }

                            if (page.liveProducts && page.liveProducts.length > 0) {
                                response += `נ’° ׳׳•׳¦׳¨׳™׳ ׳—׳™׳™׳:\n`;
                                page.liveProducts.forEach(product => {
                                    response += `ג€¢ ${product.name} - ג‚×${product.price}\n`;
                                });
                            }

                            response += `נ”— [׳¦׳₪׳” ׳‘׳“׳£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                        });

                        addAIMessage(response, false);
                        return;
                    }
                } catch (error) {
                    console.error('Error in live search:', error);
                }
                
                // If no smart search result, send to N8N with REAL DATA
                try {
                    // Prepare real data context for N8N
                    const realDataContext = `׳׳×׳” ׳¢׳•׳–׳¨ ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡. ׳¢׳ ׳” ׳¢׳ ׳©׳׳׳•׳× ׳‘׳¦׳•׳¨׳” ׳™׳“׳™׳“׳•׳×׳™׳× ׳‘׳”׳×׳‘׳¡׳¡ ׳¢׳ ׳”׳ ׳×׳•׳ ׳™׳ ׳”׳׳׳™׳×׳™׳™׳ ׳”׳‘׳׳™׳:

**׳“׳₪׳™׳ ׳–׳׳™׳ ׳™׳ ׳‘׳׳¢׳¨׳›׳×:**
${allPages.map(page => {
    let pageInfo = `- ${page.title} (${page.pageType === 'store' ? '׳—׳ ׳•׳×' : page.pageType === 'course' ? '׳§׳•׳¨׳¡' : page.pageType === 'event' ? '׳׳™׳¨׳•׳¢' : '׳©׳™׳¨׳•׳×'})`;
    if (page.products && page.products.length > 0) {
        pageInfo += '\n  ׳׳•׳¦׳¨׳™׳:';
        page.products.forEach(product => {
            pageInfo += `\n  * ${product.name} - ג‚×${product.price}`;
        });
    }
    return pageInfo;
}).join('\n')}

**׳—׳©׳•׳‘:** ׳”׳©׳×׳׳© ׳¨׳§ ׳‘׳ ׳×׳•׳ ׳™׳ ׳׳׳™׳×׳™׳™׳ ׳׳”׳¨׳©׳™׳׳” ׳׳׳¢׳׳”. ׳׳ ׳×׳׳¦׳™׳ ׳“׳₪׳™׳, ׳—׳ ׳•׳™׳•׳× ׳׳• ׳׳•׳¦׳¨׳™׳ ׳©׳׳ ׳׳•׳₪׳™׳¢׳™׳ ׳‘׳¨׳©׳™׳׳”. ׳׳ ׳׳™׳ ׳׳™׳“׳¢ ׳–׳׳™׳, ׳׳׳•׳¨ ׳–׳׳× ׳‘׳›׳ ׳•׳×.`;

                    const response = await fetch('https://n8n-service-how4.onrender.com/webhook/jhfuhgufkhlkuho8erhf757754jhldkbsjkbmreketpg', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            message: userMessage,
                            context: 'marketplace',
                            contextText: realDataContext
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        removeTypingIndicator();
                        
                        // ג… Display N8N response
                        addAIMessage(data.message || '׳¡׳׳™׳—׳”, ׳§׳¨׳×׳” ׳©׳’׳™׳׳”. ׳ ׳¡׳” ׳©׳•׳‘!', false);
                        
                        // נ EXTRACT page names from N8N response and show PREVIEW for each!
                        // Example: "נ× **׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢ AI 1760965952188** store page"
                        const pagePattern = /נ×\s+\*\*([^\*]+)\*\*/g;
                        const pageMatches = [...data.message.matchAll(pagePattern)];
                        
                        if (pageMatches.length > 0) {
                            console.log('נ Found', pageMatches.length, 'pages in N8N response - showing previews!');
                            
                            const chatMessages = document.getElementById('aiChatMessages');
                            const displayedPages = new Set(); // נ« Track displayed pages to avoid duplicates
                            let previewIndex = 0;
                            
                            for (const match of pageMatches) {
                                const pageTitle = match[1].trim();
                                console.log('נ” Looking for page:', pageTitle);
                                
                                // Find the page in allPages
                                const foundPage = allPages.find(p => 
                                    p.title === pageTitle || 
                                    p.pageId === pageTitle ||
                                    pageTitle.includes(p.pageId)
                                );
                                
                                if (foundPage && chatMessages) {
                                    const pageId = foundPage.pageId;
                                    
                                    // נ« SKIP if we already displayed this page
                                    if (displayedPages.has(pageId)) {
                                        console.log('ג­ן¸  Skipping duplicate page:', foundPage.title);
                                        continue;
                                    }
                                    
                                    displayedPages.add(pageId); // Mark as displayed
                                    
                                    const pageUrl = `/users/${foundPage.userId}/${foundPage.pageId}_html`;
                                    console.log('ג… Found page! Creating preview for:', foundPage.title);
                                    
                                    // Create animated preview
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'ai-message bot';
                                    previewDiv.style.cssText = `
                                        margin: 16px 0;
                                        border: 2px solid #e5e7eb;
                                        border-radius: 12px;
                                        overflow: hidden;
                                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                                        width: 100%;
                                        max-width: 100%;
                                        height: 350px;
                                        opacity: 0;
                                        transform: translateY(20px);
                                        transition: all 0.5s ease;
                                    `;
                                    
                                    previewDiv.innerHTML = `
                                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                            <span>נ</span>
                                            <span>${foundPage.title}</span>
                                        </div>
                                        <div style="position: relative; height: 300px; overflow: hidden;">
                                            <iframe src="` + pageUrl + `" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top right; position: absolute; top: 0; right: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';"></iframe>
                                        </div>
                                    `;
                                    
                                    chatMessages.appendChild(previewDiv);
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                    
                                    // Animate in with stagger
                                    setTimeout(() => {
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 100 * (previewIndex + 1)); // Stagger animation based on actual displayed index
                                    
                                    previewIndex++; // Increment for next preview
                                }
                            }
                        }
                        
                        return;
                    }
                } catch (error) {
                    console.error('Error calling N8N:', error);
                }
                
                // Fallback if N8N fails - try to search live pages
                removeTypingIndicator();
                
                // Try to search live pages for the user's query
                console.log(`נ” Searching for: "${userMessage}"`);
                try {
                    // Auto-reload pages to get latest pages
                    console.log('נ”„ Auto-reloading pages to get latest...');
                    await loadPages();
                    
                    const liveSearchResult = await searchLivePages(userMessage);
                    if (liveSearchResult && liveSearchResult.length > 0) {
                        let response = `׳׳¦׳׳×׳™ ${liveSearchResult.length} ׳“׳₪׳™׳ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳:\n\n`;
                        liveSearchResult.forEach(page => {
                            response += `נ× **${page.title}**\n`;
                            if (page.description) {
                                response += `${page.description}\n`;
                            }
                            
                            // Show live product data if available
                            if (page.liveProducts && page.liveProducts.length > 0) {
                                response += `נ’° ׳׳•׳¦׳¨׳™׳ ׳—׳™׳™׳:\n`;
                                page.liveProducts.forEach(product => {
                                    response += `ג€¢ ${product.name} - ג‚×${product.price}\n`;
                                });
                            }
                            
                            response += `נ”— [׳¦׳₪׳” ׳‘׳“׳£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                        });
                        addAIMessage(response, false);
                    } else {
                        // נ¯ FIX: Simple message without "׳׳ ׳™ ׳™׳›׳•׳׳” ׳׳¢׳–׳•׳¨"
                        addAIMessage("׳׳™׳–׳” ׳׳•׳¦׳¨ ׳׳• ׳©׳™׳¨׳•׳× ׳׳×׳” ׳׳—׳₪׳©? ׳™׳© ׳׳ ׳• ׳׳×׳ ׳•׳×, ׳׳§, ׳©׳¢׳•׳ ׳™׳, ׳¦׳¢׳¦׳•׳¢׳™׳, ׳§׳•׳¨׳¡׳™׳ ׳•׳¢׳•׳“.", false);
                    }
                } catch (error) {
                    console.error('Error in live search:', error);
                    // נ¯ FIX: Simple message without "׳׳ ׳™ ׳™׳›׳•׳׳” ׳׳¢׳–׳•׳¨"
                    addAIMessage("׳׳™׳–׳” ׳׳•׳¦׳¨ ׳׳• ׳©׳™׳¨׳•׳× ׳׳×׳” ׳׳—׳₪׳©? ׳™׳© ׳׳ ׳• ׳׳×׳ ׳•׳×, ׳׳§, ׳©׳¢׳•׳ ׳™׳, ׳¦׳¢׳¦׳•׳¢׳™׳, ׳§׳•׳¨׳¡׳™׳ ׳•׳¢׳•׳“.", false);
                }
                return;
                
            } catch (error) {
                console.error('ג Error in sendAIMessageEnhanced:', error);
                removeTypingIndicator();
                addAIMessage('׳¡׳׳™׳—׳”, ׳§׳¨׳×׳” ׳©׳’׳™׳׳”. ׳ ׳¡׳” ׳©׳•׳‘!', false);
            }
        }
        
        // Execute actions
        async function executeAction(action) {
            if (action.type === 'change_category') {
                console.log('נ·ן¸ Changing to category:', action.category);
                
                // Map category names
                const categoryMap = {
                    'store': 'store',
                    'stores': 'store',
                    '׳—׳ ׳•׳×': 'store',
                    '׳—׳ ׳•׳™׳•׳×': 'store',
                    'event': 'event',
                    'events': 'event',
                    '׳׳™׳¨׳•׳¢': 'event',
                    '׳׳™׳¨׳•׳¢׳™׳': 'event',
                    'course': 'course',
                    'courses': 'course',
                    '׳§׳•׳¨׳¡': 'course',
                    '׳§׳•׳¨׳¡׳™׳': 'course',
                    'serviceProvider': 'serviceProvider',
                    'service': 'serviceProvider',
                    '׳‘׳¢׳׳™ ׳׳§׳¦׳•׳¢': 'serviceProvider',
                    'all': 'all',
                    '׳”׳›׳': 'all'
                };
                
                const mappedCategory = categoryMap[action.category.toLowerCase()] || action.category;
                console.log('נ“‚ Mapped category:', mappedCategory);
                
                // Update UI buttons - use the existing filterByType function
                filterByType(mappedCategory);
                
                // Scroll to top to see results
                setTimeout(() => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    console.log('ג… Category changed to:', mappedCategory);
                    console.log('נ“ New filteredPages length:', filteredPages.length);
                    
                    // Show success message
                    addAIMessage(`ג… ׳¢׳‘׳¨׳×׳™ ׳׳§׳˜׳’׳•׳¨׳™׳™׳× ${getTypeName(mappedCategory)}! ׳׳¦׳ ${filteredPages.length} ׳“׳₪׳™׳.`, false);
                }, 100);
            } else if (action.type === 'change_category_and_highlight') {
                console.log('נ·ן¸ Changing to category and highlighting pages:', action.category, action.highlight_pages);
                
                // Map category names
                const categoryMap = {
                    'store': 'store',
                    'stores': 'store',
                    '׳—׳ ׳•׳×': 'store',
                    '׳—׳ ׳•׳™׳•׳×': 'store',
                    'event': 'event',
                    'events': 'event',
                    '׳׳™׳¨׳•׳¢': 'event',
                    '׳׳™׳¨׳•׳¢׳™׳': 'event',
                    'course': 'course',
                    'courses': 'course',
                    '׳§׳•׳¨׳¡': 'course',
                    '׳§׳•׳¨׳¡׳™׳': 'course',
                    'serviceProvider': 'serviceProvider',
                    'service': 'serviceProvider',
                    '׳‘׳¢׳׳™ ׳׳§׳¦׳•׳¢': 'serviceProvider',
                    'all': 'all',
                    '׳”׳›׳': 'all'
                };
                
                const mappedCategory = categoryMap[action.category.toLowerCase()] || action.category;
                console.log('נ“‚ Mapped category:', mappedCategory);
                
                // Update UI buttons - use the existing filterByType function
                filterByType(mappedCategory);
                
                // Scroll to top and highlight pages
                setTimeout(() => {
                    // Highlight matching pages first
                    if (action.highlight_pages && action.highlight_pages.length > 0) {
                        action.highlight_pages.forEach((pageId, index) => {
                            const pageCard = document.querySelector(`[data-page-id="${pageId}"]`);
                            if (pageCard) {
                                pageCard.style.outline = '3px solid #667eea';
                                pageCard.style.transform = 'scale(1.05)';
                                pageCard.style.transition = 'all 0.3s ease';
                                pageCard.style.boxShadow = '0 10px 25px rgba(102, 126, 234, 0.3)';
                                
                                // Scroll to first highlighted page with delay
                                if (index === 0) {
                                    setTimeout(() => {
                                        pageCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    }, 200);
                                }
                                
                                setTimeout(() => {
                                    pageCard.style.outline = '';
                                    pageCard.style.transform = '';
                                    pageCard.style.boxShadow = '';
                                }, 5000);
                            }
                        });
                    }
                    
                    console.log('ג… Category changed to:', mappedCategory);
                    console.log('נ“ New filteredPages length:', filteredPages.length);
                    
                    // Show success message
                    addAIMessage(`ג… ׳¢׳‘׳¨׳×׳™ ׳׳§׳˜׳’׳•׳¨׳™׳™׳× ${getTypeName(mappedCategory)}! ׳׳¦׳ ${filteredPages.length} ׳“׳₪׳™׳.`, false);
                }, 100);
            } else if (action.type === 'scroll_to_page' && action.page_id) {
                console.log('נ” Looking for page card with ID:', action.page_id);
                
                // Find the page card and scroll to it
                setTimeout(() => {
                    const pageCard = document.querySelector(`[data-page-id="${action.page_id}"]`);
                    if (pageCard) {
                        pageCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        pageCard.style.outline = '3px solid #667eea';
                        pageCard.style.transform = 'scale(1.05)';
                        pageCard.style.transition = 'all 0.3s ease';
                        pageCard.style.boxShadow = '0 10px 25px rgba(102, 126, 234, 0.3)';
                        
                        setTimeout(() => {
                            pageCard.style.outline = '';
                            pageCard.style.transform = '';
                            pageCard.style.boxShadow = '';
                        }, 3000);
                    } else {
                        console.error('ג Page card not found for:', action.page_id);
                        addAIMessage('נ” ׳׳¦׳׳×׳™ ׳׳× ׳”׳“׳£ ׳׳‘׳ ׳׳ ׳”׳¦׳׳—׳×׳™ ׳׳’׳׳•׳ ׳׳׳™׳•. ׳—׳₪׳© ׳׳•׳×׳• ׳‘׳¨׳©׳™׳׳” ׳׳׳¢׳׳”!', false);
                    }
                }, 500);
            } else if (action.type === 'show_page' && action.page_id) {
                // Open page in new tab
                const page = allPages.find(p => p.pageId === action.page_id);
                if (page) {
                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                    window.open(pageUrl, '_blank');
                }
            }
        }
        
        // Function to extract prices from page content
        async function extractPricesFromPage(page) {
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (!response.ok) return null;
                
                const htmlContent = await response.text();
                const priceRegex = /ג‚×\s*(\d+(?:,\d{3})*(?:\.\d{2})?)/g;
                const prices = [];
                let match;
                
                while ((match = priceRegex.exec(htmlContent)) !== null) {
                    prices.push(match[0]);
                }
                
                return prices.length > 0 ? prices : null;
            } catch (error) {
                console.error('Error extracting prices:', error);
                return null;
            }
        }
        
        // Enhanced search with price information - LIVE VERSION
        async function searchWithPrices(message) {
            // Enhanced search that reads from live pages
            const searchResults = [];
            
            for (const page of allPages) {
                if (page.pageType === 'store') {
                    // Always check live page content for products
                    const productInfo = await extractProductInfo(page.description, message, `/users/${page.userId}/${page.pageId}_html`);
                    
                    if (productInfo && productInfo.price) {
                        searchResults.push({
                            ...page,
                            productInfo: productInfo
                        });
                    }
                }
            }
            
            console.log(`נ” Live search results for "${message}":`, searchResults);
            return searchResults;
        }
        
        // Fix the filterByCategory function
        function filterByCategory(category) {
            currentType = category;
            
            if (category === 'all') {
                filteredPages = [...allPages];
            } else {
                filteredPages = allPages.filter(page => page.pageType === category);
            }
            
            displayPages();
            updatePagesCount();
        }
        
        // New function to search live pages - FORCE LIVE DATA VERSION
        async function searchLivePages(query) {
            try {
                // נ¯ NEW: Fix common typos before search
                let fixedQuery = query;
                
                // נ¯ FIX: First, fix patterns like "׳× X" -> "X" (common speech recognition error)
                fixedQuery = fixedQuery.replace(/\s+׳×\s+([׳-׳×]+)/gi, ' $1'); // Remove "׳×" before Hebrew words
                
                const typoFixes = {
                    '׳©׳¢׳˜׳ ׳™׳': '׳©׳¢׳•׳ ׳™׳',
                    '׳©׳¢׳˜׳•׳': '׳©׳¢׳•׳',
                    '׳¦׳¢׳¦׳•׳˜׳™׳': '׳¦׳¢׳¦׳•׳¢׳™׳',
                    '׳¦׳¢׳¦׳˜׳•׳¢': '׳¦׳¢׳¦׳•׳¢',
                    '׳׳¡׳¢׳“׳': '׳׳¡׳¢׳“׳”',
                    '׳׳¡׳“׳¢׳”': '׳׳¡׳¢׳“׳”',
                    '׳× ׳¦׳¢׳¦׳•׳¢׳™׳': '׳¦׳¢׳¦׳•׳¢׳™׳', // נ¯ FIX: "׳× ׳¦׳¢׳¦׳•׳¢׳™׳" -> "׳¦׳¢׳¦׳•׳¢׳™׳" (typo from speech)
                    '׳× ׳¦׳¢׳¦׳•׳¢': '׳¦׳¢׳¦׳•׳¢', // נ¯ FIX: "׳× ׳¦׳¢׳¦׳•׳¢" -> "׳¦׳¢׳¦׳•׳¢"
                    ' ׳× ׳¦׳¢׳¦׳•׳¢׳™׳': ' ׳¦׳¢׳¦׳•׳¢׳™׳', // נ¯ FIX: with space
                    ' ׳× ׳¦׳¢׳¦׳•׳¢': ' ׳¦׳¢׳¦׳•׳¢' // נ¯ FIX: with space
                };
                
                for (const [typo, correct] of Object.entries(typoFixes)) {
                    if (fixedQuery.toLowerCase().includes(typo)) {
                        fixedQuery = fixedQuery.replace(new RegExp(typo, 'gi'), correct);
                        console.log(`נ”§ Fixed typo: "${typo}" ג†’ "${correct}" in query: "${query}" ג†’ "${fixedQuery}"`);
                    }
                }
                
                const searchTerm = fixedQuery.toLowerCase();
                const searchWords = searchTerm.replace(/[^׳-׳×\s]/g, ' ').split(/\s+/).filter(Boolean);
                const hasStoreKeyword = searchWords.some(word => word === '׳—׳ ׳•׳×' || word === '׳—׳ ׳•׳™׳•׳×');
                const serviceKeywordList = ['׳©׳™׳¨׳•׳×', '׳©׳¨׳•׳×', '׳©׳™׳¨׳•׳×׳™׳', '׳‘׳¢׳׳™', '׳׳§׳¦׳•׳¢', '׳—׳©׳׳׳׳™', '׳—׳©׳׳׳׳™׳×', '׳ ׳’׳¨', '׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳׳™׳×', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳'];
                const hasServiceKeywordInQuery = serviceKeywordList.some(word => searchTerm.includes(word));
                
                // נ¯ NEW: Detect if user wants pages with phone number only
                const requiresPhone = /׳¢׳ ׳˜׳׳₪׳•׳|׳™׳©.*׳˜׳׳₪׳•׳|׳©׳™׳©.*׳˜׳׳₪׳•׳|׳¢׳.*׳׳¡׳₪׳¨.*׳˜׳׳₪׳•׳|׳¨׳§.*׳¢׳.*׳˜׳׳₪׳•׳/.test(searchTerm);
                
                let results = []; // Changed from const to let - need to reassign for city filtering
                
                console.log(`נ” FORCING LIVE DATA SEARCH for: "${searchTerm}"`);
                if (requiresPhone) console.log('נ“ User requires phone number in results');
            
            // Extract location from query - expanded city list
            const cities = [
                '׳×׳ ׳׳‘׳™׳‘', '׳™׳¨׳•׳©׳׳™׳', '׳—׳™׳₪׳”', '׳‘׳׳¨ ׳©׳‘׳¢', '׳ ׳×׳ ׳™׳”', '׳׳©׳“׳•׳“', '׳¨׳׳× ׳’׳', '׳₪׳×׳— ׳×׳§׳•׳•׳”', 
                '׳‘׳ ׳™ ׳‘׳¨׳§', '׳—׳•׳׳•׳', '׳¨׳—׳•׳‘׳•׳×', '׳›׳₪׳¨ ׳¡׳‘׳', '׳׳™׳׳×', '׳¨׳¢׳ ׳ ׳”', '׳”׳¨׳¦׳׳™׳”', '׳‘׳׳•׳׳₪׳™׳׳“', 
                '׳¨׳׳× ׳—׳', '׳—׳“׳¨׳”', '׳§׳¨׳™׳™׳× ׳‘׳™׳׳׳™׳§', '׳§׳¨׳™׳™׳× ׳׳•׳¦׳§׳™׳', '׳¨׳׳©׳•׳ ׳׳¦׳™׳•׳', '׳ ׳”׳¨׳™׳”', 
                '׳”׳•׳“ ׳”׳©׳¨׳•׳', '׳’׳‘׳¢׳×׳™׳™׳', '׳§׳¨׳™׳™׳× ׳׳×׳', '׳§׳¨׳™׳™׳× ׳©׳׳•׳ ׳”', '׳‘׳™׳× ׳©׳׳', '׳¢׳₪׳•׳׳”',
                '׳—׳“׳¨׳”', '׳¨׳׳× ׳”׳©׳¨׳•׳', '׳¨׳¢׳ ׳ ׳”', '׳¨׳׳× ׳’׳', '׳₪׳×׳— ׳×׳§׳•׳•׳”', '׳›׳₪׳¨ ׳¡׳‘׳'
            ];
            
            // Common typos/variations map
            const cityTypos = {
                '׳§׳™׳¨׳™׳×': '׳§׳¨׳™׳™׳×',
                '׳§׳¨׳™׳×': '׳§׳¨׳™׳™׳×',
                '׳§׳™׳¨׳™׳™׳×': '׳§׳¨׳™׳™׳×',
                '׳×׳-׳׳‘׳™׳‘': '׳×׳ ׳׳‘׳™׳‘',
                '׳×׳׳׳‘׳™׳‘': '׳×׳ ׳׳‘׳™׳‘',
                '׳×"׳': '׳×׳ ׳׳‘׳™׳‘',
                '׳‘׳׳¨-׳©׳‘׳¢': '׳‘׳׳¨ ׳©׳‘׳¢',
                '׳‘׳׳¨׳©׳‘׳¢': '׳‘׳׳¨ ׳©׳‘׳¢',
                '׳‘"׳©': '׳‘׳׳¨ ׳©׳‘׳¢'
            };
            
            let requiredCity = null;
            
            // Try multiple patterns to extract city
            // Pattern 1: "׳©׳™׳¨׳•׳× ׳‘׳ ׳×׳ ׳™׳”" or "׳ ׳’׳¨ ׳‘׳ ׳×׳ ׳™׳”" (service ׳‘ city)
            const patternWithBe = /([׳-׳×\s]+)\s+׳‘([׳-׳×\s]+)/;
            const matchWithBe = searchTerm.match(patternWithBe);
            if (matchWithBe && matchWithBe[2]) {
                let potentialCity = matchWithBe[2].trim();
                
                // נ¯ FIX: Check for typos first
                for (const [typo, correct] of Object.entries(cityTypos)) {
                    if (potentialCity.includes(typo)) {
                        potentialCity = potentialCity.replace(typo, correct);
                        console.log(`נ“ Fixed city typo: "${matchWithBe[2]}" ג†’ "${potentialCity}"`);
                        break;
                    }
                }
                
                // נ¯ FIX: Check if it's a known city, but don't match "׳™׳ ׳™׳‘ ׳—׳" to "׳¨׳׳× ׳—׳"
                // First check if it's an exact match or a store name (like "׳™׳ ׳™׳‘ ׳—׳")
                const isStoreName = searchTerm.toLowerCase().includes('׳™׳ ׳™׳‘') || searchTerm.toLowerCase().includes('red') || 
                                    searchTerm.toLowerCase().includes('׳—׳’׳™׳×') || searchTerm.toLowerCase().includes('׳¦׳™׳₪׳™');
                
                if (!isStoreName) {
                    // Check if it's a known city
                    for (const city of cities) {
                        if (city.toLowerCase() === potentialCity.toLowerCase() || 
                            (city.toLowerCase().includes(potentialCity.toLowerCase()) && potentialCity.length >= 3) || 
                            (potentialCity.toLowerCase().includes(city.toLowerCase()) && city.length >= 3)) {
                            requiredCity = city;
                            console.log(`ג… Location specified (׳‘ pattern): "${matchWithBe[2]}" ג†’ ${city}`);
                            break;
                        }
                    }
                } else {
                    console.log(`נ× Store name detected, skipping city match: "${potentialCity}"`);
                }
                // If no match but it looks like a city (Hebrew word 2-15 chars), use it
                if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15 && /^[׳-׳×\s]+$/.test(potentialCity)) {
                    requiredCity = potentialCity;
                    console.log(`נ“ Location specified (new city from ׳‘ pattern): ${potentialCity}`);
                }
            }
            
            // Pattern 2: Exact city name in query
            // נ¯ FIX: Don't match store names like "׳™׳ ׳™׳‘ ׳—׳" to cities like "׳¨׳׳× ׳—׳"
            if (!requiredCity) {
                const isStoreName = searchTerm.toLowerCase().includes('׳™׳ ׳™׳‘') || searchTerm.toLowerCase().includes('red') || 
                                    searchTerm.toLowerCase().includes('׳—׳’׳™׳×') || searchTerm.toLowerCase().includes('׳¦׳™׳₪׳™');
                
                if (!isStoreName) {
                    for (const city of cities) {
                        // Only match if it's a clear city match (not a store name)
                        if (searchTerm.toLowerCase() === city.toLowerCase() || 
                            (searchTerm.toLowerCase().includes(city.toLowerCase()) && city.length >= 4)) {
                            requiredCity = city;
                            console.log(`נ“ Location specified (exact): ${city}`);
                            break;
                        }
                    }
                } else {
                    console.log(`נ× Store name detected, skipping city match: "${searchTerm}"`);
                }
            }
            
            // Pattern 3: "(׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”) ׳¢׳™׳¨" pattern
            if (!requiredCity) {
                const cityPattern = /(?:׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”)\s+([׳-׳×]{2,})/;
                const cityMatch = searchTerm.match(cityPattern);
                if (cityMatch && cityMatch[1]) {
                    const potentialCity = cityMatch[1].trim();
                    // Check if it's a known city (partial match)
                    for (const city of cities) {
                        if (city.toLowerCase().includes(potentialCity.toLowerCase()) || potentialCity.toLowerCase().includes(city.toLowerCase())) {
                            requiredCity = city;
                            console.log(`נ“ Location specified (partial): ${potentialCity} ג†’ ${city}`);
                            break;
                        }
                    }
                    // If no match found but it's a city query, use it as-is
                    if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15) {
                        requiredCity = potentialCity;
                        console.log(`נ“ Location specified (new city): ${potentialCity}`);
                    }
                }
            }
            
            // SMART KEYWORD MAPPING - ׳׳™׳׳•׳× ׳׳₪׳×׳— ׳׳§׳˜׳’׳•׳¨׳™׳•׳× ׳¢׳ ׳”׳§׳©׳¨׳™׳ ׳—׳›׳׳™׳
            const smartKeywords = {
                // ׳׳×׳ ׳•׳×
                '׳׳×׳ ׳” ׳׳™׳׳“': {categories: ['׳¦׳¢׳¦׳•׳¢', '׳׳©׳—׳§'], excludeTypes: ['serviceProvider', 'course'], excludeWords: ['׳—׳׳₪׳™׳', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳—׳©׳׳׳׳™', '׳—׳©׳׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨'], requireWords: ['׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳‘׳•׳‘׳”', '׳‘׳•׳‘׳•׳×', 'toy', 'lego', '׳׳’׳•', '׳׳›׳•׳ ׳™׳×', '׳™׳׳“', '׳™׳׳“׳™׳']},
                '׳׳×׳ ׳” ׳׳™׳׳“׳™׳': {categories: ['׳¦׳¢׳¦׳•׳¢', '׳׳©׳—׳§'], excludeTypes: ['serviceProvider', 'course'], excludeWords: ['׳—׳׳₪׳™׳', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳—׳©׳׳׳׳™', '׳—׳©׳׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨'], requireWords: ['׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳‘׳•׳‘׳”', '׳‘׳•׳‘׳•׳×', 'toy', 'lego', '׳׳’׳•', '׳׳›׳•׳ ׳™׳×', '׳™׳׳“', '׳™׳׳“׳™׳']},
                '׳׳×׳ ׳” ׳׳‘׳': {categories: ['׳¦׳¢׳¦׳•׳¢', '׳׳©׳—׳§'], excludeTypes: ['serviceProvider', 'course'], excludeWords: ['׳—׳׳₪׳™׳', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳—׳©׳׳׳׳™', '׳—׳©׳׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨'], requireWords: ['׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳‘׳•׳‘׳”', '׳‘׳•׳‘׳•׳×', 'toy', 'lego', '׳׳’׳•', '׳׳›׳•׳ ׳™׳×', '׳™׳׳“', '׳™׳׳“׳™׳']},
                '׳׳×׳ ׳” ׳׳‘׳×': {categories: ['׳¦׳¢׳¦׳•׳¢', '׳׳©׳—׳§', '׳׳§'], excludeTypes: ['serviceProvider', 'course'], excludeWords: ['׳—׳׳₪׳™׳', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳—׳©׳׳׳׳™', '׳—׳©׳׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜'], requireWords: ['׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳‘׳•׳‘׳”', '׳‘׳•׳‘׳•׳×', 'toy', 'lego', '׳׳’׳•', '׳׳›׳•׳ ׳™׳×', '׳™׳׳“', '׳™׳׳“׳™׳', '׳׳§']},
                '׳׳×׳ ׳” ׳׳׳™׳©׳”': {categories: ['׳©׳¢׳•׳', '׳×׳›׳©׳™׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”'], excludeTypes: ['serviceProvider']},
                '׳׳×׳ ׳” ׳׳‘׳—׳•׳¨׳”': {categories: ['׳©׳¢׳•׳', '׳×׳›׳©׳™׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”'], excludeTypes: ['serviceProvider']},
                '׳׳×׳ ׳” ׳׳׳©׳”': {categories: ['׳©׳¢׳•׳', '׳×׳›׳©׳™׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”'], excludeTypes: ['serviceProvider']},
                '׳׳×׳ ׳” ׳׳‘׳¢׳': {categories: ['׳©׳¢׳•׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳’׳׳“׳’׳˜'], excludeTypes: ['serviceProvider'], excludeWords: ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳—׳׳₪׳™׳']},
                '׳׳×׳ ׳” ׳׳‘׳¢׳׳™': {categories: ['׳©׳¢׳•׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳’׳׳“׳’׳˜'], excludeTypes: ['serviceProvider'], excludeWords: ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳—׳׳₪׳™׳']},
                '׳׳×׳ ׳” ׳׳’׳‘׳¨': {categories: ['׳©׳¢׳•׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳’׳׳“׳’׳˜'], excludeTypes: ['serviceProvider'], excludeWords: ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳—׳׳₪׳™׳']},
                '׳׳×׳ ׳” ׳׳‘׳—׳•׳¨': {categories: ['׳©׳¢׳•׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳’׳׳“׳’׳˜'], excludeTypes: ['serviceProvider'], excludeWords: ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳—׳׳₪׳™׳']},
                '׳׳×׳ ׳”': {categories: ['׳©׳¢׳•׳', '׳×׳›׳©׳™׳˜', '׳¦׳¢׳¦׳•׳¢', '׳׳§'], excludeTypes: ['serviceProvider']},
                
                // ׳™׳׳“׳™׳
                '׳™׳׳“': {categories: ['׳¦׳¢׳¦׳•׳¢'], excludeTypes: ['serviceProvider', 'course'], excludeWords: ['׳—׳׳₪׳™׳', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳—׳©׳׳׳׳™', '׳—׳©׳׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨'], requireWords: ['׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳‘׳•׳‘׳”', '׳‘׳•׳‘׳•׳×', 'toy', 'lego', '׳׳’׳•', '׳׳›׳•׳ ׳™׳×', '׳™׳׳“', '׳™׳׳“׳™׳']},
                '׳™׳׳“׳™׳': {categories: ['׳¦׳¢׳¦׳•׳¢'], excludeTypes: ['serviceProvider', 'course'], excludeWords: ['׳—׳׳₪׳™׳', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳—׳©׳׳׳׳™', '׳—׳©׳׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨'], requireWords: ['׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳‘׳•׳‘׳”', '׳‘׳•׳‘׳•׳×', 'toy', 'lego', '׳׳’׳•', '׳׳›׳•׳ ׳™׳×', '׳™׳׳“', '׳™׳׳“׳™׳']},
                '׳¦׳¢׳¦׳•׳¢': {categories: ['׳¦׳¢׳¦׳•׳¢'], excludeTypes: ['serviceProvider', 'course'], excludeWords: ['׳—׳׳₪׳™׳', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳—׳©׳׳׳׳™', '׳—׳©׳׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳©׳¢׳•׳', 'watch'], requireWords: ['׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳‘׳•׳‘׳”', '׳‘׳•׳‘׳•׳×', 'toy', 'lego', '׳׳’׳•', '׳׳›׳•׳ ׳™׳×', '׳™׳׳“', '׳™׳׳“׳™׳']},
                '׳¦׳¢׳¦׳•׳¢׳™׳': {categories: ['׳¦׳¢׳¦׳•׳¢'], excludeTypes: ['serviceProvider', 'course'], excludeWords: ['׳—׳׳₪׳™׳', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳—׳©׳׳׳׳™', '׳—׳©׳׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳©׳¢׳•׳', 'watch'], requireWords: ['׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳‘׳•׳‘׳”', '׳‘׳•׳‘׳•׳×', 'toy', 'lego', '׳׳’׳•', '׳׳›׳•׳ ׳™׳×', '׳™׳׳“', '׳™׳׳“׳™׳']},
                '׳׳©׳—׳§': {categories: ['׳¦׳¢׳¦׳•׳¢', '׳׳©׳—׳§'], excludeTypes: ['serviceProvider', 'course'], excludeWords: ['׳—׳׳₪׳™׳', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳—׳©׳׳׳׳™', '׳—׳©׳׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳©׳¢׳•׳', 'watch'], requireWords: ['׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳‘׳•׳‘׳”', '׳‘׳•׳‘׳•׳×', 'toy', 'lego', '׳׳’׳•', '׳׳›׳•׳ ׳™׳×', '׳™׳׳“', '׳™׳׳“׳™׳']},
                '׳׳©׳—׳§׳™׳': {categories: ['׳¦׳¢׳¦׳•׳¢', '׳׳©׳—׳§'], excludeTypes: ['serviceProvider', 'course'], excludeWords: ['׳—׳׳₪׳™׳', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳—׳©׳׳׳׳™', '׳—׳©׳׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳©׳¢׳•׳', 'watch'], requireWords: ['׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳‘׳•׳‘׳”', '׳‘׳•׳‘׳•׳×', 'toy', 'lego', '׳׳’׳•', '׳׳›׳•׳ ׳™׳×', '׳™׳׳“', '׳™׳׳“׳™׳']},
                
                // ׳׳•׳¦׳¨׳™׳ - ׳׳™׳׳•׳× ׳׳₪׳×׳— ׳׳“׳•׳™׳§׳•׳× ׳¢׳ ׳¡׳™׳ ׳•׳
                '׳׳§': {
                    categories: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳'],
                    excludeTypes: [],
                    excludeWords: ['׳©׳¢׳•׳', 'watch', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', 'technology', '׳—׳׳₪׳™׳', '׳—׳׳§׳™', '׳¨׳›׳‘', '׳׳›׳•׳ ׳™׳×', '׳׳•׳¡׳', '׳“׳•׳“ ׳—׳׳₪׳™׳'], // ׳׳ ׳׳”׳‘׳™׳ ׳©׳¢׳•׳ ׳™׳ ׳׳• ׳—׳׳₪׳™׳
                    requireWords: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳¦׳™׳₪׳•׳¨׳™׳'] // ׳“׳¨׳•׳© ׳׳—׳“ ׳׳”׳
                },
                '׳׳§ ׳’׳': {
                    categories: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳׳§ ׳’\'׳', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳'],
                    excludeTypes: [],
                    excludeWords: ['׳©׳¢׳•׳', 'watch', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', 'technology', '׳—׳׳₪׳™׳', '׳—׳׳§׳™', '׳¨׳›׳‘', '׳׳›׳•׳ ׳™׳×', '׳׳•׳¡׳', '׳“׳•׳“ ׳—׳׳₪׳™׳'], // ׳׳ ׳׳”׳‘׳™׳ ׳©׳¢׳•׳ ׳™׳ ׳׳• ׳—׳׳₪׳™׳
                    requireWords: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳¦׳™׳₪׳•׳¨׳™׳'] // ׳“׳¨׳•׳© ׳׳—׳“ ׳׳”׳
                },
                '׳׳§ ׳’\'׳': {
                    categories: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳׳§ ׳’׳', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳'],
                    excludeTypes: [],
                    excludeWords: ['׳©׳¢׳•׳', 'watch', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', 'technology', '׳—׳׳₪׳™׳', '׳—׳׳§׳™', '׳¨׳›׳‘', '׳׳›׳•׳ ׳™׳×', '׳׳•׳¡׳', '׳“׳•׳“ ׳—׳׳₪׳™׳'], // ׳׳ ׳׳”׳‘׳™׳ ׳©׳¢׳•׳ ׳™׳ ׳׳• ׳—׳׳₪׳™׳
                    requireWords: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳¦׳™׳₪׳•׳¨׳™׳'] // ׳“׳¨׳•׳© ׳׳—׳“ ׳׳”׳
                },
                '׳©׳¢׳•׳': {
                    categories: ['׳©׳¢׳•׳'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳¦׳¢׳¦׳•׳¢', 'toy'], // ׳׳ ׳׳”׳‘׳™׳ ׳׳§ ׳׳• ׳¦׳¢׳¦׳•׳¢׳™׳
                    requireWords: ['׳©׳¢׳•׳', 'watch']
                },
                '׳¨׳§ ׳©׳¢׳•׳': {
                    categories: ['׳©׳¢׳•׳'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳¦׳¢׳¦׳•׳¢', 'toy', '׳—׳׳₪׳™׳', '׳—׳׳£'], // נ¯ STRICT: exclude toys, car parts, etc.
                    requireWords: ['׳©׳¢׳•׳', 'watch'] // MUST have watch in title/products
                },
                '׳©׳¢׳•׳ ׳‘׳׳‘׳“': {
                    categories: ['׳©׳¢׳•׳'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳¦׳¢׳¦׳•׳¢', 'toy', '׳—׳׳₪׳™׳', '׳—׳׳£'], // נ¯ STRICT: exclude toys, car parts, etc.
                    requireWords: ['׳©׳¢׳•׳', 'watch'] // MUST have watch in title/products
                },
                '׳¨׳§ ׳©׳¢׳•׳ ׳™׳': {
                    categories: ['׳©׳¢׳•׳'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳¦׳¢׳¦׳•׳¢', 'toy', '׳—׳׳₪׳™׳', '׳—׳׳£'], // נ¯ STRICT: exclude toys, car parts, etc.
                    requireWords: ['׳©׳¢׳•׳', 'watch'] // MUST have watch in title/products
                },
                '׳©׳¢׳•׳ ׳™׳': {
                    categories: ['׳©׳¢׳•׳'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”'],
                    requireWords: ['׳©׳¢׳•׳', 'watch']
                },
                '׳˜׳׳₪׳•׳': {
                    categories: ['׳˜׳›׳ ׳•׳׳•׳’׳™׳”'],
                    excludeTypes: [],
                    excludeWords: [],
                    requireWords: ['׳˜׳׳₪׳•׳', 'phone', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”']
                },
                '׳˜׳›׳ ׳•׳׳•׳’׳™׳”': {
                    categories: ['׳˜׳›׳ ׳•׳׳•׳’׳™׳”'],
                    excludeTypes: [],
                    excludeWords: [],
                    requireWords: ['׳˜׳›׳ ׳•׳׳•׳’׳™׳”', 'technology']
                },
                
                // ׳¨׳›׳‘ - ׳”׳§׳©׳¨ ׳—׳›׳!
                '׳”׳׳ ׳׳™ ׳”׳¨׳›׳‘': {categories: ['׳—׳׳₪׳™׳', '׳׳•׳¡׳', '׳¨׳›׳‘׳×', '׳¨׳›׳‘', '׳—׳׳§'], preferTypes: ['store']},
                '׳”׳׳ ׳׳™ ׳¨׳›׳‘': {categories: ['׳—׳׳₪׳™׳', '׳׳•׳¡׳', '׳¨׳›׳‘׳×', '׳¨׳›׳‘', '׳—׳׳§'], preferTypes: ['store']},
                '׳×׳§׳׳” ׳‘׳¨׳›׳‘': {categories: ['׳—׳׳₪׳™׳', '׳׳•׳¡׳', '׳¨׳›׳‘', '׳—׳׳§'], preferTypes: ['store']},
                '׳‘׳¢׳™׳” ׳‘׳¨׳›׳‘': {categories: ['׳—׳׳₪׳™׳', '׳׳•׳¡׳', '׳¨׳›׳‘', '׳—׳׳§'], preferTypes: ['store']},
                '׳§׳׳§׳•׳ ׳¨׳›׳‘': {categories: ['׳—׳׳₪׳™׳', '׳׳•׳¡׳', '׳¨׳›׳‘', '׳—׳׳§'], preferTypes: ['store']},
                '׳¦׳¨׳™׳ ׳—׳׳₪׳™׳': {categories: ['׳—׳׳₪׳™׳', '׳¨׳›׳‘', '׳—׳׳§'], preferTypes: ['store']},
                '׳—׳׳₪׳™׳': {categories: ['׳—׳׳₪׳™׳', '׳¨׳›׳‘', '׳—׳׳§'], preferTypes: ['store']},
                '׳׳•׳¡׳': {categories: ['׳׳•׳¡׳', '׳—׳׳₪׳™׳', '׳¨׳›׳‘'], preferTypes: ['store', 'serviceProvider']},
                '׳¨׳›׳‘׳×': {categories: ['׳—׳׳₪׳™׳', '׳¨׳›׳‘׳×', '׳¨׳›׳‘', '׳—׳׳§'], preferTypes: ['store']},
                '׳—׳׳§׳™ ׳¨׳›׳‘': {categories: ['׳—׳׳₪׳™׳', '׳¨׳›׳‘', '׳—׳׳§'], preferTypes: ['store']},
                '׳¨׳›׳‘': {categories: ['׳—׳׳₪׳™׳', '׳¨׳›׳‘', '׳—׳׳§', '׳׳•׳¡׳'], preferTypes: ['store']},
                
                // ׳©׳™׳¨׳•׳×׳™׳
                '׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨': {categories: ['׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨', '׳©׳™׳¨׳•׳×'], preferTypes: ['serviceProvider']},
                '׳ ׳’׳¨': {categories: ['׳ ׳’׳¨', '׳ ׳’׳¨׳•׳×', '׳©׳™׳¨׳•׳×'], preferTypes: ['serviceProvider']},
                '׳ ׳’׳¨׳•׳×': {categories: ['׳ ׳’׳¨', '׳ ׳’׳¨׳•׳×', '׳©׳™׳¨׳•׳×'], preferTypes: ['serviceProvider']},
                'plumber': {categories: ['׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨', '׳©׳™׳¨׳•׳×'], preferTypes: ['serviceProvider']},
                'electrician': {categories: ['׳—׳©׳׳׳׳™', '׳©׳™׳¨׳•׳×'], preferTypes: ['serviceProvider']},
                '׳—׳©׳׳׳׳™': {categories: ['׳—׳©׳׳׳׳™', '׳©׳™׳¨׳•׳×'], preferTypes: ['serviceProvider']},
                '׳׳¡׳₪׳¨׳”': {categories: ['׳׳¡׳₪׳¨׳”', '׳©׳™׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳×׳¡׳₪׳•׳¨׳×'], preferTypes: ['serviceProvider']},
                '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨': {categories: ['׳׳¡׳₪׳¨׳”', '׳©׳™׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳×׳¡׳₪׳•׳¨׳×'], preferTypes: ['serviceProvider']},
                '׳׳¢׳¦׳‘ ׳©׳¢׳¨': {categories: ['׳׳¡׳₪׳¨׳”', '׳©׳™׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳×׳¡׳₪׳•׳¨׳×'], preferTypes: ['serviceProvider']}, // Typo fix
                '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨': {categories: ['׳׳¡׳₪׳¨׳”', '׳©׳™׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳×׳¡׳₪׳•׳¨׳×'], preferTypes: ['serviceProvider']},
                '׳§׳•׳¡׳׳˜׳™׳§׳׳™׳×': {categories: ['׳׳§', '׳§׳•׳¡׳׳˜׳™׳§׳׳™׳×', '׳©׳™׳¨׳•׳×'], preferTypes: ['serviceProvider']},
                '׳׳׳׳': {categories: ['׳׳׳׳', '׳׳׳׳ ׳×', '׳©׳™׳¨׳•׳×'], preferTypes: ['serviceProvider']},
                '׳׳׳׳ ׳×': {categories: ['׳׳׳׳', '׳׳׳׳ ׳×', '׳©׳™׳¨׳•׳×'], preferTypes: ['serviceProvider']},
                '׳¦׳׳': {categories: ['׳¦׳׳', '׳¦׳™׳׳•׳', '׳©׳™׳¨׳•׳×'], preferTypes: ['serviceProvider']},
                '׳¡׳₪׳¨': {categories: ['׳׳¡׳₪׳¨׳”', '׳©׳™׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳×׳¡׳₪׳•׳¨׳×'], preferTypes: ['serviceProvider']}, // נ¯ FIX: "׳¡׳₪׳¨" = ׳׳¡׳₪׳¨׳”, not store
                '׳§׳•׳¨׳¡': {categories: ['׳§׳•׳¨׳¡'], preferTypes: ['course']}
            };
            
            // Initialize searchTermWithoutCity
            let searchTermWithoutCity = searchTerm;
            
            // נ¯ FIX: Check for known service categories FIRST before detecting city patterns
            // This prevents "׳©׳™׳¢׳¨" from being misidentified as a city in "׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨"
            const knownServiceCategories = [
                '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×',
                '׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨', '׳©׳¨׳‘׳¨׳‘', '׳—׳©׳׳׳׳™', '׳ ׳’׳¨', '׳¦׳‘׳¢', '׳׳¡׳’׳¨',
                '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳׳™׳×', '׳§׳•׳¡׳׳˜׳™׳§׳”',
                '׳¦׳׳', '׳¦׳™׳׳•׳', '׳׳׳׳', '׳׳׳׳ ׳×'
            ];
            
            let isKnownServiceCategory = false;
            for (const category of knownServiceCategories) {
                if (searchTerm.toLowerCase().includes(category.toLowerCase())) {
                    isKnownServiceCategory = true;
                    console.log(`ג… Detected known service category: "${category}" in "${searchTerm}"`);
                    break;
                }
            }
            
            // Check if query is about services/stores in a city - expanded patterns
            // Pattern 1: "׳׳™׳–׳” ׳©׳™׳¨׳•׳×׳™׳ ׳‘׳ ׳×׳ ׳™׳”", "׳׳” ׳—׳ ׳•׳™׳•׳× ׳‘׳ ׳×׳ ׳™׳”"
            const isCityServiceQueryPattern1 = /(?:׳׳™׳–׳”|׳׳”|׳™׳©)\s*(?:׳©׳™׳¨׳•׳×׳™׳|׳¢׳¡׳§׳™׳|׳—׳ ׳•׳™׳•׳×|׳׳•׳¦׳¨׳™׳|׳ ׳•׳×׳ ׳™\s+׳©׳¨׳•׳×|׳‘׳¢׳׳™\s+׳׳§׳¦׳•׳¢)\s*(?:׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”)\s*([׳-׳×]+)/.test(searchTerm);
            
            // Pattern 2: "׳—׳ ׳•׳™׳•׳× ׳‘׳ ׳×׳ ׳™׳”", "׳ ׳•׳×׳ ׳™ ׳©׳¨׳•׳× ׳‘׳ ׳×׳ ׳™׳”", "׳‘׳¢׳׳™ ׳׳§׳¦׳•׳¢ ׳‘׳ ׳×׳ ׳™׳”"
            const isCityServiceQueryPattern2 = /^(?:׳—׳ ׳•׳™׳•׳×|׳ ׳•׳×׳ ׳™\s+׳©׳¨׳•׳×|׳‘׳¢׳׳™\s+׳׳§׳¦׳•׳¢|׳©׳™׳¨׳•׳×׳™׳|׳¢׳¡׳§׳™׳)\s+׳‘([׳-׳×]+)$/.test(searchTerm);
            
            // Pattern 3: "׳—׳ ׳•׳™׳•׳× ׳‘׳ ׳×׳ ׳™׳”", "׳ ׳•׳×׳ ׳™ ׳©׳¨׳•׳× ׳‘׳ ׳×׳ ׳™׳”" (with any text before)
            const isCityServiceQueryPattern3 = /(?:׳—׳ ׳•׳™׳•׳×|׳ ׳•׳×׳ ׳™\s+׳©׳¨׳•׳×|׳‘׳¢׳׳™\s+׳׳§׳¦׳•׳¢|׳©׳™׳¨׳•׳×׳™׳|׳¢׳¡׳§׳™׳)\s+׳‘([׳-׳×]+)/.test(searchTerm);
            
            // נ¯ IMPROVED Pattern 4: "X ׳‘Y" (any word + city) - more flexible!
            // This will match: "׳׳§ ׳‘׳ ׳×׳ ׳™׳”", "׳©׳¢׳•׳ ׳‘׳—׳™׳₪׳”", "׳ ׳’׳¨ ׳‘׳×׳ ׳׳‘׳™׳‘", etc.
            // נ¯ FIX: Don't use Pattern 4 if it's a known service category (prevents "׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨" from being split incorrectly)
            const generalCityPattern = /^([׳-׳×a-zA-Z\s]+)\s+׳‘([׳-׳×]+)$/;
            const isCityServiceQueryPattern4 = !isKnownServiceCategory && generalCityPattern.test(searchTerm);
            
            const isCityServiceQuery = isCityServiceQueryPattern1 || isCityServiceQueryPattern2 || isCityServiceQueryPattern3 || isCityServiceQueryPattern4;
            
            console.log(`נ” City service query detection for "${searchTerm}": isCityServiceQuery=${isCityServiceQuery} (P1=${isCityServiceQueryPattern1}, P2=${isCityServiceQueryPattern2}, P3=${isCityServiceQueryPattern3}, P4=${isCityServiceQueryPattern4}), isKnownServiceCategory=${isKnownServiceCategory}`);
            
            // נ¯ IMPROVED: Extract service/product for ANY "X ׳‘..." patterns (Pattern 4)
            // This now works for ANY search term + city combination
            if (isCityServiceQueryPattern4 && !requiredCity) {
                const productCityMatch = searchTerm.match(generalCityPattern);
                if (productCityMatch && productCityMatch[1] && productCityMatch[2]) {
                    const searchWord = productCityMatch[1].trim();
                    const potentialCity = productCityMatch[2].trim();
                    
                    console.log(`נ” Pattern 4 (flexible) - searching for "${searchWord}" in city "${potentialCity}"`);
                    
                    // נ¯ FIX: Check if searchWord is a known service category - if so, don't split it
                    let searchWordIsService = false;
                    for (const category of knownServiceCategories) {
                        if (searchWord.toLowerCase().includes(category.toLowerCase())) {
                            searchWordIsService = true;
                            console.log(`ג ן¸ Pattern 4 - search word "${searchWord}" contains service category "${category}" - won't split it`);
                            break;
                        }
                    }
                    
                    if (searchWordIsService) {
                        // Don't split - the searchWord is itself a service category
                        console.log(`ג Skipping Pattern 4 match because searchWord is a service category`);
                    } else {
                        // Check if it's a known city
                        let foundCity = false;
                        for (const city of cities) {
                            if (city.toLowerCase() === potentialCity.toLowerCase() || 
                                city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                                potentialCity.toLowerCase().includes(city.toLowerCase())) {
                                requiredCity = city;
                                searchTermWithoutCity = searchWord;
                                console.log(`ג… Pattern 4 match - Product/Service: "${searchTermWithoutCity}", City: ${requiredCity}`);
                                foundCity = true;
                                break;
                            }
                        }
                        
                        // נ¯ FIX: Don't use potentialCity as city if it looks like it's part of a service name (e.g., "׳©׳™׳¢׳¨")
                        // Check if it's NOT in the cities list and it's a common service word
                        if (!foundCity) {
                            const commonServiceWords = ['׳©׳™׳¢׳¨', '׳ ׳™׳™׳', '׳‘׳ ׳™׳™׳', '׳‘׳™׳×', '׳¢׳¥', '׳–׳›׳•׳›׳™׳×', '׳׳×׳›׳×'];
                            const isProbablyServiceWord = commonServiceWords.some(word => potentialCity.toLowerCase().includes(word));
                            
                            if (isProbablyServiceWord) {
                                console.log(`ג Skipping Pattern 4 - "${potentialCity}" looks like a service word, not a city`);
                            } else if (potentialCity.length >= 2 && potentialCity.length <= 15 && /^[׳-׳×\s]+$/.test(potentialCity)) {
                                requiredCity = potentialCity;
                                searchTermWithoutCity = searchWord;
                                console.log(`ג… Pattern 4 match (new city) - Product/Service: "${searchTermWithoutCity}", City: ${requiredCity}`);
                            }
                        }
                    }
                }
            }
            
            // Extract service/product from search term if city was found (and not already extracted by Pattern 4)
            if (requiredCity && searchTermWithoutCity === searchTerm) {
                // Remove city and "׳‘" from search term
                searchTermWithoutCity = searchTerm
                    .replace(new RegExp(requiredCity.toLowerCase(), 'g'), '')
                    .replace(/\s*׳‘\s*/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                console.log(`נ” Search term without city: "${searchTermWithoutCity}" (original: "${searchTerm}", requiredCity: "${requiredCity}")`);
            } else if (requiredCity) {
                console.log(`נ” Required city: "${requiredCity}", search term without city: "${searchTermWithoutCity}"`);
            }
            
            // Find matching keyword
            let searchVariations = [searchTermWithoutCity, searchTerm];
            
            // נ¯ NEW: Add singular form to search variations (e.g., "׳ ׳’׳¨׳™׳" -> also search for "׳ ׳’׳¨")
            const singularForms = [];
            for (const variation of searchVariations) {
                if (variation && typeof variation === 'string') {
                    let singular = variation.toLowerCase().trim();
                    
                    // Remove "׳”" from beginning
                    if (singular.startsWith('׳”') && singular.length > 2) {
                        singular = singular.substring(1);
                    }
                    
                    // Remove plural suffixes
                    if (singular.endsWith('׳™׳') && singular.length > 3) {
                        singularForms.push(singular.substring(0, singular.length - 2));
                        console.log(`נ“ Added singular form: "${variation}" -> "${singular.substring(0, singular.length - 2)}"`);
                    } else if (singular.endsWith('׳•׳×') && singular.length > 3) {
                        singularForms.push(singular.substring(0, singular.length - 2));
                        console.log(`נ“ Added singular form: "${variation}" -> "${singular.substring(0, singular.length - 2)}"`);
                    }
                }
            }
            
            // Add singular forms to search variations
            searchVariations = [...searchVariations, ...singularForms];
            console.log(`נ” Search variations (with singular forms): [${searchVariations.join(', ')}]`);
            
            // נ¯ COMPREHENSIVE: Synonym expansion covering ALL business types, products & services
            const synonymMap = {
                // Coaching & Fitness
                '׳׳׳׳': ['׳׳׳׳ ׳×', '׳׳™׳׳•׳', '׳§׳•׳׳¦\'׳™׳ ׳’', 'coaching', '׳׳׳׳ ׳׳™׳©׳™', '׳׳׳׳ ׳›׳•׳©׳¨', '׳׳™׳׳•׳ ׳׳™׳©׳™', '׳›׳•׳©׳¨'],
                '׳׳׳׳ ׳×': ['׳׳׳׳', '׳׳™׳׳•׳', '׳§׳•׳׳¦\'׳™׳ ׳’', 'coaching', '׳׳׳׳ ׳׳™׳©׳™', '׳׳™׳׳•׳ ׳׳™׳©׳™', '׳›׳•׳©׳¨'],
                '׳׳™׳׳•׳': ['׳׳׳׳', '׳׳׳׳ ׳×', '׳§׳•׳׳¦\'׳™׳ ׳’', 'coaching', '׳׳™׳׳•׳ ׳׳™׳©׳™', '׳›׳•׳©׳¨'],
                '׳§׳•׳׳¦\'׳™׳ ׳’': ['׳׳׳׳', '׳׳׳׳ ׳×', '׳׳™׳׳•׳', 'coaching', '׳›׳•׳©׳¨'],
                'coaching': ['׳׳׳׳', '׳׳׳׳ ׳×', '׳׳™׳׳•׳', '׳§׳•׳׳¦\'׳™׳ ׳’', '׳›׳•׳©׳¨'],
                '׳›׳•׳©׳¨': ['׳׳׳׳', '׳׳׳׳ ׳×', '׳׳™׳׳•׳', '׳›׳•׳©׳¨ ׳׳™׳©׳™', '׳׳׳׳ ׳›׳•׳©׳¨', '׳—׳“׳¨ ׳›׳•׳©׳¨', '׳¡׳₪׳•׳¨׳˜'],
                
                // Carpentry & Woodwork
                '׳ ׳’׳¨': ['׳ ׳’׳¨׳•׳×', '׳ ׳’׳¨׳™׳”', '׳¢׳‘׳•׳“׳•׳× ׳¢׳¥', '׳ ׳’׳¨׳™׳™׳”', '׳ ׳’׳¨ ׳׳˜׳‘׳—׳™׳', '׳׳¨׳•׳ ׳•׳×'],
                '׳ ׳’׳¨׳•׳×': ['׳ ׳’׳¨', '׳ ׳’׳¨׳™׳”', '׳¢׳‘׳•׳“׳•׳× ׳¢׳¥', '׳׳¨׳•׳ ׳•׳×', '׳׳˜׳‘׳—׳™׳'],
                
                // Watches & Jewelry
                '׳©׳¢׳•׳': ['׳©׳¢׳•׳ ׳™׳', '׳©׳¢׳•׳ ׳™ ׳™׳“', '׳©׳¢׳•׳ ׳™׳“', '׳©׳¢׳•׳ ׳™ ׳§׳™׳¨'],
                '׳©׳¢׳•׳ ׳™׳': ['׳©׳¢׳•׳', '׳©׳¢׳•׳ ׳™ ׳™׳“', '׳×׳›׳©׳™׳˜׳™׳'],
                '׳×׳›׳©׳™׳˜': ['׳×׳›׳©׳™׳˜׳™׳', '׳×׳›׳©׳™׳˜׳ ׳•׳×', '׳×׳›׳©׳™׳˜׳', '׳–׳”׳‘', '׳›׳¡׳£', '׳×׳›׳©׳™׳˜ ׳–׳”׳‘'],
                
                // Toys & Games
                '׳¦׳¢׳¦׳•׳¢': ['׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳¦׳¢׳¦׳•׳¢׳™ ׳™׳׳“׳™׳'],
                '׳¦׳¢׳¦׳•׳¢׳™׳': ['׳¦׳¢׳¦׳•׳¢', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳', '׳׳©׳—׳§׳™ ׳™׳׳“׳™׳'],
                
                // Hairdressing & Barbershops
                '׳¡׳₪׳¨': ['׳׳¡׳₪׳¨׳”', '׳×׳¡׳₪׳•׳¨׳×', '׳×׳¡׳₪׳•׳¨׳•׳×', '׳׳¡׳₪׳¨', '׳¡׳₪׳¨ ׳’׳‘׳¨׳™׳', '׳¡׳₪׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨'], // נ¯ FIX: "׳¡׳₪׳¨" is hairdresser, not books!
                '׳׳¡׳₪׳¨׳”': ['׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳×׳¡׳₪׳•׳¨׳•׳×', '׳׳¡׳₪׳¨', '׳¡׳₪׳¨ ׳’׳‘׳¨׳™׳', '׳¡׳₪׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨'],
                '׳×׳¡׳₪׳•׳¨׳×': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳׳¡׳₪׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨'],
                '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨'],
                '׳׳¢׳¦׳‘ ׳©׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'], // Typo fix
                '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                
                // Beauty & Nails
                '׳׳§': ['׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳׳§ ׳’\'׳', '׳¢׳™׳¦׳•׳‘ ׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳'],
                '׳׳ ׳™׳§׳•׳¨': ['׳׳§', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳₪׳“׳™׳§׳•׳¨', '׳׳§ ׳’\'׳'],
                '׳₪׳“׳™׳§׳•׳¨': ['׳׳§', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳׳ ׳™׳§׳•׳¨', '׳׳§ ׳’\'׳'],
                '׳™׳•׳₪׳™': ['׳§׳•׳¡׳׳˜׳™׳§׳”', '׳˜׳™׳₪׳•׳—', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳׳™׳₪׳•׳¨', '׳¢׳™׳¦׳•׳‘ ׳’׳‘׳•׳×'],
                '׳׳¢׳¦׳‘': ['׳׳¢׳¦׳‘׳×', '׳¢׳™׳¦׳•׳‘', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳₪׳ ׳™׳', '׳׳¢׳¦׳‘ ׳’׳¨׳₪׳™'],
                
                // Restaurants & Food
                '׳׳¡׳¢׳“׳”': ['׳׳¡׳¢׳“׳•׳×', '׳׳•׳›׳', '׳׳›׳™׳׳”', '׳‘׳™׳× ׳§׳₪׳”', '׳׳–׳•׳', '׳׳•׳›׳ ׳׳”׳™׳¨'],
                '׳׳¡׳¢׳“׳•׳×': ['׳׳¡׳¢׳“׳”', '׳׳•׳›׳', '׳׳›׳™׳׳”', '׳‘׳×׳™ ׳§׳₪׳”'],
                '׳§׳₪׳”': ['׳‘׳™׳× ׳§׳₪׳”', '׳§׳₪׳” ׳‘׳•׳§׳¨', '׳§׳₪׳™׳˜׳¨׳™׳”'],
                '׳׳•׳›׳': ['׳׳¡׳¢׳“׳”', '׳׳–׳•׳', '׳׳›׳™׳׳”', '׳׳–׳•׳ ׳׳”׳™׳¨'],
                '׳₪׳™׳¦׳”': ['׳₪׳™׳¦׳¨׳™׳™׳”', '׳׳™׳˜׳׳§׳™', '׳׳¡׳¢׳“׳”'],
                '׳”׳׳‘׳•׳¨׳’׳¨': ['׳”׳׳‘׳•׳¨׳’׳¨׳™׳', '׳‘׳•׳¨׳’׳¨', '׳׳–׳•׳ ׳׳”׳™׳¨'],
                '׳¡׳•׳©׳™': ['׳™׳₪׳ ׳™', '׳׳¡׳™׳™׳×׳™', '׳¡׳•׳©׳™ ׳‘׳¨'],
                
                // Plumbing & Electrician
                '׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨': ['׳׳™׳ ׳¡׳˜׳׳¦׳™׳”', '׳©׳¨׳‘׳¨׳‘', '׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨ ׳‘׳©׳‘׳×', '׳©׳¨׳‘׳¨׳‘׳•׳×'],
                '׳©׳¨׳‘׳¨׳‘': ['׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨', '׳׳™׳ ׳¡׳˜׳׳¦׳™׳”', '׳©׳¨׳‘׳¨׳‘׳•׳×'],
                '׳—׳©׳׳׳׳™': ['׳—׳©׳׳', '׳—׳©׳׳׳׳•׳×', '׳×׳™׳§׳•׳ ׳—׳©׳׳'],
                
                // Car & Auto
                '׳¨׳›׳‘': ['׳׳›׳•׳ ׳™׳×', '׳¨׳›׳‘׳™׳', '׳׳•׳˜׳•', '׳׳›׳•׳ ׳™׳•׳×'],
                '׳—׳׳₪׳™׳': ['׳—׳׳§׳™ ׳—׳™׳׳•׳£', '׳—׳׳₪׳™ ׳¨׳›׳‘', '׳׳‘׳™׳–׳¨׳™׳ ׳׳¨׳›׳‘'],
                '׳׳•׳¡׳': ['׳×׳™׳§׳•׳ ׳¨׳›׳‘', '׳׳›׳•׳ ׳׳™', '׳׳•׳¡׳›׳™׳'],
                '׳׳›׳•׳ ׳׳™': ['׳׳•׳¡׳', '׳×׳™׳§׳•׳ ׳¨׳›׳‘', '׳׳›׳•׳ ׳׳•׳×'],
                
                // Technology & Robotics
                '׳¨׳•׳‘׳•׳˜': ['׳¨׳•׳‘׳•׳˜׳™׳§׳”', '׳¨׳•׳‘׳•׳˜׳™׳', '׳׳•׳˜׳•׳׳¦׳™׳”'],
                '׳¨׳•׳‘׳•׳˜׳™׳§׳”': ['׳¨׳•׳‘׳•׳˜', '׳¨׳•׳‘׳•׳˜׳™׳', '׳׳•׳˜׳•׳׳¦׳™׳”'],
                '׳˜׳›׳ ׳•׳׳•׳’׳™׳”': ['׳”׳™׳™-׳˜׳§', '׳˜׳›׳ ׳•׳׳•׳’׳™', '׳—׳“׳©׳ ׳•׳×'],
                '׳׳—׳©׳‘': ['׳׳—׳©׳‘׳™׳', '׳׳₪׳˜׳•׳₪', '׳׳—׳©׳‘ ׳ ׳™׳™׳“', '׳§׳•׳׳₪׳™׳•׳˜׳¨'],
                
                // Courses & Education
                '׳§׳•׳¨׳¡': ['׳§׳•׳¨׳¡׳™׳', '׳”׳©׳×׳׳׳•׳×', '׳׳™׳׳•׳“׳™׳', '׳”׳›׳©׳¨׳”'],
                '׳§׳•׳¨׳¡׳™׳': ['׳§׳•׳¨׳¡', '׳”׳©׳×׳׳׳•׳×', '׳׳™׳׳•׳“׳™׳', '׳”׳›׳©׳¨׳”'],
                '׳׳™׳׳•׳“׳™׳': ['׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳”׳©׳×׳׳׳•׳×', '׳”׳›׳©׳¨׳”'],
                
                // Events & Entertainment
                '׳׳™׳¨׳•׳¢': ['׳׳™׳¨׳•׳¢׳™׳', '׳׳™׳¨׳•׳¢ ׳—׳‘׳¨׳”', '׳׳™׳¨׳•׳¢ ׳₪׳¨׳˜׳™'],
                '׳׳™׳¨׳•׳¢׳™׳': ['׳׳™׳¨׳•׳¢', '׳—׳×׳•׳ ׳”', '׳‘׳¨ ׳׳¦׳•׳•׳”', '׳׳™׳¨׳•׳¢ ׳—׳‘׳¨׳”'],
                '׳¦׳׳': ['׳¦׳™׳׳•׳', '׳¦׳׳׳×', '׳¦׳™׳׳•׳׳™׳', '׳¦׳׳ ׳׳™׳¨׳•׳¢׳™׳'],
                '׳¦׳™׳׳•׳': ['׳¦׳׳', '׳¦׳׳׳×', '׳¦׳™׳׳•׳׳™׳', '׳¦׳™׳׳•׳ ׳׳™׳¨׳•׳¢׳™׳'],
                '׳“׳™ ׳’\'׳™׳™': ['dj', '׳“׳™.׳’\'׳™׳™', '׳×׳§׳׳™׳˜׳', '׳׳•׳–׳™׳§׳”'],
                
                // Health & Wellness
                '׳“׳™׳׳˜׳”': ['׳×׳–׳•׳ ׳”', '׳“׳™׳׳˜׳', '׳“׳™׳׳˜׳ ׳™׳×', '׳”׳¨׳–׳™׳”'],
                '׳×׳–׳•׳ ׳”': ['׳“׳™׳׳˜׳”', '׳“׳™׳׳˜׳', '׳“׳™׳׳˜׳ ׳™׳×', '׳×׳–׳•׳ ׳׳™'],
                '׳™׳•׳’׳”': ['׳™׳•׳’׳” ׳׳™׳©׳™׳×', '׳©׳™׳¢׳•׳¨׳™ ׳™׳•׳’׳”', '׳׳•׳¨׳× ׳™׳•׳’׳”'],
                '׳¢׳™׳¡׳•׳™': ['׳׳¢׳¡׳”', '׳׳¢׳¡׳•׳×', '׳¢׳™׳¡׳•׳™ ׳¨׳₪׳•׳׳™', '׳¢׳™׳¡׳•׳™ ׳©׳•׳•׳“׳™'],
                '׳₪׳™׳–׳™׳•׳×׳¨׳₪׳™׳”': ['׳₪׳™׳–׳™׳•׳×׳¨׳₪׳™׳¡׳˜', '׳₪׳™׳–׳™׳•', '׳©׳™׳§׳•׳'],
                
                // Home Services
                '׳ ׳™׳§׳™׳•׳': ['׳ ׳™׳§׳™׳•׳ ׳•׳×', '׳׳ ׳§׳”', '׳—׳‘׳¨׳× ׳ ׳™׳§׳™׳•׳', '׳©׳™׳¨׳•׳×׳™ ׳ ׳™׳§׳™׳•׳'],
                '׳’׳™׳ ׳•׳': ['׳’׳ ׳', '׳’׳™׳ ׳”', '׳©׳™׳¨׳•׳×׳™ ׳’׳™׳ ׳•׳', '׳¢׳™׳¦׳•׳‘ ׳’׳™׳ ׳•׳×'],
                '׳¦׳‘׳¢': ['׳¦׳‘׳¢׳™׳', '׳¦׳‘׳¢׳™', '׳¦׳‘׳¢׳™ ׳‘׳ ׳™׳™׳', '׳¦׳‘׳׳™'],
                '׳©׳™׳₪׳•׳¦׳™׳': ['׳©׳™׳₪׳•׳¥', '׳‘׳ ׳™׳™׳”', '׳‘׳ ׳™׳™׳', '׳§׳‘׳׳'],
                '׳§׳‘׳׳': ['׳§׳‘׳׳ ׳™׳', '׳©׳™׳₪׳•׳¦׳™׳', '׳‘׳ ׳™׳™׳”'],
                
                // Fashion & Clothing
                '׳׳•׳₪׳ ׳”': ['׳‘׳’׳“׳™׳', '׳‘׳™׳’׳•׳“', '׳׳‘׳•׳©', '׳׳•׳₪׳ ׳× ׳ ׳©׳™׳'],
                '׳‘׳’׳“׳™׳': ['׳‘׳™׳’׳•׳“', '׳׳•׳₪׳ ׳”', '׳׳‘׳•׳©', '׳‘׳’׳“׳™ ׳ ׳©׳™׳'],
                '׳ ׳¢׳׳™׳™׳': ['׳ ׳¢׳׳™׳', '׳ ׳¢׳', '׳ ׳¢׳׳™ ׳¡׳₪׳•׳¨׳˜', '׳ ׳¢׳׳™ ׳ ׳©׳™׳'],
                
                // Pets
                '׳›׳׳‘': ['׳›׳׳‘׳™׳', '׳‘׳¢׳׳™ ׳—׳™׳™׳', '׳—׳™׳•׳× ׳׳—׳׳“', '׳׳–׳•׳ ׳׳›׳׳‘׳™׳'],
                '׳—׳×׳•׳': ['׳—׳×׳•׳׳™׳', '׳‘׳¢׳׳™ ׳—׳™׳™׳', '׳—׳™׳•׳× ׳׳—׳׳“', '׳׳–׳•׳ ׳׳—׳×׳•׳׳™׳'],
                '׳•׳˜׳¨׳™׳ ׳¨': ['׳•׳˜׳¨׳™׳ ׳¨׳™׳×', '׳•׳˜׳¨׳™׳ ׳¨׳™׳”', '׳¨׳•׳₪׳ ׳•׳˜׳¨׳™׳ ׳¨', '׳׳¨׳₪׳׳”'],
                
                // Gifts & Party
                '׳׳×׳ ׳”': ['׳׳×׳ ׳•׳×', '׳׳×׳ ׳•׳× ׳׳’׳‘׳¨', '׳׳×׳ ׳•׳× ׳׳׳™׳©׳”', '׳׳×׳ ׳× ׳™׳•׳ ׳”׳•׳׳“׳×'],
                '׳׳×׳ ׳•׳×': ['׳׳×׳ ׳”', '׳©׳™', '׳©׳™ ׳׳’׳‘׳¨', '׳©׳™ ׳׳׳™׳©׳”'],
                
                // Books & Print
                '׳¡׳₪׳¨': ['׳¡׳₪׳¨׳™׳', '׳¡׳₪׳¨׳™׳”', '׳—׳ ׳•׳× ׳¡׳₪׳¨׳™׳'],
                '׳”׳“׳₪׳¡׳”': ['׳׳“׳₪׳¡׳×', '׳“׳₪׳•׳¡', '׳”׳“׳₪׳¡׳•׳×', '׳“׳™׳’׳™׳˜׳'],
                
                // Flowers
                '׳₪׳¨׳—׳™׳': ['׳₪׳¨׳—', '׳–׳¨׳™ ׳₪׳¨׳—׳™׳', '׳–׳¨ ׳₪׳¨׳—׳™׳', '׳₪׳¨׳—׳™'],
                
                // Insurance & Legal
                '׳‘׳™׳˜׳•׳—': ['׳‘׳™׳˜׳•׳—׳™׳', '׳¡׳•׳›׳ ׳‘׳™׳˜׳•׳—', '׳—׳‘׳¨׳× ׳‘׳™׳˜׳•׳—'],
                '׳¢׳•׳¨׳ ׳“׳™׳': ['׳¢׳•"׳“', '׳׳©׳¨׳“ ׳¢׳•׳¨׳›׳™ ׳“׳™׳', '׳™׳™׳¢׳•׳¥ ׳׳©׳₪׳˜׳™'],
                '׳¨׳•׳׳” ׳—׳©׳‘׳•׳': ['׳¨׳•"׳—', '׳—׳©׳‘׳•׳ ׳׳•׳×', '׳”׳ ׳”׳׳× ׳—׳©׳‘׳•׳ ׳•׳×'],
                
                // Real Estate
                '׳ ׳“׳׳': ['׳“׳™׳¨׳•׳×', '׳“׳™׳¨׳”', '׳ ׳›׳¡׳™׳', '׳׳×׳•׳•׳'],
                '׳׳×׳•׳•׳': ['׳׳×׳•׳•׳›׳™׳', '׳ ׳“׳׳', '׳“׳™׳¨׳•׳×', '׳ ׳›׳¡׳™׳']
            };
            
            const synonymExpansion = [];
            for (const variation of searchVariations) {
                if (variation && typeof variation === 'string') {
                    const varLower = variation.toLowerCase().trim();
                    // Check if this variation has synonyms
                    for (const [key, synonyms] of Object.entries(synonymMap)) {
                        if (varLower === key || varLower.includes(key)) {
                            synonymExpansion.push(...synonyms);
                            console.log(`נ“ Added synonyms for "${varLower}": [${synonyms.join(', ')}]`);
                            break;
                        }
                    }
                }
            }
            
            // Add synonyms to search variations (avoid duplicates)
            searchVariations = [...new Set([...searchVariations, ...synonymExpansion])];
            console.log(`נ” Search variations (with synonyms): [${searchVariations.join(', ')}]`);
            
            let excludeTypes = [];
            let preferTypes = null;
            // Initialize excludeWords and requireWords at function level (they might be used later)
            let excludeWords = [];
            let requireWords = [];
            
            // FIRST: Check if query is about products in a specific store (e.g., "׳׳•׳¦׳¨׳™׳ ׳‘׳—׳ ׳•׳× ׳¨׳׳“")
            // OR about store info (e.g., "׳׳” ׳”׳˜׳׳₪׳•׳ ׳©׳ ׳”׳—׳ ׳•׳× RED", "׳‘׳׳™׳–׳” ׳¢׳™׳¨ ׳”׳—׳ ׳•׳× ׳¨׳׳“")
            const storeProductPattern = /(?:׳”׳׳•׳¦׳¨׳™׳|׳׳•׳¦׳¨׳™׳|׳׳” ׳™׳©|׳׳” ׳™׳© ׳|׳׳” ׳׳•׳›׳¨׳™׳|׳׳™׳–׳” ׳׳•׳¦׳¨׳™׳)\s*(?:׳‘|׳‘׳—׳ ׳•׳×|׳©׳)\s*([׳-׳×a-zA-Z]+)/i;
            const storeInfoPattern = /(?:׳׳”|׳׳™׳–׳”)\s*(?:׳”׳˜׳׳₪׳•׳|׳”׳›׳×׳•׳‘׳×|׳”׳¢׳™׳¨|׳”׳׳™׳™׳)\s*(?:׳©׳|׳‘)\s*(?:׳”׳—׳ ׳•׳×|׳”׳¢׳¡׳§|׳”׳“׳£)?\s*([׳-׳×a-zA-Z]+)/i;
            const storeCityPattern = /(?:׳‘׳׳™׳–׳”|׳׳™׳₪׳”)\s+(?:׳¢׳™׳¨|׳׳™׳§׳•׳)\s+(?:׳”׳—׳ ׳•׳×|׳”׳¢׳¡׳§|׳”׳“׳£)\s*([׳-׳×a-zA-Z]+)/i;
            
            const storeProductMatch = searchTerm.match(storeProductPattern);
            const storeInfoMatch = searchTerm.match(storeInfoPattern) || searchTerm.match(storeCityPattern);
            const storeMatch = storeProductMatch || storeInfoMatch;
            
            if (storeMatch && storeMatch[1]) {
                const storeName = storeMatch[1].trim();
                console.log('נ× Store query detected for:', storeName);
                
                // Add the store name as primary search term (both Hebrew and English versions)
                searchVariations = [storeName.toLowerCase(), searchTerm];
                
                // If store name is Hebrew, also try English equivalent (e.g., "׳¨׳׳“" -> "red")
                // If store name is English, also try Hebrew (less common)
                if (storeName.match(/[׳-׳×]/)) {
                    // Hebrew store name - add common English equivalents
                    const hebrewToEnglish = {
                        '׳¨׳׳“': 'red',
                        '׳™׳ ׳™׳‘': 'yaniv'
                    };
                    if (hebrewToEnglish[storeName.toLowerCase()]) {
                        searchVariations.push(hebrewToEnglish[storeName.toLowerCase()]);
                    }
                } else {
                    // English store name - also try common Hebrew equivalents
                    const englishToHebrew = {
                        'red': '׳¨׳׳“',
                        'yaniv': '׳™׳ ׳™׳‘'
                    };
                    if (englishToHebrew[storeName.toLowerCase()]) {
                        searchVariations.push(englishToHebrew[storeName.toLowerCase()]);
                    }
                    searchVariations.push(storeName.toLowerCase());
                }
                
                // Don't exclude any types, prefer stores
                preferTypes = ['store'];
                console.log('נ” Store search variations:', searchVariations);
            } else {
                // Regular search flow
                
                // Check if query is about services/stores in a city (already defined above)
                if (isCityServiceQuery) {
                    // Try multiple patterns to extract city
                    let city = null;
                    
                    // Pattern 1: "׳—׳ ׳•׳™׳•׳× ׳‘׳ ׳×׳ ׳™׳”", "׳ ׳•׳×׳ ׳™ ׳©׳¨׳•׳× ׳‘׳ ׳×׳ ׳™׳”"
                    const pattern1 = /(?:׳—׳ ׳•׳™׳•׳×|׳ ׳•׳×׳ ׳™\s+׳©׳¨׳•׳×|׳‘׳¢׳׳™\s+׳׳§׳¦׳•׳¢|׳©׳™׳¨׳•׳×׳™׳|׳¢׳¡׳§׳™׳)\s+׳‘([׳-׳×]+)/;
                    const match1 = searchTerm.match(pattern1);
                    if (match1 && match1[1]) {
                        city = match1[1].trim();
                    }
                    
                    // Pattern 2: "(׳׳™׳–׳”|׳׳”|׳™׳©) (׳©׳™׳¨׳•׳×׳™׳|׳¢׳¡׳§׳™׳|׳—׳ ׳•׳™׳•׳×) ׳‘..."
                    if (!city) {
                        const pattern2 = /(?:׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”)\s*([׳-׳×]+)/;
                        const match2 = searchTerm.match(pattern2);
                        if (match2 && match2[1]) {
                            city = match2[1].trim();
                        }
                    }
                    
                    if (city) {
                        // Check what type of query it is
                        const isStoresQuery = /׳—׳ ׳•׳™׳•׳×/.test(searchTerm);
                        const isServicesQuery = /(?:׳ ׳•׳×׳ ׳™\s+׳©׳¨׳•׳×|׳‘׳¢׳׳™\s+׳׳§׳¦׳•׳¢|׳©׳™׳¨׳•׳×׳™׳)/.test(searchTerm);
                        
                        console.log(`נ™ן¸ City query detected: "${city}", stores: ${isStoresQuery}, services: ${isServicesQuery}`);
                        
                        // Set search variations and preferred types based on query
                        if (isStoresQuery) {
                            searchVariations = [city, '׳—׳ ׳•׳×', '׳—׳ ׳•׳™׳•׳×', '׳׳•׳¦׳¨'];
                            preferTypes = ['store'];
                            console.log('נ× Filtering for stores only');
                        } else if (isServicesQuery) {
                            searchVariations = [city, '׳©׳™׳¨׳•׳×', '׳ ׳•׳×׳ ׳©׳™׳¨׳•׳×', '׳‘׳¢׳ ׳׳§׳¦׳•׳¢'];
                            preferTypes = ['serviceProvider'];
                            console.log('נ”§ Filtering for services only');
                        } else {
                            // General query - show all
                            searchVariations = [city, '׳©׳™׳¨׳•׳×', '׳¢׳¡׳§', '׳—׳ ׳•׳×', '׳׳•׳¦׳¨'];
                            preferTypes = ['store', 'serviceProvider', 'event', 'course'];
                            console.log('נ Showing all types');
                        }
                    }
                }
                
                // If no city query, check for regular keywords
                // נ¯ Check for "׳×׳׳׳™׳¦׳™" / "׳”׳׳׳¦" queries first (recommendation queries)
                if (!isCityServiceQuery) {
                    // Check for recommendation queries ("׳×׳׳׳™׳¦׳™", "׳×׳׳׳™׳¥", "׳”׳׳׳¦")
                    if (searchTerm.includes('׳×׳׳׳™׳¦׳™') || searchTerm.includes('׳×׳׳׳™׳¥') || searchTerm.includes('׳”׳׳׳¦')) {
                        // Check if it's about gifts/products for someone specific
                        if (searchTerm.includes('׳׳×׳ ׳”') || searchTerm.includes('׳׳•׳¦׳¨')) {
                            // Extract target person (e.g., "׳׳׳™׳©׳”", "׳׳‘׳—׳•׳¨׳”", "׳׳’׳‘׳¨", "׳׳™׳׳“")
                            if (searchTerm.includes('׳׳׳™׳©׳”') || searchTerm.includes('׳׳‘׳—׳•׳¨׳”') || searchTerm.includes('׳׳׳©׳”')) {
                                // Gift for woman - prefer watches, nail polish, jewelry
                                searchVariations = ['׳©׳¢׳•׳', '׳׳§', '׳×׳›׳©׳™׳˜', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”'];
                                excludeTypes = ['serviceProvider'];
                                excludeWords = ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳—׳׳₪׳™׳', '׳—׳׳£']; // Exclude toys, car parts
                            } else if (searchTerm.includes('׳׳’׳‘׳¨') || searchTerm.includes('׳׳‘׳—׳•׳¨') || 
                                       searchTerm.includes('׳׳‘׳¢׳') || searchTerm.includes('׳׳‘׳¢׳׳™')) {
                                // Gift for man/husband - prefer watches, technology, gadgets (NOT toys!)
                                searchVariations = ['׳©׳¢׳•׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳¨׳•׳‘׳•׳˜', '׳’׳׳“׳’׳˜'];
                                excludeTypes = ['serviceProvider'];
                                excludeWords = ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳—׳׳₪׳™׳', '׳—׳׳£']; // נ¯ STRICT: Exclude toys, nail polish, car parts
                            } else if (searchTerm.includes('׳׳™׳׳“') || searchTerm.includes('׳׳™׳׳“׳™׳')) {
                                // Gift for child - prefer toys
                                searchVariations = ['׳¦׳¢׳¦׳•׳¢', '׳׳©׳—׳§', '׳‘׳•׳‘׳”', '׳׳›׳•׳ ׳™׳×'];
                                excludeTypes = ['serviceProvider'];
                                excludeWords = ['׳©׳¢׳•׳', '׳׳§', '׳—׳׳₪׳™׳']; // Exclude watches, nail polish, car parts
                            } else {
                                // General gift - prefer watches, jewelry, toys (but exclude services)
                                searchVariations = ['׳©׳¢׳•׳', '׳×׳›׳©׳™׳˜', '׳¦׳¢׳¦׳•׳¢', '׳׳§'];
                                excludeTypes = ['serviceProvider'];
                            }
                        } else if (searchTerm.includes('׳׳¨׳§׳˜') || searchTerm.includes('׳׳¨׳§׳˜׳₪׳׳™׳™׳¡')) {
                            // "׳×׳׳׳™׳¦׳™ ׳׳”׳׳•׳¦׳¨׳™׳ ׳‘׳׳¨׳§׳˜" - show all products
                            searchVariations = ['׳©׳¢׳•׳', '׳×׳›׳©׳™׳˜', '׳¦׳¢׳¦׳•׳¢', '׳׳§', '׳׳•׳¦׳¨'];
                            excludeTypes = ['serviceProvider'];
                        } else {
                            // General "׳×׳׳׳™׳¦׳™" - show gifts (watches, jewelry, toys)
                            searchVariations = ['׳©׳¢׳•׳', '׳×׳›׳©׳™׳˜', '׳¦׳¢׳¦׳•׳¢', '׳׳§'];
                            excludeTypes = ['serviceProvider'];
                        }
                        console.log(`נ” Recommendation query detected, searchVariations: ${searchVariations.join(', ')}`);
                    } else {
                        // Check for strict keywords first ("׳¨׳§ ׳©׳¢׳•׳", etc.)
                        let foundStrictKeyword = false;
                        for (const [keyword, config] of Object.entries(smartKeywords)) {
                            // For strict keywords like "׳¨׳§ ׳©׳¢׳•׳", check if query includes it
                            if (searchTerm.includes(keyword) && (keyword.includes('׳¨׳§') || keyword.includes('׳‘׳׳‘׳“'))) {
                                if (typeof config === 'object' && config.categories) {
                                    searchVariations = [...searchVariations, ...config.categories];
                                    if (config.excludeTypes) excludeTypes = [...excludeTypes, ...config.excludeTypes];
                                    if (config.preferTypes) preferTypes = config.preferTypes;
                                    // Store excludeWords and requireWords for later filtering
                                    if (config.excludeWords) excludeWords = [...excludeWords, ...config.excludeWords];
                                    if (config.requireWords) requireWords = [...requireWords, ...config.requireWords];
                                }
                                console.log(`נ” STRICT keyword matched: "${keyword}", excludeWords: ${excludeWords.length}, requireWords: ${requireWords.length}`);
                                foundStrictKeyword = true;
                                break;
                            }
                        }
                        
                        // If no strict keyword found, check regular keywords
                        if (!foundStrictKeyword) {
                            // נ¯ FIX: Sort keywords by length (longest first) to match "׳׳×׳ ׳” ׳׳׳™׳©׳”" before "׳׳×׳ ׳”"
                            const sortedKeywords = Object.entries(smartKeywords).sort((a, b) => {
                                // Skip strict keywords
                                if (a[0].includes('׳¨׳§') || a[0].includes('׳‘׳׳‘׳“')) return 1;
                                if (b[0].includes('׳¨׳§') || b[0].includes('׳‘׳׳‘׳“')) return -1;
                                // Sort by length (longest first)
                                return b[0].length - a[0].length;
                            });
                            
                            for (const [keyword, config] of sortedKeywords) {
                                // Skip strict keywords if we already checked them
                                if (keyword.includes('׳¨׳§') || keyword.includes('׳‘׳׳‘׳“')) continue;
                                
                                // נ¯ IMPROVED: Check for exact match OR if keyword is contained in searchTerm OR if searchTerm is contained in keyword
                                const searchTermLower = searchTerm.toLowerCase().trim();
                                const keywordLower = keyword.toLowerCase().trim();
                                const isMatch = searchTermLower === keywordLower || 
                                               searchTermLower.includes(keywordLower) || 
                                               keywordLower.includes(searchTermLower) ||
                                               // Also check word-by-word matching for multi-word keywords
                                               (keywordLower.split(/\s+/).length > 1 && 
                                                keywordLower.split(/\s+/).every(word => searchTermLower.includes(word)));
                                
                                if (isMatch) {
                                    if (typeof config === 'object' && config.categories) {
                                        searchVariations = [...searchVariations, ...config.categories];
                                        if (config.excludeTypes) excludeTypes = [...excludeTypes, ...config.excludeTypes];
                                        if (config.preferTypes) preferTypes = config.preferTypes;
                                        // Store excludeWords and requireWords for later filtering
                                        if (config.excludeWords) excludeWords = [...excludeWords, ...config.excludeWords];
                                        if (config.requireWords) requireWords = [...requireWords, ...config.requireWords];
                                    } else if (Array.isArray(config)) {
                                        searchVariations = [...searchVariations, ...config];
                                    }
                                    console.log(`נ” Keyword matched: "${keyword}" (searchTerm: "${searchTerm}"), excludeWords: ${excludeWords.length}, requireWords: ${requireWords.length}`);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            // נ¯ NEW: Add default category filtering even if no keyword was matched
            // This ensures that categories are strictly separated (toys ג‰  watches ג‰  nails)
            if (excludeWords.length === 0 && requireWords.length === 0) {
                // No keyword config found - apply default category rules
                const defaultCategoryRules = {
                    '׳¦׳¢׳¦׳•׳¢': { exclude: ['׳©׳¢׳•׳', 'watch', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳—׳׳₪׳™׳', '׳¨׳›׳‘', '׳׳•׳¡׳'], require: ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳׳©׳—׳§', '׳‘׳•׳‘׳”', '׳׳’׳•', '׳׳›׳•׳ ׳™׳× ׳׳©׳—׳§'] },
                    '׳¦׳¢׳¦׳•׳¢׳™׳': { exclude: ['׳©׳¢׳•׳', 'watch', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳—׳׳₪׳™׳', '׳¨׳›׳‘', '׳׳•׳¡׳'], require: ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳׳©׳—׳§', '׳‘׳•׳‘׳”', '׳׳’׳•'] },
                    '׳©׳¢׳•׳': { exclude: ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳—׳׳₪׳™׳', '׳¨׳›׳‘'], require: ['׳©׳¢׳•׳', 'watch'] },
                    '׳©׳¢׳•׳ ׳™׳': { exclude: ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳—׳׳₪׳™׳', '׳¨׳›׳‘'], require: ['׳©׳¢׳•׳', 'watch'] },
                    '׳׳§': { exclude: ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳©׳¢׳•׳', 'watch', '׳—׳׳₪׳™׳', '׳¨׳›׳‘', '׳׳•׳¡׳'], require: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', 'nail'] },
                    '׳׳ ׳™׳§׳•׳¨': { exclude: ['׳¦׳¢׳¦׳•׳¢', 'toy', '׳©׳¢׳•׳', 'watch', '׳—׳׳₪׳™׳', '׳¨׳›׳‘'], require: ['׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', 'nail'] }
                };
                
                // Check if searchTerm contains any default category
                for (const [category, rules] of Object.entries(defaultCategoryRules)) {
                    if (searchTerm.includes(category)) {
                        excludeWords = rules.exclude;
                        requireWords = rules.require;
                        console.log(`נ¯ Applied default category rules for "${category}": exclude=${excludeWords.length}, require=${requireWords.length}`);
                        break;
                    }
                }
            }
            
            console.log('נ” Search variations:', searchVariations);
            console.log('נ« Exclude types:', excludeTypes);
            console.log('ג­ Prefer types:', preferTypes);
            console.log('נ« Exclude words:', excludeWords);
            console.log('ג… Require words:', requireWords);
            
            // ALWAYS get fresh pages from server (ALL users in marketplace)
            const response = await fetch('/api/pages/all/marketplace');
            if (!response.ok) {
                console.error('ג Failed to fetch marketplace pages:', response.status);
                return [];
            }
            const data = await response.json();
            const allPages = data.pages || [];
            
            console.log(`נ” Got ${allPages.length} fresh pages from server`);
            
            if (allPages.length === 0) {
                console.warn('ג ן¸ WARNING: No pages found in marketplace!');
                // Try fallback endpoint
                try {
                    const fallbackResponse = await fetch('/api/pages/all');
                    if (fallbackResponse.ok) {
                        const fallbackData = await fallbackResponse.json();
                        const fallbackPages = fallbackData.pages || fallbackData || [];
                        console.log(`נ”„ Fallback: Got ${fallbackPages.length} pages from /api/pages/all`);
                        return fallbackPages.length > 0 ? fallbackPages : [];
                    }
                } catch (e) {
                    console.error('Fallback also failed:', e);
                }
                return [];
            }
            
            for (const page of allPages) {
                try {
                    let matchScore = 0;
                    
                    // EXCLUDE pages if needed
                    if (excludeTypes.includes(page.pageType)) {
                        console.log(`ג Excluding "${page.title}" - excluded type: ${page.pageType}`);
                        continue;
                    }
                    
                    // נ¯ NEW: Strict type filtering - if query explicitly mentions store or service, filter by type
                    if (hasStoreKeyword && page.pageType !== 'store') {
                        console.log(`ג ן¸ Penalizing "${page.title}" - user wants stores, but this is: ${page.pageType}`);
                        matchScore -= 50; // Heavy penalty for wrong type
                    }
                    if (hasServiceKeywordInQuery && page.pageType !== 'serviceProvider') {
                        console.log(`ג ן¸ Penalizing "${page.title}" - user wants service providers, but this is: ${page.pageType}`);
                        matchScore -= 50; // Heavy penalty for wrong type
                    }
                    
                    // Extract business name from query (e.g., "׳׳” ׳”׳˜׳׳₪׳•׳ ׳©׳ ׳“׳•׳“ ׳—׳׳₪׳™׳" -> "׳“׳•׳“ ׳—׳׳₪׳™׳")
                    let businessNameFromQuery = null;
                
                // Check for specific question patterns first
                const questionPatterns = [
                    /(?:׳׳”|׳׳™׳₪׳”|׳”׳™׳›׳|׳׳™׳–׳”)\s+(?:׳”)?׳˜׳׳₪׳•׳\s+(?:׳©׳|׳‘|׳‘׳×׳•׳)\s+([׳-׳×\s]+)/,
                    /(?:׳׳”|׳׳™׳₪׳”|׳”׳™׳›׳)\s+(?:׳”׳›׳×׳•׳‘׳×|׳”׳׳™׳™׳|׳”׳₪׳¨׳˜׳™׳)\s+(?:׳©׳|׳‘|׳‘׳×׳•׳)\s+([׳-׳×\s]+)/,
                    /(?:׳©׳|׳‘|׳‘׳×׳•׳)\s+([׳-׳×]{3,})/  // "׳©׳ ׳“׳•׳“ ׳—׳׳₪׳™׳" or "׳‘ ׳™׳ ׳™׳‘"
                ];
                
                for (const pattern of questionPatterns) {
                    const match = searchTerm.match(pattern);
                    if (match && match[1]) {
                        businessNameFromQuery = match[1].trim();
                        // Clean up common words
                        businessNameFromQuery = businessNameFromQuery.replace(/\b(׳׳”|׳׳™׳₪׳”|׳”׳™׳›׳|׳׳™׳–׳”|׳˜׳׳₪׳•׳|׳›׳×׳•׳‘׳×|׳׳™׳™׳|׳₪׳¨׳˜׳™׳|׳©׳|׳׳×|׳¢׳|׳‘|׳‘׳×׳•׳)\b/g, '').trim();
                        if (businessNameFromQuery.length >= 2 && businessNameFromQuery.length <= 50) {
                            console.log('נ¢ Extracted business name from query:', businessNameFromQuery);
                            break;
                        }
                    }
                }
                
                // If no pattern matched, try to find store/business name from query
                // Special case: "׳”׳׳•׳¦׳¨׳™׳ ׳‘׳—׳ ׳•׳× ׳¨׳׳“" -> extract "׳¨׳׳“" or "red"
                if (!businessNameFromQuery) {
                    // נ¯ IMPROVED: Use searchTermWithoutCity to avoid extracting city as business name
                    const termToSearch = searchTermWithoutCity || searchTerm;
                    // Try to extract store name from product queries
                    const storeNameMatch = termToSearch.match(/(?:׳‘|׳‘׳—׳ ׳•׳×|׳©׳)\s*([׳-׳×a-zA-Z]+)/i);
                    if (storeNameMatch && storeNameMatch[1]) {
                        const extractedName = storeNameMatch[1].trim();
                        // נ¯ IMPROVED: Don't use city as business name
                        if (!requiredCity || extractedName.toLowerCase() !== requiredCity.toLowerCase()) {
                            businessNameFromQuery = extractedName;
                            console.log('נ¢ Extracted store name from product query:', businessNameFromQuery);
                        }
                    }
                }
                
                // If still no match, try to find Hebrew/English word sequences
                if (!businessNameFromQuery) {
                    // נ¯ IMPROVED: Use searchTermWithoutCity to avoid including city
                    const termToSearch = searchTermWithoutCity || searchTerm;
                    const words = termToSearch.match(/[׳-׳×a-zA-Z]+(?:\s+[׳-׳×a-zA-Z]+){0,2}/g);
                    if (words) {
                        // Take the longest sequence that's not a common word or city
                        const commonWords = ['׳׳”', '׳׳™׳₪׳”', '׳”׳™׳›׳', '׳׳™׳–׳”', '׳˜׳׳₪׳•׳', '׳›׳×׳•׳‘׳×', '׳׳™׳™׳', '׳₪׳¨׳˜׳™׳', '׳©׳', '׳׳×', '׳¢׳', '׳‘', '׳‘׳×׳•׳', '׳”׳׳', '׳׳™', '׳”׳¨׳›׳‘', '׳”׳׳•׳¦׳¨׳™׳', '׳׳•׳¦׳¨׳™׳', '׳‘׳—׳ ׳•׳×', '׳—׳ ׳•׳×', '׳™׳©', '׳׳” ׳™׳©'];
                        businessNameFromQuery = words
                            .filter(w => {
                                const wLower = w.trim().toLowerCase();
                                // נ¯ IMPROVED: Filter out common words AND the required city
                                return !commonWords.includes(wLower) && (!requiredCity || wLower !== requiredCity.toLowerCase());
                            })
                            .sort((a, b) => b.length - a.length)[0];
                        if (businessNameFromQuery && businessNameFromQuery.length >= 2) {
                            businessNameFromQuery = businessNameFromQuery.trim();
                            console.log('נ¢ Extracted business name (fallback):', businessNameFromQuery);
                        }
                    }
                }
                
                // Check if page title or description matches (flexible matching)
                const titleLower = page.title.toLowerCase();
                const descLower = (page.description || '').toLowerCase();
                // נ¯ IMPROVED: Use searchTermWithoutCity when searching with city
                const searchTermLower = (searchTermWithoutCity || searchTerm).toLowerCase();
                
                // נ¯ IMPROVED: Check synonyms for search term
                const searchTermSynonyms = synonymMap[searchTermLower] || [];
                const allSearchTerms = [searchTermLower, ...searchTermSynonyms];
                
                // Exact title match (including synonyms)
                // נ¯ FIX: Check both includes and equals for exact matches (e.g., "׳׳¡׳₪׳¨׳”" matches "׳׳¡׳₪׳¨׳”")
                const titleMatch = allSearchTerms.some(term => 
                    titleLower.includes(term) || term.includes(titleLower) || titleLower === term
                );
                if (titleMatch) {
                    // נ¯ FIX: Higher score for exact match (e.g., "׳׳¡׳₪׳¨׳”" === "׳׳¡׳₪׳¨׳”")
                    const isExactMatch = titleLower === searchTermLower || allSearchTerms.some(term => titleLower === term);
                    matchScore += isExactMatch ? 20 : 10;
                    console.log(`ג… Title match for "${page.title}" with search term "${searchTermLower}" (exact: ${isExactMatch})`);
                }
                
                // Partial word match (e.g., "׳¨׳׳“" matches "red" or vice versa) - including synonyms
                const titleWords = titleLower.split(/\s+/);
                const searchWords = searchTermLower.split(/\s+/);
                const wordMatch = searchWords.some(word => {
                    const wordSynonyms = synonymMap[word] || [];
                    const allWordTerms = [word, ...wordSynonyms];
                    return allWordTerms.some(term => 
                        titleWords.some(titleWord => titleWord.includes(term) || term.includes(titleWord))
                    );
                });
                if (wordMatch && !titleMatch) {
                    matchScore += 7; // Partial match bonus
                    console.log(`ג… Partial word match for "${page.title}" with search term "${searchTermLower}"`);
                }
                
                // Description match - including synonyms
                // נ¯ IMPROVED: If title is generic, description match is more important
                const genericTitlesDesc = ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳¡׳₪׳¨׳•׳×', '׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨׳™׳'];
                const isGenericTitleDesc = genericTitlesDesc.some(gt => titleLower.includes(gt.toLowerCase()));
                
                // Check if description contains search term OR any of its synonyms
                const descMatch = allSearchTerms.some(term => descLower.includes(term));
                if (descMatch) {
                    // נ¯ If title is generic, description match gets higher score
                    matchScore += isGenericTitleDesc ? 15 : 5;
                    console.log(`ג… Description match for "${page.title}" (generic: ${isGenericTitleDesc}): +${isGenericTitleDesc ? 15 : 5} points`);
                }
                
                // Special handling for city-based queries - match even if title/desc don't match
                if (isCityServiceQuery) {
                    // For city queries, start with a base score for all pages (we'll check city later)
                    matchScore += 5; // Base score for city-based queries (increased from 3)
                    console.log(`נ™ן¸ City query detected - giving base score to "${page.title}"`);
                }
                
                // Also check if any part of search term matches title/description (broader matching) - including synonyms
                const searchTermWords = searchTerm.split(/\s+/).filter(w => w.length > 2);
                // נ¯ IMPROVED: Check if title is generic - if so, description is more important
                const genericTitlesForSearch = ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳¡׳₪׳¨׳•׳×', '׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨׳™׳'];
                const isGenericTitleForSearch = genericTitlesForSearch.some(gt => titleLower.includes(gt.toLowerCase()));
                
                searchTermWords.forEach(word => {
                    // Get synonyms for this word
                    const wordSynonyms = synonymMap[word.toLowerCase()] || [];
                    const allWordTerms = [word.toLowerCase(), ...wordSynonyms];
                    
                    // Check if title contains word OR any of its synonyms
                    const titleHasWord = allWordTerms.some(term => titleLower.includes(term));
                    if (titleHasWord) {
                        matchScore += 3;
                        console.log(`ג… Word match in title for "${page.title}": "${word}" (or synonym)`);
                    }
                    
                    // Check if description contains word OR any of its synonyms
                    if (page.description) {
                        const descHasWord = allWordTerms.some(term => page.description.toLowerCase().includes(term));
                        if (descHasWord) {
                            // נ¯ If title is generic, description match is more important
                            matchScore += isGenericTitleForSearch ? 8 : 2;
                            console.log(`ג… Word match in description for "${page.title}" (generic: ${isGenericTitleForSearch}): +${isGenericTitleForSearch ? 8 : 2} points`);
                        }
                    }
                });
                
                // EXACT business name match gets highest priority
                // Also check for partial matches (e.g., "red" matches "RED" or vice versa)
                if (businessNameFromQuery) {
                    const businessLower = businessNameFromQuery.toLowerCase();
                    let titleLower = page.title.toLowerCase();
                    
                    // Hebrew-English name mapping (bidirectional)
                    const nameMappings = {
                        '׳¨׳׳“': 'red',
                        'red': '׳¨׳׳“',
                        '׳™׳ ׳™׳‘': 'yaniv',
                        'yaniv': '׳™׳ ׳™׳‘'
                    };
                    
                    // Try to find matching name (direct or via mapping)
                    let businessMatch = null;
                    let titleMatch = null;
                    
                    if (nameMappings[businessLower]) {
                        businessMatch = nameMappings[businessLower];
                    }
                    if (nameMappings[titleLower]) {
                        titleMatch = nameMappings[titleLower];
                    }
                    
                    // Check direct match
                    if (titleLower.includes(businessLower) || businessLower.includes(titleLower) || 
                        titleLower === businessLower) {
                        matchScore += 50; // VERY HIGH score for exact business name (highest priority!)
                        console.log('ג… Exact business name match:', businessNameFromQuery, 'ג†’', page.title);
                    } 
                    // Check via mapping (e.g., "׳¨׳׳“" -> "red" matches "red" page)
                    else if (businessMatch && (titleLower.includes(businessMatch) || titleLower === businessMatch)) {
                        matchScore += 50; // VERY HIGH score for mapped match
                        console.log('ג… Mapped business name match:', businessNameFromQuery, 'ג†’', businessMatch, 'ג†’', page.title);
                    }
                    else if (titleMatch && (businessLower.includes(titleMatch) || businessLower === titleMatch)) {
                        matchScore += 50; // VERY HIGH score for reverse mapped match
                        console.log('ג… Reverse mapped business name match:', businessNameFromQuery, 'ג†’', titleMatch, 'ג†’', page.title);
                    }
                    else {
                        // Check for word-level match (e.g., "׳¨׳׳“" in Hebrew vs "red" in English)
                        const businessWords = businessLower.split(/\s+/);
                        const titleWords = titleLower.split(/\s+/);
                        const hasWordMatch = businessWords.some(bw => 
                            titleWords.some(tw => tw.includes(bw) || bw.includes(tw))
                        ) || (businessMatch && titleWords.some(tw => tw.includes(businessMatch) || businessMatch.includes(tw)));
                        
                        if (hasWordMatch) {
                            matchScore += 40; // High score for word-level match
                            console.log('ג… Word-level business name match:', businessNameFromQuery, 'ג†’', page.title);
                        } else {
                            matchScore -= 30; // Heavy penalty for non-matching pages when specific business was requested
                            console.log('ג Business name mismatch:', businessNameFromQuery, 'ג‰ ', page.title);
                        }
                    }
                }
                
                // Check if any search variation matches
                // נ¯ IMPROVED: If title is generic (like "׳׳¡׳₪׳¨׳”", "׳¡׳₪׳¨", etc.), give more weight to description
                const genericTitles = ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳¡׳₪׳¨׳•׳×', '׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨׳™׳'];
                const isGenericTitle = genericTitles.some(gt => page.title.toLowerCase().includes(gt.toLowerCase()));
                
                for (const variation of searchVariations) {
                    if (page.title.toLowerCase().includes(variation)) {
                        matchScore += 8;
                    }
                    if (page.description && page.description.toLowerCase().includes(variation)) {
                        // נ¯ If title is generic, description match is more important
                        matchScore += isGenericTitle ? 10 : 4;
                        console.log(`ג… Description match for "${page.title}" (generic: ${isGenericTitle}): +${isGenericTitle ? 10 : 4} points`);
                    }
                }
                
                // BONUS for preferred types
                if (preferTypes && preferTypes.includes(page.pageType)) {
                    matchScore += 5;
                }
                
                // For city-based queries, accept ALL pages (we'll filter by city later)
                // For regular queries, need at least some match - BUT also check products!
                const minScoreForCityQuery = isCityServiceQuery ? 1 : 0; // Lower threshold to allow product-based matches
                
                // Use metadata first (much faster!), fallback to live extraction for old pages
                let liveProducts = page.products || [];
                let contactInfo = {
                    phone: page.phone,
                    phones: page.phones || [],
                    email: page.email,
                    city: page.city,
                    address: page.address
                };
                
                // If metadata is missing, extract from HTML (for old pages)
                const needsExtraction = !page.city || !page.phone || (page.products && page.products.length === 0);
                if (needsExtraction) {
                try {
                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        console.log(`נ” Extracting metadata for old page: ${page.title}`);
                    const response = await fetch(pageUrl);
                    if (response.ok) {
                        const html = await response.text();
                            
                            // Extract live data (only if metadata is missing)
                            if (!contactInfo.city || !contactInfo.phone) {
                                const extractedContactInfo = extractLiveContactInfo(html);
                                contactInfo = {
                                    ...contactInfo,
                                    phone: contactInfo.phone || extractedContactInfo.phone,
                                    phones: contactInfo.phones.length > 0 ? contactInfo.phones : extractedContactInfo.phones || [],
                                    email: contactInfo.email || extractedContactInfo.email,
                                    city: contactInfo.city || extractedContactInfo.city,
                                    address: contactInfo.address || extractedContactInfo.address
                                };
                            }
                            
                            // Extract products (only if metadata is missing or empty)
                            if (!liveProducts || liveProducts.length === 0) {
                                liveProducts = extractLiveProducts(html);
                            }
                        }
                    } catch (error) {
                        console.error('Error extracting metadata for old page:', error);
                        console.error('Error details:', error.message, error.stack);
                        // נ¯ FIX: Don't fail completely - continue with page data we have
                        // The page might still be useful even if metadata extraction failed
                    }
                }
                
                // FILTER: Check excludeWords and requireWords for focused search
                // Build combined text from page title, description, and products
                const pageText = [
                    page.title,
                    page.description || '',
                    ...(liveProducts || []).map(p => p.name || '').filter(Boolean)
                ].join(' ').toLowerCase();
                
                // Exclude pages that contain excludeWords (e.g., "׳׳§" should exclude pages with "׳©׳¢׳•׳" or "׳—׳׳₪׳™׳")
                // נ¯ IMPROVED: Make this check STRICT - if excludeWords exist, page MUST NOT have any of them
                if (excludeWords && excludeWords.length > 0) {
                    const hasExcludedWord = excludeWords.some(word => 
                        pageText.includes(word.toLowerCase())
                    );
                    if (hasExcludedWord) {
                        console.log(`נ« Excluding "${page.title}" - contains excluded word (one of: ${excludeWords.join(', ')})`);
                        matchScore = -1000; // Very negative score to exclude
                        // נ¯ CRITICAL: Skip this page completely if it has excluded words
                        continue;
                    }
                }
                
                // Require pages that contain at least one requireWords (e.g., "׳׳§" should require "׳׳§" or "׳׳ ׳™׳§׳•׳¨")
                // נ¯ IMPROVED: Make this check STRICT - if requireWords exist, page MUST have one of them
                if (requireWords && requireWords.length > 0) {
                    const hasRequiredWord = requireWords.some(word => 
                        pageText.includes(word.toLowerCase())
                    );
                    if (!hasRequiredWord) {
                        console.log(`ג Excluding "${page.title}" - missing required word (need one of: ${requireWords.join(', ')})`);
                        matchScore = -1000; // Very negative score to exclude - this is STRICT!
                        // נ¯ CRITICAL: Skip this page completely if it doesn't have required words
                        continue;
                    } else {
                        matchScore += 30; // Bigger bonus for having required word
                        console.log(`ג… "${page.title}" has required word - bonus score`);
                    }
                }
                
                // Check if products match search variations (VERY IMPORTANT - can override low title/desc scores!)
                // נ¯ IMPROVED: Also check word-by-word matching for better product search
                if (liveProducts && liveProducts.length > 0) {
                    let productMatches = 0;
                    let productWordMatches = 0;
                    
                    // Helper function to normalize text (handle typos/variations)
                    const normalizeText = (text) => {
                        return text
                            .toLowerCase()
                            .replace(/׳׳™׳¨׳•׳¥|׳׳¨׳•׳¥/g, '׳׳™׳¨׳•׳¥') // Normalize "׳׳™׳¨׳•׳¥" variations
                            .replace(/׳—׳‘׳¨׳•׳×׳™|׳—׳‘׳¨׳•׳×/g, '׳—׳‘׳¨׳•׳×׳™') // Normalize "׳—׳‘׳¨׳•׳×׳™" variations
                            .replace(/׳‘׳•׳‘׳”|׳‘׳•׳‘׳×/g, '׳‘׳•׳‘׳”') // Normalize "׳‘׳•׳‘׳”" variations
                            .trim();
                    };
                    
                    // Check exact variation matches
                    for (const variation of searchVariations) {
                        for (const product of liveProducts) {
                            if (product.name && product.name.toLowerCase().includes(variation)) {
                                productMatches += 5; // Increased from 3 - products are VERY important!
                                console.log(`נ›ן¸ Product match: "${product.name}" matches "${variation}"`);
                            }
                        }
                    }
                    
                    // נ¯ NEW: Check word-by-word matching for product queries (e.g., "׳‘׳•׳‘׳× ׳₪׳¨׳•׳•׳”", "׳¨׳›׳‘׳× ׳¢׳¥")
                    // נ¯ FIX: Use searchTermWithoutCity or searchTerm instead of undefined searchKeyword
                    const searchKeywordForProducts = (searchTermWithoutCity && searchTermWithoutCity.length > 0 && searchTermWithoutCity !== searchTerm) 
                        ? searchTermWithoutCity 
                        : searchTerm;
                    const queryWords = searchKeywordForProducts.split(/\s+/).filter(w => w.length >= 2);
                    if (queryWords.length >= 2) {
                        // This is likely a specific product query (e.g., "׳‘׳•׳‘׳× ׳₪׳¨׳•׳•׳”")
                        for (const product of liveProducts) {
                            if (product.name) {
                                const productNameLower = normalizeText(product.name);
                                const queryNormalized = normalizeText(searchKeywordForProducts);
                                
                                // Check if all query words appear in product name (flexible matching)
                                const allWordsMatch = queryWords.every(queryWord => {
                                    const normalizedQueryWord = normalizeText(queryWord);
                                    return productNameLower.includes(normalizedQueryWord);
                                });
                                
                                // Also check if product name contains the query (normalized)
                                const containsQuery = productNameLower.includes(queryNormalized) || 
                                                    queryNormalized.includes(productNameLower.split(' ')[0]);
                                
                                if (allWordsMatch || containsQuery) {
                                    productWordMatches += 10; // High score for word-by-word match
                                    console.log(`נ›ן¸ Product word match: "${product.name}" matches query words "${queryWords.join(', ')}"`);
                                }
                            }
                        }
                    } else {
                        // Single word query - check if product name contains it
                        const normalizedQuery = normalizeText(searchKeywordForProducts);
                        for (const product of liveProducts) {
                            if (product.name) {
                                const productNameLower = normalizeText(product.name);
                                if (productNameLower.includes(normalizedQuery) || normalizedQuery.includes(productNameLower.split(' ')[0])) {
                                    productWordMatches += 8;
                                    console.log(`נ›ן¸ Product single word match: "${product.name}" matches "${searchKeywordForProducts}"`);
                                }
                            }
                        }
                    }
                    
                    if (productMatches > 0 || productWordMatches > 0) {
                        matchScore += productMatches + productWordMatches; // Bonus for relevant products
                        console.log(`ג… Page "${page.title}" has ${(productMatches + productWordMatches)/5} matching products, total score: ${matchScore}`);
                        
                        // If products match but title/desc don't, give minimum score to include it
                        if (matchScore === (productMatches + productWordMatches)) {
                            matchScore += 10; // Base score for having matching products
                            console.log(`נ“ˆ Giving base score for product matches: ${matchScore}`);
                        }
                    }
                }
                    
                    // נ¯ FIX: Check location if specified - CRITICAL: Must match exactly or exclude
                    let cityMatches = false; // Initialize cityMatches variable
                    
                    // נ¯ ׳©׳™׳׳•׳© ׳‘׳¢׳™׳¨ ׳-metadata ׳׳• ׳-contactInfo
                    const pageCityFromMetadata = page.city || page.businessCity || null;
                    const pageCityFinal = pageCityFromMetadata || contactInfo.city || '';
                    
                    console.log(`נ” Page "${page.title}" has city: "${pageCityFinal || 'unknown'}" (metadata: ${pageCityFromMetadata || 'none'}, contactInfo: ${contactInfo.city || 'none'}), required: "${requiredCity || 'none'}", matchScore so far: ${matchScore}`);
                    
                    if (requiredCity) {
                        const pageCityLower = (pageCityFinal || '').toLowerCase().trim();
                        const requiredCityLower = requiredCity.toLowerCase().trim();
                        
                        // Check for exact match or partial match (e.g., "׳ ׳×׳ ׳™׳”" matches "׳ ׳×׳ ׳™׳”", "׳—׳“׳¨׳”" matches "׳—׳“׳¨׳”")
                        cityMatches = pageCityLower === requiredCityLower || 
                                          pageCityLower.includes(requiredCityLower) || 
                                          requiredCityLower.includes(pageCityLower);
                        
                        if (cityMatches && pageCityLower) {
                            matchScore += 50; // BIG bonus for matching location
                            console.log(`ג… Location match: ${pageCityFinal} matches ${requiredCity}`);
                        } else {
                            // נ¯ IMPROVED: Don't completely exclude - mark as "wrong city" but keep in results
                            // This allows fallback to show "not found in X, but found in Y"
                            matchScore -= 10; // REDUCED penalty (was -30) - allow fallback results
                            page.wrongCity = true; // Mark as wrong city for later filtering
                            page.actualCity = pageCityFinal || '׳׳ ׳™׳“׳•׳¢';
                            console.log(`ג ן¸ Wrong city - "${pageCityFinal || 'unknown'}" ג‰  "${requiredCity}" - PENALIZING (score: ${matchScore})`);
                        }
                    } else if (isCityServiceQuery) {
                        // Even if city wasn't extracted before, try to match from contact info
                        const cityFromQuery = searchTerm.match(/(?:׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”)\s*([׳-׳×]+)/);
                        if (cityFromQuery && cityFromQuery[1]) {
                            const requestedCity = cityFromQuery[1].trim().toLowerCase();
                            const pageCityLower = (pageCityFinal || '').toLowerCase().trim();
                            
                            cityMatches = pageCityLower && (pageCityLower === requestedCity || 
                                pageCityLower.includes(requestedCity) || 
                                requestedCity.includes(pageCityLower));
                            
                            if (cityMatches) {
                                matchScore += 50; // Big bonus
                                console.log(`נ“ City match found: ${pageCityFinal} matches ${cityFromQuery[1]}`);
                            } else {
                                // נ¯ IMPROVED: Don't completely exclude - penalty instead
                                matchScore -= 10; // REDUCED penalty (was -30) - allow fallback results
                                page.wrongCity = true;
                                page.actualCity = pageCityFinal || '׳׳ ׳™׳“׳•׳¢';
                                console.log(`ג ן¸ City doesn't match - "${pageCityFinal || 'unknown'}" ג‰  "${cityFromQuery[1]}" - PENALIZING`);
                            }
                        } else if (cityFromQuery && cityFromQuery[1] && !pageCityFinal) {
                            // נ¯ IMPROVED: If city was requested but page has no city info, penalty but don't exclude
                            cityMatches = false;
                            matchScore -= 10; // REDUCED penalty (was -20) - allow fallback results
                            page.wrongCity = true;
                            page.actualCity = '׳׳ ׳™׳“׳•׳¢';
                            console.log(`ג ן¸ City query but no city info in page - PENALIZING (not excluding)`);
                        }
                    }
                    
                // Add live data to page
                            page.liveProducts = liveProducts;
                page.liveContactInfo = contactInfo;
                page.matchScore = matchScore;
                
                // נ¯ FIX: For specific service+city queries (e.g., "׳׳§ ׳‘׳ ׳×׳ ׳™׳”"), MUST match BOTH service AND city
                // Don't add pages that don't match the service/product if a specific service was requested
                let serviceMatchesQuery = true; // Default: if no specific service, accept all
                
                // נ¯ IMPROVED: Check service match for ALL queries, not just city queries
                // Use searchTermWithoutCity if available, otherwise use searchTerm
                const serviceToCheck = (searchTermWithoutCity && searchTermWithoutCity.length > 0 && searchTermWithoutCity !== searchTerm) 
                    ? searchTermWithoutCity 
                    : searchTerm;
                
                if (serviceToCheck && serviceToCheck.length > 0) {
                    // There's a specific service/product in the query (e.g., "׳׳§" from "׳׳§ ׳‘׳ ׳×׳ ׳™׳”" or "׳׳¡׳₪׳¨׳”")
                    let serviceLower = serviceToCheck.toLowerCase().trim();
                    
                    // נ¯ FIX: Remove "׳׳—׳₪׳©", "׳׳—׳₪׳©׳×", "׳׳ ׳™ ׳׳—׳₪׳©", "׳›׳‘׳¨ ׳—׳™׳₪׳©׳×׳™", "׳×׳ ׳•", etc. from query
                    serviceLower = serviceLower
                        .replace(/^(?:׳׳ ׳™\s+)?(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×|׳¨׳•׳¦׳”|׳¦׳¨׳™׳|׳¦׳¨׳™׳›׳”|׳›׳‘׳¨\s+׳—׳™׳₪׳©׳×׳™|׳—׳™׳₪׳©׳×׳™|׳—׳™׳₪׳©׳×|׳×׳ ׳•|׳×׳\s+׳׳™|׳×׳ ׳™\s+׳׳™)\s+/i, '') // Remove "׳׳—׳₪׳©", "׳׳ ׳™ ׳׳—׳₪׳©", "׳›׳‘׳¨ ׳—׳™׳₪׳©׳×׳™", "׳×׳ ׳•", etc.
                        .replace(/\s+(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×|׳¨׳•׳¦׳”|׳¦׳¨׳™׳|׳¦׳¨׳™׳›׳”|׳—׳™׳₪׳©׳×׳™|׳—׳™׳₪׳©׳×)$/i, '') // Remove trailing "׳׳—׳₪׳©"
                        .trim();
                    
                    // נ¯ FIX: Remove "׳׳™׳׳“", "׳׳™׳׳“׳™׳", "׳׳׳©׳×׳™", etc. from query (e.g., "׳¦׳¢׳¦׳•׳¢ ׳׳™׳׳“" -> "׳¦׳¢׳¦׳•׳¢")
                    serviceLower = serviceLower
                        .replace(/\s+׳(?:׳™׳׳“|׳™׳׳“׳™׳|׳׳©׳×׳™|׳’׳‘׳¨|׳‘׳—׳•׳¨|׳‘׳—׳•׳¨׳”|׳׳™׳©׳”|׳׳©׳”|׳‘׳¢׳|׳‘׳¢׳׳™|׳‘׳|׳‘׳×)\s*$/i, '')
                        .trim();
                    
                    // נ¯ IMPROVED: Remove definite article "׳”" from beginning (e.g., "׳”׳ ׳’׳¨" -> "׳ ׳’׳¨")
                    if (serviceLower.startsWith('׳”') && serviceLower.length > 2) {
                        serviceLower = serviceLower.substring(1);
                        console.log(`נ”§ Removed definite article: "${serviceToCheck}" -> "${serviceLower}"`);
                    }
                    
                    // נ¯ NEW: Remove plural suffix "׳™׳" or "׳•׳×" (e.g., "׳ ׳’׳¨׳™׳" -> "׳ ׳’׳¨", "׳׳¡׳¢׳“׳•׳×" -> "׳׳¡׳¢׳“")
                    if (serviceLower.endsWith('׳™׳') && serviceLower.length > 3) {
                        serviceLower = serviceLower.substring(0, serviceLower.length - 2);
                        console.log(`נ”§ Removed plural suffix: "${serviceToCheck}" -> "${serviceLower}"`);
                    } else if (serviceLower.endsWith('׳•׳×') && serviceLower.length > 3) {
                        serviceLower = serviceLower.substring(0, serviceLower.length - 2);
                        console.log(`נ”§ Removed plural suffix: "${serviceToCheck}" -> "${serviceLower}"`);
                    }
                    
                    // נ¯ FIX: If query is just "׳©׳™׳¨׳•׳×" or "׳©׳¨׳•׳×", accept ALL serviceProvider pages
                    // נ¯ BUT: If query is specific (e.g., "׳ ׳’׳¨ ׳‘׳ ׳×׳ ׳™׳”"), MUST match the specific service!
                    if (serviceLower === '׳©׳™׳¨׳•׳×' || serviceLower === '׳©׳¨׳•׳×' || serviceLower === '׳©׳™׳¨׳•׳×׳™׳' || serviceLower === '׳©׳¨׳•׳×׳™׳') {
                        console.log(`נ”§ General service query detected: "${serviceLower}" - accepting ALL serviceProvider pages`);
                        if (page.pageType === 'serviceProvider') {
                            serviceMatchesQuery = true;
                            console.log(`ג… Page "${page.title}" is a serviceProvider - ACCEPTING`);
                        } else {
                            serviceMatchesQuery = false;
                            console.log(`ג Page "${page.title}" is NOT a serviceProvider - EXCLUDING`);
                        }
                        // Skip the rest of the service matching logic for general "׳©׳™׳¨׳•׳×" queries
                        if (!serviceMatchesQuery) {
                            continue;
                        }
                    } else {
                        // נ¯ FIX: For specific service queries (e.g., "׳ ׳’׳¨ ׳‘׳ ׳×׳ ׳™׳”"), MUST match the service!
                        // Don't accept pages that don't match the specific service
                        console.log(`נ” Specific service query detected: "${serviceLower}" - MUST match service`);
                    }
                    
                    // נ¯ IMPROVED: Use synonyms when checking service match!
                    // Get synonyms for the service term
                    const serviceSynonyms = synonymMap[serviceLower] || [];
                    const allServiceTerms = [serviceLower, ...serviceSynonyms];
                    console.log(`נ” Checking service match for "${serviceLower}" (with synonyms: ${serviceSynonyms.join(', ')}) against page "${page.title}"`);
                    console.log(`   titleLower: "${titleLower}"`);
                    console.log(`   descLower: "${descLower}"`);
                    
                    // Check if title contains service OR any of its synonyms
                    // נ¯ FIX: Also check if service is "׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨" and title is "׳׳¡׳₪׳¨׳”" (they're the same)
                    // נ¯ FIX: For specific service queries (e.g., "׳ ׳’׳¨ ׳‘׳ ׳×׳ ׳™׳”"), be more strict - require exact match or synonym match
                    // נ¯ FIX: Use word boundary matching to avoid false matches (e.g., "׳׳¡׳₪׳¨׳”" shouldn't match "׳׳¡׳₪׳¨" in "׳׳¡׳₪׳¨ ׳˜׳׳₪׳•׳")
                    const titleHasService = allServiceTerms.some(term => {
                        // Check for exact word match (with word boundaries) or full title match
                        const wordBoundaryRegex = new RegExp(`\\b${term}\\b|^${term}$|${term}$`, 'i');
                        const hasTerm = wordBoundaryRegex.test(titleLower) || titleLower === term || titleLower.includes(` ${term} `) || titleLower.startsWith(`${term} `) || titleLower.endsWith(` ${term}`);
                        if (hasTerm) console.log(`   ג… Title contains "${term}" (word boundary match)`);
                        return hasTerm;
                    }) || 
                    // נ¯ FIX: Special case - "׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨" matches "׳׳¡׳₪׳¨׳”" and vice versa
                    (serviceLower.includes('׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨') && titleLower.includes('׳׳¡׳₪׳¨׳”')) ||
                    (serviceLower.includes('׳׳¡׳₪׳¨׳”') && titleLower.includes('׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨')) ||
                    // נ¯ FIX: For single-word services (e.g., "׳ ׳’׳¨"), check if word or its synonyms match
                    // BUT: Only if the word is a known service keyword (not just any word)
                    (serviceLower.split(/\s+/).length === 1 && synonymMap[serviceLower] && synonymMap[serviceLower].length > 0 &&
                     serviceLower.split(/\s+/)
                        .filter(word => word && word.length > 1 && /[\u0590-\u05FF]/.test(word))
                                               .some(word => {
                                                   const cleanWord = word.startsWith('׳”') && word.length > 2 ? word.substring(1) : word;
                            // Check if word or its synonyms match
                            const wordSynonyms = synonymMap[cleanWord] || [];
                            const allWordTerms = [cleanWord, ...wordSynonyms];
                            return allWordTerms.some(term => titleLower.includes(term));
                        })) ||
                    // נ¯ FIX: For multi-word services, check word-by-word matching
                    (serviceLower.split(/\s+/).length > 1 &&
                     serviceLower.split(/\s+/)
                        .filter(word => word && word.length > 1 && /[\u0590-\u05FF]/.test(word))
                        .some(word => {
                            const cleanWord = word.startsWith('׳”') && word.length > 2 ? word.substring(1) : word;
                            // Check if word or its synonyms match
                            const wordSynonyms = synonymMap[cleanWord] || [];
                            const allWordTerms = [cleanWord, ...wordSynonyms];
                            return allWordTerms.some(term => titleLower.includes(term));
                        }));
                    
                    // Check if description contains service OR any of its synonyms
                    // נ¯ FIX: Also check if service is "׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨" and description contains "׳׳¡׳₪׳¨׳”" (they're the same)
                    // נ¯ FIX: Use word boundary matching to avoid false matches
                    const descHasService = allServiceTerms.some(term => {
                        // Check for exact word match (with word boundaries) or full description match
                        const wordBoundaryRegex = new RegExp(`\\b${term}\\b|^${term}$|${term}$`, 'i');
                        return wordBoundaryRegex.test(descLower) || descLower === term || descLower.includes(` ${term} `) || descLower.startsWith(`${term} `) || descLower.endsWith(` ${term}`);
                    }) || 
                                          // נ¯ FIX: Special case - "׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨" matches "׳׳¡׳₪׳¨׳”" and vice versa
                                          (serviceLower.includes('׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨') && descLower.includes('׳׳¡׳₪׳¨׳”')) ||
                                          (serviceLower.includes('׳׳¡׳₪׳¨׳”') && descLower.includes('׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨')) ||
                                          serviceLower.split(/\s+/)
                                              .filter(word => word && word.length > 1 && /[\u0590-\u05FF]/.test(word))
                                              .some(word => {
                                                  const cleanWord = word.startsWith('׳”') && word.length > 2 ? word.substring(1) : word;
                                                  // Check if word or its synonyms match
                                                  const wordSynonyms = synonymMap[cleanWord] || [];
                                                  const allWordTerms = [cleanWord, ...wordSynonyms];
                                                  return allWordTerms.some(term => descLower.includes(term));
                                              });
                    
                    // Check if products match the service OR any of its synonyms
                    // נ¯ IMPROVED: Also check word-by-word matching for product queries
                    const productsMatchService = liveProducts && liveProducts.length > 0 && 
                        liveProducts.some(product => {
                            if (!product.name) return false;
                            const productNameLower = product.name.toLowerCase();
                            
                            // Check if any service term matches product name
                            const exactMatch = allServiceTerms.some(term => 
                                productNameLower.includes(term)
                            );
                            
                            // נ¯ NEW: Also check word-by-word for multi-word queries (e.g., "׳‘׳•׳‘׳× ׳₪׳¨׳•׳•׳”")
                            if (!exactMatch && serviceLower.split(/\s+/).length >= 2) {
                                const serviceWords = serviceLower.split(/\s+/).filter(w => w.length >= 2);
                                const allWordsMatch = serviceWords.every(word => {
                                    const wordSynonyms = synonymMap[word] || [];
                                    const allWordTerms = [word, ...wordSynonyms];
                                    return allWordTerms.some(term => productNameLower.includes(term));
                                });
                                return allWordsMatch;
                            }
                            
                            return exactMatch;
                        });
                    
                    // נ¯ FIX: Check if searchVariations (categories) match the page
                    // This ensures "׳׳×׳ ׳” ׳׳׳™׳©׳”" searches for watches/jewelry/nail polish, not toys
                    let categoryMatches = false;
                    if (searchVariations && searchVariations.length > 0) {
                        // Check if page title, description, or products match any of the search variations (categories)
                        const pageText = [titleLower, descLower, ...(liveProducts || []).map(p => (p.name || '').toLowerCase())].join(' ');
                        categoryMatches = searchVariations.some(variation => {
                            const variationLower = variation.toLowerCase();
                            return pageText.includes(variationLower) || 
                                   titleLower.includes(variationLower) || 
                                   descLower.includes(variationLower) ||
                                   (liveProducts && liveProducts.some(p => p.name && p.name.toLowerCase().includes(variationLower)));
                        });
                        console.log(`נ” Category match check: searchVariations=[${searchVariations.join(', ')}], categoryMatches=${categoryMatches}`);
                    }
                    
                    // Service must match title, description, or products (including synonyms)
                    // נ¯ CRITICAL: Also check if search term is in page title (e.g., "׳¦׳¢׳¦׳•׳¢" matches "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢", "׳׳¡׳₪׳¨׳”" matches "׳׳¡׳₪׳¨׳”")
                    const searchTermInTitleForService = titleLower.includes(serviceLower) || serviceLower.includes(titleLower.split(' ')[0]) || titleLower === serviceLower;
                    const searchTermInDescForService = descLower.includes(serviceLower);
                    const hasSearchTermMatchForService = searchTermInTitleForService || searchTermInDescForService;
                    
                    // נ¯ FIX: If search term exactly matches page title (e.g., "׳׳¡׳₪׳¨׳”" === "׳׳¡׳₪׳¨׳”"), always match
                    const exactTitleMatchForService = titleLower === serviceLower || titleLower.trim() === serviceLower.trim();
                    
                    // נ¯ FIX: For specific service queries (e.g., "׳ ׳’׳¨"), MUST match the service - don't rely on categories alone
                    // Categories are only for product queries (e.g., "׳׳×׳ ׳” ׳׳׳™׳©׳”")
                    // נ¯ CRITICAL: If service is specific (not "׳©׳™׳¨׳•׳×" or "׳׳•׳¦׳¨"), require service match
                    const isGeneralServiceQuery = serviceLower === '׳©׳™׳¨׳•׳×' || serviceLower === '׳©׳¨׳•׳×' || serviceLower === '׳׳•׳¦׳¨' || serviceLower === '׳׳•׳¦׳¨׳™׳';
                    if (isGeneralServiceQuery && searchVariations && searchVariations.length > 0) {
                        // General query with categories - allow category match
                        serviceMatchesQuery = exactTitleMatchForService || categoryMatches || (titleHasService || descHasService || productsMatchService || hasSearchTermMatchForService);
                    } else {
                        // Specific service query (e.g., "׳ ׳’׳¨") - MUST match service, not just categories
                        serviceMatchesQuery = exactTitleMatchForService || titleHasService || descHasService || productsMatchService || hasSearchTermMatchForService;
                    }
                    
                    console.log(`נ” Service match check for "${serviceLower}": title=${titleHasService}, desc=${descHasService}, products=${productsMatchService}, searchTermMatch=${hasSearchTermMatchForService}, exactTitleMatch=${exactTitleMatchForService}, categoryMatches=${categoryMatches}, RESULT=${serviceMatchesQuery}`);
                    
                    if (!serviceMatchesQuery) {
                        console.log(`ג Service doesn't match: page "${page.title}" doesn't contain "${serviceLower}" or categories - EXCLUDING`);
                        continue; // Skip this page - it doesn't match the requested service
                    }
                }
                
                // נ¯ IMPROVED: Pages with wrong city get penalty, but aren't excluded
                // This allows fallback message "not found in X, but found in Y"
                // The penalty was already applied above
                
                // Only add to results if score is high enough OR if it has matching products
                const hasMatchingProducts = liveProducts && liveProducts.length > 0 && 
                    searchVariations.some(variation => 
                        liveProducts.some(product => 
                            product.name && product.name.toLowerCase().includes(variation)
                        )
                    );
                
                // נ¯ IMPROVED: Allow fallback to wrong cities (with marked wrongCity flag)
                // If service matches, add the page even if city doesn't match (for fallback)
                // But prefer pages with matching city (already handled by matchScore bonus/penalty)
                // נ¯ FIX: For regular queries (not city queries), require at least some match score (5+) OR matching products
                // נ¯ CRITICAL: Also check if search term is in page title (e.g., "׳¦׳¢׳¦׳•׳¢" matches "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢", "׳׳¡׳₪׳¨׳”" matches "׳׳¡׳₪׳¨׳”")
                // נ¯ FIX: For service queries, check if SERVICE term (not full query) matches page title
                // נ¯ FIX: serviceLower might not be defined if serviceToCheck is empty - use searchTermLower as fallback
                const serviceLowerFinal = (serviceToCheck && serviceToCheck.length > 0) ? serviceToCheck.toLowerCase() : searchTermLower;
                const searchTermInTitle = serviceToCheck && serviceToCheck.length > 0 
                    ? (titleLower.includes(serviceLowerFinal) || serviceLowerFinal.includes(titleLower.split(' ')[0]) || titleLower === serviceLowerFinal)
                    : (titleLower.includes(searchTermLower) || searchTermLower.includes(titleLower.split(' ')[0]) || titleLower === searchTermLower);
                const searchTermInDesc = serviceToCheck && serviceToCheck.length > 0
                    ? descLower.includes(serviceLowerFinal)
                    : descLower.includes(searchTermLower);
                const hasSearchTermMatch = searchTermInTitle || searchTermInDesc;
                
                // נ¯ FIX: If search term exactly matches page title (e.g., "׳׳¡׳₪׳¨׳”" === "׳׳¡׳₪׳¨׳”"), always include it
                // נ¯ FIX: For service queries, check if SERVICE term (not full query) matches page title
                const exactTitleMatch = serviceToCheck && serviceToCheck.length > 0
                    ? (titleLower === serviceLower || titleLower.trim() === serviceLower.trim())
                    : (titleLower === searchTermLower || titleLower.trim() === searchTermLower.trim());
                
                const minScoreForRegularQuery = isCityServiceQuery ? minScoreForCityQuery : 5;
                // נ¯ CRITICAL: Include page if:
                // 1. Service matches AND (score is high enough OR has matching products OR search term is in title/desc OR exact title match)
                // 2. This ensures "׳¦׳¢׳¦׳•׳¢" finds "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢", "׳׳¡׳₪׳¨׳”" finds "׳׳¡׳₪׳¨׳”", and "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢" finds itself
                // 3. נ¯ FIX: If exact title match (e.g., "׳׳¡׳₪׳¨׳”" === "׳׳¡׳₪׳¨׳”"), always include it regardless of service match
                // 4. נ¯ FIX: For city+service queries (e.g., "׳ ׳’׳¨ ׳‘׳ ׳×׳ ׳™׳”"), MUST match service - don't include if service doesn't match!
                // 5. נ¯ FIX: For service queries, ONLY include if service matches OR exact title match (don't include unrelated pages!)
                // נ¯ FIX: Make it less strict - if service matches, include it even with lower score (for better results)
                const shouldInclude = (serviceToCheck && serviceToCheck.length > 0)
                    ? (exactTitleMatch || serviceMatchesQuery) && (exactTitleMatch || serviceMatchesQuery || matchScore >= minScoreForRegularQuery || hasMatchingProducts || hasSearchTermMatch)
                    : (exactTitleMatch || (serviceMatchesQuery && (matchScore >= minScoreForRegularQuery || hasMatchingProducts || hasSearchTermMatch)));
                
                // נ¯ FIX: For city+service queries, if service doesn't match, exclude the page even if city matches
                // נ¯ FIX: Also exclude if service doesn't match for ANY query (not just city queries)
                if (isCityServiceQuery && requiredCity && !serviceMatchesQuery && !exactTitleMatch) {
                    console.log(`ג City+service query: page "${page.title}" doesn't match service "${serviceLower}" - EXCLUDING even though city matches`);
                    continue; // Skip this page - it doesn't match the requested service
                }
                
                // נ¯ FIX: For ALL service queries (not just city queries), MUST match service!
                // Don't include pages that don't match the requested service
                // נ¯ FIX: But allow pages with matching city even if service doesn't match (for fallback)
                if (serviceToCheck && serviceToCheck.length > 0 && !serviceMatchesQuery && !exactTitleMatch && !cityMatches) {
                    console.log(`ג Service query: page "${page.title}" doesn't match service "${serviceLower}" and city doesn't match - EXCLUDING`);
                    continue; // Skip this page - it doesn't match the requested service or city
                }
                
                if (shouldInclude) {
                    results.push(page);
                    console.log(`ג… Added "${page.title}" with score ${matchScore} (service: ${serviceMatchesQuery}, city: ${cityMatches}, wrongCity: ${page.wrongCity || false}, score: ${matchScore})`);
                } else {
                    console.log(`ג ן¸ Skipped "${page.title}" - service: ${serviceMatchesQuery}, city: ${cityMatches}, score: ${matchScore} too low`);
                }
                } catch (error) {
                    console.error(`ג Error processing page "${page?.title || 'unknown'}" - skipping:`, error);
                    console.error(`ג Error details:`, error.message, error.stack);
                    // נ¯ FIX: Don't skip the page completely - try to add it with minimal data
                    // Only skip if it's a critical error (like null reference)
                    if (error.message && error.message.includes('null')) {
                        console.warn(`ג ן¸ Critical error (null reference) - skipping page "${page?.title || 'unknown'}"`);
                    continue; // Skip to next page
                    }
                    // For other errors, try to add the page anyway (might still be useful)
                    if (page && page.title) {
                        console.log(`ג ן¸ Non-critical error - trying to add page "${page.title}" anyway`);
                        // נ¯ FIX: matchScore might not be defined - use 0 as fallback
                        const safeMatchScore = (typeof matchScore !== 'undefined') ? matchScore : 0;
                        // Add page with minimal data
                        results.push({
                            ...page,
                            matchScore: safeMatchScore,
                            error: error.message
                        });
                    }
                }
            }
            
            // Sort by match score, but boost new pages (created/updated in last 7 days)
            results.sort((a, b) => {
                const scoreA = b.matchScore || 0;
                const scoreB = a.matchScore || 0;
                
                // נ¯ Boost new pages (created/updated in last 7 days) - they should appear higher
                const boostA = (a.isNew || (a.lastUpdated && (Date.now() - new Date(a.lastUpdated).getTime()) < (7 * 24 * 60 * 60 * 1000))) ? 10 : 0;
                const boostB = (b.isNew || (b.lastUpdated && (Date.now() - new Date(b.lastUpdated).getTime()) < (7 * 24 * 60 * 60 * 1000))) ? 10 : 0;
                
                return (scoreB + boostB) - (scoreA + boostA);
            });
            
            // נ¯ NEW: Handle city-specific queries - if user searched for "X ׳‘Y" and no results in Y
            // Show results from other cities with appropriate message
            if (requiredCity && results.length > 0) {
                const resultsInRequestedCity = results.filter(page => !page.wrongCity);
                const resultsInOtherCities = results.filter(page => page.wrongCity);
                
                console.log(`נ™ן¸ City filter: ${resultsInRequestedCity.length} in ${requiredCity}, ${resultsInOtherCities.length} in other cities`);
                
                // נ” DEBUG: Show all results before filtering
                console.log('נ“‹ All results BEFORE city filter:');
                results.forEach((page, i) => {
                    console.log(`  ${i+1}. ${page.title} - city: ${page.actualCity || 'unknown'}, wrongCity: ${page.wrongCity}, score: ${page.matchScore}`);
                });
                
                // נ¯ NEW LOGIC: Always show top result, even if from wrong city
                const topScore = results[0].matchScore;
                const topResult = results[0];
                
                if (resultsInRequestedCity.length === 0 && resultsInOtherCities.length > 0) {
                    // Found results, but not in the requested city
                    // Add a flag so the UI can show appropriate message
                    results.forEach(page => {
                        page.notInRequestedCity = true;
                        page.requestedCity = requiredCity;
                    });
                    console.log(`ג ן¸ No results in ${requiredCity}, but found ${resultsInOtherCities.length} in other cities`);
                    console.log('נ“‹ Returning results from OTHER cities');
                } else if (resultsInRequestedCity.length > 0) {
                    // Found results in requested city
                    const bestInRequestedCity = resultsInRequestedCity[0];
                    
                    // נ¯ If top result is from another city but MUCH better (score difference > 30), include it
                    if (topResult.wrongCity && topScore > bestInRequestedCity.matchScore + 30) {
                        console.log(`ג­ Top result "${topResult.title}" (score: ${topScore}) is from ${topResult.actualCity}, but much better than best in ${requiredCity} (score: ${bestInRequestedCity.matchScore})`);
                        console.log('נ“‹ Including top result from other city at the beginning');
                        // Keep top result + results from requested city
                        results = [topResult, ...resultsInRequestedCity];
                        topResult.notInRequestedCity = true;
                        topResult.requestedCity = requiredCity;
                    } else {
                        // Filter to only requested city
                        results = resultsInRequestedCity;
                        console.log(`ג… Found ${resultsInRequestedCity.length} results in ${requiredCity}`);
                        console.log('נ“‹ Results AFTER city filter (only in requested city):');
                        results.forEach((page, i) => {
                            console.log(`  ${i+1}. ${page.title} - city: ${page.actualCity || 'unknown'}, score: ${page.matchScore}`);
                        });
                    }
                }
            }
            
            // If there's a specific business name in query, filter to only exact matches or very high scores
            const lowerQuery = searchTerm.toLowerCase();
            const businessNamePattern = /(?:׳©׳|׳׳×|׳¢׳|׳‘|׳‘׳×׳•׳|׳׳”|׳׳™׳₪׳”|׳”׳™׳›׳)\s+([׳-׳×]{2,})/;
            const businessMatch = searchTerm.match(businessNamePattern);
            
            if (businessMatch && businessMatch[1]) {
                const requestedBusiness = businessMatch[1].trim().toLowerCase();
                // Remove common words
                const cleanBusinessName = requestedBusiness.replace(/\b(׳©׳|׳׳×|׳¢׳|׳‘|׳‘׳×׳•׳|׳׳”|׳׳™׳₪׳”|׳”׳™׳›׳|׳˜׳׳₪׳•׳|׳›׳×׳•׳‘׳×|׳׳™׳™׳|׳₪׳¨׳˜׳™׳)\b/g, '').trim();
                
                if (cleanBusinessName.length >= 2) {
                    // Filter: keep only pages that match the business name OR have very high score
                    const filteredResults = results.filter(page => {
                        const titleMatch = page.title.toLowerCase().includes(cleanBusinessName);
                        const highScore = (page.matchScore || 0) >= 40;
                        return titleMatch || highScore;
                    });
                    
                    if (filteredResults.length > 0) {
                        console.log(`נ¯ Filtered results from ${results.length} to ${filteredResults.length} for exact business: "${cleanBusinessName}"`);
                        return filteredResults;
                    }
                }
            }
            
            // נ¯ FIX: Limit results to 5, but save all results for "׳׳—׳¨׳™׳" option
            const maxResults = 5;
            const allResults = [...results]; // Save all results
            const limitedResults = results.slice(0, maxResults);
            
            // Store all results in context for "׳׳—׳¨׳™׳" option
            if (allResults.length > maxResults) {
                limitedResults._allResults = allResults;
                limitedResults._hasMore = true;
                limitedResults._currentOffset = 0;
            }
            
            console.log(`נ” Found ${allResults.length} LIVE pages for "${searchTerm}", showing first ${limitedResults.length}`);
            return limitedResults;
            } catch (error) {
                console.error('גגג CRITICAL ERROR in searchLivePages:', error);
                console.error('ג Error stack:', error.stack);
                console.error('ג Error message:', error.message);
                console.error('ג Query was:', query);
                return []; // Return empty array on error
            }
        }
        
        // Extract live description from HTML
        function extractLiveDescription(html) {
            console.log('נ“ Extracting description from HTML');
            
            // Try to extract from meta description tag
            const metaDescMatch = html.match(/<meta[^>]*name=["']description["'][^>]*content=["']([^"']{10,300})["']/i);
            if (metaDescMatch && metaDescMatch[1]) {
                const desc = metaDescMatch[1].trim();
                console.log('נ“ Found meta description:', desc);
                return desc;
            }
            
            // Try to extract from og:description
            const ogDescMatch = html.match(/<meta[^>]*property=["']og:description["'][^>]*content=["']([^"']{10,300})["']/i);
            if (ogDescMatch && ogDescMatch[1]) {
                const desc = ogDescMatch[1].trim();
                console.log('נ“ Found og:description:', desc);
                return desc;
            }
            
            // Try to extract from first paragraph after h1
            const h1Match = html.match(/<h1[^>]*>.*?<\/h1>\s*<p[^>]*>([^<]{20,300})<\/p>/is);
            if (h1Match && h1Match[1]) {
                const desc = h1Match[1].trim().replace(/<[^>]+>/g, '');
                console.log('נ“ Found description from first paragraph:', desc);
                return desc;
            }
            
            // Try to extract from any paragraph with class containing "desc" or "about"
            const descParagraphMatch = html.match(/<p[^>]*class=["'][^"']*(?:desc|about|intro)[^"']*["'][^>]*>([^<]{20,300})<\/p>/i);
            if (descParagraphMatch && descParagraphMatch[1]) {
                const desc = descParagraphMatch[1].trim().replace(/<[^>]+>/g, '');
                console.log('נ“ Found description from paragraph class:', desc);
                return desc;
            }
            
            // Try to extract from ANY paragraph after header/hero section
            const anyParagraphMatch = html.match(/<(?:header|section|div)[^>]*>[\s\S]*?<p[^>]*>([^<]{30,300})<\/p>/i);
            if (anyParagraphMatch && anyParagraphMatch[1]) {
                const desc = anyParagraphMatch[1].trim().replace(/<[^>]+>/g, '');
                // Make sure it's not navigation or footer text
                if (!desc.match(/׳–׳›׳•׳™׳•׳×|׳׳•׳“׳•׳×|׳¦׳•׳¨ ׳§׳©׳¨|׳×׳₪׳¨׳™׳˜|׳¢׳׳™׳ ׳•|home|about|contact/i)) {
                    console.log('נ“ Found description from any paragraph:', desc);
                    return desc;
                }
            }
            
            // Try to extract from h2 or h3 that looks like a description
            const h2Match = html.match(/<h2[^>]*>([^<]{20,300})<\/h2>/i);
            if (h2Match && h2Match[1]) {
                const desc = h2Match[1].trim();
                // Make sure it's descriptive text, not a title
                if (desc.length > 30 && !desc.match(/^[\u0590-\u05FF\s]{2,15}$/)) {
                    console.log('נ“ Found description from h2:', desc);
                    return desc;
                }
            }
            
            console.log('ג ן¸ No description found in HTML');
            return '';
        }
        
        // Extract live contact info from HTML
        function extractLiveContactInfo(html) {
            const contactInfo = {};
            
            console.log('נ“ Extracting contact info from HTML');
            
            // Extract phone numbers - SIMPLE approach like email extraction
            // Search entire HTML for Israeli phone number patterns (just like email does)
            const phonePatterns = [
                // International format (+972)
                /\+972[\s\-\)]?\s*5[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /\+972[\s\-\)]?\s*7[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /\+972[\s\-\)]?\s*5[0-9][\s\-]?\d{7}/g,
                // Standard Israeli format (05X/07X) - various separators
                /0?5[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /0?7[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /0?5[0-9][\s\-]?\d{7}/g,
                /0?7[0-9][\s\-]?\d{7}/g,
                // Dotted formats: 0X2.XXX.XXXX or similar
                /0[57]\d(?:[\.\s\-]?\d){8}/g
            ];
            
            let foundPhones = [];
            let contactAreaPhones = []; // Phones found in contact/footer areas (higher priority)
            const phoneScores = new Map(); // normalizedPhone -> score
            
            // First: Search in contact/footer areas specifically (higher priority)
            const contactAreaPattern = /<(?:section|div|footer)[^>]*(?:class|id)="[^"]*(?:contact|footer|info|details)[^"]*"[^>]*>([\s\S]{500,3000})<\/[^>]+>/gi;
            const contactAreas = [...html.matchAll(contactAreaPattern)];
            
            contactAreas.forEach(areaMatch => {
                const areaHtml = areaMatch[1];
                // Boost any phone found in contact area
                phonePatterns.forEach(pattern => {
                    const matches = areaHtml.match(pattern);
                    if (matches) {
                        matches.forEach(match => {
                            let phone = match.replace(/[\s\-\(\)\.]/g, '');
                            if (phone.startsWith('+972')) {
                                phone = phone.replace('+972', '0');
                            }
                            if (phone.length === 9 && (phone.startsWith('5') || phone.startsWith('7'))) {
                                phone = '0' + phone;
                            }
                            if (phone.length === 10 && phone.startsWith('0') && (phone[1] === '5' || phone[1] === '7')) {
                                const isValidPhone = phone.match(/^0[57][0-9]{8}$/);
                                if (isValidPhone && !phone.match(/^0+$/) && phone !== '0500000000' && phone !== '0700000000') {
                                    const formatted = `${phone.substring(0, 3)}-${phone.substring(3, 6)}-${phone.substring(6)}`;
                                    if (!contactAreaPhones.includes(formatted)) {
                                        contactAreaPhones.push(formatted);
                                        console.log('נ“ Found phone (contact area):', formatted);
                                    }
                                    // score boost for contact area
                                    phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 5);
                                }
                            }
                        });
                    }
                });
                // Boost phones in tel: links inside contact area
                const telLinks = [...areaHtml.matchAll(/href\s*=\s*"tel:([^"'>\s]+)/gi)];
                telLinks.forEach(t => {
                    let raw = t[1] || '';
                    raw = decodeURIComponent(raw);
                    let phone = raw.replace(/[^0-9\+]/g, '').replace(/^\+972/, '0');
                    if (phone.length === 9 && (phone.startsWith('5') || phone.startsWith('7'))) phone = '0' + phone;
                    if (/^0[57]\d{8}$/.test(phone)) {
                        const formatted = `${phone.substring(0, 3)}-${phone.substring(3, 6)}-${phone.substring(6)}`;
                        phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 6); // higher weight for explicit tel link
                        if (!contactAreaPhones.includes(formatted)) contactAreaPhones.push(formatted);
                    }
                });
            });
            
            // Then: Search entire HTML for phone numbers (like email - simple and direct!)
            phonePatterns.forEach(pattern => {
                const matches = html.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        let phone = match.replace(/[\s\-\(\)\.]/g, '');
                        if (phone.startsWith('+972')) {
                            phone = phone.replace('+972', '0');
                        }
                        if (phone.length === 9 && (phone.startsWith('5') || phone.startsWith('7'))) {
                            phone = '0' + phone;
                        }
                        if (phone.length === 10 && phone.startsWith('0') && (phone[1] === '5' || phone[1] === '7')) {
                            const isValidPhone = phone.match(/^0[57][0-9]{8}$/);
                            if (isValidPhone && !phone.match(/^0+$/) && phone !== '0500000000' && phone !== '0700000000') {
                                const formatted = `${phone.substring(0, 3)}-${phone.substring(3, 6)}-${phone.substring(6)}`;
                                if (!foundPhones.includes(formatted)) {
                                    foundPhones.push(formatted);
                                    console.log('נ“ Found phone:', formatted, 'from pattern:', pattern);
                                }
                                // base score for any appearance
                                phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 1);
                            }
                        }
                    });
                }
            });

            // Boost phones that are near the word "׳˜׳׳₪׳•׳" or "Phone"
            const proximityMatches = [...html.matchAll(/׳˜׳׳₪׳•׳[:\s\-]*([^<\n]{0,60})/gi)];
            proximityMatches.forEach(pm => {
                const seg = (pm[1] || '').toString();
                const hits = seg.match(/0[57]\d[\d\s\-\.]{7,}/g) || [];
                hits.forEach(h => {
                    let normalized = h.replace(/[^0-9]/g, '');
                    if (normalized.length === 9 && (normalized.startsWith('5') || normalized.startsWith('7'))) normalized = '0' + normalized;
                    if (/^0[57]\d{8}$/.test(normalized)) {
                        const formatted = `${normalized.substring(0, 3)}-${normalized.substring(3, 6)}-${normalized.substring(6)}`;
                        phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 3);
                    }
                });
            });
            
            // Prefer phones from contact areas, but fallback to any phone found
            const allPhones = [...contactAreaPhones, ...foundPhones.filter(p => !contactAreaPhones.includes(p))];
            
            if (allPhones.length > 0) {
                // Filter out phones that look like placeholders
                const validPhones = allPhones.filter(phone => {
                    const digits = phone.replace(/-/g, '');
                    const firstDigit = digits[0];
                    const isAllSame = digits.split('').every(d => d === firstDigit);
                    const isPlaceholder = phone.includes('000-000') || phone.includes('111-111') || phone.includes('123-456');
                    return !isAllSame && !isPlaceholder;
                });
                
                if (validPhones.length > 0) {
                    // Rank by score (desc), then by contact-area preference ordering
                    const ranked = [...new Set(validPhones)]
                        .map(p => ({ phone: p, score: phoneScores.get(p) || 0, inContact: contactAreaPhones.includes(p) }))
                        .sort((a, b) => (b.score - a.score) || (b.inContact - a.inContact));
                    contactInfo.phones = ranked.map(r => r.phone);
                    contactInfo.phone = contactInfo.phones[0]; // Primary best-scored
                    console.log('ג… Using phone(s):', validPhones, '(found', allPhones.length, 'total,', contactAreaPhones.length, 'from contact areas)');
                } else if (allPhones.length > 0) {
                    contactInfo.phones = allPhones;
                    contactInfo.phone = allPhones[0];
                    console.log('ג ן¸ Using phone (fallback):', contactInfo.phone);
                }
            }
            
            // Extract email - SIMPLE approach (search entire HTML)
            const emailMatch = html.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
            if (emailMatch) {
                contactInfo.email = emailMatch[1];
                console.log('נ“§ Found email:', contactInfo.email);
            }
            
            // Extract address and city (look for common address patterns) - expanded list
            const cities = [
                '׳×׳ ׳׳‘׳™׳‘', '׳™׳¨׳•׳©׳׳™׳', '׳—׳™׳₪׳”', '׳‘׳׳¨ ׳©׳‘׳¢', '׳ ׳×׳ ׳™׳”', '׳׳©׳“׳•׳“', '׳¨׳׳× ׳’׳', '׳₪׳×׳— ׳×׳§׳•׳•׳”', 
                '׳‘׳ ׳™ ׳‘׳¨׳§', '׳—׳•׳׳•׳', '׳¨׳—׳•׳‘׳•׳×', '׳›׳₪׳¨ ׳¡׳‘׳', '׳׳™׳׳×', '׳¨׳¢׳ ׳ ׳”', '׳”׳¨׳¦׳׳™׳”', '׳—׳“׳¨׳”', 
                '׳§׳¨׳™׳™׳× ׳‘׳™׳׳׳™׳§', '׳§׳¨׳™׳™׳× ׳׳•׳¦׳§׳™׳', '׳¨׳׳©׳•׳ ׳׳¦׳™׳•׳', '׳ ׳”׳¨׳™׳”', '׳”׳•׳“ ׳”׳©׳¨׳•׳', '׳’׳‘׳¢׳×׳™׳™׳', 
                '׳§׳¨׳™׳™׳× ׳׳×׳', '׳§׳¨׳™׳™׳× ׳©׳׳•׳ ׳”', '׳‘׳™׳× ׳©׳׳', '׳¢׳₪׳•׳׳”'
            ];
            
            // Try exact match first
            for (const city of cities) {
                const cityRegex = new RegExp(city, 'g');
                if (html.match(cityRegex)) {
                    contactInfo.city = city;
                    console.log('נ™ן¸ Found city (exact):', contactInfo.city);
                    break;
                }
            }
            
                // נ¯ FIX: Skip city extraction from page metadata - page is not available here
                // City extraction will be done elsewhere in the code
                // Just return contactInfo as is
                
                // נ¯ FIX: Improve city extraction - use known cities list for accuracy
                if (!contactInfo.city) {
                    // List of common Israeli cities for accurate matching
                    const knownCities = [
                        '׳×׳ ׳׳‘׳™׳‘', '׳™׳¨׳•׳©׳׳™׳', '׳—׳™׳₪׳”', '׳‘׳׳¨ ׳©׳‘׳¢', '׳ ׳×׳ ׳™׳”', '׳׳©׳“׳•׳“', '׳¨׳׳× ׳’׳', '׳₪׳×׳— ׳×׳§׳•׳•׳”', 
                        '׳‘׳ ׳™ ׳‘׳¨׳§', '׳—׳•׳׳•׳', '׳¨׳—׳•׳‘׳•׳×', '׳›׳₪׳¨ ׳¡׳‘׳', '׳׳™׳׳×', '׳¨׳¢׳ ׳ ׳”', '׳”׳¨׳¦׳׳™׳”', '׳—׳“׳¨׳”', 
                        '׳§׳¨׳™׳™׳× ׳‘׳™׳׳׳™׳§', '׳§׳¨׳™׳™׳× ׳׳•׳¦׳§׳™׳', '׳¨׳׳©׳•׳ ׳׳¦׳™׳•׳', '׳ ׳”׳¨׳™׳”', '׳”׳•׳“ ׳”׳©׳¨׳•׳', '׳’׳‘׳¢׳×׳™׳™׳', 
                        '׳§׳¨׳™׳™׳× ׳׳×׳', '׳§׳¨׳™׳™׳× ׳©׳׳•׳ ׳”', '׳‘׳™׳× ׳©׳׳', '׳¢׳₪׳•׳׳”', '׳׳¢׳׳•׳×', '׳ ׳¦׳¨׳×', '׳¢׳›׳•', '׳˜׳‘׳¨׳™׳”',
                        '׳¦׳₪׳×', '׳§׳¨׳™׳× ׳’׳×', '׳“׳™׳׳•׳ ׳”', '׳׳•׳₪׳§׳™׳', '׳ ׳×׳™׳‘׳•׳×', '׳§׳¨׳™׳× ׳׳׳׳›׳™', '׳§׳¨׳™׳× ׳©׳׳•׳ ׳”',
                        '׳§׳¨׳™׳× ׳׳¨׳‘׳¢', '׳‘׳™׳× ׳©׳׳©', '׳׳•׳“׳™׳¢׳™׳', '׳׳•׳“', '׳¨׳׳׳”', '׳™׳‘׳ ׳”', '׳’׳“׳¨׳”', '׳§׳¨׳™׳× ׳¢׳§׳¨׳•׳'
                    ];
                
                // Search for cities in contact info areas first (more reliable)
                const contactAreaPattern = /<(?:section|div|footer)[^>]*(?:class|id)="[^"]*(?:contact|footer|info|details)[^"]*"[^>]*>([\s\S]{500,3000})<\/[^>]+>/gi;
                const contactAreas = [...html.matchAll(contactAreaPattern)];
                
                // Check in contact areas first
                for (const areaMatch of contactAreas) {
                    const areaHtml = areaMatch[1].toLowerCase();
                    for (const city of knownCities) {
                        if (areaHtml.includes(city.toLowerCase())) {
                            contactInfo.city = city;
                            console.log('נ™ן¸ Found city in contact area:', contactInfo.city);
                            break;
                        }
                    }
                    if (contactInfo.city) break;
                }
                
                // If not found in contact area, search entire HTML for known cities
                if (!contactInfo.city) {
                    const htmlLower = html.toLowerCase();
                    const citiesFound = [];
                    for (const city of knownCities) {
                        if (htmlLower.includes(city.toLowerCase())) {
                            citiesFound.push(city);
                            if (!contactInfo.city) {
                                contactInfo.city = city;
                                console.log('נ™ן¸ Found city in HTML:', contactInfo.city);
                            }
                        }
                    }
                    if (citiesFound.length > 1) {
                        console.log('ג ן¸ Multiple cities found in HTML:', citiesFound.join(', '), '- using first:', contactInfo.city);
                    }
                }
                
                // Last resort: try pattern matching (but be more strict)
                if (!contactInfo.city) {
                    const cityPattern = /(?:׳‘|׳‘׳×׳•׳|׳‘׳™׳|׳¢׳|׳׳™׳“|׳§׳¨׳•׳‘\s+׳)\s*([׳-׳×]{2,15})/gi;
                    const matches = [...html.matchAll(cityPattern)];
                    if (matches.length > 0) {
                        for (const match of matches) {
                            const potentialCity = match[1].trim();
                            // Check if it matches a known city
                            for (const city of knownCities) {
                                if (city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                                    potentialCity.toLowerCase().includes(city.toLowerCase())) {
                                    contactInfo.city = city;
                                    console.log('נ™ן¸ Found city by pattern:', contactInfo.city);
                                    break;
                                }
                            }
                            if (contactInfo.city) break;
                        }
                    }
                }
            }
            
            // Extract address - FIRST try navigation button links (Google Maps / Waze)
            // Users add address to navigation buttons, this is the most accurate source
            const navigationButtonPatterns = [
                // Google Maps: href="https://www.google.com/maps?q=..." or href="https://maps.google.com/?q=..."
                /href\s*=\s*["']https?:\/\/(?:www\.)?(?:maps\.)?google\.com\/maps[^"']*q=([^"'\&]+)/gi,
                /href\s*=\s*["']https?:\/\/(?:www\.)?(?:maps\.)?google\.com\/maps[^"']*daddr=([^"'\&]+)/gi,
                // Waze: href="https://waze.com/ul?q=..." or href="https://www.waze.com/ul?q=..."
                /href\s*=\s*["']https?:\/\/(?:www\.)?waze\.com\/ul[^"']*q=([^"'\&]+)/gi,
                /href\s*=\s*["']https?:\/\/(?:www\.)?waze\.com\/ul[^"']*ll=([^"'\&]+)/gi,
                // General navigation link with address in text
                /<a[^>]*href\s*=\s*["'](?:https?:\/\/(?:maps|waze))[^"']*["'][^>]*>([^<]{10,100})<\/a>/gi
            ];
            
            for (const pattern of navigationButtonPatterns) {
                const matches = [...html.matchAll(pattern)];
                if (matches && matches.length > 0) {
                    for (const match of matches) {
                        if (match[1]) {
                            // Decode URL-encoded address
                            let address = decodeURIComponent(match[1].trim());
                            // Clean up address
                            address = address.replace(/\+/g, ' ').replace(/%20/g, ' ').replace(/\s+/g, ' ').trim();
                            // Check if it looks like a real address (contains Hebrew/English, not just coordinates)
                            if (address.length > 5 && (address.match(/[׳-׳×]/) || address.match(/[a-zA-Z]/))) {
                                // Prioritize addresses with street names
                                if (address.match(/׳¨׳—׳•׳‘|street|st\./i) || address.match(/\d+/)) {
                                    contactInfo.address = address;
                                    console.log('נ“ Found address from navigation button:', contactInfo.address);
                                    break;
                                } else if (!contactInfo.address) {
                                    // Use this as fallback if no street address found yet
                                    contactInfo.address = address;
                                    console.log('נ“ Found address from navigation button (fallback):', contactInfo.address);
                                }
                            }
                        }
                    }
                    if (contactInfo.address) break;
                }
            }
            
            // If no address from navigation button, try text patterns
            if (!contactInfo.address) {
                const addressPatterns = [
                    /([׳-׳×\s]+,\s*׳¨׳—׳•׳‘\s+[׳-׳×\s\d]+)/g,
                    /([׳-׳×\s]+,\s*[׳-׳×\s\d]+\s+\d+)/g,
                    /(׳¨׳—׳•׳‘\s+[׳-׳×\s\d]+,\s*[׳-׳×\s]+)/g,
                    /׳›׳×׳•׳‘׳×[:\s]*([^<\n]{5,80})/gi
                ];
                
                for (const pattern of addressPatterns) {
                    const matches = html.match(pattern);
                    if (matches && matches[0]) {
                        let address = matches[0].replace(/׳›׳×׳•׳‘׳×[:\s]*/gi, '').trim();
                        if (address.length > 5) {
                            contactInfo.address = address;
                            console.log('נ“ Found address from text pattern:', contactInfo.address);
                            break;
                        }
                    }
                }
            }
            
            return contactInfo;
        }
        
        // Extract live products from HTML - ONLY REAL PRODUCTS, NO INVENTIONS
        function extractLiveProducts(html) {
            const products = [];
            
            console.log('נ” Marketplace extractLiveProducts called, HTML length:', html.length);
            
            // ג›” STRICT EXCLUSIONS - ׳“׳‘׳¨׳™׳ ׳©׳”׳ ׳‘׳•׳•׳“׳׳•׳× ׳׳ ׳׳•׳¦׳¨׳™׳!
            // Get page title and h1 to exclude them from products (they're not products!)
            const pageTitleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
            const pageH1Match = html.match(/<h1[^>]*>([^<]{3,80})<\/h1>/i);
            const pageTitle = pageTitleMatch ? pageTitleMatch[1].trim() : '';
            const pageH1 = pageH1Match ? pageH1Match[1].trim() : '';
            
            const excludePatterns = [
                '׳ ׳’׳™׳©׳•׳×', '׳׳•׳“׳•׳×', '׳¦׳•׳¨ ׳§׳©׳¨', '׳“׳£ ׳”׳‘׳™׳×', '׳¢׳׳™׳ ׳•', '׳×׳§׳ ׳•׳', '׳׳“׳™׳ ׳™׳•׳×', 
                '׳₪׳¨׳˜׳™׳•׳×', '׳×׳ ׳׳™׳', '׳©׳™׳¨׳•׳×', '׳׳©׳׳•׳—׳™׳', '׳”׳—׳–׳¨׳•׳×', '׳׳™׳ ׳׳”׳–׳׳™׳',
                '׳’׳׳¨׳™', '׳”׳׳•׳¦׳¨׳™׳', '׳×׳™׳׳•׳¨', '׳”׳׳™׳•׳—׳“׳™׳', '׳”׳›׳ ׳¢׳', '׳›׳ ׳”׳–׳›׳•׳™׳•׳×',
                '׳–׳›׳•׳™׳•׳× ׳™׳•׳¦׳¨׳™׳', '׳‘׳¨׳•׳›׳™׳ ׳”׳‘׳׳™׳', '׳׳§׳•׳—׳•׳×', '׳©׳׳׳•׳×', '׳×׳©׳•׳‘׳•׳×',
                '׳׳•׳¦׳¨׳™׳ ׳©׳׳ ׳•', '׳”׳׳•׳¦׳¨׳™׳ ׳©׳׳ ׳•', '׳×׳₪׳¨׳™׳˜', '׳›׳•׳×׳¨׳×', '׳›׳•׳×׳¨׳× ׳¨׳׳©׳™׳×',
                '׳׳׳”', '׳׳׳” ׳׳‘׳—׳•׳¨', '׳׳׳” ׳׳‘׳—׳•׳¨ ׳‘', '׳׳׳” ׳׳‘׳—׳•׳¨ ׳‘׳¨׳•׳‘׳•׳˜׳™׳', // נ¯ FIX: Exclude question-style text
                '׳׳™׳', '׳׳™׳ ׳', '׳›׳™׳¦׳“', '׳׳“׳•׳¢', '׳׳” ׳”׳™׳×׳¨׳•׳ ׳•׳×', '׳׳” ׳”׳™׳×׳¨׳•׳',
                // נ¯ NEW: Exclude accessibility/design options that are NOT real products
                '׳ ׳™׳’׳•׳“׳™׳•׳×', '׳’׳•׳₪׳', '׳§׳¨׳™׳', '׳”׳“׳’׳©', '׳§׳™׳©׳•׳¨׳™׳', '׳¨׳™׳•׳•׳—', '׳©׳•׳¨׳•׳×', 
                '׳׳•׳’׳‘׳¨', '׳¡׳׳', '׳’׳“׳•׳', '׳¢׳¦׳•׳¨', '׳׳ ׳™׳׳¦׳™׳•׳×', '׳×׳¦׳•׳’׳”', '׳’׳“׳׳”',
                '׳’׳“׳׳×', '׳§׳˜׳ ׳”', '׳§׳˜׳ ׳×', '׳’׳•׳₪׳ ׳’׳“׳•׳', '׳’׳•׳₪׳ ׳§׳˜׳', '׳ ׳™׳’׳•׳“׳™׳•׳× ׳’׳‘׳•׳”׳”',
                '׳ ׳™׳’׳•׳“׳™׳•׳× ׳ ׳׳•׳›׳”', '׳’׳•׳₪׳ ׳§׳¨׳™׳', '׳’׳•׳₪׳ ׳’׳“׳•׳', '׳’׳•׳₪׳ ׳§׳˜׳',
                // נ¯ FIX: Exclude common names/places that are NOT products (e.g., "׳“׳•׳“ ׳—׳׳₪׳™׳")
                '׳“׳•׳“', '׳—׳׳₪׳™׳', '׳—׳׳£', // Exclude names like "׳“׳•׳“ ׳—׳׳₪׳™׳" which is a business name, not a product
                pageTitle, pageH1 // Exclude page title and main h1
            ].filter(Boolean); // Remove empty strings
            
            // ג›” EXCLUDE common non-product words from product names
            const excludeFromName = [
                'ג‚×', '׳©׳§׳', '׳©"׳—', '׳׳—׳™׳¨', '׳׳—׳™׳¨׳™׳', '׳׳—׳™׳¨׳•׳', '׳׳©׳›׳•׳¨׳×',
                '׳˜׳׳₪׳•׳', '׳׳™׳™׳', '׳׳™׳׳™׳™׳', '׳›׳×׳•׳‘׳×', '׳¢׳™׳¨', '׳™׳©׳¨׳׳', '׳™׳©׳¨׳׳',
                '׳©׳ ׳”', '׳—׳•׳“׳©', '׳™׳•׳', '׳©׳¢׳”', '׳“׳§׳”', '׳©׳ ׳™׳™׳”',
                '׳׳•׳׳ ׳•׳×', '׳–׳׳', '׳—׳™׳™׳', '׳—׳™׳™׳', '׳—׳•׳•׳™׳”', '׳—׳•׳•׳™׳•׳×',
                '׳˜׳•׳”׳¨', '׳™׳•׳₪׳™', '׳׳™׳›׳•׳×', '׳”׳©׳¨׳׳”', '׳—׳׳•׳', '׳׳׳×', '׳ ׳©׳׳”',
                '׳™׳¢׳™׳׳•׳×', '׳—׳¡׳¨׳×', '׳×׳§׳“׳™׳', '׳×׳§׳“׳™׳׳™׳', // נ¯ FIX: Exclude descriptive text like "׳™׳¢׳™׳׳•׳× ׳—׳¡׳¨׳× ׳×׳§׳“׳™׳"
                '׳‘׳™׳¦׳•׳¢׳™׳', '׳‘׳™׳¦׳•׳¢', '׳×׳›׳•׳ ׳”', '׳×׳›׳•׳ ׳•׳×', '׳™׳×׳¨׳•׳', '׳™׳×׳¨׳•׳ ׳•׳×',
                '׳׳§׳¦׳•׳¢׳™׳•׳×', '׳׳”׳™׳¨׳•׳×', '׳׳׳™׳ ׳•׳×', '׳¡׳˜׳™׳’׳ ׳¡', '׳¡׳˜׳’׳ ׳¡', '׳¡׳˜׳’׳ ׳',
                // נ¯ FIX: Exclude business names/places that are NOT products
                '׳“׳•׳“', '׳—׳׳₪׳™׳', '׳—׳׳£' // Exclude names like "׳“׳•׳“ ׳—׳׳₪׳™׳" which is a business name, not a product
            ];
            
            // ג›” EXCLUDE phrases that are clearly NOT products (taglines, mottos, inspirational text, questions, descriptions)
            const excludePhrases = [
                /׳–׳׳\s+(׳–׳•|׳–׳”)\s+׳׳•׳׳ ׳•׳×/,
                /.*׳׳•׳׳ ׳•׳×.*/,
                /.*׳—׳•׳•׳™׳”.*/,
                /.*׳¡׳˜׳’׳ ׳¡.*/,
                /.*׳׳•׳©׳׳.*/,
                /^׳˜׳•׳”׳¨$/,
                /^׳™׳•׳₪׳™$/,
                /^׳׳™׳›׳•׳×$/,
                /^׳”׳©׳¨׳׳”$/,
                /^׳—׳׳•׳$/,
                /^׳׳׳×$/,
                /^׳ ׳©׳׳”$/,
                /^׳׳׳”.*/, // נ¯ FIX: Exclude questions like "׳׳׳” ׳׳‘׳—׳•׳¨ ׳‘..."
                /.*׳׳׳”.*׳‘׳—׳•׳¨.*/, // נ¯ FIX: Exclude "׳׳׳” ׳׳‘׳—׳•׳¨ ׳‘..." patterns
                /.*׳׳׳”.*׳¨׳•׳‘׳•׳˜.*/, // נ¯ FIX: Exclude "׳׳׳” ׳׳‘׳—׳•׳¨ ׳‘׳¨׳•׳‘׳•׳˜׳™׳..."
                /.*\?$/, // נ¯ FIX: Exclude text ending with question mark (likely a title/question, not product)
                /׳™׳¢׳™׳׳•׳×\s+(׳—׳¡׳¨׳×|׳—׳¡׳¨).*/, // נ¯ FIX: Exclude "׳™׳¢׳™׳׳•׳× ׳—׳¡׳¨׳× ׳×׳§׳“׳™׳"
                /׳™׳¢׳™׳׳•׳×.*׳×׳§׳“׳™׳/, // נ¯ FIX: Exclude "׳™׳¢׳™׳׳•׳× ׳—׳¡׳¨׳× ׳×׳§׳“׳™׳"
                /.*׳™׳¢׳™׳׳•׳×.*/, // נ¯ FIX: Exclude descriptive text like "׳™׳¢׳™׳׳•׳×"
                /.*׳‘׳™׳¦׳•׳¢׳™׳.*/, // נ¯ FIX: Exclude "׳‘׳™׳¦׳•׳¢׳™׳" (performance, not a product)
                /.*׳×׳›׳•׳ ׳”.*/, // נ¯ FIX: Exclude "׳×׳›׳•׳ ׳”" (feature, not a product)
                /.*׳™׳×׳¨׳•׳.*/, // נ¯ FIX: Exclude "׳™׳×׳¨׳•׳" (advantage, not a product)
                /.*׳׳§׳¦׳•׳¢׳™׳•׳×.*/, // נ¯ FIX: Exclude "׳׳§׳¦׳•׳¢׳™׳•׳×" (professionalism, not a product)
                /.*׳׳”׳™׳¨׳•׳×.*/, // נ¯ FIX: Exclude "׳׳”׳™׳¨׳•׳×" (speed, not a product)
                /.*׳׳׳™׳ ׳•׳×.*/, // נ¯ FIX: Exclude "׳׳׳™׳ ׳•׳×" (reliability, not a product)
                // נ¯ NEW: Exclude accessibility/design options that are NOT real products
                /^׳ ׳™׳’׳•׳“׳™׳•׳×\s+(׳’׳‘׳•׳”׳”|׳ ׳׳•׳›׳”|׳׳•׳’׳‘׳¨׳×)$/i,
                /^׳’׳•׳₪׳\s+(׳§׳¨׳™׳|׳’׳“׳•׳|׳§׳˜׳|׳׳•׳’׳‘׳¨)$/i,
                /^׳”׳“׳’׳©\s+׳§׳™׳©׳•׳¨׳™׳$/i,
                /^׳¨׳™׳•׳•׳—\s+׳©׳•׳¨׳•׳×\s+׳׳•׳’׳‘׳¨$/i,
                /^׳¡׳׳\s+׳’׳“׳•׳$/i,
                /^׳¢׳¦׳•׳¨\s+׳׳ ׳™׳׳¦׳™׳•׳×$/i,
                /^׳×׳¦׳•׳’׳”\s+(׳’׳“׳׳”|׳§׳˜׳ ׳”)$/i,
                /^׳ ׳™׳’׳•׳“׳™׳•׳×\s+׳’׳‘׳•׳”׳”$/i,
                /^׳’׳•׳₪׳\s+׳§׳¨׳™׳$/i,
            ];
            
            // נ¯ Look for products - try multiple strategies for different page structures
            // Strategy 1: Look for product-card elements (common in RED and other stores)
            const productCardPattern = /<div[^>]*class="[^"]*product-card[^"]*"[^>]*>([\s\S]{50,2000})<\/div>/gi;
            const productCardMatches = [...html.matchAll(productCardPattern)];
            
            if (productCardMatches.length > 0) {
                console.log('ג… Found product-card elements:', productCardMatches.length);
                
                productCardMatches.forEach(cardMatch => {
                    const cardHtml = cardMatch[1];
                    
                    // Look for product name - try multiple strategies
                    let nameMatch = null;
                    
                    // Priority 1: h3.product-name or h4.product-name
                    nameMatch = cardHtml.match(/<h[1-6][^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/h[1-6]>/i);
                    
                    // Priority 2: any h3 or h4 (common in stores)
                        if (!nameMatch) {
                        const hMatches = cardHtml.match(/<h[34][^>]*>([^<]{3,100})<\/h[34]>/gi);
                        if (hMatches && hMatches.length > 0) {
                            // Take the first one that looks like a product name
                            for (const hMatch of hMatches) {
                                const text = hMatch.replace(/<[^>]*>/g, '').trim();
                                if (text.length >= 3 && text.length <= 100 && text.match(/[׳-׳×]/)) {
                                    nameMatch = [null, text];
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Priority 3: any element with class product-name (span, div, p, etc.)
                    if (!nameMatch) {
                        nameMatch = cardHtml.match(/<[^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/[^>]+>/i);
                    }
                    
                    // Priority 4: Look for text that's clearly a product name (standalone text in card)
                    if (!nameMatch) {
                        // Remove HTML tags and find meaningful text blocks
                        const textOnly = cardHtml.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                        const words = textOnly.split(/\s+/);
                        if (words.length >= 2 && words.length <= 10) {
                            // Check if it looks like product name (not price, not button text)
                            const potentialName = words.slice(0, 5).join(' ');
                            if (potentialName.match(/[׳-׳×]/) && !potentialName.includes('ג‚×') && 
                                !potentialName.includes('׳”׳•׳¡׳£') && !potentialName.includes('׳¢׳’׳׳”') &&
                                potentialName.length >= 3 && potentialName.length <= 50) {
                                nameMatch = [null, potentialName];
                            }
                        }
                    }
                    
                    // Look for price - try multiple strategies
                    let priceMatch = null;
                    
                    // Priority 1: element with class product-price
                    priceMatch = cardHtml.match(/<[^>]*class="[^"]*product-price[^"]*"[^>]*>.*?ג‚×\s*(\d+(?:[.,]\d+)?)/i);
                    
                    // Priority 2: any ג‚× symbol with number in the card (most common)
                        if (!priceMatch) {
                        priceMatch = cardHtml.match(/ג‚×\s*(\d+(?:[.,]\d+)?)|(\d+(?:[.,]\d+)?)\s*ג‚×/);
                    }
                    
                    // Priority 3: Look for number patterns that look like prices (4 digits or more, possibly with comma)
                    if (!priceMatch) {
                        priceMatch = cardHtml.match(/(\d{1,3}(?:,\d{3})+(?:\.\d+)?)/); // e.g., 1,500 or 1,500.00
                        }
                        
                        if (nameMatch && priceMatch) {
                        const name = nameMatch[1].replace(/<[^>]*>/g, '').trim(); // Remove any HTML tags
                        let priceText = priceMatch[1] || priceMatch[2];
                        
                        // Additional validation: ensure price is actually in the same card context
                        const nameIndex = cardHtml.indexOf(nameMatch[0] || nameMatch.input);
                        const priceIndex = cardHtml.indexOf(priceMatch[0]);
                        
                        // Name and price must be reasonably close in the card (within 800 chars)
                        const distance = Math.abs((nameIndex || 0) - (priceIndex || 0));
                        if (distance > 800 && nameIndex !== -1 && priceIndex !== -1) {
                            console.log(`   ג ן¸ Skipping - name and price too far apart in card (${distance} chars)`);
                            return; // Skip this card - name and price not related
                        }
                        
                        // Clean price: remove commas and spaces, handle formats like 1,500
                        priceText = priceText.replace(/[,\s]/g, '');
                        const price = parseFloat(priceText);
                        
                        // STRICT validation
                            const isExcluded = excludePatterns.some(pattern => 
                                name.toLowerCase().includes(pattern.toLowerCase())
                            );
                            
                        const hasExcludedWords = excludeFromName.some(ex => name.includes(ex));
                        
                        // Check if name matches excluded phrases (taglines, mottos)
                        const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                        
                        // נ¯ FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        // Only accept prices >= 10 (real product prices like ג‚×10, ג‚×60, ג‚×75)
                        const isValidPrice = price >= 2 && price < 100000 && !isNaN(price);
                        // Exclude single words that are likely taglines/mottos (too short to be a real product name)
                        const isSingleWord = name.trim().split(/\s+/).length === 1;
                        const isShortTagline = isSingleWord && name.length <= 8 && !name.match(/[0-9]/);
                        const isValidName = name.length >= 3 && name.length <= 100 && 
                                           name.match(/[׳-׳×]/) && 
                                           !name.match(/^[0-9\s-]+$/) &&
                                           !name.includes('ג‚×') &&
                                           !name.includes('!') && // Exclude taglines that end with !
                                           !matchesExcludedPhrase &&
                                           !isShortTagline; // Exclude single short words that are likely taglines
                        
                        if (!isExcluded && !hasExcludedWords && !matchesExcludedPhrase && isValidName && isValidPrice) {
                            // Check for duplicates
                            const isDuplicate = products.some(p => p.name.toLowerCase() === name.toLowerCase());
                            if (!isDuplicate) {
                                products.push({ name, price });
                                console.log(`   ג… VALID product-card: "${name}" - ג‚×${price}`);
                            }
                        } else {
                            console.log(`   ג EXCLUDED product-card: "${name}" - ג‚×${price} (isExcluded: ${isExcluded}, hasExcluded: ${hasExcludedWords}, validName: ${isValidName}, validPrice: ${isValidPrice})`);
                        }
                    } else {
                        if (!nameMatch) console.log(`   ג ן¸ No name found in product-card`);
                        if (!priceMatch) console.log(`   ג ן¸ No price found in product-card`);
                    }
                });
            }
            
            // Strategy 2: Look for ANY div with product-like classes or patterns
            // נ¯ FIX: More comprehensive search for product containers
            const productContainerPatterns = [
                /<div[^>]*(?:class|id)="[^"]*(?:product-grid|product-gallery|store-items|gallery|products|main-content|container|grid|flex|items)[^"]*"[^>]*>([\s\S]*?)<\/div>/gi,
                /<section[^>]*(?:class|id)="[^"]*(?:products|store|gallery|main)[^"]*"[^>]*>([\s\S]*?)<\/section>/gi,
                /<main[^>]*>([\s\S]*?)<\/main>/gi
            ];
            
            let allContentSections = [];
            productContainerPatterns.forEach(pattern => {
                const matches = [...html.matchAll(pattern)];
                matches.forEach(match => {
                    if (match[1] && match[1].length > 100) { // Only add meaningful sections
                        allContentSections.push(match[1]);
                    }
                });
            });
            
            // If no specific sections found, use entire body/main content
            if (allContentSections.length === 0) {
                const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
                if (bodyMatch) {
                    allContentSections.push(bodyMatch[1]);
                }
            }
            
            console.log(`ג… Found ${allContentSections.length} content sections to search`);
            
            allContentSections.forEach((sectionHtml, sectionIndex) => {
                console.log(`נ” Searching section ${sectionIndex + 1} (${sectionHtml.length} chars)`);
                
                // Strategy 2a: Look for product items with price patterns
                // נ¯ FIX: Look for patterns like: <h2>Product Name</h2>...<p class="product-price">ג‚×XX</p>
                const productPatternWithPrice = /(?:<h[2-6][^>]*>([^<]{3,80})<\/h[2-6]>|<[^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,80})<\/[^>]+>)[\s\S]{0,500}?ג‚×\s*(\d+(?:[.,]\d+)?)/gi;
                const productMatches = [...sectionHtml.matchAll(productPatternWithPrice)];
                
                productMatches.forEach(productMatch => {
                    const name = (productMatch[1] || productMatch[2] || '').trim();
                    const priceText = (productMatch[3] || '').replace(/[,\s]/g, '');
                    const price = parseFloat(priceText);
                    
                    if (name && name.length >= 3 && name.length <= 80 && 
                        !name.includes('ג‚×') && !name.includes('׳”׳•׳¡׳£') && !name.includes('׳¢׳’׳׳”') &&
                        price > 0 && price < 100000 && !isNaN(price) &&
                        name.match(/[׳-׳×]/)) {
                        // Check exclusions
                        const isExcluded = excludePatterns.some(pattern => 
                            name.toLowerCase().includes(pattern.toLowerCase())
                        );
                        const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                        const isDuplicate = products.some(p => p.name.toLowerCase() === name.toLowerCase());
                        
                        if (!isExcluded && !matchesExcludedPhrase && !isDuplicate) {
                            products.push({ name, price });
                            console.log(`   ג… Found product (pattern with price): "${name}" - ג‚×${price}`);
                        }
                    }
                });
            });
            
            // Strategy 2b: Original gallery search (keep for backward compatibility)
            const galleryPattern = /<div[^>]*(?:class|id)="[^"]*(?:product-grid|product-gallery|store-items|gallery|products|main-content|container)[^"]*"[^>]*>([\s\S]*?)<\/div>/gi;
            const galleryMatches = [...html.matchAll(galleryPattern)];
            
            if (galleryMatches.length > 0) {
                console.log('ג… Found product gallery/content sections:', galleryMatches.length);
                
                galleryMatches.forEach(galleryMatch => {
                    const gallery = galleryMatch[0];
                    
                    // Look for product items inside gallery - try multiple patterns
                    const itemPatterns = [
                        /<div[^>]*class="[^"]*(?:product-item|product-card|gallery-item|store-item)[^"]*"[^>]*>([\s\S]{50,2000})<\/div>/gi,
                        /<div[^>]*id="[^"]*product[^"]*"[^>]*>([\s\S]{50,2000})<\/div>/gi,
                        /<article[^>]*>([\s\S]{50,2000})<\/article>/gi, // Some stores use article tags
                        /<section[^>]*class="[^"]*product[^"]*"[^>]*>([\s\S]{50,2000})<\/section>/gi
                    ];
                    
                    itemPatterns.forEach(pattern => {
                        const itemMatches = [...gallery.matchAll(pattern)];
                        
                        itemMatches.forEach(itemMatch => {
                            const itemHtml = itemMatch[1];
                            
                            // Extract product name - comprehensive search
                            let nameMatch = itemHtml.match(/<h[1-6][^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/h[1-6]>/i);
                    if (!nameMatch) {
                                const hMatches = itemHtml.match(/<h[34][^>]*>([^<]{3,100})<\/h[34]>/gi);
                                if (hMatches && hMatches.length > 0) {
                                    for (const hMatch of hMatches) {
                                        const text = hMatch.replace(/<[^>]*>/g, '').trim();
                                        if (text.length >= 3 && text.length <= 100 && text.match(/[׳-׳×]/) &&
                                            !text.includes('ג‚×') && !text.includes('׳”׳•׳¡׳£')) {
                                            nameMatch = [null, text];
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!nameMatch) {
                                nameMatch = itemHtml.match(/<[^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/[^>]+>/i);
                            }
                            
                            // Extract price - comprehensive search
                            let priceMatch = itemHtml.match(/<[^>]*class="[^"]*product-price[^"]*"[^>]*>.*?ג‚×\s*(\d+(?:[.,]\d+)?)/i);
                    if (!priceMatch) {
                                priceMatch = itemHtml.match(/ג‚×\s*(\d+(?:[.,]\d+)?)|(\d+(?:[.,]\d+)?)\s*ג‚×/);
                            }
                            if (!priceMatch) {
                                priceMatch = itemHtml.match(/(\d{1,3}(?:,\d{3})+(?:\.\d+)?)/); // Formats like 1,500
                    }
                    
                    if (nameMatch && priceMatch) {
                                const name = nameMatch[1].replace(/<[^>]*>/g, '').trim();
                                let priceText = priceMatch[1] || priceMatch[2];
                                // Clean price: remove commas, spaces
                                priceText = priceText.replace(/[,\s]/g, '');
                                const price = parseFloat(priceText);
                        
                        const isExcluded = excludePatterns.some(pattern => 
                            name.toLowerCase().includes(pattern.toLowerCase())
                        );
                                const hasExcludedWords = excludeFromName.some(ex => name.includes(ex));
                                const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                                // נ¯ FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        // Only accept prices >= 10 (real product prices like ג‚×10, ג‚×60, ג‚×75)
                        const isValidPrice = price >= 2 && price < 100000 && !isNaN(price);
                                const isSingleWord = name.trim().split(/\s+/).length === 1;
                                const isShortTagline = isSingleWord && name.length <= 8 && !name.match(/[0-9]/);
                                const isValidName = name.length >= 3 && name.length <= 100 && 
                                                   name.match(/[׳-׳×]/) && 
                                                   !name.match(/^[0-9\s-]+$/) &&
                                                   !name.includes('!') &&
                                                   !matchesExcludedPhrase &&
                                                   !isShortTagline;
                                
                                if (!isExcluded && !hasExcludedWords && !matchesExcludedPhrase && isValidName && isValidPrice) {
                                    // Check if not duplicate
                                    const isDuplicate = products.some(p => p.name.toLowerCase() === name.toLowerCase());
                                    if (!isDuplicate) {
                            products.push({ name, price });
                                        console.log(`   ג… VALID gallery product: "${name}" - ג‚×${price}`);
                                    }
                                }
                            }
                        });
                    });
                });
            }
            
            // Strategy 3: Direct search for product patterns (ALWAYS try, even if we found some)
            // This helps find products that might be in different structures
            console.log(`ג ן¸ Found ${products.length} products so far, trying additional patterns...`);
            
            // Strategy 3: Look for patterns where h2-h6 appears near a price (within same structural block)
            // נ¯ FIX: More comprehensive search for product blocks
            // Look for ANY block that contains both a product name AND a price
            const blockPatterns = [
                /<(?:div|section|article|li)[^>]*>([\s\S]{30,3000})<\/(?:div|section|article|li)>/gi,
                /<article[^>]*>([\s\S]{30,3000})<\/article>/gi,
                /<li[^>]*>([\s\S]{30,3000})<\/li>/gi
            ];
            
            let allBlocks = [];
            blockPatterns.forEach(pattern => {
                const matches = [...html.matchAll(pattern)];
                matches.forEach(match => {
                    if (match[1] && match[1].length >= 30 && match[1].length <= 3000) {
                        // Only add if it contains Hebrew and potential price
                        // נ¯ FIX: Must catch single digit prices like ג‚×10 (change \d{2,} to \d{1,})
                        if (match[1].match(/[׳-׳×]/) && match[1].match(/ג‚×|\d{1,}/)) {
                            allBlocks.push(match[1]);
                        }
                    }
                });
            });
            
            console.log(`נ” Scanning ${allBlocks.length} blocks for additional products...`);
            
            allBlocks.forEach((blockHtml, blockIndex) => {
                // Skip if block is too generic (navigation, header, footer)
                if (blockHtml.includes('nav') || blockHtml.includes('header') || 
                    blockHtml.includes('footer') || blockHtml.includes('׳×׳₪׳¨׳™׳˜') ||
                    blockHtml.includes('menu') || blockHtml.includes('navigation')) {
                    return;
                }
                
                // נ¯ FIX: Look for product names in multiple patterns
                // Priority 1: h2-h6 with Hebrew text (potential product name)
                // ג ן¸ EXCLUDE h1 - it's usually the page title, not a product!
                let nameMatches = blockHtml.match(/<h[2-6][^>]*>([^<]{3,80})<\/h[2-6]>/gi) || [];
                
                // Priority 2: strong, b, span, p with product-like text
                if (nameMatches.length === 0) {
                    const strongMatches = blockHtml.match(/<(?:strong|b)[^>]*>([^<]{4,60})<\/(?:strong|b)>/gi);
                    if (strongMatches) {
                        strongMatches.forEach(match => {
                            const text = match.replace(/<[^>]*>/g, '').trim();
                            if (text.match(/[׳-׳×]{4,}/) && !text.includes('ג‚×') && !text.includes('׳”׳•׳¡׳£') && text.length >= 4 && text.length <= 60) {
                                nameMatches.push(`<h3>${text}</h3>`); // Treat as name
                            }
                        });
                    }
                }
                
                // Priority 3: Look for text in divs/spans that could be product names
                if (nameMatches.length === 0) {
                    const textMatches = blockHtml.match(/<(?:p|span|div)[^>]*class="[^"]*[^"]*"[^>]*>([^<]{4,60})<\/(?:p|span|div)>/gi);
                    if (textMatches) {
                        textMatches.forEach(textMatch => {
                            const text = textMatch.replace(/<[^>]*>/g, '').trim();
                            // Check if it looks like a product name (Hebrew, not price, not button)
                            if (text.match(/[׳-׳×]{4,}/) && !text.includes('ג‚×') && !text.includes('׳”׳•׳¡׳£') && 
                                !text.includes('׳¢׳’׳׳”') && !text.match(/^\d+$/) && // Not just numbers
                                text.length >= 4 && text.length <= 60 &&
                                !excludePatterns.some(pattern => text.toLowerCase().includes(pattern.toLowerCase()))) {
                                nameMatches.push(`<h3>${text}</h3>`); // Treat as name
                            }
                        });
                    }
                }
                if (nameMatches.length === 0) {
                    // Also try p, span, strong with product-like text
                    const textMatches = blockHtml.match(/<(?:p|span|strong|b)[^>]*>([^<]{4,60})<\/(?:p|span|strong|b)>/gi);
                    if (textMatches) {
                        // Check if any look like product names
                        textMatches.forEach(textMatch => {
                            const text = textMatch.replace(/<[^>]*>/g, '').trim();
                            if (text.match(/[׳-׳×]{4,}/) && !text.includes('ג‚×') && !text.includes('׳”׳•׳¡׳£')) {
                                nameMatches.push(`<h3>${text}</h3>`); // Treat as name
                            }
                        });
                    }
                }
                
                if (!nameMatches || nameMatches.length === 0) return;
                
                nameMatches.forEach(nameMatch => {
                    const nameText = nameMatch.replace(/<[^>]*>/g, '').trim();
                    
                    // Check if this is the page title or h1 (not a product!)
                    const isPageTitle = pageTitle && nameText.toLowerCase() === pageTitle.toLowerCase();
                    const isPageH1 = pageH1 && nameText.toLowerCase() === pageH1.toLowerCase();
                    
                    // Check excluded phrases
                    const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(nameText));
                    
                    // Check if name looks valid (Hebrew, not excluded, not page title, not tagline)
                    const isSingleWord = nameText.trim().split(/\s+/).length === 1;
                    const isShortTagline = isSingleWord && nameText.length <= 8 && !nameText.match(/[0-9]/);
                    const isValidName = !isPageTitle && !isPageH1 && !matchesExcludedPhrase && !isShortTagline &&
                                       nameText.length >= 3 && nameText.length <= 80 && 
                                       nameText.match(/[׳-׳×]/) && 
                                       !nameText.match(/^[0-9\s-]+$/) &&
                                       !nameText.includes('!') &&
                                       !excludePatterns.some(pattern => 
                                           nameText.toLowerCase().includes(pattern.toLowerCase())
                                       ) &&
                                       !excludeFromName.some(ex => nameText.includes(ex));
                    
                    if (!isValidName) return;
                    
                    // נ¯ FIX: Look for price in the SAME block (must be nearby) - improved pattern
                    // Must catch low prices like ג‚×10, ג‚×60, ג‚×75, ג‚×85, ג‚×90!
                    const pricePatterns = [
                        /ג‚×\s*(\d{1,4}(?:,\d{3})*)/,  // ג‚×1,500 or ג‚×1500 or ג‚×10
                        /(\d{1,4}(?:,\d{3})*)\s*ג‚×/,  // 1,500ג‚× or 10ג‚×
                        /ג‚×\s*(\d{1,6})/,                  // ג‚×720 or ג‚×10 (must catch single digits!)
                        /(\d{1,6})/,                   // 720, 1500, 10 (standalone number - must catch single digits!)
                    ];
                    
                    let priceMatch = null;
                    for (const pattern of pricePatterns) {
                        priceMatch = blockHtml.match(pattern);
                        if (priceMatch && priceMatch[1]) {
                            const testPrice = parseFloat(priceMatch[1].replace(/[,\s]/g, ''));
                            // נ¯ FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                            // (e.g., "׳™׳¢׳™׳׳•׳× ׳—׳¡׳¨׳× ׳×׳§׳“׳™׳ - ג‚×2" - the 2 is probably part of text, not a product price)
                            // Only accept prices >= 10 (real product prices like ג‚×10, ג‚×60, ג‚×75)
                            if (testPrice >= 10 && testPrice < 50000) { // Reasonable price range (includes small prices like 10!)
                                break;
                            }
                            priceMatch = null;
                        }
                    }
                    
                    if (priceMatch) {
                        let priceText = priceMatch[1];
                        priceText = priceText.replace(/[,\s]/g, '');
                        const price = parseFloat(priceText);
                        
                        // Additional validation: price must be reasonable and in the same block as name
                        const nameIndex = blockHtml.indexOf(nameMatch);
                        const priceIndex = blockHtml.indexOf(priceMatch[0]);
                        const distance = Math.abs(nameIndex - priceIndex);
                        
                        // נ¯ FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        // (e.g., "׳™׳¢׳™׳׳•׳× ׳—׳¡׳¨׳× ׳×׳§׳“׳™׳ - ג‚×2" - the price 2 is probably not a product price)
                        // Only accept prices >= 10 (real product prices like ג‚×10, ג‚×60, ג‚×75)
                        const isValidPriceValue = price >= 2 && price < 50000;
                        
                        // נ¯ FIX: Allow low prices like 10, 60, 75, 85, 90 (not just >50!)
                        // Price must be within 800 chars of name (increased from 500 to catch more products)
                        // But exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        if (isValidPriceValue && !isNaN(price) && distance < 800) {
                            // Check if not duplicate and not already found
                            const isDuplicate = products.some(p => p.name.toLowerCase() === nameText.toLowerCase());
                            if (!isDuplicate) {
                                products.push({ name: nameText, price });
                                console.log(`   ג… VALID additional product: "${nameText}" - ג‚×${price} (distance: ${distance})`);
                            }
                        }
                    }
                });
            });
            
            // Remove duplicates
            const uniqueProducts = [];
            const seenNames = new Set();
            products.forEach(p => {
                if (!seenNames.has(p.name.toLowerCase())) {
                    seenNames.add(p.name.toLowerCase());
                    uniqueProducts.push(p);
                }
            });
            
            console.log(`ג… Marketplace extractLiveProducts found ${uniqueProducts.length} REAL products:`, uniqueProducts);
            return uniqueProducts;
        }
        
        // Shared smart search function (Same as Stav bot) - ENHANCED WITH AUTO-RELOAD
        async function handleSharedSmartSearch(message, allPages) {
            const lowerMessage = message.toLowerCase();
            
            // Handle greetings - respond locally with friendly greeting
            if (lowerMessage.includes('׳©׳׳•׳') || lowerMessage.includes('׳”׳™׳™') || lowerMessage.includes('׳”׳™')) {
                const greetingResponses = [
                    '׳©׳׳•׳! ׳׳™׳ ׳׳₪׳©׳¨ ׳׳¢׳–׳•׳¨?',
                    '׳”׳™׳™! ׳‘׳׳” ׳׳•׳›׳ ׳׳¢׳–׳•׳¨ ׳׳?',
                    '׳©׳׳•׳! ׳׳—׳₪׳© ׳׳©׳”׳• ׳׳™׳•׳—׳“?'
                ];
                return greetingResponses[Math.floor(Math.random() * greetingResponses.length)];
            }
            
            // Handle personal questions - send to N8N for conversational response
            if (lowerMessage.includes('׳©׳׳™') || lowerMessage.includes('׳§׳•׳¨׳׳™׳ ׳׳™') || lowerMessage.includes('׳׳ ׳™') ||
                lowerMessage.includes('׳׳” ׳©׳׳•׳׳') || lowerMessage.includes('׳׳™׳ ׳׳×׳”') || lowerMessage.includes('׳׳™׳ ׳׳×')) {
                return null; // Send to N8N instead of fixed message
            }
            
            // Handle knowledge questions - send to N8N
            if (lowerMessage.includes('׳׳” ׳’׳•׳“׳') || lowerMessage.includes('׳׳” ׳–׳”') || lowerMessage.includes('׳׳™׳') || 
                lowerMessage.includes('׳׳×׳™') || lowerMessage.includes('׳׳™׳₪׳”') || lowerMessage.includes('׳׳׳”') ||
                lowerMessage.includes('׳›׳׳”') || lowerMessage.includes('׳׳™') || lowerMessage.includes('׳׳™׳–׳”')) {
                return null; // Send to N8N for general knowledge questions
            }
            
            // Only search for pages if user is specifically looking for something
            if (!lowerMessage.includes('׳׳×׳ ׳”') && !lowerMessage.includes('׳׳§') && !lowerMessage.includes('׳©׳¢׳•׳') && !lowerMessage.includes('׳¦׳¢׳¦׳•׳¢') && !lowerMessage.includes('׳§׳•׳¨׳¡') && !lowerMessage.includes('׳—׳ ׳•׳×') && !lowerMessage.includes('׳©׳™׳¨׳•׳×') && !lowerMessage.includes('׳׳™׳¨׳•׳¢') && !lowerMessage.includes('׳׳—׳™׳¨') && !lowerMessage.includes('׳›׳׳”') && !lowerMessage.includes('׳¢׳•׳׳”') && !lowerMessage.includes('ג‚×') && !lowerMessage.includes('׳©׳§׳') && !lowerMessage.includes('׳”׳›׳™ ׳–׳•׳') && !lowerMessage.includes('׳”׳›׳™ ׳™׳§׳¨') && !lowerMessage.includes('׳”׳©׳•׳•׳׳”') && !lowerMessage.includes('׳ ׳’׳™׳“') && !lowerMessage.includes('׳•׳׳§') && !lowerMessage.includes('׳•׳©׳¢׳•׳') && !lowerMessage.includes('׳•׳¦׳¢׳¦׳•׳¢') && !lowerMessage.includes('׳¦׳¢׳¦׳•׳¢׳™׳') && !lowerMessage.includes('׳©׳¢׳•׳ ׳™׳')) {
                // For other general questions, send to N8N
                return null;
            }
            
            // Search for pages with live content - ALWAYS get fresh data
            const liveResults = await searchLivePages(message);
            if (liveResults.length > 0) {
                let response = `׳׳¦׳׳×׳™ ${liveResults.length} ׳“׳₪׳™׳ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳:\n\n`;
                liveResults.forEach(page => {
                    response += `נ× **${page.title}**\n`;
                    if (page.description) {
                        response += `${page.description}\n`;
                    }
                    
                    // Show live product data if available
                    if (page.liveProducts && page.liveProducts.length > 0) {
                        response += `נ’° ׳׳•׳¦׳¨׳™׳ ׳—׳™׳™׳:\n`;
                        page.liveProducts.forEach(product => {
                            response += `ג€¢ ${product.name} - ג‚×${product.price}\n`;
                        });
                    }
                    
                    response += `נ”— [׳¦׳₪׳” ׳‘׳“׳£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                });
                return { message: response, action: { type: 'none' } };
            }
            
            return null;
        }
        
        // Replace the original sendAIMessage with enhanced version
        window.sendAIMessage = sendAIMessageEnhanced;
        
        // Allow Enter key in chat input
        document.getElementById('aiChatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendAIMessage();
            }
        });
        
        // Go to full app function
        function goToFullApp() {
            window.location.href = '/';
        }

        // === STAV CHAT FUNCTIONS ===
        function toggleStavChat() {
            const chatWindow = document.getElementById('stavChatWindow');
            if (chatWindow) {
            chatWindow.classList.toggle('active');
            if (chatWindow.classList.contains('active')) {
                    const input = document.getElementById('stavChatInput');
                    if (input) input.focus();
                }
            }
        }
        
        // Make sure toggleStavChat is available globally
        window.toggleStavChat = toggleStavChat;

        // Process Stav message with REAL data search
        async function processStavMessage(userMessage, allPages) {
            try {
                console.log('נ” Processing Stav message with REAL data:', userMessage);
                console.log('נ“ allPages available:', allPages ? allPages.length : 0);
                
                // נ¯ CRITICAL: Validate allPages
                if (!allPages || !Array.isArray(allPages) || allPages.length === 0) {
                    console.error('ג allPages is empty or invalid!');
                    return {
                        type: 'message',
                        message: '׳׳¦׳˜׳¢׳¨, ׳׳™׳ ׳“׳₪׳™׳ ׳–׳׳™׳ ׳™׳ ׳›׳¨׳’׳¢. ׳ ׳¡׳” ׳©׳•׳‘ ׳׳׳•׳—׳¨ ׳™׳•׳×׳¨.'
                    };
                }
                
                const lowerMessage = userMessage.toLowerCase().trim();
                
                // נ¯ CRITICAL: ׳‘׳“׳™׳§׳” ׳¨׳׳©׳•׳ ׳” - ׳©׳׳׳•׳× ׳׳™׳©׳™׳•׳×/׳›׳׳׳™׳•׳× -> NULL (׳™׳׳›׳• ׳-N8N)
                // ׳–׳” ׳׳•׳ ׳¢ ׳—׳™׳₪׳•׳© ׳¢׳ ׳׳™׳׳™׳ ׳›׳׳• "׳׳×", "׳׳×׳”", "׳©׳׳•׳׳" ׳•׳›׳•'
                const personalQuestions = /^(׳׳™\s+׳׳×|׳׳™\s+׳׳×׳”|׳׳”\s+׳׳×|׳׳”\s+׳׳×׳”|׳©׳׳•׳|׳”׳™׳™|׳”׳™|׳׳”\s+׳©׳׳•׳׳|׳׳”\s+׳§׳•׳¨׳”|׳׳”\s+׳ ׳©׳׳¢|׳׳™׳\s+׳׳×|׳׳™׳\s+׳׳×׳”|׳׳”\s+׳”׳׳¦׳‘|׳×׳•׳“׳”|׳×׳•׳“׳”\s+׳¨׳‘׳”|׳׳™\s+׳–׳”|׳׳™\s+׳–׳׳×)/i;
                if (personalQuestions.test(userMessage.trim())) {
                    console.log('נ’¬ Personal question detected - returning null to send to N8N');
                    return null; // ׳©׳׳— ׳-N8N ׳׳©׳™׳—׳”
                }
                
                // נ¯ FIX: Call handleSmartSearch FIRST for price queries and "׳”׳›׳™ ׳–׳•׳" queries
                // This ensures that price-related queries are handled correctly before other logic
                const isPriceQuery = /׳”׳›׳™ ׳–׳•׳|׳”׳›׳™ ׳™׳§׳¨|׳׳—׳™׳¨|׳׳—׳™׳¨׳™׳|׳›׳׳” ׳¢׳•׳׳”|׳”׳©׳•׳•׳׳”/.test(lowerMessage);
                if (isPriceQuery) {
                    console.log('נ’° Price query detected - calling handleSmartSearch');
                    const smartResult = await handleSmartSearch(userMessage, allPages);
                    if (smartResult && typeof smartResult === 'string') {
                        // handleSmartSearch returned a string response - use it
                        console.log('ג… handleSmartSearch returned response:', smartResult.substring(0, 100));
                        return {
                            type: 'message',
                            message: smartResult
                        };
                    } else if (smartResult && smartResult.type) {
                        // handleSmartSearch returned a result object - return it
                        return smartResult;
                    }
                    // If handleSmartSearch didn't return anything, continue with normal flow
                }
                
                // נ¯ Check if user is asking to see website/link/page
                // נ¯ FIX: Added more patterns for "׳×׳¦׳™׳’׳™ ׳׳× ׳”׳“׳£", "׳׳× ׳™׳›׳•׳׳” ׳׳”׳¨׳׳•׳× ׳׳™ ׳׳× ׳”׳׳×׳¨", "׳™׳›׳•׳׳” ׳׳”׳¦׳™׳’ ׳׳× ׳”׳׳×׳¨", "׳×׳₪׳×׳—׳™ ׳׳× ׳׳₪׳©׳¨׳•׳× ׳׳—׳×"
                const userWantsLink = /׳×׳¨׳׳”.*׳׳×׳¨|׳×׳¨׳׳”.*׳“׳£|׳×׳¨׳׳™.*׳׳×׳¨|׳×׳¨׳׳™.*׳“׳£|׳”׳¨׳׳”.*׳׳×׳¨|׳׳¨׳׳•׳×.*׳׳×׳¨|׳׳₪׳©׳¨.*׳׳×׳¨|׳§׳™׳©׳•׳¨|׳₪׳×׳—.*׳׳×׳¨|׳׳™׳ ׳§|link|׳׳×׳¨.*׳©׳|׳׳“׳£.*׳©׳|׳₪׳×׳™׳—׳×.*׳׳×׳¨|׳×׳¨׳׳•.*׳׳×׳¨|׳”׳¦׳’.*׳׳×׳¨|׳×׳¦׳™׳’׳™.*׳“׳£|׳×׳¦׳™׳’׳™.*׳׳×׳¨|׳”׳¨׳׳•׳×.*׳׳×׳¨|׳”׳¨׳׳•׳×.*׳“׳£|׳׳×.*׳™׳›׳•׳׳”.*׳׳”׳¨׳׳•׳×|׳׳×.*׳™׳›׳•׳׳”.*׳׳”׳¦׳™׳’|׳™׳›׳•׳׳”.*׳׳”׳¦׳™׳’|׳™׳›׳•׳׳”.*׳׳”׳¨׳׳•׳×|׳×׳¦׳™׳’|׳×׳¨׳׳™|׳×׳¨׳׳”|׳×׳₪׳×׳—׳™.*׳׳₪׳©׳¨׳•׳×|׳₪׳×׳—׳™.*׳׳₪׳©׳¨׳•׳×|׳₪׳×׳—.*׳׳₪׳©׳¨׳•׳×|׳×׳₪׳×׳—.*׳׳₪׳©׳¨׳•׳×/i.test(userMessage);
                
                // נ¯ NEW: Check if user is responding "yes" to previous "want to see website?" question
                // (e.g., "׳›׳", "׳×׳¨׳׳”", "׳‘׳˜׳—", "׳׳©׳׳—", "׳”׳¨׳׳”", "׳׳©׳׳— ׳׳₪׳¨׳˜׳™׳ ׳¢׳ X", "׳¨׳•׳¦׳” ׳׳₪׳×׳•׳—")
                // נ¯ FIX: Use context from LAST message only (window.lastUserMessage), not entire conversation
                let userSaysYes = /^(׳›׳|׳‘׳˜׳—|׳׳©׳׳—|yes|ok|׳׳•׳§׳™׳™)$/i.test(userMessage.trim()) || 
                                  /׳׳©׳׳— ׳׳₪׳¨׳˜׳™׳|׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳|׳×׳ ׳₪׳¨׳˜׳™׳|׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳|׳¨׳•׳¦׳” ׳׳₪׳×׳•׳—|׳׳ ׳™ ׳¨׳•׳¦׳” ׳׳₪׳×׳•׳—/i.test(userMessage);
                
                // נ¯ FIX: Use context from LAST message only (window.lastUserMessage + window.stavCurrentPages from last message)
                // Check if last message mentioned pages, and current message refers to them
                if (!userSaysYes && window.stavCurrentPages && window.stavCurrentPages.length > 0 && window.lastUserMessage) {
                    const pageNamesInContext = window.stavCurrentPages.map(p => p.title?.toLowerCase()).filter(Boolean);
                    const hasPageNameInMessage = pageNamesInContext.some(pageName => 
                        userMessage.toLowerCase().includes(pageName) && 
                        /׳₪׳¨׳˜׳™׳|׳׳™׳“׳¢|׳˜׳׳₪׳•׳|׳›׳×׳•׳‘׳×/i.test(userMessage)
                    );
                    // Also check if last message was about showing pages
                    const lastMessageWasAboutPages = /׳׳¦׳׳×׳™|׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳|׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳/i.test(window.lastUserMessage);
                    if (hasPageNameInMessage && lastMessageWasAboutPages) {
                        console.log('ג… User asking for details about page from LAST message - treating as YES');
                        userSaysYes = true;
                    }
                }
                
                // נ¯ FIX: Use context from LAST message only
                // נ¯ IMPROVED: Also check last BOT message (not just user message) to ensure we're responding to the right recommendation
                const lastBotMessage = window.lastBotMessage || '';
                const lastBotMessageWasRecommendation = /׳׳¦׳׳×׳™|׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳|׳׳™׳–׳” ׳“׳£ ׳׳₪׳×׳•׳—|׳¨׳•׳¦׳” ׳׳₪׳×׳•׳—|׳”׳ ׳” ׳”׳“׳£|׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳/.test(lastBotMessage);
                
                const userSaysYesToPreview = window.stavCurrentPages && window.stavCurrentPages.length > 0 && 
                    lastBotMessageWasRecommendation &&
                    /^(׳›׳|׳×׳¨׳׳”|׳×׳¨׳׳™|׳‘׳˜׳—|׳׳©׳׳—|׳”׳¨׳׳”|׳”׳¨׳׳™|׳‘׳•׳|׳₪׳×׳—|yes|ok|׳׳•׳§׳™׳™|׳₪׳×׳—׳™)$/i.test(userMessage.trim());
                
                console.log(`נ” [LINK CHECK] userMessage: "${userMessage}"`);
                console.log(`נ” [LINK CHECK] userSaysYes: ${userSaysYes}`);
                console.log(`נ” [LINK CHECK] userWantsLink: ${userWantsLink}`);
                console.log(`נ” [LINK CHECK] userSaysYesToPreview: ${userSaysYesToPreview}`);
                console.log(`נ” [LINK CHECK] lastBotMessage: "${lastBotMessage.substring(0, 50)}..."`);
                console.log(`נ” [LINK CHECK] lastBotMessageWasRecommendation: ${lastBotMessageWasRecommendation}`);
                console.log(`נ” [LINK CHECK] window.stavCurrentPages: ${window.stavCurrentPages?.length || 0} pages`);
                
                // נ¯ BUSINESS NAME MAPPING - Map known business names to their types/categories
                // This helps the bot understand what "׳™׳ ׳™׳‘ ׳—׳" is (׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨, ׳×׳¡׳¨׳•׳§׳•׳× ׳¢׳¨׳‘)
                const businessNameMap = {
                    '׳™׳ ׳™׳‘ ׳—׳': { type: 'serviceProvider', category: '׳׳¡׳₪׳¨׳”', keywords: ['׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳×׳¡׳¨׳•׳§׳•׳× ׳¢׳¨׳‘', '׳׳¡׳₪׳¨׳”'] },
                    '׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢': { type: 'store', category: '׳¦׳¢׳¦׳•׳¢', keywords: ['׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§׳™׳'] },
                    '׳™׳ ׳™׳‘ ׳˜׳›׳ ׳•׳׳•׳’׳™׳”': { type: 'store', category: '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', keywords: ['׳¨׳•׳‘׳•׳˜׳™׳', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”'] },
                    'red': { type: 'store', category: '׳¦׳¢׳¦׳•׳¢', keywords: ['׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§׳™׳'] },
                    '׳¨׳׳“': { type: 'store', category: '׳¦׳¢׳¦׳•׳¢', keywords: ['׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§׳™׳'] },
                    'nbk ׳§׳•׳¨׳¡׳™׳': { type: 'course', category: '׳§׳•׳¨׳¡', keywords: ['׳§׳•׳¨׳¡׳™׳', '׳׳™׳׳•׳“׳™׳'] },
                    'nbk': { type: 'course', category: '׳§׳•׳¨׳¡', keywords: ['׳§׳•׳¨׳¡׳™׳', '׳׳™׳׳•׳“׳™׳'] }
                };
                
                // נ¯ Check if user said a known business name (e.g., "׳׳›׳™׳¨׳” ׳׳× ׳™׳ ׳™׳‘ ׳—׳", "׳™׳•׳“׳¢׳× ׳׳× ׳™׳ ׳™׳‘ ׳—׳")
                const userMessageLower = userMessage.toLowerCase().trim();
                let knownBusiness = null;
                
                // נ¯ FIX: Extract business name from queries like "׳׳›׳™׳¨׳” ׳׳× ׳™׳ ׳™׳‘ ׳—׳", "׳™׳•׳“׳¢׳× ׳׳× ׳™׳ ׳™׳‘ ׳—׳"
                const businessNamePatterns = [
                    /(?:׳׳›׳™׳¨׳”|׳׳›׳™׳¨|׳™׳•׳“׳¢׳×|׳™׳•׳“׳¢|׳–׳”|׳–׳”׳•|׳–׳”׳•)\s+(?:׳׳×|׳”׳•׳|׳”׳™׳|׳–׳”|׳–׳”׳•)?\s*([׳-׳×a-zA-Z\s]{2,30})/i,
                    /([׳-׳×a-zA-Z\s]{2,30})\s*(?:׳–׳”|׳–׳”׳•|׳”׳•׳|׳”׳™׳)/i
                ];
                
                let extractedBusinessName = null;
                for (const pattern of businessNamePatterns) {
                    const match = userMessage.match(pattern);
                    if (match && match[1]) {
                        extractedBusinessName = match[1].trim();
                        console.log(`נ” Extracted business name from query: "${extractedBusinessName}"`);
                        break;
                    }
                }
                
                // Check if extracted name or full message matches known business
                const nameToCheck = extractedBusinessName || userMessage;
                const nameToCheckLower = nameToCheck.toLowerCase().trim();
                
                for (const [businessName, businessInfo] of Object.entries(businessNameMap)) {
                    if (nameToCheckLower.includes(businessName.toLowerCase()) || 
                        businessName.toLowerCase().includes(nameToCheckLower) ||
                        (extractedBusinessName && extractedBusinessName.toLowerCase().includes(businessName.toLowerCase()))) {
                        knownBusiness = { name: businessName, ...businessInfo };
                        console.log(`נ× Found known business: "${businessName}" - type: ${businessInfo.type}, category: ${businessInfo.category}`);
                        break;
                    }
                }
                
                // נ¯ NEW: Check if user said a store name directly (e.g., "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢") - search and open preview
                // This works even if there's no context (window.stavCurrentPages)
                // Check if message looks like a store name (2-4 words, Hebrew/English, not a question)
                // נ¯ FIX: Don't treat price queries as store name queries!
                const isPriceOrProductQuery = /׳׳—׳™׳¨|׳׳—׳™׳¨׳™׳|׳”׳›׳™ ׳–׳•׳|׳”׳›׳™ ׳™׳§׳¨|׳›׳׳” ׳¢׳•׳׳”|׳¨׳©׳™׳׳×|׳¨׳©׳™׳׳” ׳©׳|׳×׳¨׳׳™ ׳׳•׳¦׳¨׳™׳|׳×׳¨׳׳™ ׳׳—׳™׳¨׳™׳/.test(userMessage.toLowerCase());
                
                // נ¯ FIX: Don't treat category searches as store names!
                const knownCategories = ['׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳©׳¢׳•׳', '׳©׳¢׳•׳ ׳™׳', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', 
                                        '׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨',
                                        '׳ ׳’׳¨', '׳ ׳’׳¨׳•׳×', '׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨', '׳—׳©׳׳׳׳™', '׳§׳•׳¡׳׳˜׳™׳§׳׳™׳×',
                                        '׳—׳ ׳•׳×', '׳—׳ ׳•׳™׳•׳×', '׳©׳™׳¨׳•׳×', '׳©׳™׳¨׳•׳×׳™׳', '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳'];
                const isCategoryQuery = knownCategories.some(cat => userMessage.toLowerCase().trim().includes(cat));
                
                const isStoreNameQuery = !isPriceOrProductQuery && !isCategoryQuery &&
                    !/^(׳׳”|׳׳™׳₪׳”|׳”׳™׳›׳|׳׳™׳–׳”|׳›׳׳”|׳׳™|׳׳׳”|׳׳׳”|׳׳™׳|׳׳×׳™|׳׳™׳–׳”|׳׳™׳–׳”|׳×׳¨׳׳”|׳×׳¨׳׳™|׳”׳¨׳׳”|׳”׳¨׳׳™|׳₪׳×׳—|׳‘׳•׳|׳›׳|׳‘׳˜׳—|׳׳©׳׳—|yes|ok|׳׳•׳§׳™׳™|׳¨׳׳©׳•׳|׳©׳ ׳™|׳©׳׳™׳©׳™|׳¨׳‘׳™׳¢׳™|׳—׳׳™׳©׳™|׳©׳™׳©׳™|׳©׳‘׳™׳¢׳™|׳©׳׳™׳ ׳™|׳×׳©׳™׳¢׳™|׳¢׳©׳™׳¨׳™|׳׳—׳“|׳©׳×׳™׳™׳|׳©׳׳•׳©|׳׳¨׳‘׳¢|׳—׳׳©|׳©׳©|׳©׳‘׳¢|׳©׳׳•׳ ׳”|׳×׳©׳¢|׳¢׳©׳¨)$/i.test(userMessage.trim()) &&
                    /^[׳-׳×a-zA-Z\s]{2,50}$/.test(userMessage.trim()) &&
                    userMessage.trim().split(/\s+/).length <= 4;
                
                // נ¯ If we found a known business, use its category for better search
                if (knownBusiness) {
                    console.log(`נ” Searching for known business: "${knownBusiness.name}" with category: ${knownBusiness.category}`);
                    // Search using the business category/keywords for better results
                    const searchQuery = knownBusiness.keywords.join(' ') + ' ' + knownBusiness.name;
                    const storeResults = await searchLivePages(searchQuery);
                    
                    // Also try searching by business name directly
                    const directResults = await searchLivePages(knownBusiness.name);
                    const allResults = [...(storeResults || []), ...(directResults || [])];
                    
                    // Remove duplicates
                    const uniqueResults = allResults.filter((page, index, self) => 
                        index === self.findIndex(p => p.pageId === page.pageId)
                    );
                    
                    if (uniqueResults.length > 0) {
                        // Find exact match by business name
                        const exactMatch = uniqueResults.find(page => {
                            const pageTitleLower = (page.title || '').toLowerCase();
                            return pageTitleLower.includes(knownBusiness.name.toLowerCase()) || 
                                   knownBusiness.name.toLowerCase().includes(pageTitleLower);
                        });
                        
                        if (exactMatch) {
                            console.log(`ג… Found exact business match: "${exactMatch.title}" - showing text first (no auto-preview)`);
                            return {
                                type: 'pages',
                                pages: [exactMatch],
                                message: `׳׳¦׳׳×׳™ ׳׳× ${exactMatch.title}${knownBusiness.description ? ' - ' + knownBusiness.description : ''}. ׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?`,
                                includeLinks: false,
                                needsPreview: false
                            };
                        } else if (uniqueResults.length === 1) {
                            console.log(`ג… Found single business result: "${uniqueResults[0].title}" - showing text first (no auto-preview)`);
                            return {
                                type: 'pages',
                                pages: [uniqueResults[0]],
                                message: `׳׳¦׳׳×׳™ ׳׳× ${uniqueResults[0].title}${knownBusiness.description ? ' - ' + knownBusiness.description : ''}. ׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?`,
                                includeLinks: false,
                                needsPreview: false
                            };
                        } else if (uniqueResults.length >= 2) {
                            console.log(`ג… Found ${uniqueResults.length} business results - showing list first (no auto-preview)`);
                            return {
                                type: 'pages',
                                pages: uniqueResults,
                                message: `׳׳¦׳׳×׳™ ${uniqueResults.length} ׳׳₪׳©׳¨׳•׳™׳•׳×:`,
                                includeLinks: false,
                                needsPreview: false
                            };
                        }
                    }
                }
                
                // נ¯ NEW: Handle category searches (e.g., "׳¦׳¢׳¦׳•׳¢׳™׳", "׳׳¡׳₪׳¨׳”") - show ALL relevant pages!
                if (isCategoryQuery && !userSaysYes && !userWantsLink) {
                    console.log(`נ” Category query detected: "${userMessage}" - showing ALL relevant pages`);
                    const categoryResults = await searchLivePages(userMessage);
                    if (categoryResults && categoryResults.length > 0) {
                        console.log(`ג… Found ${categoryResults.length} pages for category "${userMessage}"`);
                        
                        // Show up to 5 results
                        const displayResults = categoryResults.slice(0, 5);
                        
                        // Store all results for "׳׳—׳¨׳™׳" option
                        if (categoryResults.length > 5) {
                            displayResults._allResults = categoryResults;
                            displayResults._currentOffset = 0;
                            displayResults._hasMore = true;
                        }
                        
                        return {
                            type: 'pages',
                            pages: displayResults,
                            message: displayResults.length === 1 
                                ? `׳׳¦׳׳×׳™ ׳׳× ${displayResults[0].title}.` 
                                : `׳׳¦׳׳×׳™ ${displayResults.length} ׳׳₪׳©׳¨׳•׳™׳•׳×.`,
                            includeLinks: false,
                            needsPreview: false
                        };
                    } else {
                        console.log(`ג ן¸ No results found for category "${userMessage}"`);
                        // Suggest similar categories instead of sending to N8N
                        const categoryMap = {
                            '׳¦׳¢׳¦׳•׳¢': ['׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§׳™׳', '׳׳™׳׳“׳™׳'],
                            '׳¦׳¢׳¦׳•׳¢׳™׳': ['׳¦׳¢׳¦׳•׳¢', '׳׳©׳—׳§׳™׳', '׳׳™׳׳“׳™׳'],
                            '׳׳¡׳₪׳¨׳”': ['׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¡׳₪׳¨'],
                            '׳¡׳₪׳¨': ['׳׳¡׳₪׳¨׳”', '׳×׳¡׳₪׳•׳¨׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨'],
                            '׳׳§': ['׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳'],
                            '׳©׳¢׳•׳': ['׳©׳¢׳•׳ ׳™׳', '׳×׳›׳©׳™׳˜׳™׳'],
                            '׳©׳¢׳•׳ ׳™׳': ['׳©׳¢׳•׳', '׳×׳›׳©׳™׳˜׳™׳']
                        };
                        
                        const category = userMessage.toLowerCase().trim();
                        const similarCategories = categoryMap[category];
                        
                        if (similarCategories) {
                            return {
                                type: 'message',
                                message: `׳׳ ׳׳¦׳׳×׳™ ${category}. ׳׳•׳׳™ ׳×׳—׳₪׳© ${similarCategories.join(' ׳׳• ')}?`
                            };
                        } else {
                            return {
                                type: 'message',
                                message: `׳׳ ׳׳¦׳׳×׳™ ${category} ׳‘׳׳¢׳¨׳›׳× ׳›׳¨׳’׳¢.`
                            };
                        }
                    }
                }
                
                if (isStoreNameQuery) {
                    console.log(`נ” Checking if "${userMessage}" is a store name...`);
                    // Search for pages matching the store name
                    const storeResults = await searchLivePages(userMessage);
                    if (storeResults && storeResults.length > 0) {
                        // Find exact match (title contains user message or vice versa)
                        const exactMatch = storeResults.find(page => {
                            const pageTitleLower = (page.title || '').toLowerCase();
                            return pageTitleLower.includes(userMessageLower) || 
                                   userMessageLower.includes(pageTitleLower) ||
                                   pageTitleLower.split(/\s+/).some(word => word.length >= 3 && userMessageLower.includes(word));
                        });
                        
                        // נ¯ FIX: Always show up to 5 results, not just one
                        // Limit to 5 results for display
                        const displayResults = storeResults.slice(0, 5);
                        
                        if (displayResults.length === 1) {
                            console.log(`ג… Found single store result: "${displayResults[0].title}" - showing text first (no auto-preview)`);
                            return {
                                type: 'pages',
                                pages: displayResults,
                                message: `׳׳¦׳׳×׳™ ׳׳× ${displayResults[0].title}. ׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?`,
                                includeLinks: false,
                                needsPreview: false // Don't auto-show preview - let user choose
                            };
                        } else if (displayResults.length >= 2) {
                            // Multiple results - show all (up to 5)
                            console.log(`ג… Found ${displayResults.length} store results - showing all (up to 5)`);
                            
                            // Store all results for "׳׳—׳¨׳™׳" option
                            if (storeResults.length > 5) {
                                displayResults._allResults = storeResults;
                                displayResults._currentOffset = 0;
                                displayResults._hasMore = true;
                            }
                            
                            return {
                                type: 'pages',
                                pages: displayResults,
                                message: `׳׳¦׳׳×׳™ ${displayResults.length} ׳׳₪׳©׳¨׳•׳™׳•׳×. ׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?`,
                                includeLinks: false,
                                needsPreview: false // Don't auto-show preview - let user choose
                            };
                        }
                    }
                }
                
                // נ¯ NEW: Check if user wants "׳׳—׳¨׳™׳" (more results) - bring next 5 results
                // נ¯ FIX: Also detect "׳™׳© ׳׳•׳₪׳¦׳™׳” ׳׳—׳¨׳×", "׳™׳© ׳¢׳•׳“ ׳׳•׳₪׳¦׳™׳”", "׳™׳© ׳¢׳•׳“ ׳׳₪׳©׳¨׳•׳×", "׳—׳ ׳•׳× ׳׳—׳¨׳×"
                const userWantsMore = /^(׳׳—׳¨׳™׳|׳¢׳•׳“|more|others|׳¢׳•׳“ ׳×׳•׳¦׳׳•׳×|׳×׳•׳¦׳׳•׳× ׳ ׳•׳¡׳₪׳•׳×|׳™׳© ׳׳•׳₪׳¦׳™׳” ׳׳—׳¨׳×|׳™׳© ׳¢׳•׳“ ׳׳•׳₪׳¦׳™׳”|׳™׳© ׳¢׳•׳“ ׳׳₪׳©׳¨׳•׳×|׳׳•׳₪׳¦׳™׳” ׳׳—׳¨׳×|׳¢׳•׳“ ׳׳•׳₪׳¦׳™׳”|׳¢׳•׳“ ׳׳₪׳©׳¨׳•׳×|׳—׳ ׳•׳× ׳׳—׳¨׳×|׳¢׳¡׳§ ׳׳—׳¨|׳“׳£ ׳׳—׳¨)$/i.test(userMessage.trim());
                
                // נ¯ FIX: If user wants "׳—׳ ׳•׳× ׳׳—׳¨׳×" / "׳׳—׳¨׳×", search again with same category/city from last search
                if (userWantsMore && (window.lastSearchCategory || window.lastSearchCity)) {
                    console.log('ג… User wants more/other - searching with context from last search');
                    const searchQuery = window.lastSearchCategory || window.lastSearchCity || userMessage;
                    const cityQuery = window.lastSearchCity ? ` ${window.lastSearchCity}` : '';
                    const fullQuery = window.lastSearchCategory ? `${window.lastSearchCategory}${cityQuery}` : cityQuery;
                    
                    console.log('נ” Searching with context - category:', window.lastSearchCategory, 'city:', window.lastSearchCity, 'query:', fullQuery);
                    const searchResults = await searchLivePages(fullQuery);
                    
                    if (searchResults && searchResults.length > 0) {
                        // Filter out pages already shown
                        const alreadyShownTitles = (window.stavCurrentPages || []).map(p => p.title?.toLowerCase()).filter(Boolean);
                        const newResults = searchResults.filter(page => !alreadyShownTitles.includes(page.title?.toLowerCase()));
                        
                        if (newResults.length > 0) {
                            const nextResults = newResults.slice(0, 5);
                            window.stavCurrentPages = nextResults;
                            window.stavCurrentPages._allResults = searchResults;
                            window.stavCurrentPages._currentOffset = 0;
                            
                            const messageToPass = `׳׳¦׳׳×׳™ ${nextResults.length} ׳׳₪׳©׳¨׳•׳™׳•׳× ׳ ׳•׳¡׳₪׳•׳×:`;
                            const textResponse = await generateTextResponseWithRealData(nextResults, messageToPass, false);
                            if (textResponse && textResponse.trim().length > 0) {
                                return {
                                    type: 'message',
                                    message: textResponse
                                };
                            }
                        } else {
                            return {
                                type: 'message',
                                message: '׳׳™׳ ׳¢׳•׳“ ׳×׳•׳¦׳׳•׳×. ׳׳¦׳׳×׳™ ׳׳× ׳›׳ ׳”׳“׳₪׳™׳ ׳”׳¨׳׳•׳•׳ ׳˜׳™׳™׳.'
                            };
                        }
                    }
                }
                
                if (userWantsMore && window.stavCurrentPages && window.stavCurrentPages.length > 0 && window.stavCurrentPages._allResults) {
                    const allResults = window.stavCurrentPages._allResults;
                    const currentOffset = window.stavCurrentPages._currentOffset || 0;
                    const nextOffset = currentOffset + 5;
                    const nextResults = allResults.slice(nextOffset, nextOffset + 5);
                    
                    if (nextResults.length > 0) {
                        console.log(`ג… User wants more results - showing next 5 (offset: ${nextOffset})`);
                        window.stavCurrentPages._currentOffset = nextOffset;
                        
                        // Update current pages to include new results
                        const updatedPages = [...window.stavCurrentPages.slice(0, 5), ...nextResults].slice(0, 5);
                        window.stavCurrentPages = updatedPages;
                        window.stavCurrentPages._allResults = allResults;
                        window.stavCurrentPages._currentOffset = nextOffset;
                        
                        const messageToPass = `׳׳¦׳׳×׳™ ${nextResults.length} ׳׳₪׳©׳¨׳•׳™׳•׳× ׳ ׳•׳¡׳₪׳•׳×:`;
                        const textResponse = await generateTextResponseWithRealData(nextResults, messageToPass, false);
                        if (textResponse && textResponse.trim().length > 0) {
                            return {
                                type: 'message',
                                message: textResponse
                            };
                        }
                    } else {
                        return {
                            type: 'message',
                            message: '׳׳™׳ ׳¢׳•׳“ ׳×׳•׳¦׳׳•׳×. ׳׳¦׳׳×׳™ ׳׳× ׳›׳ ׳”׳“׳₪׳™׳ ׳”׳¨׳׳•׳•׳ ׳˜׳™׳™׳.'
                        };
                    }
                }
                
                // נ¯ NEW: If user chose a specific option by name or word (e.g., "׳¨׳׳©׳•׳", "׳©׳ ׳™")
                // נ¯ NEW: Also check if user said a store name (e.g., "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢")
                if (window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    let selectedIndex = -1;
                    let selectedPage = null;
                    
                    // נ¯ NEW: Check if user said a store/page name
                    // נ¯ FIX: Improve matching to catch cases like "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢" when it's in the list
                    const userMessageLower = userMessage.toLowerCase().trim();
                    for (let i = 0; i < window.stavCurrentPages.length; i++) {
                        const page = window.stavCurrentPages[i];
                        const pageTitleLower = (page.title || '').toLowerCase().trim();
                        const pageTitleWords = pageTitleLower.split(/\s+/).filter(w => w.length >= 2);
                        
                        // Check if user message contains the full page title or significant words from it
                        // נ¯ FIX: More flexible matching - check if all significant words from page title are in user message
                        const allWordsMatch = pageTitleWords.length > 0 && pageTitleWords.every(word => 
                            userMessageLower.includes(word) || word.includes(userMessageLower)
                        );
                        
                        if (pageTitleLower.includes(userMessageLower) || 
                            userMessageLower.includes(pageTitleLower) ||
                            allWordsMatch ||
                            pageTitleWords.some(word => word.length >= 3 && userMessageLower.includes(word))) {
                            selectedPage = page;
                            selectedIndex = i;
                            console.log(`ג… User said store name "${page.title}" (matched "${userMessageLower}") - opening preview`);
                            break;
                        }
                    }
                    
                    // נ¯ FIX: Check for phrases like "׳”׳“׳£ ׳”׳©׳ ׳™", "׳”׳׳₪׳©׳¨׳•׳× ׳”׳©׳ ׳™׳™׳”", "׳¨׳¦׳™׳×׳™ ׳׳× ׳”׳“׳£ ׳”׳©׳ ׳™"
                    if (selectedIndex < 0) {
                        const pagePattern = /(?:׳”׳“׳£|׳”׳׳₪׳©׳¨׳•׳×|׳”׳“׳£\s+׳”|׳”׳׳₪׳©׳¨׳•׳×\s+׳”)\s*(?:׳”)?(׳¨׳׳©׳•׳|׳¨׳׳©׳•׳ ׳”|׳©׳ ׳™|׳©׳ ׳™׳”|׳©׳׳™׳©׳™|׳©׳׳™׳©׳™׳×|׳¨׳‘׳™׳¢׳™|׳¨׳‘׳™׳¢׳™׳×|׳—׳׳™׳©׳™|׳—׳׳™׳©׳™׳×|׳©׳™׳©׳™|׳©׳™׳©׳™׳×|׳©׳‘׳™׳¢׳™|׳©׳‘׳™׳¢׳™׳×|׳©׳׳™׳ ׳™|׳©׳׳™׳ ׳™׳×|׳×׳©׳™׳¢׳™|׳×׳©׳™׳¢׳™׳×|׳¢׳©׳™׳¨׳™|׳¢׳©׳™׳¨׳™׳×|׳׳—׳“|׳©׳×׳™׳™׳|׳©׳׳•׳©|׳׳¨׳‘׳¢|׳—׳׳©|׳©׳©|׳©׳‘׳¢|׳©׳׳•׳ ׳”|׳×׳©׳¢|׳¢׳©׳¨)/i;
                        const pageMatch = userMessage.match(pagePattern);
                        if (pageMatch) {
                            const hebrewOrdinals = {
                                '׳¨׳׳©׳•׳': 0, '׳¨׳׳©׳•׳ ׳”': 0, '׳׳—׳“': 0,
                                '׳©׳ ׳™': 1, '׳©׳ ׳™׳”': 1, '׳©׳×׳™׳™׳': 1,
                                '׳©׳׳™׳©׳™': 2, '׳©׳׳™׳©׳™׳×': 2, '׳©׳׳•׳©': 2,
                                '׳¨׳‘׳™׳¢׳™': 3, '׳¨׳‘׳™׳¢׳™׳×': 3, '׳׳¨׳‘׳¢': 3,
                                '׳—׳׳™׳©׳™': 4, '׳—׳׳™׳©׳™׳×': 4, '׳—׳׳©': 4,
                                '׳©׳™׳©׳™': 5, '׳©׳™׳©׳™׳×': 5, '׳©׳©': 5,
                                '׳©׳‘׳™׳¢׳™': 6, '׳©׳‘׳™׳¢׳™׳×': 6, '׳©׳‘׳¢': 6,
                                '׳©׳׳™׳ ׳™': 7, '׳©׳׳™׳ ׳™׳×': 7, '׳©׳׳•׳ ׳”': 7,
                                '׳×׳©׳™׳¢׳™': 8, '׳×׳©׳™׳¢׳™׳×': 8, '׳×׳©׳¢': 8,
                                '׳¢׳©׳™׳¨׳™': 9, '׳¢׳©׳™׳¨׳™׳×': 9, '׳¢׳©׳¨': 9
                            };
                            const ordinalWord = pageMatch[1];
                            if (hebrewOrdinals[ordinalWord] !== undefined) {
                                selectedIndex = hebrewOrdinals[ordinalWord];
                                console.log(`ג… User said "׳”׳“׳£ ${ordinalWord}" - opening preview`);
                            }
                        }
                    }
                    
                    // נ¯ NEW: Check for direct numbers (1, 2, 3, 4...) or "׳׳¡׳₪׳¨ 4"
                    if (selectedIndex < 0) {
                        const directNumberMatch = userMessage.match(/^(\d+)$/) || userMessage.match(/׳׳¡׳₪׳¨\s+(\d+)/i);
                        if (directNumberMatch && directNumberMatch[1]) {
                            const number = parseInt(directNumberMatch[1]);
                            if (number >= 1 && number <= window.stavCurrentPages.length) {
                                selectedIndex = number - 1; // Convert to 0-based index
                                console.log(`ג… User said number "${number}" - opening preview`);
                            }
                        }
                    }
                    
                    // נ¯ FIX: Check for "׳¨׳¦׳™׳×׳™ ׳׳× ׳”׳“׳£ ׳”׳©׳ ׳™" or similar phrases
                    if (selectedIndex < 0) {
                        const wantedPattern = /(?:׳¨׳¦׳™׳×׳™|׳¨׳•׳¦׳”|׳¨׳•׳¦׳”\s+׳׳×|׳¨׳¦׳™׳×׳™\s+׳׳×)\s*(?:׳”)?(?:׳“׳£|׳׳₪׳©׳¨׳•׳×)\s*(?:׳”)?(?:׳”)?(׳¨׳׳©׳•׳|׳¨׳׳©׳•׳ ׳”|׳©׳ ׳™|׳©׳ ׳™׳”|׳©׳׳™׳©׳™|׳©׳׳™׳©׳™׳×|׳¨׳‘׳™׳¢׳™|׳¨׳‘׳™׳¢׳™׳×|׳—׳׳™׳©׳™|׳—׳׳™׳©׳™׳×|׳©׳™׳©׳™|׳©׳™׳©׳™׳×|׳©׳‘׳™׳¢׳™|׳©׳‘׳™׳¢׳™׳×|׳©׳׳™׳ ׳™|׳©׳׳™׳ ׳™׳×|׳×׳©׳™׳¢׳™|׳×׳©׳™׳¢׳™׳×|׳¢׳©׳™׳¨׳™|׳¢׳©׳™׳¨׳™׳×|׳׳—׳“|׳©׳×׳™׳™׳|׳©׳׳•׳©|׳׳¨׳‘׳¢|׳—׳׳©|׳©׳©|׳©׳‘׳¢|׳©׳׳•׳ ׳”|׳×׳©׳¢|׳¢׳©׳¨)/i;
                        const wantedMatch = userMessage.match(wantedPattern);
                        if (wantedMatch) {
                            const hebrewOrdinals = {
                                '׳¨׳׳©׳•׳': 0, '׳¨׳׳©׳•׳ ׳”': 0, '׳׳—׳“': 0,
                                '׳©׳ ׳™': 1, '׳©׳ ׳™׳”': 1, '׳©׳×׳™׳™׳': 1,
                                '׳©׳׳™׳©׳™': 2, '׳©׳׳™׳©׳™׳×': 2, '׳©׳׳•׳©': 2,
                                '׳¨׳‘׳™׳¢׳™': 3, '׳¨׳‘׳™׳¢׳™׳×': 3, '׳׳¨׳‘׳¢': 3,
                                '׳—׳׳™׳©׳™': 4, '׳—׳׳™׳©׳™׳×': 4, '׳—׳׳©': 4,
                                '׳©׳™׳©׳™': 5, '׳©׳™׳©׳™׳×': 5, '׳©׳©': 5,
                                '׳©׳‘׳™׳¢׳™': 6, '׳©׳‘׳™׳¢׳™׳×': 6, '׳©׳‘׳¢': 6,
                                '׳©׳׳™׳ ׳™': 7, '׳©׳׳™׳ ׳™׳×': 7, '׳©׳׳•׳ ׳”': 7,
                                '׳×׳©׳™׳¢׳™': 8, '׳×׳©׳™׳¢׳™׳×': 8, '׳×׳©׳¢': 8,
                                '׳¢׳©׳™׳¨׳™': 9, '׳¢׳©׳™׳¨׳™׳×': 9, '׳¢׳©׳¨': 9
                            };
                            const ordinalWord = wantedMatch[1];
                            if (hebrewOrdinals[ordinalWord] !== undefined) {
                                selectedIndex = hebrewOrdinals[ordinalWord];
                                console.log(`ג… User said "׳¨׳¦׳™׳×׳™ ׳׳× ׳”׳“׳£ ${ordinalWord}" - opening preview`);
                            }
                        }
                    }
                    
                    // Check for number (1, 2, 3...) - RE-ENABLED
                    if (selectedIndex < 0) {
                    const numberMatch = userMessage.trim().match(/^(\d+)$/);
                    if (numberMatch) {
                        selectedIndex = parseInt(numberMatch[1], 10) - 1; // Convert to 0-based index
                            console.log(`ג… User said number ${numberMatch[1]} - opening preview`);
                        }
                    }
                    
                    // Check for Hebrew ordinal words (standalone)
                    if (selectedIndex < 0) {
                    const hebrewOrdinals = {
                        '׳¨׳׳©׳•׳': 0, '׳¨׳׳©׳•׳ ׳”': 0, '׳׳—׳“': 0,
                        '׳©׳ ׳™': 1, '׳©׳ ׳™׳”': 1, '׳©׳×׳™׳™׳': 1,
                        '׳©׳׳™׳©׳™': 2, '׳©׳׳™׳©׳™׳×': 2, '׳©׳׳•׳©': 2,
                        '׳¨׳‘׳™׳¢׳™': 3, '׳¨׳‘׳™׳¢׳™׳×': 3, '׳׳¨׳‘׳¢': 3,
                        '׳—׳׳™׳©׳™': 4, '׳—׳׳™׳©׳™׳×': 4, '׳—׳׳©': 4,
                        '׳©׳™׳©׳™': 5, '׳©׳™׳©׳™׳×': 5, '׳©׳©': 5,
                        '׳©׳‘׳™׳¢׳™': 6, '׳©׳‘׳™׳¢׳™׳×': 6, '׳©׳‘׳¢': 6,
                        '׳©׳׳™׳ ׳™': 7, '׳©׳׳™׳ ׳™׳×': 7, '׳©׳׳•׳ ׳”': 7,
                        '׳×׳©׳™׳¢׳™': 8, '׳×׳©׳™׳¢׳™׳×': 8, '׳×׳©׳¢': 8,
                        '׳¢׳©׳™׳¨׳™': 9, '׳¢׳©׳™׳¨׳™׳×': 9, '׳¢׳©׳¨': 9
                    };
                    
                    const userMessageTrimmed = userMessage.trim();
                    for (const [word, index] of Object.entries(hebrewOrdinals)) {
                        // נ¯ FIX: Check for exact match or word boundary match (not just includes)
                        // This prevents matching "׳©׳׳•׳©" in "׳©׳׳•׳© ׳“׳₪׳™׳" when user just says "׳©׳׳•׳©"
                        if (userMessageTrimmed === word || 
                            new RegExp(`\\b${word}\\b`).test(userMessageTrimmed)) {
                            selectedIndex = index;
                            console.log(`ג… User said "${word}" (index ${index}) - opening preview`);
                            break;
                            }
                        }
                    }
                    
                    // If valid selection, show that specific page
                    if (selectedIndex >= 0 && selectedIndex < window.stavCurrentPages.length) {
                        const pageToShow = selectedPage || window.stavCurrentPages[selectedIndex];
                        console.log(`ג… User selected option ${selectedIndex + 1} (index ${selectedIndex}) - showing page: ${pageToShow.title}`);
                        
                        // Build message with LIVE description - will be fetched when displaying
                        // For now, just pass the page and let the display function fetch the description
                        return {
                            type: 'pages',
                            pages: [pageToShow], // Only the selected page
                            message: `׳‘׳‘׳§׳©׳”, ׳”׳ ׳” ׳”׳“׳£ ׳©׳ ${pageToShow.title}`, // Description will be added during display
                            includeLinks: true,
                            needsPreview: true // Show iframe preview
                        };
                    } else if (selectedIndex >= 0) {
                        // נ¯ FIX: User selected a number that doesn't exist - show error message
                        console.log(`ג User selected option ${selectedIndex + 1} but only ${window.stavCurrentPages.length} pages available`);
                        const pagesList = window.stavCurrentPages.map((p, idx) => `${idx + 1}. ${p.title}`).join('\n');
                        return {
                            type: 'message',
                            message: `׳׳¦׳˜׳¢׳¨׳×, ׳™׳© ׳¨׳§ ${window.stavCurrentPages.length} ׳׳₪׳©׳¨׳•׳™׳•׳×:\n${pagesList}\n\n׳׳™׳–׳” ׳×׳¨׳¦׳”?`
                        };
                    }
                }
                
                // נ¯ NEW: Check if user wants to see a specific page (e.g., "׳×׳¦׳™׳’׳™ ׳׳× ׳”׳“׳£ ׳©׳׳•", "׳׳× ׳™׳›׳•׳׳” ׳׳”׳¨׳׳•׳× ׳׳™ ׳׳× ׳”׳׳×׳¨", "׳™׳›׳•׳׳” ׳׳”׳¦׳™׳’ ׳׳× ׳”׳׳×׳¨")
                if (userWantsLink) {
                    // First check if we have pages in context
                    if (window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                        console.log('ג… User wants to see page - showing PAGE for pages in context');
                    
                    // Show the page with iframe + link
                        const pageToShow = window.stavCurrentPages.length === 1 ? window.stavCurrentPages[0] : window.stavCurrentPages[0];
                    return { 
                        type: 'pages', 
                            pages: [pageToShow],
                            message: `׳‘׳‘׳§׳©׳”, ׳”׳ ׳” ׳”׳“׳£ ׳©׳ ${pageToShow.title}`,
                            includeLinks: true, // Show links
                            needsPreview: true // Show iframe preview in chat
                        };
                    } else {
                        // No pages in context - try to search for pages based on the message
                        console.log('ג… User wants to see page but no context - searching for pages');
                        const searchResults = await searchLivePages(userMessage);
                        if (searchResults && searchResults.length > 0) {
                            const pageToShow = searchResults[0];
                            return { 
                                type: 'pages', 
                                pages: [pageToShow],
                                message: `׳‘׳‘׳§׳©׳”, ׳”׳ ׳” ׳”׳“׳£ ׳©׳ ${pageToShow.title}`,
                        includeLinks: true, // Show links
                        needsPreview: true // Show iframe preview in chat
                            };
                        }
                    }
                }
                
                // נ¯ NEW: If user says "׳›׳" (yes) and we have pages in context, show PAGE (not just contact info)
                // נ¯ FIX: If multiple pages, ask which one they want instead of showing the first one automatically
                if (userSaysYes && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    console.log('ג…ג…ג… User said YES - checking pages in context');
                    console.log('נ“נ“נ“ Pages in context:', window.stavCurrentPages.map(p => p.title).join(', '));
                    console.log('נ“ Number of pages:', window.stavCurrentPages.length);
                    
                    // נ¯ FIX: If multiple pages, ask which one they want
                    if (window.stavCurrentPages.length > 1) {
                        const pagesList = window.stavCurrentPages.map((p, idx) => `${idx + 1}. ${p.title}`).join('\n');
                        return {
                            type: 'message',
                            message: `׳™׳© ${window.stavCurrentPages.length} ׳׳₪׳©׳¨׳•׳™׳•׳×:\n${pagesList}\n\n׳׳™׳–׳” ׳×׳¨׳¦׳”? (׳×׳•׳›׳/׳™ ׳׳•׳׳¨ ׳׳× ׳”׳׳¡׳₪׳¨, "׳”׳“׳£ ׳”׳©׳ ׳™", ׳׳• ׳׳× ׳©׳ ׳”׳“׳£)`
                        };
                    }
                    
                    // Single page - show it directly
                    const pageToShow = window.stavCurrentPages[0];
                    return { 
                        type: 'pages', 
                        pages: [pageToShow],
                        message: `׳‘׳‘׳§׳©׳”, ׳”׳ ׳” ׳”׳“׳£ ׳©׳ ${pageToShow.title}`,
                        includeLinks: true,
                        needsPreview: true
                    };
                }
                
                // נ¯ NEW: Check if user is asking "׳׳™׳₪׳”" about a page in context
                const isWhereQuestion = /^׳׳™׳₪׳”|׳׳™׳₪׳” ׳”|׳׳™׳₪׳” ׳”|׳”׳™׳›׳|׳׳™׳₪׳” ׳”/.test(lowerMessage.trim());
                if (isWhereQuestion && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    console.log('נ“ User asking "׳׳™׳₪׳”" about page in context');
                    const page = window.stavCurrentPages[0]; // Use first page
                    let locationInfo = '';
                    
                    // Try to get location from page metadata
                    if (page.city) {
                        locationInfo += `נ“ ${page.city}`;
                    }
                    if (page.address) {
                        locationInfo += locationInfo ? `, ${page.address}` : `נ“ ${page.address}`;
                    }
                    if (page.liveContactInfo && page.liveContactInfo.address) {
                        locationInfo += locationInfo ? `, ${page.liveContactInfo.address}` : `נ“ ${page.liveContactInfo.address}`;
                    }
                    
                    if (locationInfo) {
                        return {
                            type: 'message',
                            message: `${page.title} ׳ ׳׳¦׳/׳× ׳‘-${locationInfo}`
                        };
                    } else {
                        // Try to fetch from live page
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const pageResponse = await fetch(pageUrl);
                            if (pageResponse.ok) {
                                const html = await pageResponse.text();
                                // Extract address from HTML
                                const addressMatch = html.match(/׳›׳×׳•׳‘׳×[:\s]*([^<\n]+)/i) || html.match(/׳׳™׳§׳•׳[:\s]*([^<\n]+)/i);
                                if (addressMatch && addressMatch[1]) {
                                    const address = addressMatch[1].trim();
                                    return {
                                        type: 'message',
                                        message: `${page.title} ׳ ׳׳¦׳/׳× ׳‘-נ“ ${address}`
                                    };
                                }
                            }
                        } catch (error) {
                            console.error('Error fetching page for location:', error);
                        }
                        
                        return {
                            type: 'message',
                            message: `׳׳¦׳˜׳¢׳¨, ׳׳ ׳׳¦׳׳×׳™ ׳׳™׳§׳•׳ ׳׳“׳•׳™׳§ ׳-${page.title}. ׳׳×׳” ׳™׳›׳•׳ ׳׳‘׳“׳•׳§ ׳׳× ׳₪׳¨׳˜׳™ ׳”׳§׳©׳¨ ׳‘׳“׳£.`
                        };
                    }
                }
                
                // If user wants link OR says yes to preview, check if we have pages in context
                if ((userWantsLink || userSaysYesToPreview) && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    console.log('נ”— ג… User EXPLICITLY wants link/preview - showing pages with PREVIEW + LINKS');
                    
                    // נ¯ IMPROVED: Show both preview AND links when user explicitly asks
                    return { 
                        type: 'pages', 
                        pages: window.stavCurrentPages,
                        message: window.stavCurrentPages.length === 1 
                            ? `׳”׳ ׳” ׳“׳£ ${window.stavCurrentPages[0].title}:` 
                            : `׳”׳ ׳” ${window.stavCurrentPages.length} ׳”׳“׳₪׳™׳:`,
                        includeLinks: true, // Show links
                        needsPreview: true // Show iframe preview in chat
                    };
                } else {
                    console.log('ג„¹ן¸ User did NOT request to see page - NO preview will be shown');
                }
                
                // נ¯ IMPROVED: Detect common product categories even in questions like "׳©׳¢׳•׳ ׳™׳ ׳™׳©?" or "׳•׳©׳¢׳•׳?"
                const productCategories = [
                    // Coaching & Fitness
                    '׳׳׳׳', '׳׳׳׳ ׳×', '׳׳™׳׳•׳', '׳§׳•׳׳¦\'׳™׳ ׳’', 'coaching', '׳›׳•׳©׳¨', '׳—׳“׳¨ ׳›׳•׳©׳¨', '׳¡׳₪׳•׳¨׳˜',
                    // Carpentry & Woodwork
                    '׳ ׳’׳¨', '׳ ׳’׳¨׳•׳×', '׳ ׳’׳¨׳™׳”', '׳¢׳‘׳•׳“׳•׳× ׳¢׳¥', '׳׳¨׳•׳ ׳•׳×', '׳׳˜׳‘׳—׳™׳',
                    // Watches & Jewelry
                    '׳©׳¢׳•׳', '׳©׳¢׳•׳ ׳™׳', '׳×׳›׳©׳™׳˜', '׳×׳›׳©׳™׳˜׳™׳', '׳–׳”׳‘', '׳›׳¡׳£',
                    // Toys & Games
                    '׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳׳©׳—׳§', '׳׳©׳—׳§׳™׳',
                    // Hairdressing & Beauty
                    '׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳™׳•׳₪׳™', '׳׳¢׳¦׳‘', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨', '׳׳™׳₪׳•׳¨',
                    // Restaurants & Food
                    '׳׳¡׳¢׳“׳”', '׳׳¡׳¢׳“׳•׳×', '׳׳•׳›׳', '׳§׳₪׳”', '׳‘׳™׳× ׳§׳₪׳”', '׳₪׳™׳¦׳”', '׳”׳׳‘׳•׳¨׳’׳¨', '׳¡׳•׳©׳™', '׳׳–׳•׳',
                    // Plumbing & Electrician
                    '׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨', '׳©׳¨׳‘׳¨׳‘', '׳—׳©׳׳׳׳™', '׳—׳©׳׳',
                    // Car & Auto
                    '׳¨׳›׳‘', '׳—׳׳₪׳™׳', '׳׳•׳¡׳', '׳׳›׳•׳ ׳׳™', '׳׳›׳•׳ ׳™׳×',
                    // Technology & Robotics
                    '׳¨׳•׳‘׳•׳˜', '׳¨׳•׳‘׳•׳˜׳™׳§׳”', '׳˜׳›׳ ׳•׳׳•׳’׳™׳”', '׳׳—׳©׳‘', '׳׳—׳©׳‘׳™׳',
                    // Courses & Education
                    '׳§׳•׳¨׳¡', '׳§׳•׳¨׳¡׳™׳', '׳׳™׳׳•׳“׳™׳', '׳”׳©׳×׳׳׳•׳×', '׳”׳›׳©׳¨׳”',
                    // Events & Entertainment
                    '׳׳™׳¨׳•׳¢', '׳׳™׳¨׳•׳¢׳™׳', '׳¦׳׳', '׳¦׳™׳׳•׳', '׳“׳™ ׳’\'׳™׳™', 'dj', '׳—׳×׳•׳ ׳”',
                    // Health & Wellness
                    '׳“׳™׳׳˜׳”', '׳×׳–׳•׳ ׳”', '׳™׳•׳’׳”', '׳¢׳™׳¡׳•׳™', '׳₪׳™׳–׳™׳•׳×׳¨׳₪׳™׳”', '׳׳¢׳¡׳”',
                    // Home Services
                    '׳ ׳™׳§׳™׳•׳', '׳’׳™׳ ׳•׳', '׳’׳ ׳', '׳¦׳‘׳¢', '׳©׳™׳₪׳•׳¦׳™׳', '׳§׳‘׳׳', '׳‘׳ ׳™׳™׳”',
                    // Fashion & Clothing
                    '׳׳•׳₪׳ ׳”', '׳‘׳’׳“׳™׳', '׳‘׳™׳’׳•׳“', '׳ ׳¢׳׳™׳™׳', '׳ ׳¢׳׳™׳',
                    // Pets
                    '׳›׳׳‘', '׳›׳׳‘׳™׳', '׳—׳×׳•׳', '׳—׳×׳•׳׳™׳', '׳•׳˜׳¨׳™׳ ׳¨', '׳—׳™׳•׳× ׳׳—׳׳“',
                    // Gifts & Party
                    '׳׳×׳ ׳”', '׳׳×׳ ׳•׳×', '׳©׳™',
                    // Books & Print
                    '׳¡׳₪׳¨', '׳¡׳₪׳¨׳™׳', '׳”׳“׳₪׳¡׳”', '׳“׳₪׳•׳¡',
                    // Flowers
                    '׳₪׳¨׳—׳™׳', '׳₪׳¨׳—', '׳–׳¨ ׳₪׳¨׳—׳™׳',
                    // Insurance & Legal
                    '׳‘׳™׳˜׳•׳—', '׳‘׳™׳˜׳•׳—׳™׳', '׳¢׳•׳¨׳ ׳“׳™׳', '׳¨׳•׳׳” ׳—׳©׳‘׳•׳',
                    // Real Estate
                    '׳ ׳“׳׳', '׳“׳™׳¨׳”', '׳“׳™׳¨׳•׳×', '׳׳×׳•׳•׳',
                    // General
                    '׳—׳ ׳•׳×', '׳—׳ ׳•׳™׳•׳×', '׳©׳™׳¨׳•׳×', '׳©׳™׳¨׳•׳×׳™׳', '׳¢׳¡׳§', '׳¢׳¡׳§׳™׳'
                ];
                const mentionsProduct = productCategories.some(cat => lowerMessage.includes(cat));
                
                // If user mentions a product category, treat as marketplace query (even with "׳™׳©?" or "׳•" prefix)
                if (mentionsProduct) {
                    console.log('נ¯ Product category mentioned - treating as marketplace query:', lowerMessage);
                    // Continue to marketplace search below (don't return null to N8N)
                }
                
                // Handle greetings and small talk - return null to send to N8N
                const greetings = ['׳©׳׳•׳', '׳”׳™׳™', '׳”׳™', '׳”׳™׳™׳™', '׳”׳™׳•', '׳‘׳•׳§׳¨', '׳¢׳¨׳‘', '׳¦׳”׳¨׳™׳™׳', '׳˜׳•׳‘', '׳׳”׳×׳¨׳׳•׳×', '׳‘׳™׳™', '׳‘׳”׳¦׳׳—׳”'];
                const isGreeting = greetings.some(greeting => lowerMessage === greeting || lowerMessage.includes(greeting));
                
                // Handle questions about bot itself or general chat
                const botQuestions = ['׳׳” ׳©׳׳•׳׳', '׳׳™׳ ׳׳×', '׳׳™ ׳׳×', '׳׳” ׳׳×', '׳׳” ׳׳×׳”', '׳׳™ ׳׳×׳”'];
                const isBotQuestion = botQuestions.some(q => lowerMessage.includes(q));
                
                // Handle self-introduction (e.g., "׳׳ ׳™ ׳™׳ ׳™׳‘", "׳׳ ׳™ ׳¦׳™׳₪׳™", "׳©׳׳™ ׳“׳•׳“", "׳§׳•׳¨׳׳™׳ ׳׳™ ׳©׳™׳¨׳”")
                const selfIntroPatterns = [
                    /^׳׳ ׳™\s+[׳-׳×]+/,
                    /^׳©׳׳™\s+[׳-׳×]+/,
                    /^׳§׳•׳¨׳׳™׳\s+׳׳™\s+[׳-׳×]+/,
                    /^׳”׳©׳\s+׳©׳׳™\s+[׳-׳×]+/,
                    /^׳׳ ׳™\s+׳”[׳-׳×]+/
                ];
                const isSelfIntro = selfIntroPatterns.some(pattern => pattern.test(userMessage.trim()));
                
                // Handle general knowledge questions (like "׳׳” ׳’׳•׳“׳ ׳”׳•׳“׳•", "׳׳™׳ ׳...", etc.)
                const generalKnowledgePatterns = [
                    /^׳׳”\s+(׳’׳•׳“׳|׳©׳˜׳—|׳׳•׳›׳׳•׳¡׳™׳”|׳׳•׳¨׳|׳¨׳•׳—׳‘|׳’׳•׳‘׳”|׳¢׳•׳׳§|׳׳©׳§׳|׳˜׳׳₪׳¨׳˜׳•׳¨׳”|׳׳”׳™׳¨׳•׳×|׳׳¨׳—׳§)/,
                    /^(׳׳™׳\s+׳|׳›׳™׳¦׳“\s+׳|׳׳“׳¨׳™׳|׳×׳”׳׳™׳|׳©׳׳‘׳™׳)/,
                    /^(׳׳”\s+׳–׳”|׳׳”\s+׳₪׳™׳¨׳•׳©|׳׳”\s+׳׳©׳׳¢׳•׳×)/,
                    /^(׳׳×׳™\s+׳”׳•׳§׳|׳׳×׳™\s+׳ ׳•׳¡׳“|׳׳×׳™\s+׳ ׳‘׳ ׳”|׳×׳׳¨׳™׳|׳©׳ ׳”)/,
                    /^(׳׳׳”|׳׳“׳•׳¢|׳׳׳™׳–׳”\s+׳¡׳™׳‘׳”)/
                ];
                const isGeneralKnowledge = generalKnowledgePatterns.some(pattern => pattern.test(userMessage.trim()));
                
                // נ¯ FIX: Handle "׳׳” X" queries (e.g., "׳׳” ׳¦׳¢׳¦׳•׳¢׳™׳", "׳׳” ׳׳¡׳₪׳¨׳”") - show all results, not count
                // נ¯ FIX: "׳׳” ׳¦׳¢׳¦׳•׳¢׳™׳" should show all toys, "׳׳” ׳׳¡׳₪׳¨׳”" should show all hair salons
                // נ¯ CRITICAL: Don't match personal questions like "׳׳” ׳©׳׳•׳׳", "׳׳” ׳§׳•׳¨׳”", "׳׳” ׳ ׳©׳׳¢"
                const personalQuestionWords = ['׳©׳׳•׳׳', '׳§׳•׳¨׳”', '׳ ׳©׳׳¢', '׳”׳¢׳ ׳™׳™׳ ׳™׳', '׳”׳׳¦׳‘', '׳–׳”', '׳”׳•׳׳'];
                const whatQueryPattern = /^׳׳”\s+([׳-׳×\s]+?)(?:\s+׳™׳©|\s+׳§׳™׳™׳׳™׳|\s*$)/i;
                const whatQueryMatch = userMessage.match(whatQueryPattern);
                const isPersonalQuestion = whatQueryMatch && whatQueryMatch[1] && personalQuestionWords.some(q => whatQueryMatch[1].includes(q));
                
                if (whatQueryMatch && whatQueryMatch[1] && !isPersonalQuestion) {
                    const category = whatQueryMatch[1].trim();
                    console.log(`נ” "׳׳” X" query detected for category: "${category}"`);
                    
                    // Search for pages matching the category
                    const searchResults = await searchLivePages(category);
                    
                    if (searchResults && searchResults.length > 0) {
                        // Show all results (up to 5 initially)
                        const displayResults = searchResults.slice(0, 5);
                        if (searchResults.length > 5) {
                            displayResults._allResults = searchResults;
                            displayResults._currentOffset = 0;
                            displayResults._hasMore = true;
                        }
                        
                        return {
                            type: 'pages',
                            pages: displayResults,
                            message: `׳׳¦׳׳×׳™ ${displayResults.length} ׳׳₪׳©׳¨׳•׳™׳•׳×. ׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?`,
                            needsPreview: false,
                            includeLinks: false
                        };
                    } else {
                        return {
                            type: 'message',
                            message: `׳׳ ׳׳¦׳׳×׳™ ${category} ׳‘׳׳¢׳¨׳›׳×.`
                        };
                    }
                }
                
                // נ¯ FIX: Handle "׳›׳׳” ׳—׳ ׳•׳™׳•׳× X ׳™׳©" queries - return count, not page list
                const countQueryPattern = /(?:׳›׳׳”|׳׳”)\s*(?:׳—׳ ׳•׳™׳•׳×|׳“׳₪׳™׳|׳¢׳¡׳§׳™׳|׳׳¡׳₪׳¨׳•׳×|׳ ׳•׳×׳ ׳™\s+׳©׳™׳¨׳•׳×|׳‘׳¢׳׳™\s+׳׳§׳¦׳•׳¢)\s+([׳-׳×\s]+)\s+(?:׳™׳©|׳§׳™׳™׳׳™׳)/i;
                const countQueryMatch = userMessage.match(countQueryPattern);
                if (countQueryMatch && countQueryMatch[1]) {
                    const category = countQueryMatch[1].trim();
                    console.log(`נ”¢ Count query detected for category: "${category}"`);
                    
                    // Search for pages matching the category
                    const searchResults = await searchLivePages(category);
                    const count = searchResults ? searchResults.length : 0;
                    
                    // Extract the type from query (׳—׳ ׳•׳™׳•׳×, ׳“׳₪׳™׳, ׳¢׳¡׳§׳™׳, etc.)
                    const typeMatch = userMessage.match(/(?:׳›׳׳”|׳׳”)\s*(׳—׳ ׳•׳™׳•׳×|׳“׳₪׳™׳|׳¢׳¡׳§׳™׳|׳׳¡׳₪׳¨׳•׳×|׳ ׳•׳×׳ ׳™\s+׳©׳™׳¨׳•׳×|׳‘׳¢׳׳™\s+׳׳§׳¦׳•׳¢)/i);
                    const type = typeMatch ? typeMatch[1] : '׳“׳₪׳™׳';
                    
                    let response = '';
                    if (count === 0) {
                        response = `׳׳ ׳׳¦׳׳×׳™ ${type} ׳©׳ ${category} ׳‘׳׳¢׳¨׳›׳×.`;
                    } else if (count === 1) {
                        response = `׳™׳© ${count} ${type.slice(0, -1)} ׳©׳ ${category} ׳‘׳׳¢׳¨׳›׳×.`;
                    } else {
                        response = `׳™׳© ${count} ${type} ׳©׳ ${category} ׳‘׳׳¢׳¨׳›׳×.`;
                    }
                    
                    return {
                        type: 'message',
                        message: response
                    };
                }
                
                // Handle general questions that don't need page previews (price info, statistics, etc.)
                const generalInfoPatterns = [
                    /(?:׳™׳•׳“׳¢׳×|׳׳”|׳׳™׳–׳”|׳›׳׳”)\s*(?:׳׳—׳™׳¨|׳׳—׳™׳¨׳™׳)/,
                    /׳׳”\s+(׳”׳׳•׳¦׳¨|׳”׳׳•׳¦׳¨׳™׳)\s*(?:׳”׳›׳™|׳”)?\s*(?:׳–׳•׳|׳™׳§׳¨|׳˜׳•׳‘)/,
                    /(?:׳›׳׳”|׳׳”)\s*(?:׳ ׳•׳×׳ ׳™|׳׳¡׳₪׳§׳™|׳‘׳¢׳׳™)\s*(?:׳©׳¨׳•׳×|׳©׳™׳¨׳•׳×|׳׳§׳¦׳•׳¢)/,
                    /(?:׳›׳׳”|׳׳”)\s*(?:׳“׳₪׳™׳|׳¢׳¡׳§׳™׳|׳—׳ ׳•׳™׳•׳×)\s*(?:׳™׳©|׳§׳™׳™׳׳™׳)/,
                    /׳‘׳׳™׳–׳”\s+׳¢׳™׳¨|׳׳”\s+׳”׳˜׳׳₪׳•׳\s+׳©׳/i
                ];
                const isGeneralInfo = generalInfoPatterns.some(pattern => pattern.test(userMessage.trim()));
                
                // נ§  Check for context-aware follow-up questions (e.g., "׳׳™׳–׳” ׳׳•׳¦׳¨׳™׳ ׳™׳© ׳©׳", "׳׳” ׳׳—׳™׳¨׳™ ׳”׳©׳¢׳˜׳ ׳™׳")
                // These refer to previously mentioned pages/stores
                const contextFollowUpPatterns = [
                    /(?:׳׳™׳–׳”|׳׳”)\s*(?:׳׳•׳¦׳¨׳™׳|׳₪׳¨׳™׳˜׳™׳)\s*(?:׳™׳©|׳§׳™׳™׳׳™׳|׳–׳׳™׳ ׳™׳)\s*(?:׳©׳|׳‘׳—׳ ׳•׳×|׳‘|׳‘׳×׳•׳›׳”)/i,
                    /(?:׳©׳|׳‘׳—׳ ׳•׳×|׳‘|׳‘׳×׳•׳›׳”)\s*(?:׳™׳©|׳§׳™׳™׳׳™׳|׳–׳׳™׳ ׳™׳)/i
                ];
                const isContextFollowUp = contextFollowUpPatterns.some(pattern => pattern.test(userMessage));
                
                // Check if query is about prices of products mentioned before (e.g., "׳׳” ׳׳—׳™׳¨׳™ ׳”׳©׳¢׳˜׳ ׳™׳")
                const isPriceOfProductsQuery = /׳׳”\s+(?:׳׳—׳™׳¨|׳׳—׳™׳¨׳™׳|׳׳—׳™׳¨׳™)/i.test(userMessage);
                const hasProductReference = /(?:׳©׳¢׳˜׳ ׳™׳|׳©׳¢׳•׳ ׳™׳|׳©׳¢׳•׳|׳׳•׳¦׳¨׳™׳|׳₪׳¨׳™׳˜׳™׳)/i.test(userMessage);
                const isPriceFollowUp = isPriceOfProductsQuery && (hasProductReference || isContextFollowUp);
                
                // Get last mentioned page from conversation context (if available)
                let lastMentionedPage = null;
                if (typeof window !== 'undefined' && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    lastMentionedPage = window.stavCurrentPages[0]; // Get the first/last page shown
                    console.log('נ§  Context follow-up detected - last mentioned page:', lastMentionedPage?.title);
                }
                
                // If this is a context follow-up or price query about products mentioned before
                if ((isContextFollowUp || isPriceFollowUp) && lastMentionedPage) {
                    console.log('נ§  Handling context follow-up - searching page:', lastMentionedPage.title);
                    const liveResults = await searchLivePages(lastMentionedPage.title);
                    if (liveResults && liveResults.length > 0) {
                        return { 
                            type: 'pages', 
                            pages: liveResults,
                            message: `׳׳¦׳׳×׳™ ׳׳× ׳”׳׳™׳“׳¢ ׳¢׳ ${liveResults[0].title}`,
                            needsPreview: false // Don't show preview for follow-up questions
                        };
                    }
                }
                
                // If it's a price query about watches but no context, search for watches
                if (isPriceQuery && /׳©׳¢׳˜׳ ׳™׳|׳©׳¢׳•׳ ׳™׳/i.test(userMessage) && !lastMentionedPage) {
                    console.log('נ’° Price query about watches detected - searching for watches');
                    const liveResults = await searchLivePages('׳©׳¢׳•׳');
                    if (liveResults && liveResults.length > 0) {
                        return { 
                            type: 'pages', 
                            pages: liveResults,
                            message: `׳׳¦׳׳×׳™ ${liveResults.length} ׳“׳₪׳™׳ ׳¢׳ ׳©׳¢׳•׳ ׳™׳`,
                            needsPreview: false
                        };
                    }
                }
                
                // ג ן¸ IMPORTANT: Don't send product/store queries to N8N - they invent data!
                // Check if query is about products in a specific store or general product query
                // But be more specific - only count as marketplace query if it's clearly about marketplace
                const storeProductPattern = /(?:׳”׳׳•׳¦׳¨׳™׳|׳׳•׳¦׳¨׳™׳|׳׳” ׳™׳©|׳׳” ׳™׳© ׳|׳׳” ׳׳•׳›׳¨׳™׳|׳׳™׳–׳” ׳׳•׳¦׳¨׳™׳)\s*(?:׳‘|׳‘׳—׳ ׳•׳×|׳‘׳—׳ ׳•׳×|׳©׳)\s*([׳-׳×a-zA-Z]+)/i;
                const storeProductMatch = userMessage.match(storeProductPattern);
                
                // Only consider it a product query if it's clearly about marketplace items
                // Exclude general questions like "׳׳” ׳–׳” ׳׳•׳¦׳¨?" which should go to N8N
                // Check for general question patterns first
                const isGeneralQuestion = /^׳׳”\s+(׳–׳”|׳₪׳™׳¨׳•׳©|׳׳©׳׳¢׳•׳×)/.test(userMessage.trim()) || 
                                         /^׳׳™׳\s+׳/.test(userMessage.trim()) ||
                                         /^׳׳׳”|^׳׳“׳•׳¢/.test(userMessage.trim());
                
                // נ¯ IMPROVED: Check if the query matches any page in the marketplace
                // This allows single-word queries like "׳ ׳’׳¨", "׳׳§", "׳¦׳¢׳¦׳•׳¢׳™׳" to be recognized as marketplace queries
                let matchesPageInMarketplace = false;
                // נ¯ FIX: Clean query - remove "׳׳—׳₪׳©", "׳׳—׳₪׳©׳×", "׳׳ ׳™ ׳׳—׳₪׳©", etc. BEFORE checking if it matches pages
                let cleanQuery = lowerMessage.trim()
                    .replace(/^(?:׳׳ ׳™\s+)?(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×|׳¨׳•׳¦׳”|׳¦׳¨׳™׳|׳¦׳¨׳™׳›׳”)\s+/i, '') // Remove "׳׳—׳₪׳©", "׳׳ ׳™ ׳׳—׳₪׳©", etc.
                    .replace(/\s+(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×|׳¨׳•׳¦׳”|׳¦׳¨׳™׳|׳¦׳¨׳™׳›׳”)$/i, '') // Remove trailing "׳׳—׳₪׳©"
                    .trim();
                
                console.log('נ” [MARKETPLACE CHECK] cleanQuery:', cleanQuery, 'length:', cleanQuery.length, 'isGeneralQuestion:', isGeneralQuestion);
                console.log('נ” [MARKETPLACE CHECK] allPages count:', allPages?.length || 0);
                
                // If query is a single word or short phrase (not a question), check if it matches pages
                if (!isGeneralQuestion && cleanQuery.length > 1 && cleanQuery.length < 30) {
                    // נ¯ Get synonyms map for matching (same as in searchLivePages)
                    const synonymMap = {
                        '׳׳¡׳₪׳¨׳”': ['׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳×׳¡׳₪׳•׳¨׳•׳×', '׳׳¡׳₪׳¨', '׳¡׳₪׳¨ ׳’׳‘׳¨׳™׳', '׳¡׳₪׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨'],
                        '׳×׳¡׳₪׳•׳¨׳×': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳׳¡׳₪׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                        '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                        '׳׳¢׳¦׳‘ ׳©׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'], // Typo fix
                        '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                        '׳ ׳’׳¨': ['׳ ׳’׳¨׳•׳×', '׳ ׳’׳¨׳™׳”', '׳¢׳‘׳•׳“׳•׳× ׳¢׳¥', '׳ ׳’׳¨׳™׳™׳”', '׳ ׳’׳¨ ׳׳˜׳‘׳—׳™׳', '׳׳¨׳•׳ ׳•׳×'],
                        '׳ ׳’׳¨׳•׳×': ['׳ ׳’׳¨', '׳ ׳’׳¨׳™׳”', '׳¢׳‘׳•׳“׳•׳× ׳¢׳¥', '׳׳¨׳•׳ ׳•׳×', '׳׳˜׳‘׳—׳™׳'],
                        '׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨': ['׳׳™׳ ׳¡׳˜׳׳¦׳™׳”', '׳©׳¨׳‘׳¨׳‘', '׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨ ׳‘׳©׳‘׳×', '׳©׳¨׳‘׳¨׳‘׳•׳×'],
                        '׳—׳©׳׳׳׳™': ['׳—׳©׳׳', '׳—׳©׳׳׳׳•׳×', '׳×׳™׳§׳•׳ ׳—׳©׳׳'],
                        '׳׳§': ['׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳׳§ ׳’\'׳', '׳׳§ ׳’׳', '׳¢׳™׳¦׳•׳‘ ׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳'],
                        '׳׳§ ׳’׳': ['׳׳§', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳׳§ ׳’\'׳', '׳¢׳™׳¦׳•׳‘ ׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳'],
                        '׳׳§ ׳’\'׳': ['׳׳§', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳׳§ ׳’׳', '׳¢׳™׳¦׳•׳‘ ׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳'],
                        '׳׳ ׳™׳§׳•׳¨': ['׳׳§', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳₪׳“׳™׳§׳•׳¨', '׳׳§ ׳’\'׳', '׳׳§ ׳’׳'],
                        '׳₪׳“׳™׳§׳•׳¨': ['׳׳§', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳׳ ׳™׳§׳•׳¨', '׳׳§ ׳’\'׳', '׳׳§ ׳’׳']
                    };
                    
                    // Check if query matches any page title, description, or product name (including synonyms)
                    for (const page of (allPages || [])) {
                        const pageTitle = (page.title || '').toLowerCase();
                        const pageDesc = (page.description || '').toLowerCase();
                        const pageProducts = (page.products || []).map(p => (p.name || '').toLowerCase()).join(' ');
                        
                        // נ¯ IMPROVED: Check word-by-word matching with synonyms
                        // Extract words from query (removing "׳‘" prefix for city queries like "׳ ׳’׳¨ ׳‘׳ ׳×׳ ׳™׳”")
                        const queryWords = cleanQuery.split(/\s+/)
                            .map(w => w.replace(/^׳‘/, '').replace(/^׳©׳/, '').replace(/^׳”/, '')) // Remove leading ׳‘, ׳©׳, or ׳”
                            .filter(w => w.length > 1); // Keep words with at least 2 chars
                        
                        // Get all synonyms for query words
                        const allQueryTerms = [cleanQuery.toLowerCase()];
                        queryWords.forEach(word => {
                            const wordLower = word.toLowerCase();
                            allQueryTerms.push(wordLower);
                            const synonyms = synonymMap[wordLower] || [];
                            allQueryTerms.push(...synonyms);
                        });
                        const uniqueQueryTerms = [...new Set(allQueryTerms)];
                        
                        // Check if any query term (or synonym) matches title/description/products
                        const hasMatch = uniqueQueryTerms.some(term => 
                            pageTitle.includes(term) || 
                            pageDesc.includes(term) || 
                            pageProducts.includes(term)
                        ) || queryWords.some(word => {
                            // Also check if word or its synonyms match
                            const wordLower = word.toLowerCase();
                            const wordSynonyms = synonymMap[wordLower] || [];
                            const allWordTerms = [wordLower, ...wordSynonyms];
                            return allWordTerms.some(term => 
                                pageTitle.includes(term) || 
                                pageDesc.includes(term) || 
                                pageProducts.includes(term)
                            );
                        }) || cleanQuery.includes(pageTitle.split(' ')[0]); // Check if query matches first word of title
                        
                        if (hasMatch) {
                            matchesPageInMarketplace = true;
                            console.log(`ג… [MARKETPLACE CHECK] Query "${cleanQuery}" matches page "${page.title}" (with synonyms) - treating as marketplace query`);
                            console.log(`ג… [MARKETPLACE CHECK] queryWords:`, queryWords, 'allQueryTerms:', uniqueQueryTerms);
                            break;
                        }
                    }
                    
                    if (!matchesPageInMarketplace) {
                        console.log(`ג [MARKETPLACE CHECK] Query "${cleanQuery}" does NOT match any pages (even with synonyms)`);
                    }
                }
                
                // נ¯ FIX: Make search more focused - exclude vague queries like "׳׳” ׳©" or single letters
                // Also exclude descriptive words like "׳׳™׳׳“", "׳׳™׳׳“׳™׳", "׳©׳׳™" that are not search queries
                const isVagueQuery = cleanQuery.length <= 2 || 
                                     cleanQuery === '׳׳” ׳©' || 
                                     cleanQuery === '׳׳”' ||
                                     cleanQuery === '׳©' ||
                                     cleanQuery === '׳׳™׳׳“' || cleanQuery === '׳׳™׳׳“׳™׳' || // נ¯ FIX: "׳׳™׳׳“" alone is not a search query
                                     cleanQuery === '׳©׳׳™' || cleanQuery === '׳©׳׳' || cleanQuery === '׳©׳׳”' ||
                                     /^[׳-׳×]\s*$/.test(cleanQuery); // Single Hebrew letter
                
                // נ¯ FIX: Check if cleanQuery is a simple product/service term (even before matching pages)
                // Also check if it's a product term with "׳׳™׳׳“" / "׳׳™׳׳“׳™׳" (e.g., "׳¦׳¢׳¦׳•׳¢ ׳׳™׳׳“")
                const cleanQueryWithoutChild = cleanQuery
                    .replace(/\s+׳(?:׳™׳׳“|׳™׳׳“׳™׳|׳׳©׳×׳™|׳’׳‘׳¨|׳‘׳—׳•׳¨|׳‘׳—׳•׳¨׳”|׳׳™׳©׳”|׳׳©׳”|׳‘׳¢׳|׳‘׳¢׳׳™|׳‘׳|׳‘׳×|׳©׳׳™|׳©׳׳|׳©׳׳”|׳©׳׳ ׳•|׳©׳׳›׳|׳©׳׳”׳)\s*$/i, '')
                    .trim();
                
                const isSimpleProductTerm = cleanQuery === '׳¦׳¢׳¦׳•׳¢' || cleanQuery === '׳¦׳¢׳¦׳•׳¢׳™׳' || 
                                           cleanQuery === '׳©׳¢׳•׳' || cleanQuery === '׳©׳¢׳•׳ ׳™׳' ||
                                           cleanQuery === '׳׳§' || cleanQuery === '׳׳•׳¦׳¨' || cleanQuery === '׳׳•׳¦׳¨׳™׳' ||
                                           cleanQuery === '׳׳×׳ ׳”' || cleanQuery === '׳׳×׳ ׳•׳×' ||
                                           cleanQuery === '׳©׳™׳¨׳•׳×' || cleanQuery === '׳©׳¨׳•׳×' ||
                                           cleanQueryWithoutChild === '׳¦׳¢׳¦׳•׳¢' || cleanQueryWithoutChild === '׳¦׳¢׳¦׳•׳¢׳™׳' || // נ¯ FIX: "׳¦׳¢׳¦׳•׳¢ ׳׳™׳׳“" -> "׳¦׳¢׳¦׳•׳¢"
                                           cleanQueryWithoutChild === '׳©׳¢׳•׳' || cleanQueryWithoutChild === '׳©׳¢׳•׳ ׳™׳' ||
                                           cleanQueryWithoutChild === '׳׳§' || cleanQueryWithoutChild === '׳׳•׳¦׳¨' || cleanQueryWithoutChild === '׳׳•׳¦׳¨׳™׳' ||
                                           cleanQueryWithoutChild === '׳׳×׳ ׳”' || cleanQueryWithoutChild === '׳׳×׳ ׳•׳×' ||
                                           (cleanQuery.length >= 3 && /^(׳ ׳’׳¨|׳ ׳’׳¨׳•׳×|׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨|׳׳™׳ ׳˜׳׳˜׳•׳¨|׳׳§|׳׳§ ׳’׳|׳׳§ ׳’'׳|׳׳ ׳™׳§׳•׳¨|׳₪׳“׳™׳§׳•׳¨|׳¦׳¢׳¦׳•׳¢|׳¦׳¢׳¦׳•׳¢׳™׳|׳©׳¢׳•׳|׳©׳¢׳•׳ ׳™׳|׳§׳•׳¨׳¡|׳§׳•׳¨׳¡׳™׳|׳—׳ ׳•׳×|׳¢׳¡׳§|׳©׳™׳¨׳•׳×|׳©׳¨׳•׳×|׳׳•׳¦׳¨|׳׳×׳ ׳”|׳—׳©׳׳׳׳™|׳׳׳׳|׳׳׳׳ ׳×|׳§׳•׳¡׳׳˜׳™׳§׳׳™׳×|׳׳¡׳₪׳¨׳”|׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨|׳׳¢׳¦׳‘ ׳©׳¢׳¨|׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨|׳¦׳׳|׳ ׳™׳§׳™׳•׳|׳‘׳™׳‘׳™׳¡׳™׳˜׳¨|׳׳’׳•)$/.test(cleanQuery)) ||
                                           (cleanQueryWithoutChild.length >= 3 && /^(׳ ׳’׳¨|׳ ׳’׳¨׳•׳×|׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨|׳׳™׳ ׳˜׳׳˜׳•׳¨|׳׳§|׳׳§ ׳’׳|׳׳§ ׳’'׳|׳׳ ׳™׳§׳•׳¨|׳₪׳“׳™׳§׳•׳¨|׳¦׳¢׳¦׳•׳¢|׳¦׳¢׳¦׳•׳¢׳™׳|׳©׳¢׳•׳|׳©׳¢׳•׳ ׳™׳|׳§׳•׳¨׳¡|׳§׳•׳¨׳¡׳™׳|׳—׳ ׳•׳×|׳¢׳¡׳§|׳©׳™׳¨׳•׳×|׳©׳¨׳•׳×|׳׳•׳¦׳¨|׳׳×׳ ׳”|׳—׳©׳׳׳׳™|׳׳׳׳|׳׳׳׳ ׳×|׳§׳•׳¡׳׳˜׳™׳§׳׳™׳×|׳׳¡׳₪׳¨׳”|׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨|׳׳¢׳¦׳‘ ׳©׳¢׳¨|׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨|׳¦׳׳|׳ ׳™׳§׳™׳•׳|׳‘׳™׳‘׳™׳¡׳™׳˜׳¨|׳׳’׳•)$/.test(cleanQueryWithoutChild));
                
                // נ¯ CRITICAL FIX: Check for product/service keywords FIRST (like a search engine)
                // Don't wait for page matches - if query contains product/service keywords, it's a marketplace query
                const hasProductKeyword = lowerMessage.includes('׳¦׳¢׳¦׳•׳¢') || lowerMessage.includes('׳¦׳¢׳¦׳•׳¢׳™׳') ||
                                         lowerMessage.includes('׳©׳¢׳•׳') || lowerMessage.includes('׳©׳¢׳•׳ ׳™׳') ||
                                         lowerMessage.includes('׳׳§') || lowerMessage.includes('׳׳ ׳™׳§׳•׳¨') || lowerMessage.includes('׳₪׳“׳™׳§׳•׳¨') ||
                                         lowerMessage.includes('׳׳•׳¦׳¨') || lowerMessage.includes('׳׳•׳¦׳¨׳™׳') ||
                                         lowerMessage.includes('׳׳×׳ ׳”') || lowerMessage.includes('׳׳×׳ ׳•׳×') ||
                                         lowerMessage.includes('׳‘׳•׳‘׳×') || lowerMessage.includes('׳‘׳•׳‘׳”') ||
                                         lowerMessage.includes('׳׳›׳•׳ ׳™׳×') || lowerMessage.includes('׳¨׳›׳‘׳×') ||
                                         lowerMessage.includes('׳¨׳•׳‘׳•׳˜') ||
                                         lowerMessage.includes('׳—׳ ׳•׳×') || lowerMessage.includes('׳¢׳¡׳§') ||
                                         lowerMessage.includes('׳׳—׳™׳¨') || lowerMessage.includes('׳׳—׳™׳¨׳™׳') ||
                                         lowerMessage.includes('׳§׳•׳¨׳¡') || lowerMessage.includes('׳§׳•׳¨׳¡׳™׳') ||
                                         lowerMessage.includes('׳׳™׳¨׳•׳¢') || lowerMessage.includes('׳׳™׳¨׳•׳¢׳™׳');
                
                const hasServiceKeyword = lowerMessage.includes('׳©׳™׳¨׳•׳×') || lowerMessage.includes('׳©׳¨׳•׳×') ||
                                         lowerMessage.includes('׳׳¡׳₪׳¨׳”') || lowerMessage.includes('׳×׳¡׳₪׳•׳¨׳×') ||
                                         (lowerMessage.includes('׳¡׳₪׳¨') && !lowerMessage.includes('׳¡׳₪׳¨׳™׳')) ||
                                         lowerMessage.includes('׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨') || lowerMessage.includes('׳׳¢׳¦׳‘ ׳©׳¢׳¨') || lowerMessage.includes('׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨') ||
                                         lowerMessage.includes('׳ ׳’׳¨') || lowerMessage.includes('׳ ׳’׳¨׳•׳×') ||
                                         lowerMessage.includes('׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨') || lowerMessage.includes('׳׳™׳ ׳˜׳׳˜׳•׳¨') ||
                                         lowerMessage.includes('׳—׳©׳׳׳׳™') || lowerMessage.includes('׳׳׳׳') || lowerMessage.includes('׳׳׳׳ ׳×') ||
                                         lowerMessage.includes('׳§׳•׳¡׳׳˜׳™׳§׳׳™׳×') || lowerMessage.includes('׳¦׳׳') || lowerMessage.includes('׳¦׳™׳׳•׳') ||
                                         lowerMessage.includes('׳ ׳™׳§׳™׳•׳') || lowerMessage.includes('׳‘׳™׳‘׳™׳¡׳™׳˜׳¨') ||
                                         lowerMessage.includes('׳‘׳¢׳ ׳׳§׳¦׳•׳¢') || lowerMessage.includes('׳‘׳¢׳׳™ ׳׳§׳¦׳•׳¢') ||
                                         lowerMessage.includes('׳ ׳•׳×׳ ׳©׳™׳¨׳•׳×') || lowerMessage.includes('׳ ׳•׳×׳ ׳™ ׳©׳™׳¨׳•׳×');
                
                console.log('נ” [KEYWORD CHECK] hasProductKeyword:', hasProductKeyword, '| hasServiceKeyword:', hasServiceKeyword, '| lowerMessage:', lowerMessage);
                
                // נ¯ CRITICAL: If query contains product/service keywords, it's ALWAYS a marketplace query (like a search engine)
                // Skip isVagueQuery and isGeneralQuestion checks for product/service keywords
                const isProductQuery = (hasProductKeyword || hasServiceKeyword) || // נ¯ CRITICAL: Product/service keywords ALWAYS trigger marketplace query
                                       (!isGeneralQuestion && !isVagueQuery && (
                    matchesPageInMarketplace || // NEW: If query matches a page, it's a marketplace query
                                           isSimpleProductTerm || // נ¯ FIX: Simple product terms like "׳¦׳¢׳¦׳•׳¢", "׳¦׳¢׳¦׳•׳¢׳™׳" are always marketplace queries
                    // נ¯ FIX: Also catch "׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳" / "׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳™׳§׳¨" / "׳׳” ׳”׳׳×׳ ׳” ׳”׳›׳™ ׳–׳•׳׳”" variations
                    lowerMessage.includes('׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳™׳§׳¨') ||
                    lowerMessage.includes('׳׳” ׳”׳׳×׳ ׳” ׳”׳›׳™ ׳–׳•׳׳”') || lowerMessage.includes('׳׳” ׳”׳׳×׳ ׳” ׳”׳›׳™ ׳™׳§׳¨׳”') ||
                    lowerMessage.includes('׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳™׳§׳¨') ||
                    lowerMessage.includes('׳”׳׳×׳ ׳” ׳”׳›׳™ ׳–׳•׳׳”') || lowerMessage.includes('׳”׳׳×׳ ׳” ׳”׳›׳™ ׳™׳§׳¨׳”') ||
                                           (lowerMessage.includes('׳׳•׳¦׳¨') && (lowerMessage.includes('׳™׳©') || lowerMessage.includes('׳׳•׳›׳¨') || lowerMessage.includes('׳—׳ ׳•׳×') || lowerMessage.includes('׳“׳£') || lowerMessage.includes('׳–׳•׳') || lowerMessage.includes('׳–׳•׳׳™׳') || lowerMessage.includes('׳–׳•׳׳”'))) ||
                                           (lowerMessage.includes('׳׳×׳ ׳”') && (lowerMessage.includes('׳™׳©') || lowerMessage.includes('׳׳•׳›׳¨') || lowerMessage.includes('׳—׳ ׳•׳×') || lowerMessage.includes('׳“׳£') || lowerMessage.includes('׳–׳•׳׳”') || lowerMessage.includes('׳–׳•׳') || lowerMessage.includes('׳׳׳©׳×׳™') || lowerMessage.includes('׳׳’׳‘׳¨') || lowerMessage.includes('׳׳™׳׳“') || lowerMessage.includes('׳׳‘׳'))) ||
                    (lowerMessage.includes('׳©׳¢׳•׳') && (lowerMessage.includes('׳™׳©') || lowerMessage.includes('׳׳—׳™׳¨') || lowerMessage.includes('׳—׳ ׳•׳×'))) ||
                                           (lowerMessage.includes('׳¦׳¢׳¦׳•׳¢') && (lowerMessage.includes('׳™׳©') || lowerMessage.includes('׳׳—׳™׳¨') || lowerMessage.includes('׳—׳ ׳•׳×') || lowerMessage.includes('׳׳™׳׳“') || lowerMessage.includes('׳׳™׳׳“׳™׳') || lowerMessage.includes('׳׳—׳₪׳©') || lowerMessage.includes('׳׳—׳₪׳©׳×'))) || // נ¯ FIX: "׳¦׳¢׳¦׳•׳¢ ׳׳™׳׳“" / "׳¦׳¢׳¦׳•׳¢׳™׳ ׳׳™׳׳“" / "׳׳—׳₪׳© ׳¦׳¢׳¦׳•׳¢"
                                           (lowerMessage.includes('׳¦׳¢׳¦׳•׳¢׳™׳') && (lowerMessage.includes('׳™׳©') || lowerMessage.includes('׳׳—׳™׳¨') || lowerMessage.includes('׳—׳ ׳•׳×') || lowerMessage.includes('׳׳™׳׳“') || lowerMessage.includes('׳׳™׳׳“׳™׳') || lowerMessage.includes('׳׳—׳₪׳©') || lowerMessage.includes('׳׳—׳₪׳©׳×'))) || // נ¯ FIX: "׳¦׳¢׳¦׳•׳¢׳™׳ ׳׳™׳׳“" / "׳׳—׳₪׳© ׳¦׳¢׳¦׳•׳¢׳™׳"
                    (lowerMessage.includes('׳׳§') && (lowerMessage.includes('׳™׳©') || lowerMessage.includes('׳׳—׳™׳¨') || lowerMessage.includes('׳©׳™׳¨׳•׳×'))) ||
                                           // נ¯ NEW: Detect "׳“׳‘׳¨׳™׳ ׳–׳•׳׳™׳", "׳׳•׳¦׳¨׳™׳ ׳–׳•׳׳™׳", "׳™׳© ׳“׳‘׳¨׳™׳ ׳–׳•׳׳™׳", "׳“׳‘׳¨׳™׳ ׳–׳•׳׳™׳ ׳₪׳”"
                                           (lowerMessage.includes('׳“׳‘׳¨׳™׳') && (lowerMessage.includes('׳–׳•׳') || lowerMessage.includes('׳–׳•׳׳™׳') || lowerMessage.includes('׳–׳•׳׳”'))) ||
                                           (lowerMessage.includes('׳׳•׳¦׳¨׳™׳') && (lowerMessage.includes('׳–׳•׳') || lowerMessage.includes('׳–׳•׳׳™׳') || lowerMessage.includes('׳–׳•׳׳”'))) ||
                                           (lowerMessage.includes('׳™׳©') && lowerMessage.includes('׳“׳‘׳¨׳™׳') && (lowerMessage.includes('׳–׳•׳') || lowerMessage.includes('׳–׳•׳׳™׳') || lowerMessage.includes('׳–׳•׳׳”'))) ||
                                           (lowerMessage.includes('׳“׳‘׳¨׳™׳') && lowerMessage.includes('׳–׳•׳׳™׳') && (lowerMessage.includes('׳₪׳”') || lowerMessage.includes('׳›׳׳') || lowerMessage.includes('׳¨׳§׳˜׳₪׳׳™׳™׳¡'))) ||
                                           // נ¯ NEW: Detect specific product queries (2-3 words that look like product names)
                                           /^(׳‘׳•׳‘׳×|׳‘׳•׳‘׳”|׳׳›׳•׳ ׳™׳×|׳¨׳›׳‘׳×|׳¨׳•׳‘׳•׳˜|׳©׳¢׳•׳|׳¦׳¢׳¦׳•׳¢|׳׳§|׳׳×׳ ׳”)\s+([׳-׳×\s]{2,20})$/i.test(cleanQuery) || // "׳‘׳•׳‘׳× ׳₪׳¨׳•׳•׳”", "׳׳›׳•׳ ׳™׳× ׳׳¨׳•׳¥", "׳¨׳›׳‘׳× ׳¢׳¥"
                                           /^([׳-׳×\s]{2,15})\s+(׳₪׳¨׳•׳•׳”|׳׳¨׳•׳¥|׳¢׳¥|׳—׳‘׳¨׳•׳×׳™|׳—׳׳•׳“׳”|׳§׳׳׳¡׳™׳×)$/i.test(cleanQuery) || // "׳‘׳•׳‘׳× ׳₪׳¨׳•׳•׳”", "׳׳›׳•׳ ׳™׳× ׳׳¨׳•׳¥", "׳¨׳›׳‘׳× ׳¢׳¥"
                                           // נ¯ NEW: Common product patterns
                                           lowerMessage.includes('׳‘׳•׳‘׳×') || lowerMessage.includes('׳‘׳•׳‘׳”') ||
                                           lowerMessage.includes('׳׳›׳•׳ ׳™׳×') || lowerMessage.includes('׳¨׳›׳‘׳×') ||
                                           lowerMessage.includes('׳¨׳•׳‘׳•׳˜') ||
                    // נ¯ FIX: Add service providers - ׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨, ׳ ׳’׳¨, etc. (with or without city)
                    lowerMessage.includes('׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨') || lowerMessage.includes('׳׳™׳ ׳˜׳׳˜׳•׳¨') || // Handle typo "׳׳™׳ ׳˜׳׳˜׳•׳¨"
                    lowerMessage.includes('׳ ׳’׳¨') || lowerMessage.includes('׳ ׳’׳¨׳•׳×') ||
                    lowerMessage.includes('׳—׳©׳׳׳׳™') || lowerMessage.includes('׳׳׳׳') || lowerMessage.includes('׳׳׳׳ ׳×') ||
                    lowerMessage.includes('׳§׳•׳¡׳׳˜׳™׳§׳׳™׳×') || lowerMessage.includes('׳׳¡׳₪׳¨׳”') ||
                                           lowerMessage.includes('׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨') || lowerMessage.includes('׳׳¢׳¦׳‘ ׳©׳¢׳¨') || lowerMessage.includes('׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨') || lowerMessage.includes('׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨') ||
                                           lowerMessage.includes('׳×׳¡׳₪׳•׳¨׳×') || (lowerMessage.includes('׳¡׳₪׳¨') && !lowerMessage.includes('׳¡׳₪׳¨׳™׳')) ||
                    lowerMessage.includes('׳¦׳׳') || lowerMessage.includes('׳¦׳™׳׳•׳') ||
                    lowerMessage.includes('׳ ׳™׳§׳™׳•׳') || lowerMessage.includes('׳‘׳™׳‘׳™׳¡׳™׳˜׳¨') ||
                                           lowerMessage.includes('׳©׳™׳¨׳•׳×') || lowerMessage.includes('׳©׳¨׳•׳×') || // נ¯ FIX: "׳׳—׳₪׳© ׳©׳™׳¨׳•׳×" / "׳׳—׳₪׳© ׳©׳¨׳•׳×"
                    lowerMessage.includes('׳—׳ ׳•׳×') ||
                    lowerMessage.includes('׳׳¨׳§׳˜׳₪׳׳™׳™׳¡') ||
                                           lowerMessage.includes('׳ ׳•׳×׳ ׳©׳™׳¨׳•׳×') || lowerMessage.includes('׳ ׳•׳×׳ ׳™ ׳©׳™׳¨׳•׳×') || lowerMessage.includes('׳ ׳•׳×׳ ׳™ ׳©׳¨׳•׳×') ||
                                           lowerMessage.includes('׳‘׳¢׳ ׳׳§׳¦׳•׳¢') || lowerMessage.includes('׳‘׳¢׳׳™ ׳׳§׳¦׳•׳¢') ||
                    // NEW: Common marketplace terms - single words that likely refer to services/products (but not too vague)
                                           (cleanQuery.length >= 3 && /^(׳ ׳’׳¨|׳ ׳’׳¨׳•׳×|׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨|׳׳™׳ ׳˜׳׳˜׳•׳¨|׳׳§|׳׳§ ׳’׳|׳׳§ ׳’'׳|׳׳ ׳™׳§׳•׳¨|׳₪׳“׳™׳§׳•׳¨|׳¦׳¢׳¦׳•׳¢|׳¦׳¢׳¦׳•׳¢׳™׳|׳©׳¢׳•׳|׳©׳¢׳•׳ ׳™׳|׳§׳•׳¨׳¡|׳§׳•׳¨׳¡׳™׳|׳—׳ ׳•׳×|׳¢׳¡׳§|׳©׳™׳¨׳•׳×|׳©׳¨׳•׳×|׳׳•׳¦׳¨|׳׳×׳ ׳”|׳—׳©׳׳׳׳™|׳׳׳׳|׳׳׳׳ ׳×|׳§׳•׳¡׳׳˜׳™׳§׳׳™׳×|׳׳¡׳₪׳¨׳”|׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨|׳׳¢׳¦׳‘ ׳©׳¢׳¨|׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨|׳¦׳׳|׳ ׳™׳§׳™׳•׳|׳‘׳™׳‘׳™׳¡׳™׳˜׳¨|׳׳’׳•)$/.test(cleanQuery)) || // נ¯ FIX: Added "׳©׳™׳¨׳•׳×" / "׳©׳¨׳•׳×"
                                           // נ¯ FIX: "׳¦׳¢׳¦׳•׳¢ ׳׳™׳׳“" / "׳¦׳¢׳¦׳•׳¢׳™׳ ׳׳™׳׳“" - even without "׳™׳©", "׳׳—׳™׳¨", "׳—׳ ׳•׳×"
                                           (lowerMessage.includes('׳¦׳¢׳¦׳•׳¢') && (lowerMessage.includes('׳׳™׳׳“') || lowerMessage.includes('׳׳™׳׳“׳™׳'))) ||
                                           (lowerMessage.includes('׳¦׳¢׳¦׳•׳¢׳™׳') && (lowerMessage.includes('׳׳™׳׳“') || lowerMessage.includes('׳׳™׳׳“׳™׳')))
                                       ));
                
                console.log('נ¯ [DECISION] isProductQuery:', isProductQuery, '| matchesPageInMarketplace:', matchesPageInMarketplace);
                console.log('נ¯ [DECISION] hasProductKeyword:', hasProductKeyword, '| hasServiceKeyword:', hasServiceKeyword);
                console.log('נ¯ [DECISION] cleanQuery:', cleanQuery, '| isVagueQuery:', isVagueQuery, '| isGeneralQuestion:', isGeneralQuestion);
                console.log('נ¯ [DECISION] lowerMessage:', lowerMessage);
                
                // Check if query is about specific store/business info (phone, city, etc.)
                const businessInfoPatterns = [
                    /(?:׳׳”|׳׳™׳–׳”)\s*(?:׳”׳˜׳׳₪׳•׳|׳”׳›׳×׳•׳‘׳×|׳”׳¢׳™׳¨|׳”׳׳™׳™׳)\s*(?:׳©׳|׳‘)\s*([׳-׳×a-zA-Z]+)/i,
                    /(?:׳‘׳׳™׳–׳”|׳׳™׳₪׳”)\s+(?:׳¢׳™׳¨|׳׳™׳§׳•׳)\s+(?:׳”׳—׳ ׳•׳×|׳”׳¢׳¡׳§|׳”׳“׳£)\s*([׳-׳×a-zA-Z]+)/i
                ];
                let requestedBusiness = null;
                for (const pattern of businessInfoPatterns) {
                    const match = userMessage.match(pattern);
                    if (match && match[1]) {
                        requestedBusiness = match[1].trim();
                        console.log('נ× Business info query detected for:', requestedBusiness);
                        break;
                    }
                }
                
                // נ¯ FIX: Handle "׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳" / "׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳™׳§׳¨" locally - don't send to N8N!
                // BUT: "׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳" / "׳¨׳©׳™׳׳× ׳׳•׳¦׳¨׳™׳" / "׳×׳¨׳׳™ ׳׳•׳¦׳¨׳™׳" SHOULD show price list!
                // נ¯ NEW: Also detect "׳¨׳©׳™׳׳” ׳©׳ ׳›׳ X" pattern (e.g., "׳¨׳©׳™׳׳” ׳©׳ ׳›׳ ׳”׳¦׳¢׳¦׳•׳¢׳™׳")
                // נ¯ NEW: Also detect "׳׳—׳™׳¨׳™׳ ׳©׳ ׳”׳›׳" - show all prices with calculation
                const isPriceListQuery = lowerMessage.includes('׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳') || lowerMessage.includes('׳¨׳©׳™׳׳× ׳׳•׳¦׳¨׳™׳') ||
                                         lowerMessage.includes('׳׳—׳™׳¨׳™׳ ׳©׳ ׳”׳›׳') || lowerMessage.includes('׳׳—׳™׳¨׳™ ׳”׳›׳') ||
                                         lowerMessage.includes('׳×׳¨׳׳™ ׳׳•׳¦׳¨׳™׳') || lowerMessage.includes('׳×׳¨׳׳™ ׳׳—׳™׳¨׳™׳') ||
                                         lowerMessage.includes('׳׳•׳¦׳¨׳™׳ ׳•׳׳—׳™׳¨׳™׳') || lowerMessage.includes('׳׳•׳¦׳¨׳™׳ ׳׳—׳™׳¨׳™׳') ||
                                         (lowerMessage.includes('׳×׳¨׳׳™') && (lowerMessage.includes('׳׳•׳¦׳¨') || lowerMessage.includes('׳׳—׳™׳¨'))) ||
                                         lowerMessage.includes('׳”׳¨׳׳™ ׳׳•׳¦׳¨׳™׳') || lowerMessage.includes('׳”׳¨׳׳™ ׳׳—׳™׳¨׳™׳') ||
                                         lowerMessage.includes('׳¨׳©׳™׳׳” ׳©׳ ׳׳•׳¦׳¨׳™׳') || lowerMessage.includes('׳¨׳©׳™׳׳” ׳©׳ ׳׳—׳™׳¨׳™׳') ||
                                         lowerMessage.includes('׳×׳ ׳™ ׳¨׳©׳™׳׳×') || lowerMessage.includes('׳×׳ ׳™ ׳׳™ ׳¨׳©׳™׳׳×') ||
                                         lowerMessage.includes('׳×׳ ׳™ ׳׳× ׳¨׳©׳™׳׳×') || lowerMessage.includes('׳×׳‘׳™׳ ׳׳™ ׳¨׳©׳™׳׳×') || lowerMessage.includes('׳×׳‘׳™׳׳™ ׳׳™ ׳¨׳©׳™׳׳×') || // נ¯ NEW: "׳×׳‘׳™׳ ׳׳™ ׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳"
                                         lowerMessage.includes('׳×׳‘׳™׳ ׳¨׳©׳™׳׳×') || lowerMessage.includes('׳×׳‘׳™׳׳™ ׳¨׳©׳™׳׳×') || // נ¯ NEW: "׳×׳‘׳™׳ ׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳"
                                         /׳×׳‘׳™׳(?:׳™)?\s+׳׳™?\s+׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳©׳\s+)?(?:׳׳—׳™׳¨׳™׳|׳׳•׳¦׳¨׳™׳)/i.test(userMessage) || // נ¯ NEW: Pattern match for "׳×׳‘׳™׳ ׳׳™ ׳¨׳©׳™׳׳×"
                                         lowerMessage.includes('׳׳₪׳©׳¨ ׳¢׳•׳“ ׳¨׳©׳™׳׳×') || lowerMessage.includes('׳׳₪׳©׳¨ ׳¢׳•׳“ ׳¨׳©׳™׳׳”') || // נ¯ NEW: "׳׳₪׳©׳¨ ׳¢׳•׳“ ׳¨׳©׳™׳׳× ׳׳•׳¦׳¨׳™׳"
                                         lowerMessage.includes('׳›׳ ׳”׳׳•׳¦׳¨׳™׳') ||
                                         lowerMessage.includes('׳׳ ׳™ ׳¨׳•׳¦׳” ׳¨׳©׳™׳׳×') || lowerMessage.includes('׳׳ ׳™ ׳¨׳•׳¦׳” ׳¨׳©׳™׳׳”') || // נ¯ NEW: "׳׳ ׳™ ׳¨׳•׳¦׳” ׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳"
                                         /׳׳ ׳™\s+׳¨׳•׳¦׳”\s+׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳©׳\s+)?(?:׳׳—׳™׳¨׳™׳|׳׳•׳¦׳¨׳™׳)/i.test(userMessage) || // נ¯ NEW: Pattern match
                                         lowerMessage.includes('׳¨׳©׳™׳׳” ׳©׳ ׳›׳') || // נ¯ NEW: "׳¨׳©׳™׳׳” ׳©׳ ׳›׳ X"
                                         /׳¨׳©׳™׳׳”\s+׳©׳\s+(?:׳׳—׳™׳¨׳™׳|׳׳•׳¦׳¨׳™׳|׳¦׳¢׳¦׳•׳¢׳™׳)/i.test(userMessage) || // נ¯ NEW: "׳¨׳©׳™׳׳” ׳©׳ ׳׳—׳™׳¨׳™׳/׳׳•׳¦׳¨׳™׳/׳¦׳¢׳¦׳•׳¢׳™׳"
                                         /׳¨׳©׳™׳׳”\s+׳©׳\s+׳›׳\s+([׳-׳×\s]+)/i.test(userMessage) || // נ¯ NEW: "׳¨׳©׳™׳׳” ׳©׳ ׳›׳ ׳”׳¦׳¢׳¦׳•׳¢׳™׳"
                                         /׳›׳\s+׳”׳¦׳¢׳¦׳•׳¢׳™׳/i.test(userMessage) || // נ¯ NEW: "׳›׳ ׳”׳¦׳¢׳¦׳•׳¢׳™׳"
                                         /׳›׳\s+׳”׳׳•׳¦׳¨׳™׳/i.test(userMessage) || // נ¯ NEW: "׳›׳ ׳”׳׳•׳¦׳¨׳™׳"
                                         /(?:׳”)?(?:׳׳—׳™׳¨׳™׳|׳™׳©\s+׳׳—׳™׳¨׳™׳)\s+׳©׳\s+([׳-׳×\s]{2,20})/.test(userMessage) || // "׳׳—׳™׳¨׳™׳ ׳©׳ ׳¦׳¢׳¦׳•׳¢׳™׳" OR "׳”׳׳—׳™׳¨׳™׳ ׳©׳ ׳¦׳¢׳¦׳•׳¢׳™׳"
                                         /׳׳™׳–׳”\s+(?:׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳™׳©/i.test(userMessage) || // נ¯ NEW: "׳׳™׳–׳” ׳¦׳¢׳¦׳•׳¢׳™׳ ׳™׳©"
                                         /׳׳”\s+(?:׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳™׳©/i.test(userMessage) || // נ¯ NEW: "׳׳” ׳¦׳¢׳¦׳•׳¢׳™׳ ׳™׳©"
                                         // נ¯ FIX: "׳¦׳¢׳¦׳•׳¢׳™׳ ׳׳™׳׳“׳™׳ ׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳" or "׳¦׳¢׳¦׳•׳¢׳™׳ ׳׳™׳׳“׳™׳ ׳¨׳©׳™׳׳” ׳©׳ ׳׳—׳™׳¨׳™׳"
                                         /(?:׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳(?:׳™׳׳“׳™׳|׳™׳׳“)\s+׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳©׳\s+)?׳׳—׳™׳¨׳™׳/i.test(userMessage) || // נ¯ NEW: "׳¦׳¢׳¦׳•׳¢׳™׳ ׳׳™׳׳“׳™׳ ׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳"
                                         /׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳©׳\s+)?׳׳—׳™׳¨׳™׳\s+(?:׳)?(?:׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳(?:׳™׳׳“׳™׳|׳™׳׳“)/i.test(userMessage); // נ¯ NEW: "׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳ ׳¦׳¢׳¦׳•׳¢׳™׳ ׳׳™׳׳“׳™׳"
                
                // נ¯ NEW: Extract category from "׳׳—׳™׳¨׳™׳ ׳©׳ X" or "׳”׳׳—׳™׳¨׳™׳ ׳©׳ X" or "׳¨׳©׳™׳׳” ׳©׳ ׳›׳ X" query
                let priceListCategory = null;
                if (isPriceListQuery) {
                    // Try "׳¨׳©׳™׳׳” ׳©׳ ׳›׳ X" pattern first (e.g., "׳¨׳©׳™׳׳” ׳©׳ ׳›׳ ׳”׳¦׳¢׳¦׳•׳¢׳™׳")
                    const allListMatch = userMessage.match(/׳¨׳©׳™׳׳”\s+׳©׳\s+׳›׳\s+(?:׳”)?([׳-׳×\s]+)/i);
                    if (allListMatch && allListMatch[1]) {
                        priceListCategory = allListMatch[1].trim();
                        console.log(`נ“‹ Price list query (all items) for category: "${priceListCategory}"`);
                        } else {
                            // Try "׳¨׳©׳™׳׳” ׳©׳ ׳׳—׳™׳¨׳™׳ ׳•׳׳•׳¦׳¨׳™׳" or "׳×׳‘׳™׳ ׳׳™ ׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳ ׳•׳׳•׳¦׳¨׳™׳"
                            // נ¯ NEW: Handle "׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳ ׳•׳׳•׳¦׳¨׳™׳" or "׳¨׳©׳™׳׳” ׳©׳ ׳׳—׳™׳¨׳™׳ ׳•׳¦׳¢׳¦׳•׳¢׳™׳" - extract the category
                            // נ¯ IMPROVED: Better pattern to extract category from "׳׳—׳™׳¨׳™׳ ׳•׳¦׳¢׳¦׳•׳¢׳™׳"
                            const listWithMultiple1 = userMessage.match(/׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳©׳\s+)?׳׳—׳™׳¨׳™׳\s+׳•(׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)/i);
                            const listWithMultiple2 = userMessage.match(/׳×׳‘׳™׳(?:׳™)?\s+׳׳™?\s+׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳©׳\s+)?׳׳—׳™׳¨׳™׳\s+׳•(׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)/i);
                            const listWithMultiple = listWithMultiple1 || listWithMultiple2;
                            
                            if (listWithMultiple && listWithMultiple[1]) {
                                priceListCategory = listWithMultiple[1].trim();
                                console.log(`נ“‹ Price list query detected: "׳׳—׳™׳¨׳™׳ ׳•${priceListCategory}" -> category: "${priceListCategory}"`);
                            } else if (/׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳׳—׳™׳¨׳™׳\s+׳•)?׳׳•׳¦׳¨׳™׳/i.test(userMessage) || 
                                /׳×׳‘׳™׳(?:׳™)?\s+׳׳™?\s+׳¨׳©׳™׳(?:׳”|׳×)\s+׳׳—׳™׳¨׳™׳\s+׳•?׳׳•׳¦׳¨׳™׳/i.test(userMessage)) {
                                priceListCategory = '׳׳•׳¦׳¨׳™׳'; // Default to "׳׳•׳¦׳¨׳™׳" for "׳׳—׳™׳¨׳™׳ ׳•׳׳•׳¦׳¨׳™׳"
                                console.log(`נ“‹ Price list query detected: "׳׳—׳™׳¨׳™׳ ׳•׳׳•׳¦׳¨׳™׳" -> category: "${priceListCategory}"`);
                            } else {
                                // Try "׳¨׳©׳™׳׳” ׳©׳ X" pattern (e.g., "׳¨׳©׳™׳׳” ׳©׳ ׳׳—׳™׳¨׳™׳", "׳¨׳©׳™׳׳” ׳©׳ ׳¦׳¢׳¦׳•׳¢׳™׳")
                                const listOfMatch = userMessage.match(/׳¨׳©׳™׳(?:׳”|׳×)\s+׳©׳\s+(?:׳׳—׳™׳¨׳™׳\s+׳©׳\s+)?([׳-׳×\s]{2,20})/i);
                                if (listOfMatch && listOfMatch[1]) {
                                    priceListCategory = listOfMatch[1].trim();
                                    console.log(`נ“‹ Price list query for category: "${priceListCategory}"`);
                                } else {
                                    // Try "׳׳—׳™׳¨׳™׳ ׳©׳ X" pattern
                    const categoryMatch = userMessage.match(/(?:׳”)?(?:׳׳—׳™׳¨׳™׳|׳™׳©\s+׳׳—׳™׳¨׳™׳)\s+׳©׳\s+([׳-׳×\s]{2,20})/i);
                    if (categoryMatch && categoryMatch[1]) {
                        priceListCategory = categoryMatch[1].trim();
                        console.log(`נ“‹ Price list query for category: "${priceListCategory}"`);
                                    }
                                }
                            }
                        }
                    
                    // נ¯ NEW: Also handle "׳›׳ ׳”׳¦׳¢׳¦׳•׳¢׳™׳" or "׳›׳ ׳”׳׳•׳¦׳¨׳™׳" without "׳¨׳©׳™׳׳”"
                    if (!priceListCategory) {
                        if (/׳›׳\s+׳”׳¦׳¢׳¦׳•׳¢׳™׳/i.test(userMessage)) {
                            priceListCategory = '׳¦׳¢׳¦׳•׳¢׳™׳';
                        } else if (/׳›׳\s+׳”׳׳•׳¦׳¨׳™׳/i.test(userMessage)) {
                            priceListCategory = '׳׳•׳¦׳¨׳™׳';
                        } else if (/׳¨׳©׳™׳(?:׳”|׳×)\s+׳©׳\s+׳¦׳¢׳¦׳•׳¢׳™׳/i.test(userMessage)) {
                            priceListCategory = '׳¦׳¢׳¦׳•׳¢׳™׳';
                        } else if (/׳¨׳©׳™׳(?:׳”|׳×)\s+׳©׳\s+׳׳•׳¦׳¨׳™׳/i.test(userMessage)) {
                            priceListCategory = '׳׳•׳¦׳¨׳™׳';
                        } else if (/׳׳™׳–׳”\s+׳¦׳¢׳¦׳•׳¢׳™׳\s+׳™׳©/i.test(userMessage)) {
                            priceListCategory = '׳¦׳¢׳¦׳•׳¢׳™׳'; // נ¯ NEW: "׳׳™׳–׳” ׳¦׳¢׳¦׳•׳¢׳™׳ ׳™׳©"
                        } else if (/׳׳”\s+׳¦׳¢׳¦׳•׳¢׳™׳\s+׳™׳©/i.test(userMessage)) {
                            priceListCategory = '׳¦׳¢׳¦׳•׳¢׳™׳'; // נ¯ NEW: "׳׳” ׳¦׳¢׳¦׳•׳¢׳™׳ ׳™׳©"
                        } else if (/׳׳™׳–׳”\s+׳׳•׳¦׳¨׳™׳\s+׳™׳©/i.test(userMessage)) {
                            priceListCategory = '׳׳•׳¦׳¨׳™׳'; // נ¯ NEW: "׳׳™׳–׳” ׳׳•׳¦׳¨׳™׳ ׳™׳©"
                        } else if (/׳׳”\s+׳׳•׳¦׳¨׳™׳\s+׳™׳©/i.test(userMessage)) {
                            priceListCategory = '׳׳•׳¦׳¨׳™׳'; // נ¯ NEW: "׳׳” ׳׳•׳¦׳¨׳™׳ ׳™׳©"
                        } else if (/׳׳₪׳©׳¨\s+׳¢׳•׳“\s+׳¨׳©׳™׳(?:׳”|׳×)/i.test(userMessage)) {
                            // נ¯ NEW: "׳׳₪׳©׳¨ ׳¢׳•׳“ ׳¨׳©׳™׳׳× ׳׳•׳¦׳¨׳™׳" or "׳׳₪׳©׳¨ ׳¢׳•׳“ ׳¨׳©׳™׳׳× ׳¦׳¢׳¦׳•׳¢׳™׳"
                            // Try to extract category from the query
                            const match1 = userMessage.match(/׳׳₪׳©׳¨\s+׳¢׳•׳“\s+׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳©׳\s+)?(?:׳׳—׳™׳¨׳™׳\s+׳•)?(׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)/i);
                            // Also check if category appears later in the query (e.g., "׳׳₪׳©׳¨ ׳¢׳•׳“ ׳¨׳©׳™׳׳× ׳׳•׳¦׳¨׳™׳ ׳׳™׳–׳” ׳¦׳¢׳¦׳•׳¢׳™׳ ׳™׳©")
                            const match2 = userMessage.match(/׳׳™׳–׳”\s+(׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳™׳©/i);
                            const match3 = userMessage.match(/׳׳”\s+(׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳™׳©/i);
                            
                            const match = match1 || match2 || match3;
                            if (match && match[1]) {
                                priceListCategory = match[1].trim();
                                console.log(`נ“‹ Price list query detected: "׳׳₪׳©׳¨ ׳¢׳•׳“ ׳¨׳©׳™׳׳× ${priceListCategory}" -> category: "${priceListCategory}"`);
                            } else {
                                priceListCategory = '׳׳•׳¦׳¨׳™׳'; // Default
                            }
                        } else if (/(?:׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳(?:׳™׳׳“׳™׳|׳™׳׳“)\s+׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳©׳\s+)?׳׳—׳™׳¨׳™׳/i.test(userMessage)) {
                            // נ¯ FIX: "׳¦׳¢׳¦׳•׳¢׳™׳ ׳׳™׳׳“׳™׳ ׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳" - extract "׳¦׳¢׳¦׳•׳¢׳™׳"
                            const match = userMessage.match(/(׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳(?:׳™׳׳“׳™׳|׳™׳׳“)\s+׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳©׳\s+)?׳׳—׳™׳¨׳™׳/i);
                            if (match && match[1]) {
                                priceListCategory = match[1].trim();
                                console.log(`נ“‹ Price list query detected: "${priceListCategory} ׳׳™׳׳“׳™׳ ׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳" -> category: "${priceListCategory}"`);
                            }
                        } else if (/׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳©׳\s+)?׳׳—׳™׳¨׳™׳\s+(?:׳)?(?:׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳(?:׳™׳׳“׳™׳|׳™׳׳“)/i.test(userMessage)) {
                            // נ¯ FIX: "׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳ ׳¦׳¢׳¦׳•׳¢׳™׳ ׳׳™׳׳“׳™׳" - extract "׳¦׳¢׳¦׳•׳¢׳™׳"
                            const match = userMessage.match(/׳¨׳©׳™׳(?:׳”|׳×)\s+(?:׳©׳\s+)?׳׳—׳™׳¨׳™׳\s+(?:׳)?(׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳(?:׳™׳׳“׳™׳|׳™׳׳“)/i);
                            if (match && match[1]) {
                                priceListCategory = match[1].trim();
                                console.log(`נ“‹ Price list query detected: "׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳ ${priceListCategory} ׳׳™׳׳“׳™׳" -> category: "${priceListCategory}"`);
                            }
                        } else {
                            // נ¯ NEW: Check if this is "׳׳—׳™׳¨׳™׳ ׳©׳ ׳”׳›׳" - show all prices with calculation
                            if (lowerMessage.includes('׳׳—׳™׳¨׳™׳ ׳©׳ ׳”׳›׳') || lowerMessage.includes('׳׳—׳™׳¨׳™ ׳”׳›׳') || lowerMessage.includes('׳›׳ ׳”׳׳—׳™׳¨׳™׳')) {
                                priceListCategory = '׳”׳›׳'; // Special category for "all prices"
                                console.log(`נ“‹ Price list query detected: "׳׳—׳™׳¨׳™׳ ׳©׳ ׳”׳›׳" - showing all prices with calculation`);
                        } else {
                            // נ¯ NEW: Try to extract category from patterns like "׳¨׳©׳™׳׳” ׳©׳ X ׳‘׳׳—׳™׳¨׳™׳" or "׳¨׳©׳™׳׳” ׳©׳ X"
                            // Pattern 1: "׳¨׳©׳™׳׳” ׳©׳ ׳¦׳¢׳¦׳•׳¢׳™׳ ׳‘׳׳—׳™׳¨׳™׳"
                            const listWithCategory = userMessage.match(/׳¨׳©׳™׳(?:׳”|׳×)\s+׳©׳\s+([׳-׳×\s]+?)(?:\s+׳‘׳׳—׳™׳¨׳™׳|\s+׳•׳׳—׳™׳¨׳™׳|$)/i);
                            if (listWithCategory && listWithCategory[1]) {
                                priceListCategory = listWithCategory[1].trim();
                                // Clean up category (remove "׳‘׳׳—׳™׳¨׳™׳", "׳•׳׳—׳™׳¨׳™׳", etc.)
                                priceListCategory = priceListCategory.replace(/\s+(?:׳‘׳׳—׳™׳¨׳™׳|׳•׳׳—׳™׳¨׳™׳|׳•׳׳¦׳¨׳™׳).*$/i, '').trim();
                                if (priceListCategory.length > 1 && !priceListCategory.match(/^(׳׳—׳™׳¨׳™׳|׳׳•׳¦׳¨׳™׳)$/i)) {
                                    console.log(`נ“‹ Extracted category from "׳¨׳©׳™׳׳” ׳©׳ X": "${priceListCategory}"`);
                                } else {
                                    priceListCategory = null; // Reset if not valid
                                }
                            }
                            
                            // Pattern 2: "׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳ ׳©׳ ׳¦׳¢׳¦׳•׳¢׳™׳"
                            if (!priceListCategory) {
                                const pricesOfMatch = userMessage.match(/׳¨׳©׳™׳(?:׳”|׳×)\s+׳׳—׳™׳¨׳™׳\s+׳©׳\s+([׳-׳×\s]+)/i);
                                if (pricesOfMatch && pricesOfMatch[1]) {
                                    priceListCategory = pricesOfMatch[1].trim();
                                    console.log(`נ“‹ Extracted category from "׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳ ׳©׳ X": "${priceListCategory}"`);
                                }
                            }
                            
                            // Pattern 3: Direct category mention (last resort)
                            if (!priceListCategory) {
                                const directCategory = userMessage.match(/(׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§|׳׳×׳ ׳•׳×)/i);
                                if (directCategory && directCategory[1]) {
                                    priceListCategory = directCategory[1];
                                    console.log(`נ“‹ Found direct category mention: "${priceListCategory}"`);
                                }
                            }
                        }
                    }
                    
                    // נ¯ SPECIAL: If user asks for product list and we have pages in context, show products from those pages
                    const asksForProductListOfCurrentContext = /׳×׳ ׳™.*׳¨׳©׳™׳׳×|׳×׳ ׳™.*׳׳×.*׳¨׳©׳™׳׳×|׳¨׳©׳™׳׳×.*׳׳•׳¦׳¨׳™׳.*׳‘|׳׳•׳¦׳¨׳™׳.*׳‘׳—׳ ׳•׳×|׳‘׳—׳ ׳•׳×.*׳”׳–׳׳×|׳‘׳׳×׳¨.*׳”׳–׳”/i.test(userMessage);
                    if (asksForProductListOfCurrentContext && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                        console.log('נ“‹ User asking for product list from current context pages');
                        const textResponse = await generateTextResponseWithRealData(window.stavCurrentPages, userMessage, false);
                        return {
                            type: 'text',
                            message: textResponse
                        };
                    }
                }
                
                // נ¯ NEW: Handle "׳©׳¢׳•׳ ׳™׳ ׳¢׳“ 2000׳©" / "׳׳•׳¦׳¨׳™׳ ׳¢׳“ X ׳©׳§׳" queries - filter by max price
                // נ¯ NEW: Also handle "׳™׳© ׳׳™ ׳×׳§׳¦׳™׳‘ ׳©׳ X ׳×׳׳׳™׳¦׳™ ׳׳™" - budget recommendations
                const maxPricePattern = /(?:׳¢׳“|׳¢׳“\s+|׳×׳§׳¦׳™׳‘\s+׳©׳|׳×׳§׳¦׳™׳‘\s+)?(\d+)\s*(?:׳©|׳©׳§׳|׳©"׳—|ג‚×)/i;
                const maxPriceMatch = userMessage.match(maxPricePattern);
                const maxPrice = maxPriceMatch ? parseFloat(maxPriceMatch[1]) : null;
                
                // נ¯ NEW: Check if this is a budget recommendation query ("׳™׳© ׳׳™ ׳×׳§׳¦׳™׳‘ ׳©׳ X ׳×׳׳׳™׳¦׳™ ׳׳™")
                const isBudgetRecommendation = (lowerMessage.includes('׳×׳§׳¦׳™׳‘') || lowerMessage.includes('׳×׳׳׳™׳¦׳™')) && 
                                               (lowerMessage.includes('׳×׳׳׳™׳¦׳™') || lowerMessage.includes('׳×׳׳׳™׳¥') || lowerMessage.includes('׳”׳׳׳¦')) &&
                                               maxPrice !== null;
                
                // נ¯ NEW: Handle "׳׳” ׳”׳׳—׳™׳¨ ׳©׳ X" or "׳׳—׳™׳¨ ׳©׳ X" queries locally - find specific product and return price
                // BUT: Skip if it's "׳׳—׳™׳¨׳™׳ ׳©׳ X" (plural) - that's a price list query!
                const isGeneralPriceListQuery = /׳׳—׳™׳¨׳™׳\s+׳©׳|׳™׳©\s+׳׳—׳™׳¨׳™׳/.test(userMessage);
                // נ¯ IMPROVED: Also match "׳׳—׳₪׳© ׳׳—׳™׳¨ ׳©׳ X", "X ׳׳” ׳”׳׳—׳™׳¨", "X ׳׳” ׳׳—׳™׳¨"
                const specificProductPricePattern = /(?:׳׳”|׳׳™׳–׳”)?\s*(?:׳”׳׳—׳™׳¨|׳׳—׳™׳¨|׳”׳׳—׳™׳¨ ׳©׳)\s*(?:׳©׳|׳‘)?\s*([׳-׳×\s]{3,30})/i;
                const specificProductPriceMatch1 = !isGeneralPriceListQuery ? userMessage.match(specificProductPricePattern) : null;
                // נ¯ NEW: Match "׳׳—׳₪׳© ׳׳—׳™׳¨ ׳©׳ X" or "X ׳׳” ׳”׳׳—׳™׳¨"
                const specificProductPricePattern2 = /(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×)\s+׳׳—׳™׳¨\s+׳©׳\s+([׳-׳×\s]{3,30})/i;
                const specificProductPriceMatch2 = !isGeneralPriceListQuery ? userMessage.match(specificProductPricePattern2) : null;
                // נ¯ NEW: Match "X ׳׳” ׳”׳׳—׳™׳¨" or "X ׳׳” ׳׳—׳™׳¨"
                const specificProductPricePattern3 = /^([׳-׳×\s]{3,30})\s+׳׳”\s+(?:׳”)?׳׳—׳™׳¨/i;
                const specificProductPriceMatch3 = !isGeneralPriceListQuery ? userMessage.match(specificProductPricePattern3) : null;
                
                const specificProductPriceMatch = specificProductPriceMatch1 || specificProductPriceMatch2 || specificProductPriceMatch3;
                
                // נ¯ NEW: Also handle "׳׳—׳™׳¨ ׳©׳ X ׳”׳›׳™ ׳–׳•׳" queries
                const cheapestProductPricePattern = /(?:׳׳”|׳׳™׳–׳”)?\s*(?:׳”׳׳—׳™׳¨|׳׳—׳™׳¨)\s*(?:׳©׳|׳‘)?\s*([׳-׳×\s]{3,30})\s*(?:׳”׳›׳™\s*׳–׳•׳|׳”׳›׳™\s*׳–׳•׳׳”)/i;
                const cheapestProductPriceMatch = userMessage.match(cheapestProductPricePattern);
                
                // Handle "׳׳—׳™׳¨ ׳©׳ X ׳”׳›׳™ ׳–׳•׳" - find cheapest product matching the category
                if (cheapestProductPriceMatch && cheapestProductPriceMatch[1]) {
                    const categoryName = cheapestProductPriceMatch[1].trim();
                    console.log(`נ’° Cheapest product in category query detected: "${categoryName}"`);
                    
                    // Search all store pages for products in this category
                    const storePages = (allPages || []).filter(page => page.pageType === 'store');
                    let allProducts = [];
                    
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            const liveProducts = extractLiveProducts(html);
                            
                            // Check if page title or products match the category
                            const pageTitleLower = (page.title || '').toLowerCase();
                            const categoryNameLower = categoryName.toLowerCase();
                            
                            if (pageTitleLower.includes(categoryNameLower) || categoryNameLower.includes(pageTitleLower)) {
                                liveProducts.forEach(product => {
                                    const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                    if (price >= 2 && price < 100000) {
                                        allProducts.push({
                                            ...product,
                                            pageTitle: page.title,
                                            pageUrl: pageUrl,
                                            userId: page.userId,
                                            pageId: page.pageId
                                        });
                                    }
                                });
                            } else {
                                // Check if products match the category
                                for (const product of liveProducts) {
                                    const productNameLower = (product.name || '').toLowerCase();
                                    if (productNameLower.includes(categoryNameLower) || categoryNameLower.includes(productNameLower.split(' ')[0])) {
                                        const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                        if (price >= 2 && price < 100000) {
                                            allProducts.push({
                                                ...product,
                                                pageTitle: page.title,
                                                pageUrl: pageUrl,
                                                userId: page.userId,
                                                pageId: page.pageId
                                            });
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('Error searching for product:', error);
                        }
                    }
                    
                    if (allProducts.length > 0) {
                        // Sort by price and get cheapest
                        allProducts.sort((a, b) => {
                            const priceA = parseFloat(String(a.price || 0).replace(/[,\s]/g, ''));
                            const priceB = parseFloat(String(b.price || 0).replace(/[,\s]/g, ''));
                            return priceA - priceB;
                        });
                        
                        const cheapest = allProducts[0];
                        const price = parseFloat(String(cheapest.price || 0).replace(/[,\s]/g, ''));
                        
                        return {
                            type: 'message',
                            message: `נ’° **${cheapest.name}** ׳‘-${cheapest.pageTitle} ׳¢׳•׳׳” **ג‚×${price.toLocaleString()}**\n\n׳–׳” ׳”׳¦׳¢׳¦׳•׳¢ ׳”׳›׳™ ׳–׳•׳ ׳‘׳§׳˜׳’׳•׳¨׳™׳” "${categoryName}"\n\nנ”— [׳¦׳₪׳” ׳‘׳“׳£](${cheapest.pageUrl})`
                        };
                    } else {
                        return {
                            type: 'message',
                            message: `׳׳¦׳˜׳¢׳¨, ׳׳ ׳׳¦׳׳×׳™ ׳¦׳¢׳¦׳•׳¢׳™׳ ׳‘׳§׳˜׳’׳•׳¨׳™׳” "${categoryName}" ׳‘׳׳¢׳¨׳›׳×.`
                        };
                    }
                }
                
                if (specificProductPriceMatch && specificProductPriceMatch[1]) {
                    const productName = specificProductPriceMatch[1].trim();
                    console.log(`נ’° Specific product price query detected: "${productName}"`);
                    
                    // נ¯ Helper function to normalize text (handle typos/variations)
                    const normalizeText = (text) => {
                        return text
                            .toLowerCase()
                            .replace(/׳׳™׳¨׳•׳¥|׳׳¨׳•׳¥/g, '׳׳™׳¨׳•׳¥') // Normalize "׳׳™׳¨׳•׳¥" variations
                            .replace(/׳—׳‘׳¨׳•׳×׳™|׳—׳‘׳¨׳•׳×/g, '׳—׳‘׳¨׳•׳×׳™') // Normalize "׳—׳‘׳¨׳•׳×׳™" variations
                            .replace(/׳‘׳•׳‘׳”|׳‘׳•׳‘׳×/g, '׳‘׳•׳‘׳”') // Normalize "׳‘׳•׳‘׳”" variations
                            .trim();
                    };
                    
                    // נ¯ Helper function to calculate similarity score between two strings
                    const calculateSimilarity = (str1, str2) => {
                        const s1 = normalizeText(str1);
                        const s2 = normalizeText(str2);
                        
                        // Exact match
                        if (s1 === s2) return 100;
                        
                        // One contains the other
                        if (s1.includes(s2) || s2.includes(s1)) return 80;
                        
                        // Word-by-word matching
                        const words1 = s1.split(/\s+/).filter(w => w.length >= 2);
                        const words2 = s2.split(/\s+/).filter(w => w.length >= 2);
                        
                        if (words1.length === 0 || words2.length === 0) return 0;
                        
                        let matchingWords = 0;
                        for (const w1 of words1) {
                            for (const w2 of words2) {
                                if (w1 === w2 || w1.includes(w2) || w2.includes(w1)) {
                                    matchingWords++;
                                    break;
                                }
                            }
                        }
                        
                        // Calculate similarity based on matching words
                        const similarity = (matchingWords / Math.max(words1.length, words2.length)) * 100;
                        return similarity;
                    };
                    
                    // Search all store pages for this specific product
                    const storePages = (allPages || []).filter(page => page.pageType === 'store');
                    let foundProduct = null;
                    let foundPage = null;
                    let similarProducts = []; // נ¯ NEW: Store similar products for recommendations
                    
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            const liveProducts = extractLiveProducts(html);
                            
                            // Find product that matches the query - improved matching for partial names
                            const productNameLower = productName.toLowerCase().trim();
                            // Remove common words that might interfere
                            const cleanProductName = productNameLower.replace(/\s+(׳©׳|׳‘|׳׳‘׳|׳׳|׳׳•|׳¢׳)\s+/g, ' ').trim();
                            
                            for (const product of liveProducts) {
                                const productNameLower2 = (product.name || '').toLowerCase().trim();
                                    const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                
                                // Skip invalid products
                                if (price < 2 || price >= 100000) continue;
                                
                                // נ¯ Calculate similarity score
                                const similarity = calculateSimilarity(cleanProductName, productNameLower2);
                                
                                // Exact or very high similarity match
                                if (similarity >= 80) {
                                        foundProduct = product;
                                        foundPage = page;
                                        break;
                                }
                                
                                // נ¯ Store similar products (similarity >= 40) for recommendations
                                if (similarity >= 40) {
                                    similarProducts.push({
                                        product: product,
                                        page: page,
                                        similarity: similarity,
                                        pageUrl: pageUrl
                                    });
                                }
                            }
                            if (foundProduct) break;
                        } catch (error) {
                            console.error('Error searching for product:', error);
                        }
                    }
                    
                    // נ¯ Sort similar products by similarity score (highest first)
                    similarProducts.sort((a, b) => b.similarity - a.similarity);
                    
                    if (foundProduct && foundPage) {
                        const price = parseFloat(String(foundProduct.price || 0).replace(/[,\s]/g, ''));
                        const pageUrl = `/users/${foundPage.userId}/${foundPage.pageId}_html`;
                        return {
                            type: 'message',
                            message: `נ’° **${foundProduct.name}** ׳‘-${foundPage.title} ׳¢׳•׳׳” **ג‚×${price.toLocaleString()}**\n\nנ”— [׳¦׳₪׳” ׳‘׳“׳£](${pageUrl})`
                        };
                    } else if (similarProducts.length > 0) {
                        // נ¯ NEW: Recommend similar products if exact match not found
                        const topSimilar = similarProducts.slice(0, 3); // Top 3 similar products
                        let message = `׳׳ ׳׳¦׳׳×׳™ ׳‘׳“׳™׳•׳§ "${productName}", ׳׳‘׳ ׳™׳© ׳׳•׳¦׳¨׳™׳ ׳“׳•׳׳™׳:\n\n`;
                        
                        topSimilar.forEach((item, index) => {
                            const price = parseFloat(String(item.product.price || 0).replace(/[,\s]/g, ''));
                            message += `${index + 1}. **${item.product.name}** ׳‘-${item.page.title} - ג‚×${price.toLocaleString()}\n`;
                        });
                        
                        message += `\nנ”— ׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳׳× ׳”׳׳•׳¦׳¨׳™׳?`;
                        
                        return {
                            type: 'message',
                            message: message
                        };
                    } else {
                        // נ¯ NEW: If no similar products found, search by category and recommend
                        // Extract category from product name (e.g., "׳¦׳¢׳¦׳•׳¢" from "׳׳—׳™׳¨ ׳©׳ ׳¦׳¢׳¦׳•׳¢")
                        const categoryKeywords = {
                            '׳¦׳¢׳¦׳•׳¢': '׳¦׳¢׳¦׳•׳¢',
                            '׳¦׳¢׳¦׳•׳¢׳™׳': '׳¦׳¢׳¦׳•׳¢',
                            '׳‘׳•׳‘׳”': '׳‘׳•׳‘׳”',
                            '׳‘׳•׳‘׳•׳×': '׳‘׳•׳‘׳”',
                            '׳׳›׳•׳ ׳™׳×': '׳׳›׳•׳ ׳™׳×',
                            '׳¨׳•׳‘׳•׳˜': '׳¨׳•׳‘׳•׳˜',
                            '׳¨׳›׳‘׳×': '׳¨׳›׳‘׳×'
                        };
                        
                        let category = null;
                        for (const [key, value] of Object.entries(categoryKeywords)) {
                            if (productName.toLowerCase().includes(key)) {
                                category = value;
                                            break;
                            }
                        }
                        
                        if (category) {
                            // Search for products in this category
                            const categoryProducts = [];
                            for (const page of storePages) {
                                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                try {
                                    const response = await fetch(pageUrl);
                                    if (!response.ok) continue;
                                    
                                    const html = await response.text();
                                    const liveProducts = extractLiveProducts(html);
                                    
                                    for (const product of liveProducts) {
                                        const productNameLower = (product.name || '').toLowerCase();
                                        if (productNameLower.includes(category)) {
                                    const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                    if (price >= 2 && price < 100000) {
                                                categoryProducts.push({
                                                    product: product,
                                                    page: page,
                                                    pageUrl: pageUrl,
                                                    price: price
                                                });
                                            }
                                        }
                                    }
                        } catch (error) {
                                    console.error('Error searching category products:', error);
                                }
                            }
                            
                            if (categoryProducts.length > 0) {
                                // Sort by price (cheapest first)
                                categoryProducts.sort((a, b) => a.price - b.price);
                                const topProducts = categoryProducts.slice(0, 3);
                                
                                let message = `׳׳ ׳׳¦׳׳×׳™ "${productName}", ׳׳‘׳ ׳™׳© ${categoryProducts.length} ${category === '׳¦׳¢׳¦׳•׳¢' ? '׳¦׳¢׳¦׳•׳¢׳™׳' : category === '׳‘׳•׳‘׳”' ? '׳‘׳•׳‘׳•׳×' : category + '׳™׳'} ׳‘׳׳¢׳¨׳›׳×:\n\n`;
                                
                                topProducts.forEach((item, index) => {
                                    message += `${index + 1}. **${item.product.name}** ׳‘-${item.page.title} - ג‚×${item.price.toLocaleString()}\n`;
                                });
                                
                                if (categoryProducts.length > 3) {
                                    message += `\n... ׳•׳¢׳•׳“ ${categoryProducts.length - 3} ${category === '׳¦׳¢׳¦׳•׳¢' ? '׳¦׳¢׳¦׳•׳¢׳™׳' : category === '׳‘׳•׳‘׳”' ? '׳‘׳•׳‘׳•׳×' : category + '׳™׳'}\n`;
                                }
                                
                                message += `\nנ”— ׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳׳× ׳›׳ ׳”${category === '׳¦׳¢׳¦׳•׳¢' ? '׳¦׳¢׳¦׳•׳¢׳™׳' : category === '׳‘׳•׳‘׳”' ? '׳‘׳•׳‘׳•׳×' : category + '׳™׳'}?`;
                                
                        return {
                            type: 'message',
                                    message: message
                        };
                            }
                        }
                        
                        return {
                            type: 'message',
                            message: `׳׳¦׳˜׳¢׳¨, ׳׳ ׳׳¦׳׳×׳™ ׳׳× ׳”׳׳•׳¦׳¨ "${productName}" ׳‘׳׳¢׳¨׳›׳×. ׳ ׳¡׳” ׳׳—׳₪׳© ׳‘׳׳•׳₪׳ ׳׳—׳¨.`
                        };
                    }
                }
                
                // נ¯ FIX: Handle "׳׳” ׳”׳¦׳¢׳¦׳•׳¢ ׳”׳›׳™ ׳–׳•׳" / "׳©׳¢׳•׳ ׳”׳›׳™ ׳–׳•׳" / "׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳" / "׳׳” ׳”׳׳×׳ ׳” ׳”׳›׳™ ׳–׳•׳׳”" - return DIRECT answer!
                // Also handle simple queries like "׳©׳¢׳•׳ ׳”׳›׳™ ׳–׳•׳" or "׳¦׳¢׳¦׳•׳¢ ׳”׳›׳™ ׳–׳•׳" or "׳׳×׳ ׳”" (without "׳׳”")
                if ((lowerMessage.includes('׳׳” ׳”׳¦׳¢׳¦׳•׳¢ ׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳׳” ׳”׳¦׳¢׳¦׳•׳¢ ׳”׳›׳™ ׳™׳§׳¨') ||
                    lowerMessage.includes('׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳™׳§׳¨') ||
                    lowerMessage.includes('׳׳” ׳”׳׳×׳ ׳” ׳”׳›׳™ ׳–׳•׳׳”') || lowerMessage.includes('׳׳” ׳”׳׳×׳ ׳” ׳”׳›׳™ ׳™׳§׳¨׳”') ||
                    lowerMessage.includes('׳”׳¦׳¢׳¦׳•׳¢ ׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳”׳¦׳¢׳¦׳•׳¢ ׳”׳›׳™ ׳™׳§׳¨') ||
                    lowerMessage.includes('׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳™׳§׳¨') ||
                    lowerMessage.includes('׳”׳׳×׳ ׳” ׳”׳›׳™ ׳–׳•׳׳”') || lowerMessage.includes('׳”׳׳×׳ ׳” ׳”׳›׳™ ׳™׳§׳¨׳”') ||
                    lowerMessage.includes('׳©׳¢׳•׳ ׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳©׳¢׳•׳ ׳”׳›׳™ ׳™׳§׳¨') ||
                    lowerMessage.includes('׳׳§ ׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳׳§ ׳”׳›׳™ ׳™׳§׳¨') ||
                    (lowerMessage.includes('׳”׳›׳™ ׳–׳•׳') && (lowerMessage.includes('׳׳•׳¦׳¨') || lowerMessage.includes('׳׳×׳ ׳”') || lowerMessage.includes('׳¦׳¢׳¦׳•׳¢') || lowerMessage.includes('׳©׳¢׳•׳') || lowerMessage.includes('׳׳§'))) ||
                    (lowerMessage.includes('׳”׳›׳™ ׳™׳§׳¨') && (lowerMessage.includes('׳׳•׳¦׳¨') || lowerMessage.includes('׳׳×׳ ׳”') || lowerMessage.includes('׳¦׳¢׳¦׳•׳¢') || lowerMessage.includes('׳©׳¢׳•׳') || lowerMessage.includes('׳׳§')))) &&
                    !isPriceListQuery) { // Don't handle locally if it's a "list prices" query
                    console.log('נ’° Price comparison query detected - handling locally, NOT sending to N8N!');
                    
                    // Search all store pages for products
                    const storePages = (allPages || []).filter(page => page.pageType === 'store');
                    let allProducts = [];
                    
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            const liveProducts = extractLiveProducts(html);
                            
                            liveProducts.forEach(product => {
                                allProducts.push({
                                    ...product,
                                    pageTitle: page.title,
                                    pageUrl: pageUrl,
                                    userId: page.userId,
                                    pageId: page.pageId
                                });
                            });
                        } catch (error) {
                            console.error('Error extracting products from', pageUrl, ':', error);
                        }
                    }
                    
                    if (allProducts.length > 0) {
                        // נ¯ FIX: Filter out invalid products (questions, taglines, etc.)
                        // Define exclude patterns (same as in extractLiveProducts)
                        const excludePatterns = [
                            '׳ ׳’׳™׳©׳•׳×', '׳׳•׳“׳•׳×', '׳¦׳•׳¨ ׳§׳©׳¨', '׳“׳£ ׳”׳‘׳™׳×', '׳¢׳׳™׳ ׳•', '׳×׳§׳ ׳•׳', '׳׳“׳™׳ ׳™׳•׳×', 
                            '׳₪׳¨׳˜׳™׳•׳×', '׳×׳ ׳׳™׳', '׳©׳™׳¨׳•׳×', '׳׳©׳׳•׳—׳™׳', '׳”׳—׳–׳¨׳•׳×', '׳׳™׳ ׳׳”׳–׳׳™׳',
                            '׳’׳׳¨׳™', '׳”׳׳•׳¦׳¨׳™׳', '׳×׳™׳׳•׳¨', '׳”׳׳™׳•׳—׳“׳™׳', '׳”׳›׳ ׳¢׳', '׳›׳ ׳”׳–׳›׳•׳™׳•׳×',
                            '׳–׳›׳•׳™׳•׳× ׳™׳•׳¦׳¨׳™׳', '׳‘׳¨׳•׳›׳™׳ ׳”׳‘׳׳™׳', '׳׳§׳•׳—׳•׳×', '׳©׳׳׳•׳×', '׳×׳©׳•׳‘׳•׳×',
                            '׳׳•׳¦׳¨׳™׳ ׳©׳׳ ׳•', '׳”׳׳•׳¦׳¨׳™׳ ׳©׳׳ ׳•', '׳×׳₪׳¨׳™׳˜', '׳›׳•׳×׳¨׳×', '׳›׳•׳×׳¨׳× ׳¨׳׳©׳™׳×',
                            '׳׳׳”', '׳׳׳” ׳׳‘׳—׳•׳¨', '׳׳׳” ׳׳‘׳—׳•׳¨ ׳‘', '׳׳׳” ׳׳‘׳—׳•׳¨ ׳‘׳¨׳•׳‘׳•׳˜׳™׳',
                            '׳׳™׳', '׳׳™׳ ׳', '׳›׳™׳¦׳“', '׳׳“׳•׳¢', '׳׳” ׳”׳™׳×׳¨׳•׳ ׳•׳×', '׳׳” ׳”׳™׳×׳¨׳•׳',
                            // נ¯ NEW: Exclude accessibility/design options that are NOT real products
                            '׳ ׳™׳’׳•׳“׳™׳•׳×', '׳’׳•׳₪׳', '׳§׳¨׳™׳', '׳”׳“׳’׳©', '׳§׳™׳©׳•׳¨׳™׳', '׳¨׳™׳•׳•׳—', '׳©׳•׳¨׳•׳×', 
                            '׳׳•׳’׳‘׳¨', '׳¡׳׳', '׳’׳“׳•׳', '׳¢׳¦׳•׳¨', '׳׳ ׳™׳׳¦׳™׳•׳×', '׳×׳¦׳•׳’׳”', '׳’׳“׳׳”',
                            '׳’׳“׳׳×', '׳§׳˜׳ ׳”', '׳§׳˜׳ ׳×', '׳’׳•׳₪׳ ׳’׳“׳•׳', '׳’׳•׳₪׳ ׳§׳˜׳', '׳ ׳™׳’׳•׳“׳™׳•׳× ׳’׳‘׳•׳”׳”',
                            '׳ ׳™׳’׳•׳“׳™׳•׳× ׳ ׳׳•׳›׳”', '׳’׳•׳₪׳ ׳§׳¨׳™׳', '׳’׳•׳₪׳ ׳’׳“׳•׳', '׳’׳•׳₪׳ ׳§׳˜׳'
                        ].filter(Boolean);
                        
                        const excludePhrases = [
                            /׳–׳׳\s+(׳–׳•|׳–׳”)\s+׳׳•׳׳ ׳•׳×/,
                            /.*׳׳•׳׳ ׳•׳×.*/,
                            /.*׳—׳•׳•׳™׳”.*/,
                            /.*׳¡׳˜׳’׳ ׳¡.*/,
                            /.*׳׳•׳©׳׳.*/,
                            /^׳˜׳•׳”׳¨$/,
                            /^׳™׳•׳₪׳™$/,
                            /^׳׳™׳›׳•׳×$/,
                            /^׳”׳©׳¨׳׳”$/,
                            /^׳—׳׳•׳$/,
                            /^׳׳׳×$/,
                            /^׳ ׳©׳׳”$/,
                            /^׳׳׳”.*/,
                            /.*׳׳׳”.*׳‘׳—׳•׳¨.*/,
                            /.*׳׳׳”.*׳¨׳•׳‘׳•׳˜.*/,
                            /.*\?$/,
                        ];
                        
                        const validProducts = allProducts.filter(product => {
                            const name = product.name || '';
                            // Exclude questions, taglines, etc.
                            const isQuestion = name.includes('?') || name.includes('׳׳׳”') || 
                                               name.includes('׳׳™׳') || name.match(/^׳׳׳”\s+.*/) ||
                                               name.includes('׳׳׳” ׳׳‘׳—׳•׳¨') || name.includes('׳׳׳” ׳׳‘׳—׳•׳¨ ׳‘');
                            const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                            const isExcluded = excludePatterns.some(pattern => 
                                name.toLowerCase().includes(pattern.toLowerCase())
                            );
                            
                            // Must have valid price (>= 10, not 2, 3, 5, 7 which are likely not product prices)
                            const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                            // נ¯ FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                            // Only accept prices >= 10 (real product prices like ג‚×10, ג‚×60, ג‚×75)
                            const hasValidPrice = price >= 2 && price < 100000 && !isNaN(price);
                            
                            // Must have valid name (not question, not excluded, reasonable length)
                            const hasValidName = name.length >= 3 && name.length <= 100 && 
                                               !isQuestion && !matchesExcludedPhrase && !isExcluded &&
                                               name.match(/[׳-׳×]/); // Must contain Hebrew
                            
                            return hasValidName && hasValidPrice;
                        });
                        
                        console.log(`ג… Filtered products: ${validProducts.length} valid out of ${allProducts.length} total`);
                        console.log(`נ” Valid products:`, validProducts.map(p => `${p.name} - ג‚×${p.price}`));
                        
                        if (validProducts.length === 0) {
                            return { type: 'message', message: '׳׳¦׳˜׳¢׳¨, ׳׳ ׳׳¦׳׳×׳™ ׳׳™׳“׳¢ ׳¢׳ ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳ ׳›׳¨׳’׳¢ ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡.' };
                        }
                        
                        // נ¯ FIX: Filter products by category if query specifies category (e.g., "׳׳” ׳”׳¦׳¢׳¦׳•׳¢ ׳”׳›׳™ ׳–׳•׳", "׳©׳¢׳•׳ ׳”׳›׳™ ׳–׳•׳")
                        let filteredProducts = validProducts;
                        
                        // Filter by toy category
                        if (lowerMessage.includes('׳¦׳¢׳¦׳•׳¢')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                return pageTitle.includes('׳¦׳¢׳¦׳•׳¢') || productName.includes('׳¦׳¢׳¦׳•׳¢') || 
                                       productName.includes('׳׳›׳•׳ ׳™׳×') || productName.includes('׳‘׳•׳‘׳”') ||
                                       productName.includes('׳§׳•׳‘׳™׳™׳”') || productName.includes('׳׳©׳—׳§') ||
                                       productName.includes('׳¨׳›׳‘׳×') || productName.includes('׳“׳™׳ ׳•׳–׳׳•׳¨');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        // Filter by watch category - handle "׳¨׳§ ׳©׳¢׳•׳" / "׳©׳¢׳•׳ ׳‘׳׳‘׳“" queries
                        else if (lowerMessage.includes('׳©׳¢׳•׳') || lowerMessage.includes('׳¨׳§ ׳©׳¢׳•׳') || lowerMessage.includes('׳©׳¢׳•׳ ׳‘׳׳‘׳“')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                
                                // For "׳¨׳§ ׳©׳¢׳•׳" - be very strict, only watches!
                                if (lowerMessage.includes('׳¨׳§ ׳©׳¢׳•׳') || lowerMessage.includes('׳©׳¢׳•׳ ׳‘׳׳‘׳“') || lowerMessage.includes('׳¨׳§ ׳©׳¢׳•׳ ׳™׳')) {
                                    // Only accept pages with "׳©׳¢׳•׳" in title OR products with "׳©׳¢׳•׳" in name
                                    // Exclude everything else (toys, etc.)
                                    return (pageTitle.includes('׳©׳¢׳•׳') && !pageTitle.includes('׳¦׳¢׳¦׳•׳¢')) || 
                                           (productName.includes('׳©׳¢׳•׳') && !productName.includes('׳¦׳¢׳¦׳•׳¢'));
                                }
                                
                                // Regular "׳©׳¢׳•׳" query - accept watches
                                return pageTitle.includes('׳©׳¢׳•׳') || productName.includes('׳©׳¢׳•׳');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        // Filter by nail polish category
                        else if (lowerMessage.includes('׳׳§')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                return pageTitle.includes('׳׳§') || productName.includes('׳׳§') ||
                                       productName.includes('׳׳ ׳™׳§׳•׳¨') || productName.includes('׳₪׳“׳™׳§׳•׳¨');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        // Filter by gift/present category - exclude services (like barber shop, numbera)
                        else if (lowerMessage.includes('׳׳×׳ ׳”')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                
                                // Exclude services (׳׳¡׳₪׳¨׳”, ׳©׳™׳¨׳•׳×׳™׳)
                                if (pageTitle.includes('׳׳¡׳₪׳¨׳”') || pageTitle.includes('׳©׳™׳¨׳•׳×') || 
                                    productName.includes('׳׳¡׳₪׳¨׳”') || productName.includes('׳©׳™׳¨׳•׳×')) {
                                    return false;
                                }
                                
                                // Include gift-worthy products: toys, watches, jewelry, etc.
                                return pageTitle.includes('׳¦׳¢׳¦׳•׳¢') || pageTitle.includes('׳©׳¢׳•׳') || 
                                       pageTitle.includes('׳×׳›׳©׳™׳˜') || pageTitle.includes('׳׳×׳ ׳”') ||
                                       productName.includes('׳¦׳¢׳¦׳•׳¢') || productName.includes('׳©׳¢׳•׳') ||
                                       productName.includes('׳×׳›׳©׳™׳˜') || productName.includes('׳׳›׳•׳ ׳™׳×') ||
                                       productName.includes('׳‘׳•׳‘׳”') || productName.includes('׳§׳•׳‘׳™׳™׳”') ||
                                       productName.includes('׳¨׳›׳‘׳×') || productName.includes('׳“׳™׳ ׳•׳–׳׳•׳¨');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        
                        // נ¯ NEW: Filter by max price if query specifies "׳¢׳“ X ׳©׳§׳" (e.g., "׳©׳¢׳•׳ ׳™׳ ׳¢׳“ 2000׳©")
                        if (maxPrice !== null && maxPrice > 0) {
                            console.log(`נ” Filtering products by max price: ג‚×${maxPrice}`);
                            const beforeCount = filteredProducts.length;
                            filteredProducts = filteredProducts.filter(product => {
                                const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                return price <= maxPrice;
                            });
                            console.log(`ג… Filtered ${filteredProducts.length} products (from ${beforeCount}) under ג‚×${maxPrice}`);
                            
                            // If query includes category word, keep filtering by category
                            if (lowerMessage.includes('׳©׳¢׳•׳')) {
                                filteredProducts = filteredProducts.filter(product => {
                                    const pageTitle = (product.pageTitle || '').toLowerCase();
                                    const productName = (product.name || '').toLowerCase();
                                    return pageTitle.includes('׳©׳¢׳•׳') || productName.includes('׳©׳¢׳•׳');
                                });
                            }
                        }
                        
                        // Sort by price
                        filteredProducts.sort((a, b) => {
                            const priceA = parseFloat(String(a.price).replace(/[,\s]/g, ''));
                            const priceB = parseFloat(String(b.price).replace(/[,\s]/g, ''));
                            return priceA - priceB;
                        });
                        
                        if (filteredProducts.length === 0) {
                            return { type: 'message', message: '׳׳¦׳˜׳¢׳¨, ׳׳ ׳׳¦׳׳×׳™ ׳׳™׳“׳¢ ׳¢׳ ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳ ׳›׳¨׳’׳¢ ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡.' };
                        }
                        
                        const cheapest = filteredProducts[0];
                        const mostExpensive = filteredProducts[filteredProducts.length - 1];
                        const cleanPageTitle = cheapest.pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                        const fullPageUrl = `${window.location.origin}${cheapest.pageUrl}`;
                        
                        let response = '';
                        
                        // נ¯ NEW: Handle "׳¢׳“ X ׳©׳§׳" queries (e.g., "׳©׳¢׳•׳ ׳™׳ ׳¢׳“ 2000׳©")
                        // נ¯ NEW: Also handle "׳™׳© ׳׳™ ׳×׳§׳¦׳™׳‘ ׳©׳ X ׳×׳׳׳™׳¦׳™ ׳׳™" - budget recommendations
                        if (maxPrice !== null && maxPrice > 0) {
                            if (filteredProducts.length === 0) {
                                return { 
                                    type: 'message', 
                                    message: `׳׳¦׳˜׳¢׳¨, ׳׳ ׳׳¦׳׳×׳™ ${lowerMessage.includes('׳©׳¢׳•׳') ? '׳©׳¢׳•׳ ׳™׳' : '׳׳•׳¦׳¨׳™׳'} ׳¢׳“ ג‚×${maxPrice.toLocaleString()} ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡.`
                                };
                            }
                            
                            // נ¯ NEW: If this is a budget recommendation query, provide recommendations
                            if (isBudgetRecommendation) {
                                // Sort by price (cheapest first) and recommend top 3-5 products
                                const topRecommendations = filteredProducts.slice(0, 5);
                                const totalPrice = topRecommendations.reduce((sum, p) => sum + parseFloat(String(p.price || 0).replace(/[,\s]/g, '')), 0);
                                
                                response = `נ’° **׳”׳׳׳¦׳•׳× ׳׳₪׳™ ׳×׳§׳¦׳™׳‘ ׳©׳ ג‚×${maxPrice.toLocaleString()}:**\n\n`;
                                topRecommendations.forEach((product, idx) => {
                                    const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                    const productPageTitle = product.pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                                    const productPageUrl = `${window.location.origin}${product.pageUrl}`;
                                    response += `${idx + 1}. **${product.name}** ׳‘-${productPageTitle} - ג‚×${price.toLocaleString()}\n`;
                                    response += `   נ”— [׳¦׳₪׳” ׳‘׳“׳£](${productPageUrl})\n\n`;
                                });
                                
                                if (topRecommendations.length > 1) {
                                    response += `נ’¡ **׳¡׳”"׳›:** ג‚×${totalPrice.toLocaleString()} (${topRecommendations.length} ׳׳•׳¦׳¨׳™׳)\n\n`;
                                }
                                
                                if (filteredProducts.length > topRecommendations.length) {
                                    response += `...׳•׳¢׳•׳“ ${filteredProducts.length - topRecommendations.length} ׳׳₪׳©׳¨׳•׳™׳•׳× ׳ ׳•׳¡׳₪׳•׳× ׳¢׳“ ג‚×${maxPrice.toLocaleString()}`;
                                }
                            } else {
                                // Regular "׳¢׳“ X ׳©׳§׳" query - show all products under max price
                            response = `נ’° **׳׳¦׳׳×׳™ ${filteredProducts.length} ${lowerMessage.includes('׳©׳¢׳•׳') ? '׳©׳¢׳•׳ ׳™׳' : '׳׳•׳¦׳¨׳™׳'} ׳¢׳“ ג‚×${maxPrice.toLocaleString()}:**\n\n`;
                            filteredProducts.slice(0, 10).forEach((product, idx) => {
                                const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                const productPageTitle = product.pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                                const productPageUrl = `${window.location.origin}${product.pageUrl}`;
                                response += `${idx + 1}. **${product.name}** ׳‘-${productPageTitle} - ג‚×${price.toLocaleString()}\n`;
                                response += `   נ”— [׳¦׳₪׳” ׳‘׳“׳£](${productPageUrl})\n\n`;
                            });
                            if (filteredProducts.length > 10) {
                                response += `...׳•׳¢׳•׳“ ${filteredProducts.length - 10} ${lowerMessage.includes('׳©׳¢׳•׳') ? '׳©׳¢׳•׳ ׳™׳' : '׳׳•׳¦׳¨׳™׳'} ׳ ׳•׳¡׳₪׳™׳`;
                                }
                            }
                        }
                        else if (lowerMessage.includes('׳”׳›׳™ ׳–׳•׳') || lowerMessage.includes('׳–׳•׳')) {
                            let categoryText = '';
                            if (lowerMessage.includes('׳¦׳¢׳¦׳•׳¢')) categoryText = ' ׳‘׳§׳˜׳’׳•׳¨׳™׳™׳× ׳¦׳¢׳¦׳•׳¢׳™׳';
                            else if (lowerMessage.includes('׳©׳¢׳•׳')) categoryText = ' ׳‘׳§׳˜׳’׳•׳¨׳™׳™׳× ׳©׳¢׳•׳ ׳™׳';
                            else if (lowerMessage.includes('׳׳§')) categoryText = ' ׳‘׳§׳˜׳’׳•׳¨׳™׳™׳× ׳׳§ ׳’\'׳';
                            else if (lowerMessage.includes('׳׳×׳ ׳”')) categoryText = ' ׳‘׳§׳˜׳’׳•׳¨׳™׳™׳× ׳׳×׳ ׳•׳×';
                            
                            // נ¯ Save page to context for "׳›׳" follow-up
                            const pageTitleForSearch = cheapest.pageTitle || cleanPageTitle;
                            const pageFromList = allPages.find(p => 
                                p.title === pageTitleForSearch || 
                                p.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === cleanPageTitle
                            );
                            if (pageFromList) {
                                window.stavCurrentPages = [pageFromList];
                                console.log('נ’¾ Saved page to context for follow-up:', cleanPageTitle);
                            }
                            
                            response = `${cheapest.name} ׳‘-${cleanPageTitle} ׳¢׳•׳׳” ג‚×${parseFloat(String(cheapest.price).replace(/[,\s]/g, '')).toLocaleString()}\n`;
                            response += `׳–׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳${categoryText} ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡.\n`;
                            response += `׳¨׳•׳¦׳” ׳׳₪׳×׳•׳— ׳׳× ׳”׳“׳£?`;
                        } else if (lowerMessage.includes('׳”׳›׳™ ׳™׳§׳¨') || lowerMessage.includes('׳™׳§׳¨')) {
                            const mostExpensiveFullUrl = `${window.location.origin}${mostExpensive.pageUrl}`;
                            const mostExpensiveCleanTitle = mostExpensive.pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                            
                            // נ¯ Save page to context for "׳›׳" follow-up
                            const pageFromList = allPages.find(p => 
                                p.title === mostExpensive.pageTitle || 
                                p.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === mostExpensiveCleanTitle
                            );
                            if (pageFromList) {
                                window.stavCurrentPages = [pageFromList];
                                console.log('נ’¾ Saved page to context for follow-up:', mostExpensiveCleanTitle);
                            }
                            
                            response = `${mostExpensive.name} ׳‘-${mostExpensiveCleanTitle} ׳¢׳•׳׳” ג‚×${parseFloat(String(mostExpensive.price).replace(/[,\s]/g, '')).toLocaleString()}\n`;
                            response += `׳–׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳™׳§׳¨ ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡.\n`;
                            response += `׳¨׳•׳¦׳” ׳׳₪׳×׳•׳— ׳׳× ׳”׳“׳£?`;
                        } else {
                            response = `נ₪– **׳׳¦׳׳×׳™ ${filteredProducts.length} ׳׳•׳¦׳¨׳™׳!**\n\n`;
                            response += `נ¥‡ **׳”׳›׳™ ׳–׳•׳:** ${cheapest.name} - ג‚×${parseFloat(String(cheapest.price).replace(/[,\s]/g, '')).toLocaleString()}\n`;
                            response += `נ’ **׳”׳›׳™ ׳™׳§׳¨:** ${mostExpensive.name} - ג‚×${parseFloat(String(mostExpensive.price).replace(/[,\s]/g, '')).toLocaleString()}\n\n`;
                        }
                        
                        console.log(`ג… Returning response with ${filteredProducts.length} products (all fetched LIVE from pages)`);
                        return { type: 'message', message: response };
                    } else {
                        return { type: 'message', message: '׳׳¦׳˜׳¢׳¨, ׳׳ ׳׳¦׳׳×׳™ ׳׳™׳“׳¢ ׳¢׳ ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳ ׳›׳¨׳’׳¢ ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡.' };
                    }
                }
                
                // Determine if this is a marketplace query (products, stores, services)
                // נ¯ CRITICAL: If query contains product/service keywords, ALWAYS treat as marketplace query (like a search engine)
                // Skip all other checks if it's a product/service query
                const isMarketplaceQuery = (hasProductKeyword || hasServiceKeyword) || // נ¯ CRITICAL: Product/service keywords ALWAYS = marketplace query
                                          (matchesPageInMarketplace || storeProductMatch || isProductQuery || requestedBusiness) && 
                                          !isGeneralKnowledge && 
                                          !isBotQuestion && 
                                          !isGreeting && 
                                          !isSelfIntro;
                
                console.log('נ” [MARKETPLACE DECISION] hasProductKeyword:', hasProductKeyword, '| hasServiceKeyword:', hasServiceKeyword);
                console.log('נ” [MARKETPLACE DECISION] isMarketplaceQuery:', isMarketplaceQuery, '| isProductQuery:', isProductQuery);
                
                // נ¯ CRITICAL: If query contains product/service keywords, ALWAYS treat as marketplace query (skip N8N)
                // This is like a search engine - product/service keywords = marketplace search
                if (hasProductKeyword || hasServiceKeyword) {
                    console.log('נ¯ Product/Service keyword detected - ALWAYS treating as marketplace query, skipping N8N');
                    // Continue to marketplace search below (don't send to N8N)
                } else if (mentionsProduct) {
                    console.log('נ¯ Product mentioned - skipping N8N, treating as marketplace query');
                    // Continue to marketplace search below (don't send to N8N)
                } else if (isGeneralKnowledge || isBotQuestion || isGreeting || isSelfIntro) {
                    // If it's a general question (knowledge, bot question, greeting, etc.) - send to N8N
                    console.log('נ’¬ General question detected (knowledge/bot/greeting), sending to N8N');
                    return null; // Return null to send to N8N webhook
                } else if (!isMarketplaceQuery) {
                    // NOT a marketplace query - send directly to N8N for intelligent response
                    console.log('נ’¬ Not a marketplace query, sending to N8N for intelligent response');
                    return null; // Return null to send to N8N webhook
                }
                
                // This IS a marketplace query - search in pages
                console.log('נ” Query about products/store/business info - will search in pages');
                console.log('נ¯ User message:', userMessage);
                
                // נ¯ IMPROVED: If this is "׳׳—׳™׳¨׳™׳ ׳©׳ X", search for X (the category) not the whole query
                // BUT: Keep the original userMessage for later use in generateTextResponseWithRealData
                let searchQuery = userMessage;
                const originalUserMessage = userMessage; // Save original for price list detection
                if (priceListCategory) {
                    searchQuery = priceListCategory;
                    console.log(`נ“‹ Price list query - searching for category: "${priceListCategory}" instead of "${userMessage}"`);
                } else {
                    // נ¯ NEW: Clean search query - remove "׳׳—׳₪׳©", "׳׳—׳₪׳©׳×", "׳׳ ׳™ ׳׳—׳₪׳©", etc. from search query
                    searchQuery = userMessage
                        .replace(/^(?:׳׳ ׳™\s+)?(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×|׳¨׳•׳¦׳”|׳¦׳¨׳™׳|׳¦׳¨׳™׳›׳”)\s+/i, '') // Remove "׳׳—׳₪׳©", "׳׳ ׳™ ׳׳—׳₪׳©", etc.
                        .replace(/\s+(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×|׳¨׳•׳¦׳”|׳¦׳¨׳™׳|׳¦׳¨׳™׳›׳”)$/i, '') // Remove trailing "׳׳—׳₪׳©"
                        .trim();
                    
                    // נ¯ FIX: Fix common typos from speech recognition (e.g., "׳× ׳¦׳¢׳¦׳•׳¢׳™׳" -> "׳¦׳¢׳¦׳•׳¢׳™׳")
                    searchQuery = searchQuery.replace(/\s+׳×\s+([׳-׳×]+)/gi, ' $1'); // Remove "׳×" before Hebrew words
                    
                    // נ¯ FIX: Remove descriptive words that make search too specific
                    // "׳¦׳¢׳¦׳•׳¢ ׳׳™׳•׳ ׳”׳•׳׳“׳× ׳׳™׳׳“" -> "׳¦׳¢׳¦׳•׳¢"
                    searchQuery = searchQuery
                        .replace(/\s+׳׳™׳•׳\s+׳”׳•׳׳“׳×/gi, '') // Remove "׳׳™׳•׳ ׳”׳•׳׳“׳×"
                        .replace(/\s+׳(?:׳™׳׳“|׳™׳׳“׳™׳|׳׳©׳×׳™|׳’׳‘׳¨|׳‘׳—׳•׳¨|׳‘׳—׳•׳¨׳”|׳׳™׳©׳”|׳׳©׳”|׳‘׳¢׳|׳‘׳¢׳׳™|׳‘׳|׳‘׳×)\s*$/i, '') // Remove "׳׳™׳׳“" etc at end
                        .replace(/\s+(?:׳©׳׳™|׳©׳׳|׳©׳׳”|׳©׳׳ ׳•|׳©׳׳›׳|׳©׳׳”׳)\s*$/i, '') // Remove possessives at end
                        .trim();
                    
                    if (searchQuery !== userMessage) {
                        console.log(`נ”§ Cleaned search query: "${userMessage}" -> "${searchQuery}"`);
                    }
                }
                
                // First, try to search in REAL pages
                console.log('נ” Starting search with', allPages?.length || 0, 'total pages available');
                console.log('נ¯ Calling searchLivePages with query:', searchQuery);
                const liveResults = await searchLivePages(searchQuery);
                
                console.log('נ” Search completed, found:', liveResults?.length || 0, 'results');
                if (liveResults && liveResults.length > 0) {
                    console.log('ג… Found pages:', liveResults.map(p => p.title).join(', '));
                } else {
                    console.log('ג No pages found for query:', userMessage);
                    // נ¯ FIX: Even if no results, try to show similar products or category recommendations
                    console.log('נ” No results found, but this is a marketplace query - will try to find similar products');
                }
                
                // נ¯ FIX: Always try to handle marketplace queries, even if no exact results
                if (liveResults && liveResults.length > 0) {
                    // Handle case when results are found - existing logic
                    console.log('ג… Found', liveResults.length, 'real pages');
                    
                    // נ¯ NEW: Sort results - stores first, then other pages
                    // This ensures stores (which have products) are shown before services
                    const sortedResults = liveResults.sort((a, b) => {
                        // Store pages first
                        if (a.pageType === 'store' && b.pageType !== 'store') return -1;
                        if (a.pageType !== 'store' && b.pageType === 'store') return 1;
                        // Then by match score (higher first)
                        return (b.matchScore || 0) - (a.matchScore || 0);
                    });
                    console.log('נ“ Sorted results: stores first, then by match score');

                    let filteredResults = sortedResults;
                    if (isStoresInCityQuery || isGeneralStoresQuery) {
                        const storeOnlyResults = sortedResults.filter(page => page.pageType === 'store');
                        if (storeOnlyResults.length > 0) {
                            filteredResults = storeOnlyResults;
                            console.log('נ× Store query detected - returning only store pages');
                        } else {
                            console.warn('ג ן¸ Store query detected but no store pages found - keeping original results');
                        }
                    }
                    
                    // נ« REMOVED: Old auto-preview logic
                    // Preview should ONLY be shown when user explicitly requests it (handled at top of function)
                    // NOT when they just search for a service/product
                    const needsPreview = false; // ג NEVER auto-show preview - user must explicitly ask
                    
                    console.log('ג„¹ן¸ Search results will NOT show preview automatically (needsPreview = false)');
                    
                    // נ¯ Check if this is a "price list" or "show products" query - if so, return text directly
                    const lowerUserMessage = userMessage.toLowerCase();
                    const isPriceListOrShowQuery = priceListCategory || // "׳׳—׳™׳¨׳™׳ ׳©׳ X"
                                                   lowerUserMessage.includes('׳×׳¨׳׳™ ׳׳•׳¦׳¨׳™׳') || 
                                                   lowerUserMessage.includes('׳×׳¨׳׳™ ׳׳—׳™׳¨׳™׳') ||
                                                   lowerUserMessage.includes('׳׳•׳¦׳¨׳™׳ ׳•׳׳—׳™׳¨׳™׳') ||
                                                   lowerUserMessage.includes('׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳') ||
                                                   lowerUserMessage.includes('׳¨׳©׳™׳׳× ׳׳•׳¦׳¨׳™׳') ||
                                                   /׳¨׳©׳™׳(?:׳”|׳×)\s+׳©׳\s+(?:׳׳—׳™׳¨׳™׳|׳׳•׳¦׳¨׳™׳|׳¦׳¢׳¦׳•׳¢׳™׳)/i.test(userMessage) || // נ¯ NEW: "׳¨׳©׳™׳׳” ׳©׳ ׳׳—׳™׳¨׳™׳/׳׳•׳¦׳¨׳™׳/׳¦׳¢׳¦׳•׳¢׳™׳"
                                                   lowerUserMessage.includes('׳×׳ ׳™ ׳¨׳©׳™׳׳×') ||
                                                   lowerUserMessage.includes('׳×׳ ׳™ ׳׳™ ׳¨׳©׳™׳׳×') ||
                                                   lowerUserMessage.includes('׳×׳ ׳™ ׳׳× ׳¨׳©׳™׳׳×') ||
                                                   lowerUserMessage.includes('׳׳₪׳©׳¨ ׳¢׳•׳“ ׳¨׳©׳™׳׳×') || lowerUserMessage.includes('׳׳₪׳©׳¨ ׳¢׳•׳“ ׳¨׳©׳™׳׳”') || // נ¯ NEW: "׳׳₪׳©׳¨ ׳¢׳•׳“ ׳¨׳©׳™׳׳× ׳׳•׳¦׳¨׳™׳"
                                                   /׳׳₪׳©׳¨\s+׳¢׳•׳“\s+׳¨׳©׳™׳(?:׳”|׳×)/i.test(userMessage) || // נ¯ NEW: Pattern match
                                                   lowerUserMessage.includes('׳›׳ ׳”׳׳•׳¦׳¨׳™׳') ||
                                                   lowerUserMessage.includes('׳¨׳©׳™׳׳” ׳©׳ ׳›׳') || // נ¯ NEW: "׳¨׳©׳™׳׳” ׳©׳ ׳›׳ X"
                                                   /׳¨׳©׳™׳׳”\s+׳©׳\s+׳›׳/.test(lowerUserMessage) || // נ¯ NEW: Pattern match
                                                   /׳›׳\s+׳”׳¦׳¢׳¦׳•׳¢׳™׳/.test(lowerUserMessage) || // נ¯ NEW: "׳›׳ ׳”׳¦׳¢׳¦׳•׳¢׳™׳"
                                                   lowerUserMessage.includes('׳׳ ׳™ ׳¨׳•׳¦׳” ׳¨׳©׳™׳׳”') || // נ¯ NEW: "׳׳ ׳™ ׳¨׳•׳¦׳” ׳¨׳©׳™׳׳”"
                                                   /׳׳ ׳™\s+׳¨׳•׳¦׳”\s+׳¨׳©׳™׳(?:׳”|׳×)/i.test(userMessage) || // נ¯ NEW: Pattern match for "׳׳ ׳™ ׳¨׳•׳¦׳” ׳¨׳©׳™׳׳×"
                                                   /׳׳™׳–׳”\s+(?:׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳™׳©/i.test(userMessage) || // נ¯ NEW: "׳׳™׳–׳” ׳¦׳¢׳¦׳•׳¢׳™׳ ׳™׳©"
                                                   /׳׳”\s+(?:׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳™׳©/i.test(userMessage) || // נ¯ NEW: "׳׳” ׳¦׳¢׳¦׳•׳¢׳™׳ ׳™׳©"
                                                   /׳׳”\s+(?:׳”׳׳•׳¦׳¨|׳”׳¦׳¢׳¦׳•׳¢|׳”׳׳×׳ ׳”|׳”׳©׳¢׳•׳)\s+׳”׳›׳™\s+(?:׳–׳•׳|׳–׳•׳׳”|׳™׳§׳¨|׳™׳§׳¨׳”)/i.test(userMessage) || // נ¯ NEW: "׳׳” ׳”׳¦׳¢׳¦׳•׳¢ ׳”׳›׳™ ׳–׳•׳"
                                                   /׳׳”\s+(?:׳”׳›׳™\s+)?(?:׳–׳•׳|׳–׳•׳׳”|׳™׳§׳¨|׳™׳§׳¨׳”)/i.test(userMessage) || // נ¯ NEW: "׳׳” ׳”׳›׳™ ׳–׳•׳"
                                                   (lowerUserMessage.includes('׳×׳¨׳׳™') && 
                                                    (lowerUserMessage.includes('׳׳•׳¦׳¨') || lowerUserMessage.includes('׳׳—׳™׳¨'))) ||
                                                   (lowerUserMessage.includes('׳×׳׳׳™׳¦׳™') && lowerUserMessage.includes('׳׳×׳ ׳”'));
                    
                    // If this is a "show products/prices" query, generate text response directly
                    if (isPriceListOrShowQuery) {
                        console.log('נ“ Price list/show products query - generating text response directly');
                        
                        // נ¯ IMPORTANT: Save pages to context so "׳›׳" will work correctly!
                        // נ¯ FIX: Make a deep copy to prevent reference issues
                        window.stavCurrentPages = liveResults.map(p => ({ ...p }));
                        console.log('נ’¾ Saved', liveResults.length, 'pages to context for follow-up questions');
                        console.log('נ’¾ Pages saved:', window.stavCurrentPages.map(p => p.title).join(', '));
                        
                        // נ¯ Check if user wants link in this query
                        const includeLinks = /׳×׳¨׳׳”.*׳׳×׳¨|׳×׳¨׳׳”.*׳“׳£|׳§׳™׳©׳•׳¨|׳₪׳×׳—.*׳׳×׳¨|׳׳™׳ ׳§|link/i.test(userMessage);
                        // נ¯ IMPORTANT: Use originalUserMessage (not searchQuery) so "׳׳—׳™׳¨׳™׳ ׳©׳ X" is detected correctly
                        const textResponse = await generateTextResponseWithRealData(liveResults, originalUserMessage, includeLinks);
                        
                        // Return pages type with text, so context is preserved
                        return {
                            type: 'pages',
                            pages: liveResults,
                            message: textResponse,
                            showAsText: true, // Flag to show as text (not buttons)
                            needsPreview: false
                        };
                    }
                    
                    // Return the pages themselves (not text) so we can display them properly
                    // נ¯ FIX: Always show up to 5 options, not just one
                    // נ¯ FIX: Use sortedResults (stores first) instead of liveResults
                    // Limit to 5 results for display
                    const displayResults = filteredResults.slice(0, 5);
                    
                    let messageText = '';
                    if (displayResults.length === 1) {
                        messageText = `׳׳¦׳׳×׳™ ׳׳× ${displayResults[0].title}. ׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?`;
                    } else {
                        messageText = `׳׳¦׳׳×׳™ ${displayResults.length} ׳׳₪׳©׳¨׳•׳™׳•׳×. ׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?`;
                    }
                    
                    // נ¯ FIX: Store all results for "׳׳—׳¨׳™׳" option
                    if (filteredResults.length > 5) {
                        displayResults._allResults = filteredResults;
                        displayResults._currentOffset = 0;
                        displayResults._hasMore = true;
                    }
                    
                    return { 
                        type: 'pages', 
                        pages: displayResults, // נ¯ FIX: Show up to 5 results
                        message: messageText,
                        needsPreview: false, // נ¯ FIX: NEVER auto-show preview - always ask first
                        includeLinks: false // נ¯ FIX: Don't show links until user says "׳›׳"
                    };
                }
                
                // If query was about products/store but no results found, try to find stores with that category first
                console.log('ג ן¸ No exact results found for marketplace query - trying to find stores with matching category');
                
                // נ¯ NEW: First try to find stores that match the category (e.g., "׳¦׳¢׳¦׳•׳¢׳™׳" -> find stores with "׳¦׳¢׳¦׳•׳¢" in title/desc)
                if (allPages && allPages.length > 0) {
                    // Clean search query for category matching
                    let categoryQuery = searchQuery
                        .replace(/^(?:׳׳ ׳™\s+)?(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×|׳¨׳•׳¦׳”|׳¦׳¨׳™׳|׳¦׳¨׳™׳›׳”)\s+/i, '')
                        .replace(/\s+(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×|׳¨׳•׳¦׳”|׳¦׳¨׳™׳|׳¦׳¨׳™׳›׳”)$/i, '')
                        .replace(/\s+׳(?:׳™׳׳“|׳™׳׳“׳™׳|׳׳©׳×׳™|׳’׳‘׳¨|׳‘׳—׳•׳¨|׳‘׳—׳•׳¨׳”|׳׳™׳©׳”|׳׳©׳”|׳‘׳¢׳|׳‘׳¢׳׳™|׳‘׳|׳‘׳×|׳©׳׳™|׳©׳׳|׳©׳׳”|׳©׳׳ ׳•|׳©׳׳›׳|׳©׳׳”׳)\s*$/i, '')
                        .trim();
                    
                    // Try to find stores by category
                    const categoryStores = allPages.filter(page => {
                        if (page.pageType !== 'store') return false;
                        const titleLower = (page.title || '').toLowerCase();
                        const descLower = (page.description || '').toLowerCase();
                        const categoryLower = categoryQuery.toLowerCase();
                        
                        // Check if store title/description contains the category
                        return titleLower.includes(categoryLower) || descLower.includes(categoryLower) ||
                               categoryLower.includes(titleLower.split(' ')[0]) || 
                               categoryLower.includes('׳¦׳¢׳¦׳•׳¢') && (titleLower.includes('׳¦׳¢׳¦׳•׳¢') || descLower.includes('׳¦׳¢׳¦׳•׳¢'));
                    });
                    
                    if (categoryStores.length > 0) {
                        console.log(`ג… Found ${categoryStores.length} stores matching category "${categoryQuery}"`);
                        // Sort stores - exact matches first
                        const sortedStores = categoryStores.sort((a, b) => {
                            const aTitle = (a.title || '').toLowerCase();
                            const bTitle = (b.title || '').toLowerCase();
                            const categoryLower = categoryQuery.toLowerCase();
                            
                            const aExact = aTitle.includes(categoryLower);
                            const bExact = bTitle.includes(categoryLower);
                            if (aExact && !bExact) return -1;
                            if (!aExact && bExact) return 1;
                            return 0;
                        });
                        
                        return {
                            type: 'pages',
                            pages: sortedStores,
                            message: `׳׳¦׳׳×׳™ ${sortedStores.length} ׳—׳ ׳•׳™׳•׳× ׳¨׳׳•׳•׳ ׳˜׳™׳•׳×`,
                            needsPreview: false
                        };
                    }
                    
                    // If no stores found by category, try to find similar products
                    console.log('ג ן¸ No stores found by category - trying to find similar products');
                    const storePages = allPages.filter(page => page.pageType === 'store');
                    
                    // Helper function to normalize text (handle typos/variations)
                    const normalizeText = (text) => {
                        return text
                            .toLowerCase()
                            .replace(/׳׳™׳¨׳•׳¥|׳׳¨׳•׳¥/g, '׳׳™׳¨׳•׳¥') // Normalize "׳׳™׳¨׳•׳¥" variations
                            .replace(/׳—׳‘׳¨׳•׳×׳™|׳—׳‘׳¨׳•׳×/g, '׳—׳‘׳¨׳•׳×׳™') // Normalize "׳—׳‘׳¨׳•׳×׳™" variations
                            .replace(/׳‘׳•׳‘׳”|׳‘׳•׳‘׳×/g, '׳‘׳•׳‘׳”') // Normalize "׳‘׳•׳‘׳”" variations
                            .trim();
                    };
                    
                    // Helper function to calculate similarity
                    const calculateSimilarity = (str1, str2) => {
                        const s1 = normalizeText(str1);
                        const s2 = normalizeText(str2);
                        if (s1 === s2) return 100;
                        if (s1.includes(s2) || s2.includes(s1)) return 80;
                        
                        const words1 = s1.split(/\s+/).filter(w => w.length >= 2);
                        const words2 = s2.split(/\s+/).filter(w => w.length >= 2);
                        if (words1.length === 0 || words2.length === 0) return 0;
                        
                        let matchingWords = 0;
                        for (const w1 of words1) {
                            for (const w2 of words2) {
                                if (w1 === w2 || w1.includes(w2) || w2.includes(w1)) {
                                    matchingWords++;
                                    break;
                                }
                            }
                        }
                        return (matchingWords / Math.max(words1.length, words2.length)) * 100;
                    };
                    
                    // Search for similar products
                    const similarProducts = [];
                    // נ¯ NEW: Clean search query - remove "׳׳—׳₪׳©", "׳׳—׳₪׳©׳×", "׳׳ ׳™ ׳׳—׳₪׳©", etc.
                    let cleanSearchQuery = searchQuery
                        .replace(/^(?:׳׳ ׳™\s+)?(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×|׳¨׳•׳¦׳”|׳¦׳¨׳™׳|׳¦׳¨׳™׳›׳”)\s+/i, '') // Remove "׳׳—׳₪׳©", "׳׳ ׳™ ׳׳—׳₪׳©", etc.
                        .replace(/\s+(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×|׳¨׳•׳¦׳”|׳¦׳¨׳™׳|׳¦׳¨׳™׳›׳”)$/i, '') // Remove trailing "׳׳—׳₪׳©"
                        .trim();
                    
                    const queryNormalized = normalizeText(cleanSearchQuery);
                    const queryWords = cleanSearchQuery.split(/\s+/).filter(w => w.length >= 2);
                    
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            const liveProducts = extractLiveProducts(html);
                            
                            for (const product of liveProducts) {
                                if (!product.name) continue;
                                const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                if (price < 2 || price >= 100000) continue;
                                
                                const productNameLower = normalizeText(product.name);
                                
                                // Calculate similarity (use cleanSearchQuery)
                                let similarity = calculateSimilarity(cleanSearchQuery || searchQuery, product.name);
                                
                                // נ¯ FIX: If searching for "׳¦׳¢׳¦׳•׳¢" or "׳¦׳¢׳¦׳•׳¢׳™׳", boost similarity for any toy product
                                if (cleanSearchQuery.includes('׳¦׳¢׳¦׳•׳¢') || cleanSearchQuery.includes('׳¦׳¢׳¦׳•׳¢׳™׳')) {
                                    // Check if product is a toy (contains common toy keywords)
                                    const toyKeywords = ['׳¦׳¢׳¦׳•׳¢', '׳‘׳•׳‘׳”', '׳׳›׳•׳ ׳™׳×', '׳¨׳›׳‘׳×', '׳¨׳•׳‘׳•׳˜', '׳׳’׳•', '׳׳©׳—׳§', '׳‘׳׳•׳§', '׳₪׳׳–׳', '׳—׳™׳”', '׳“׳™׳ ׳•׳–׳׳•׳¨'];
                                    const isToy = toyKeywords.some(keyword => productNameLower.includes(keyword));
                                    if (isToy && similarity < 60) {
                                        similarity = 60; // Boost similarity for toy category match
                                    }
                                }
                                
                                // Also check word-by-word matching
                                if (queryWords.length >= 2) {
                                    const allWordsMatch = queryWords.every(queryWord => {
                                        const normalizedQueryWord = normalizeText(queryWord);
                                        return productNameLower.includes(normalizedQueryWord);
                                    });
                                    if (allWordsMatch && similarity < 80) {
                                        similarity = 75; // High similarity for word matches
                                    }
                                }
                                
                                // נ¯ FIX: Also check if query word matches product (e.g., "׳¦׳¢׳¦׳•׳¢" matches any toy product)
                                if (cleanSearchQuery === '׳¦׳¢׳¦׳•׳¢' || cleanSearchQuery === '׳¦׳¢׳¦׳•׳¢׳™׳') {
                                    // If searching for toys, include any product that looks like a toy
                                    const toyKeywords = ['׳¦׳¢׳¦׳•׳¢', '׳‘׳•׳‘׳”', '׳׳›׳•׳ ׳™׳×', '׳¨׳›׳‘׳×', '׳¨׳•׳‘׳•׳˜', '׳׳’׳•', '׳׳©׳—׳§', '׳‘׳׳•׳§', '׳₪׳׳–׳'];
                                    const isToy = toyKeywords.some(keyword => productNameLower.includes(keyword));
                                    if (isToy && similarity < 50) {
                                        similarity = 50; // Minimum similarity for toy category
                                    }
                                }
                                
                                if (similarity >= 40) {
                                    similarProducts.push({
                                        product: product,
                                        page: page,
                                        similarity: similarity,
                                        pageUrl: pageUrl,
                                        price: price
                                    });
                                }
                            }
                        } catch (error) {
                            console.error('Error searching for similar products:', error);
                        }
                    }
                    
                    // Sort by similarity and show top stores first
                    similarProducts.sort((a, b) => b.similarity - a.similarity);
                    
                    if (similarProducts.length > 0) {
                        // נ¯ NEW: Group products by store and show stores first
                        const storesMap = new Map();
                        for (const item of similarProducts) {
                            const storeTitle = item.page.title;
                            if (!storesMap.has(storeTitle)) {
                                storesMap.set(storeTitle, {
                                    page: item.page,
                                    products: []
                                });
                            }
                            storesMap.get(storeTitle).products.push(item);
                        }
                        
                        // Sort stores by best product similarity
                        const storesArray = Array.from(storesMap.entries()).map(([title, data]) => ({
                            title,
                            page: data.page,
                            products: data.products.sort((a, b) => b.similarity - a.similarity),
                            bestSimilarity: data.products[0].similarity
                        })).sort((a, b) => b.bestSimilarity - a.bestSimilarity);
                        
                        // נ¯ Use cleanSearchQuery for display (without "׳׳—׳₪׳©")
                        const displayQuery = cleanSearchQuery || searchQuery;
                        let message = `׳׳ ׳׳¦׳׳×׳™ ׳‘׳“׳™׳•׳§ "${displayQuery}", ׳׳‘׳ ׳™׳©:\n\n`;
                        
                        // Show stores first, then products (max 3 stores, max 3 products per store)
                        storesArray.slice(0, 3).forEach((store, storeIndex) => {
                            message += `נ× **${store.title}**\n`;
                            store.products.slice(0, 3).forEach((item, productIndex) => {
                                message += `   ג€¢ ${item.product.name} - ג‚×${item.price.toLocaleString()}\n`;
                            });
                            message += `\n`;
                        });
                        
                        message += `נ”— ׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳׳× ׳”׳׳•׳¦׳¨׳™׳?`;
                        
                        return {
                            type: 'message',
                            message: message
                        };
                    }
                }
                
                // If no similar products found, show generic message
                if (allPages && allPages.length > 0) {
                    let message = `׳׳ ׳׳¦׳׳×׳™ ׳׳× ׳׳” ׳©׳—׳™׳₪׳©׳×. נ˜”\n\n׳׳•׳׳™ ׳×׳ ׳¡׳” ׳׳—׳₪׳© ׳‘׳׳•׳₪׳ ׳׳—׳¨ ׳׳• ׳©׳™׳¨׳•׳× ׳׳—׳¨?`;
                    
                    return { 
                        type: 'message',
                        message: message
                    };
                }
                
                return { 
                    type: 'message',
                    message: '׳׳ ׳׳¦׳׳×׳™ ׳׳× ׳׳” ׳©׳—׳™׳₪׳©׳×. נ˜”\n\n׳׳•׳׳™ ׳×׳ ׳¡׳” ׳׳—׳₪׳© ׳‘׳׳•׳₪׳ ׳׳—׳¨ ׳׳• ׳©׳™׳¨׳•׳× ׳׳—׳¨?'
                };
            }
            } catch (error) {
                console.error('גגג Error in processStavMessage:', error);
                console.error('ג Error stack:', error.stack);
                console.error('ג Error message:', error.message);
                return { 
                    type: 'message',
                    message: '׳׳¦׳˜׳¢׳¨, ׳׳™׳¨׳¢׳” ׳©׳’׳™׳׳”. ׳ ׳¡׳” ׳©׳•׳‘.'
                };
            }
        }

        // נ₪ Speech Recognition & Text-to-Speech
        let recognition = null;
        let isListening = false;
        let isSpeaking = false;
        let lastInputWasVoice = false; // Track if user used voice input
        let continuousConversation = false; // נ¯ ׳©׳™׳—׳” ׳₪׳×׳•׳—׳” ׳¨׳¦׳™׳₪׳”
        let speechSynthesis = window.speechSynthesis;
        
        // נ¯ FIX: Track last messages to prevent duplicates
        let lastSentUserMessage = '';
        let lastSentUserMessageTime = 0;
        let lastSentBotMessage = '';
        let lastSentBotMessageTime = 0;

        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.log('ג ן¸ Speech recognition not supported');
                return null;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'he-IL';
            recognition.continuous = continuousConversation; // נ¯ ׳׳¦׳‘ ׳¨׳¦׳™׳£ ׳׳₪׳™ continuousConversation
            recognition.interimResults = false;

            recognition.onstart = function() {
                console.log('נ₪ Listening...', continuousConversation ? '(continuous)' : '(single)');
                isListening = true;
                const micButton = document.getElementById('micButton');
                if (micButton) {
                    if (continuousConversation) {
                        micButton.style.background = '#f59e0b'; // נ  ׳›׳×׳•׳ = ׳©׳™׳—׳” ׳₪׳×׳•׳—׳”
                    } else {
                        micButton.style.background = '#ef4444'; // נ”´ ׳׳“׳•׳ = ׳₪׳¢׳ ׳׳—׳×
                    }
                    micButton.textContent = 'נ”´';
                }
            };

            // נ¯ FIX: Track last message to prevent loops
            let lastProcessedMessage = '';
            let lastMessageTime = 0;
            
            recognition.onresult = function(event) {
                // נ¯ FIX: Don't process if bot is currently speaking (might hear its own voice)
                if (isSpeaking) {
                    console.log('ג ן¸ Ignoring recognition result - bot is speaking');
                    return;
                }
                
                let transcript = event.results[0][0].transcript;
                console.log('נ“ Heard (RAW):', transcript);
                
                // נ¯ CLEAN: Remove punctuation marks from voice input
                transcript = transcript.replace(/[.,!?;:״״›]/g, '').trim();
                console.log('נ“ Heard (CLEAN):', transcript);
                
                // נ¯ FIX: Ignore very short transcripts (likely noise or bot's own voice)
                if (transcript.length < 2) {
                    console.log('ג ן¸ Ignoring very short transcript (likely noise):', transcript);
                    return;
                }
                
                // נ¯ FIX: Prevent loop - ignore if same message was processed recently
                const now = Date.now();
                if (transcript === lastProcessedMessage && (now - lastMessageTime) < 15000) {
                    console.log('ג ן¸ Ignoring duplicate message (likely loop):', transcript);
                    return;
                }
                
                // נ¯ FIX: Also check if transcript matches common bot responses (prevent hearing bot's voice)
                const commonBotPhrases = [
                    '׳׳¦׳׳×׳™ ׳׳×', '׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳', '׳‘׳•׳§׳¨ ׳˜׳•׳‘', '׳׳” ׳©׳׳•׳׳', '׳©׳׳•׳'
                ];
                const isBotPhrase = commonBotPhrases.some(phrase => transcript.includes(phrase));
                if (isBotPhrase && (now - lastMessageTime) < 10000) {
                    console.log('ג ן¸ Ignoring bot response heard by microphone:', transcript);
                    return;
                }
                
                lastProcessedMessage = transcript;
                lastMessageTime = now;
                
                lastInputWasVoice = true; // Mark that user used voice
                const input = document.getElementById('stavChatInput');
                if (input) {
                    input.value = transcript;
                    sendStavMessage();
                }
            };

            recognition.onerror = function(event) {
                console.error('ג Speech recognition error:', event.error);
                isListening = false;
                const micButton = document.getElementById('micButton');
                if (micButton) {
                    micButton.style.background = '#667eea';
                    micButton.textContent = 'נ₪';
                }
            };

            recognition.onend = function() {
                console.log('נ₪ Stopped listening');
                isListening = false;
                
                // נ¯ ׳׳ ׳–׳” ׳׳¦׳‘ ׳©׳™׳—׳” ׳₪׳×׳•׳—׳”, ׳׳ ׳×׳¢׳¦׳•׳¨ - ׳”׳₪׳¢׳ ׳׳—׳“׳©!
                if (continuousConversation && recognition) {
                    console.log('נ”„ Continuous conversation - waiting for bot to finish speaking...');
                    
                    // נ¯ FIX: Wait for bot to finish speaking before restarting microphone
                    const checkAndRestart = () => {
                        if (continuousConversation && recognition && !isSpeaking && !isListening) {
                            try {
                                const micButton = document.getElementById('micButton');
                                if (micButton) {
                                    micButton.style.background = '#f59e0b'; // נ  ׳›׳×׳•׳
                                    micButton.textContent = 'נ”´';
                                }
                                if (!isListening) {
                                    recognition.start();
                                    console.log('נ₪ Microphone restarted after bot finished speaking');
                                }
                            } catch (e) {
                                if (e.name !== 'InvalidStateError' || !e.message.includes('already started')) {
                                    console.log('ג ן¸ Could not restart recognition:', e);
                                }
                            }
                        } else if (isSpeaking) {
                            // Bot is still speaking, check again in 500ms
                            setTimeout(checkAndRestart, 500);
                        }
                    };
                    
                    // Start checking after 1 second (give bot time to start speaking)
                    setTimeout(checkAndRestart, 1000);
                    return; // ׳׳ ׳×׳—׳–׳™׳¨ ׳׳× ׳”׳›׳₪׳×׳•׳¨ ׳׳›׳—׳•׳
                }
                
                const micButton = document.getElementById('micButton');
                if (micButton) {
                    micButton.style.background = '#667eea';
                    micButton.textContent = 'נ₪';
                }
            };

            return recognition;
        }

        function toggleSpeechRecognition() {
            // If currently speaking, stop the speech
            if (isSpeaking) {
                stopSpeaking();
                return;
            }

            if (!recognition) {
                recognition = initSpeechRecognition();
                if (!recognition) {
                    alert('׳”׳“׳₪׳“׳₪׳ ׳©׳׳ ׳׳ ׳×׳•׳׳ ׳‘׳–׳™׳”׳•׳™ ׳§׳•׳׳™');
                    return;
                }
            }

            // נ¯ ׳׳ ׳–׳” ׳׳¦׳‘ ׳©׳™׳—׳” ׳₪׳×׳•׳—׳” ׳׳• ׳׳׳–׳™׳ - ׳¢׳•׳¦׳¨
            if (isListening || continuousConversation) {
                recognition.stop();
                continuousConversation = false; // ׳¢׳•׳¦׳¨ ׳׳× ׳”׳©׳™׳—׳” ׳”׳₪׳×׳•׳—׳”
                const micButton = document.getElementById('micButton');
                if (micButton) {
                    micButton.style.background = '#667eea';
                    micButton.textContent = 'נ₪';
                }
            } else {
                // נ¯ ׳׳₪׳¢׳™׳ ׳©׳™׳—׳” ׳₪׳×׳•׳—׳”
                continuousConversation = true;
                // ׳¢׳“׳›׳ ׳׳× recognition.continuous
                recognition.continuous = true;
                recognition.start();
            }
        }

        function stopSpeaking() {
            speechSynthesis.cancel();
            isSpeaking = false;
            
            // נ₪– Stop Google TTS audio
            if (window.currentAudio) {
                window.currentAudio.pause();
                window.currentAudio = null;
                console.log('נ₪– Google TTS audio stopped');
            }
            
            const micButton = document.getElementById('micButton');
            if (micButton) {
                micButton.style.background = '#667eea';
                micButton.textContent = 'נ₪';
            }
            console.log('נ”‡ Speech stopped');
        }

        async function speakText(text) {
            // Remove emojis, asterisks, HTML, parentheses, and clean text for speech
            let cleanText = text
                .replace(/<[^>]*>/g, '') // Remove HTML tags
                .replace(/&[^;]+;/g, '') // Remove HTML entities
                .replace(/[נ˜נ’¡נ“נ“נ“§נ נ’°ג…גנ”—נ“„נ×נ‰נ“נ”§נ‘ן¸נ¯נ”נ“נ“נ”נ₪נ”´]/g, '')
                .replace(/\*\*/g, '')
                .replace(/\*/g, '')
                .replace(/\([^)]*\)/g, '') // Remove parentheses
                .replace(/\.{2,}/g, '') // Remove multiple dots
                .replace(/\n\n+/g, '. ')
                .replace(/\n/g, '. ')
                .replace(/ג€¢/g, '')
                .replace(/\|/g, '')
                .replace(/\s+/g, ' ')
                .trim();

            if (!cleanText) return;
            
            // נ¯ REMOVED: SSML prosody tags for "׳׳—׳™׳¨׳™׳" - user doesn't like tone changes

            // Cancel any ongoing speech and audio
            speechSynthesis.cancel();
            if (window.currentAudio) {
                window.currentAudio.pause();
                window.currentAudio = null;
            }

            const micButton = document.getElementById('micButton');
            if (micButton) {
                micButton.style.background = '#10b981';
                micButton.textContent = 'נ”';
            }

            try {
                // נ₪– Google Cloud Text-to-Speech API
                const API_KEY = 'AIzaSyBexR71l9bdJ28OKx8P7QhyQDQpqTPa56o';
                
                console.log('נ₪– Calling Google TTS API...');
                
                // נ¯ Add timeout to prevent hanging (10 seconds max)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                // נ¯ NEW: Add SSML for natural tone and pauses between stores
                // Add pauses between stores (look for store separators)
                let textWithPauses = cleanText;
                
                // נ¯ IMPROVED: Add pause between stores - replace [PAUSE] marker with SSML break
                textWithPauses = textWithPauses
                    .replace(/\[PAUSE\]/g, '<break time="800ms"/>') // Pause between stores (800ms)
                    // Pattern 1: Store name followed by dash (e.g., "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢ - ׳—׳ ׳•׳×...")
                    .replace(/([׳-׳×]+\s+[׳-׳×]+)\s*[-ג€“]\s*/g, '$1<break time="500ms"/>') // Pause after store name before description
                    // Pattern 2: Double newline or period followed by store name (e.g., ". ׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢")
                    .replace(/(\.\s+)([׳-׳×]+\s+[׳-׳×]+)/g, '$1<break time="700ms"/>$2') // Pause before store name
                    // Pattern 3: "׳׳™׳–׳” ׳×׳¨׳¦׳”?" followed by store name
                    .replace(/(\?\s*)([׳-׳×]+\s+[׳-׳×]+)/g, '$1<break time="800ms"/>$2') // Pause after question mark before store
                    // Pattern 4: Colon followed by store name
                    .replace(/(:\s*)([׳-׳×]+\s+[׳-׳×]+)/g, '$1<break time="500ms"/>$2') // Pause after colon before store
                    // Pattern 5: "׳׳₪׳©׳¨׳•׳™׳•׳×:" or similar followed by store names
                    .replace(/(׳׳₪׳©׳¨׳•׳™׳•׳×|׳“׳₪׳™׳|׳—׳ ׳•׳™׳•׳×)[:\s]+/g, '$1<break time="600ms"/>');
                
                // Use SSML for natural prosody (tone) - faster and robotic
                const ssmlText = `<speak>
                    <prosody rate="1.3" pitch="-2st" volume="medium">
                        ${textWithPauses}
                    </prosody>
                </speak>`;
                
                const input = { ssml: ssmlText };
                
                const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${API_KEY}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        input: input,
                        voice: {
                            languageCode: 'he-IL',
                            name: 'he-IL-Wavenet-C', // Female robotic voice (Wavenet = highest quality available for Hebrew)
                            ssmlGender: 'FEMALE'
                        },
                        audioConfig: {
                            audioEncoding: 'MP3',
                            pitch: -1.0,        // Lower pitch (more robotic, but still female)
                            speakingRate: 1.6,  // Faster speech rate (more robotic and faster)
                            volumeGainDb: 0.0,  // Normal volume
                            effectsProfileId: ['telephony-class-application'] // Robotic effect
                        }
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);

                const data = await response.json();
                
                if (data.error) {
                    console.error('ג Google TTS error:', data.error);
                    throw new Error(data.error.message);
                }
                
                if (data.audioContent) {
                    console.log('ג… Received audio from Google TTS');
                    
                    // Convert base64 to audio and play
                    const audio = new Audio('data:audio/mp3;base64,' + data.audioContent);
                    window.currentAudio = audio;
                    
                    audio.onplay = () => {
                        isSpeaking = true;
                        console.log('נ” Speaking (Google TTS):', cleanText.substring(0, 50) + '...');
                        
                        // נ¯ FIX: Stop microphone when bot starts speaking to prevent hearing its own voice
                        if (recognition && isListening) {
                            try {
                                recognition.stop();
                                console.log('נ₪ Stopped microphone - bot is speaking');
                            } catch (e) {
                                console.log('ג ן¸ Could not stop recognition:', e);
                            }
                        }
                    };
                    
                    audio.onended = () => {
                        isSpeaking = false;
                        console.log('ג… Speech finished');
                        
                        // נ¯ ׳׳ ׳–׳” ׳©׳™׳—׳” ׳₪׳×׳•׳—׳”, ׳”׳₪׳¢׳ ׳׳× ׳”׳׳™׳§׳¨׳•׳₪׳•׳ ׳׳—׳“׳© ׳׳”׳¨!
                        if (continuousConversation && recognition) {
                            // נ¯ FIX: Restart microphone quickly after bot finishes speaking (short delay to avoid echo)
                            setTimeout(() => {
                                if (continuousConversation && recognition && !isSpeaking && !isListening) {
                                    try {
                                        const micButton = document.getElementById('micButton');
                                        if (micButton) {
                                            micButton.style.background = '#f59e0b'; // נ  ׳›׳×׳•׳
                                            micButton.textContent = 'נ”´';
                                        }
                                        if (!isListening) {
                                            recognition.start();
                                            console.log('נ₪ Microphone restarted quickly after bot finished');
                                        }
                                    } catch (e) {
                                        if (e.name !== 'InvalidStateError' || !e.message.includes('already started')) {
                                            console.log('ג ן¸ Could not restart recognition:', e);
                                        }
                                    }
                                }
                            }, 500); // נ¯ Short delay (500ms) - bot already finished, restart quickly
                        } else {
                            const micButton = document.getElementById('micButton');
                            if (micButton) {
                                micButton.style.background = '#667eea';
                                micButton.textContent = 'נ₪';
                            }
                        }
                    };
                    
                    audio.onerror = (e) => {
                        console.error('ג Audio playback error:', e);
                        isSpeaking = false;
                        if (micButton) {
                            micButton.style.background = '#667eea';
                            micButton.textContent = 'נ₪';
                        }
                    };
                    
                    await audio.play();
                } else {
                    throw new Error('No audio content received');
                }
            } catch (error) {
                console.error('ג Google TTS error:', error);
                console.error('ג Error details:', error.message);
                console.error('ג Error name:', error.name);
                
                // נ¯ Check error type
                if (error.name === 'AbortError') {
                    console.warn('ג ן¸ Google TTS request timed out (>10s)');
                } else if (error.message && (error.message.includes('quota') || error.message.includes('429'))) {
                    console.warn('ג ן¸ Google TTS quota exceeded or rate limit hit');
                } else if (error.message && error.message.includes('API key')) {
                    console.warn('ג ן¸ Google TTS API key issue');
                } else if (error.message && error.message.includes('network')) {
                    console.warn('ג ן¸ Network error - no internet connection?');
                }
                
                // Fallback to browser TTS if Google fails
                console.log('ג ן¸ Falling back to browser TTS');
                
                try {
                    const utterance = new SpeechSynthesisUtterance(cleanText);
                    utterance.lang = 'he-IL';
                    utterance.rate = 1.6; // Faster speech rate (more robotic and faster)
                    utterance.pitch = 0.8; // Lower pitch (more robotic)
                    
                    utterance.onstart = () => {
                        isSpeaking = true;
                        console.log('נ” Browser TTS started (fallback)');
                        
                        // נ¯ FIX: Stop microphone when bot starts speaking to prevent hearing its own voice
                        if (recognition && isListening) {
                            try {
                                recognition.stop();
                                console.log('נ₪ Stopped microphone - bot is speaking');
                            } catch (e) {
                                console.log('ג ן¸ Could not stop recognition:', e);
                            }
                        }
                    };
                    
                    utterance.onend = () => {
                        isSpeaking = false;
                        console.log('ג… Browser TTS finished (fallback)');
                        
                        // נ¯ ׳׳ ׳–׳” ׳©׳™׳—׳” ׳₪׳×׳•׳—׳”, ׳”׳₪׳¢׳ ׳׳× ׳”׳׳™׳§׳¨׳•׳₪׳•׳ ׳׳—׳“׳© ׳׳”׳¨!
                        if (continuousConversation && recognition) {
                            // נ¯ FIX: Restart microphone quickly after bot finishes speaking (short delay to avoid echo)
                            setTimeout(() => {
                                if (continuousConversation && recognition && !isSpeaking && !isListening) {
                                    try {
                                        const micButton = document.getElementById('micButton');
                                        if (micButton) {
                                            micButton.style.background = '#f59e0b'; // נ  ׳›׳×׳•׳
                                            micButton.textContent = 'נ”´';
                                        }
                                        if (!isListening) {
                                            recognition.start();
                                            console.log('נ₪ Microphone restarted quickly after bot finished (fallback)');
                                        }
                                    } catch (e) {
                                        if (e.name !== 'InvalidStateError' || !e.message.includes('already started')) {
                                            console.log('ג ן¸ Could not restart recognition:', e);
                                        }
                                    }
                                }
                            }, 500); // נ¯ Short delay (500ms) - bot already finished, restart quickly
                        } else {
                            const micButton = document.getElementById('micButton');
                            if (micButton) {
                                micButton.style.background = '#667eea';
                                micButton.textContent = 'נ₪';
                            }
                        }
                    };
                    
                    utterance.onerror = (e) => {
                        console.error('ג Browser TTS error:', e);
                        isSpeaking = false;
                        if (micButton) {
                            micButton.style.background = '#667eea';
                            micButton.textContent = 'נ₪';
                        }
                    };
                    
                    speechSynthesis.speak(utterance);
                } catch (fallbackError) {
                    console.error('ג Browser TTS fallback also failed:', fallbackError);
                    // Reset mic button
                    isSpeaking = false;
                    if (micButton) {
                        micButton.style.background = '#667eea';
                        micButton.textContent = 'נ₪';
                    }
                }
            }
        }

        // נ¯ NEW SIMPLE BOT - ׳›׳ ׳“׳‘׳¨ ׳¢׳•׳‘׳¨ ׳“׳¨׳ N8N!
        async function sendStavMessage() {
            const input = document.getElementById('stavChatInput');
            const userMessage = input.value.trim();
            
            if (!userMessage) return;
            
            // ׳׳ ׳¢ ׳”׳•׳“׳¢׳•׳× ׳›׳₪׳•׳׳•׳×
            const now = Date.now();
            if (userMessage === lastSentUserMessage && (now - lastSentUserMessageTime) < 10000) {
                console.log('ג ן¸ Ignoring duplicate:', userMessage);
                return;
            }
            
            lastSentUserMessage = userMessage;
            lastSentUserMessageTime = now;
            
            // נ¯ FIX: Store user message in window for later use (for price list detection)
            window.lastUserMessage = userMessage;
            // נ¯ FIX: Store search context (category, city) for "׳—׳ ׳•׳× ׳׳—׳¨׳×" / "׳׳—׳¨׳×" requests
            // Extract category and city from user message
            // נ¯ IMPROVED: Also detect "׳™׳© X", "׳׳¡׳₪׳¨׳”", "׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨", etc.
            const categoryMatch = userMessage.match(/(?:׳׳—׳₪׳©|׳׳—׳₪׳©׳×|׳¨׳•׳¦׳”|׳¦׳¨׳™׳|׳¦׳¨׳™׳›׳”|׳™׳©|׳׳™׳₪׳”|׳”׳™׳›׳)\s+([׳-׳×\s]+?)(?:\s+׳‘|\s+׳‘׳×׳•׳|\s+׳‘׳©׳“׳”|\s*$)/i);
            const cityMatch = userMessage.match(/(?:׳‘|׳‘׳×׳•׳|׳‘׳©׳“׳”)\s+([׳-׳×\s]+)/i);
            
            // נ¯ NEW: If no category match, check if the entire message is a known service category
            const knownServiceCategories = [
                '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×',
                '׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨', '׳©׳¨׳‘׳¨׳‘', '׳—׳©׳׳׳׳™', '׳ ׳’׳¨', '׳¦׳‘׳¢', '׳׳¡׳’׳¨',
                '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳׳™׳×', '׳§׳•׳¡׳׳˜׳™׳§׳”',
                '׳¦׳׳', '׳¦׳™׳׳•׳', '׳׳׳׳', '׳׳׳׳ ׳×'
            ];
            
            let detectedCategory = categoryMatch ? categoryMatch[1].trim() : null;
            
            // If no category detected yet, check if message contains a known service category
            if (!detectedCategory) {
                for (const category of knownServiceCategories) {
                    if (userMessage.toLowerCase().includes(category.toLowerCase())) {
                        detectedCategory = category;
                        console.log(`ג… Detected known service category from message: "${category}"`);
                        break;
                    }
                }
            }
            
            if (detectedCategory || cityMatch) {
                window.lastSearchCategory = detectedCategory;
                window.lastSearchCity = cityMatch ? cityMatch[1].trim() : null;
                console.log('נ’¾ Stored search context - category:', window.lastSearchCategory, 'city:', window.lastSearchCity);
            }
            console.log('נ’¾ Stored user message:', userMessage);
            
            // Check if this was a typed message (not voice)
            const wasVoice = lastInputWasVoice;
            console.log('ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”');
            console.log('נ“¨ INPUT METHOD:', wasVoice ? 'נ₪ VOICE' : 'ג¨ן¸ TEXT');
            console.log('נ“ MESSAGE:', userMessage);
            console.log('נ” MESSAGE LENGTH:', userMessage.length);
            console.log('נ”₪ MESSAGE CHARS:', Array.from(userMessage).map(c => c.charCodeAt(0)));
            console.log(wasVoice ? 'נ” Response will be SPOKEN + TEXT' : 'נ“ Response will be TEXT ONLY');
            console.log('ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”ג”');
            
            // Display user message
            addStavMessage(userMessage, true);
            // נ¯ FIX: Clear input IMMEDIATELY to prevent showing user text again
            input.value = '';
            
            // Reset voice flag after sending (for next message)
            // Don't reset here - wait for response to be added
            // lastInputWasVoice = false;
            
            // נ¯ FIX: Show "׳¡׳×׳™׳• ׳׳§׳׳™׳“׳”" WITH animation (loader)
            const typingMessageDiv = document.createElement('div');
            typingMessageDiv.className = 'stav-message bot stav-typing-indicator';
            typingMessageDiv.id = 'stav-typing-indicator';
            typingMessageDiv.innerHTML = `
                <div class="stav-loader">
                    <div class="inner one"></div>
                    <div class="inner two"></div>
                    <div class="inner three"></div>
                </div>
                <span>׳¡׳×׳™׳• ׳׳§׳׳™׳“׳”...</span>
            `;
            const messagesDiv = document.getElementById('stavChatMessages');
            messagesDiv.appendChild(typingMessageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            try {
                // Get all pages for Stav
                const response = await fetch('/api/pages/all');
                if (!response.ok) {
                    console.error('ג Failed to fetch pages:', response.status, response.statusText);
                    // נ¯ FIX: Remove typing indicator ONLY after bot responds
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) typingIndicator.remove();
                    addStavMessage('׳׳¦׳˜׳¢׳¨, ׳‘׳¢׳™׳” ׳‘׳˜׳¢׳™׳ ׳× ׳”׳“׳₪׳™׳ ׳׳”׳©׳¨׳×. ׳ ׳¡׳” ׳©׳•׳‘ ׳׳׳•׳—׳¨ ׳™׳•׳×׳¨.', false);
                    return;
                }
                const data = await response.json();
                const allPages = data.pages || data || [];
                
                console.log('נ“ All pages for Stav:', allPages.length, 'pages');
                if (allPages.length === 0) {
                    console.warn('ג ן¸ No pages returned from API!');
                }
                
                // Process the message and get response
                let botResponse = await processStavMessage(userMessage, allPages);
                
                // נ¯ SMART FALLBACK: ׳¨׳§ ׳׳ ׳–׳• ׳©׳׳׳” ׳¢׳ ׳׳•׳¦׳¨׳™׳/׳©׳™׳¨׳•׳×׳™׳ ׳¡׳₪׳¦׳™׳₪׳™׳™׳ - ׳—׳₪׳© ׳™׳©׳™׳¨׳•׳×
                // ׳©׳׳׳•׳× ׳׳™׳©׳™׳•׳× ׳›׳׳• "׳׳™ ׳׳×", "׳©׳׳•׳", "׳׳” ׳§׳•׳¨׳”" - ׳™׳׳›׳• ׳-N8N
                if (!botResponse || botResponse === null) {
                    // ׳‘׳“׳•׳§ ׳׳ ׳–׳• ׳©׳׳׳” ׳׳™׳©׳™׳× (׳׳ ׳¦׳¨׳™׳ ׳—׳™׳₪׳•׳©)
                    const personalQuestionsPattern = /^(׳׳™\s+׳׳×|׳׳™\s+׳׳×׳”|׳©׳׳•׳|׳”׳™׳™|׳”׳™|׳׳”\s+׳©׳׳•׳׳|׳׳”\s+׳§׳•׳¨׳”|׳׳”\s+׳ ׳©׳׳¢|׳׳™׳\s+׳׳×|׳׳™׳\s+׳׳×׳”|׳׳”\s+׳”׳׳¦׳‘|׳×׳•׳“׳”|׳×׳•׳“׳”\s+׳¨׳‘׳”)/i;
                    const isPersonalQuestion = personalQuestionsPattern.test(userMessage.trim());
                    
                    // ׳‘׳“׳•׳§ ׳׳ ׳™׳© ׳׳™׳׳•׳× ׳׳₪׳×׳— ׳©׳ ׳׳•׳¦׳¨׳™׳/׳©׳™׳¨׳•׳×׳™׳
                    const productKeywords = /(׳¦׳¢׳¦׳•׳¢|׳¦׳¢׳¦׳•׳¢׳™׳|׳©׳¢׳•׳|׳©׳¢׳•׳ ׳™׳|׳׳§|׳׳ ׳™׳§׳•׳¨|׳׳¡׳₪׳¨׳”|׳¡׳₪׳¨|׳ ׳’׳¨|׳ ׳’׳¨׳•׳×|׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨|׳—׳©׳׳׳׳™|׳§׳•׳¨׳¡|׳§׳•׳¨׳¡׳™׳|׳—׳ ׳•׳×|׳׳•׳¦׳¨|׳׳•׳¦׳¨׳™׳|׳©׳™׳¨׳•׳×|׳׳×׳ ׳”)/i;
                    const hasProductKeyword = productKeywords.test(userMessage);
                    
                    // ׳¨׳§ ׳׳ ׳–׳• ׳׳ ׳©׳׳׳” ׳׳™׳©׳™׳× ׳•׳™׳© ׳׳™׳׳× ׳׳₪׳×׳— ׳©׳ ׳׳•׳¦׳¨ - ׳—׳₪׳©
                    if (!isPersonalQuestion && hasProductKeyword && userMessage.length > 2) {
                        console.log('נ” Product query detected - trying simple direct search');
                        try {
                            let cleanQuery = userMessage.toLowerCase().trim()
                                .replace(/׳׳—׳₪׳©/gi, '')
                                .replace(/׳׳—׳₪׳©׳×/gi, '')
                                .replace(/׳׳ ׳™/gi, '')
                                .replace(/^׳×\s+/, '')
                                .trim();
                            
                            console.log(`נ” Simple search for: "${cleanQuery}"`);
                            
                            const searchResults = [];
                            if (allPages && Array.isArray(allPages)) {
                                for (const page of allPages) {
                                    try {
                                        const title = String(page.title || '').toLowerCase();
                                        const desc = String(page.description || '').toLowerCase();
                                        const query = cleanQuery.toLowerCase();
                                        
                                        if (title.includes(query) || desc.includes(query)) {
                                            searchResults.push(page);
                                        }
                                    } catch (e) {
                                        // ׳׳“׳׳’ ׳¢׳ ׳“׳£ ׳–׳”
                                    }
                                }
                            }
                            
                            console.log(`ג… Simple search found ${searchResults.length} results`);
                            
                            if (searchResults.length > 0) {
                                botResponse = {
                                    type: 'pages',
                                    pages: searchResults.slice(0, 5),
                                    message: searchResults.length === 1 
                                        ? `׳׳¦׳׳×׳™ ׳׳× ${searchResults[0].title}.` 
                                        : `׳׳¦׳׳×׳™ ${Math.min(searchResults.length, 5)} ׳׳₪׳©׳¨׳•׳™׳•׳×.`,
                                    includeLinks: false,
                                    needsPreview: false
                                };
                            }
                        } catch (error) {
                            console.error('ג Error in smart fallback:', error);
                        }
                    } else {
                        console.log('ג„¹ן¸ Personal question or no product keyword - will send to N8N for conversation');
                    }
                }
                
                // נ¯ FIX: Handle text responses (like "׳׳” ׳”׳׳•׳¦׳¨ ׳”׳›׳™ ׳–׳•׳") FIRST - don't send to N8N!
                if (botResponse && (botResponse.type === 'text' || botResponse.type === 'message') && botResponse.message) {
                    console.log('ג… Found text response, displaying directly:', botResponse.message);
                
                // Remove typing indicator
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) {
                        typingIndicator.remove();
                    }
                    
                    // Display the message
                    addStavMessage(botResponse.message, false);
                    
                    // נ¯ FIX: Clear input field AFTER bot responds
                    const inputField = document.getElementById('stavChatInput');
                    if (inputField) inputField.value = '';
                    
                    return; // Don't send to N8N
                }
                
                // If we have pages to display, show them as TEXT ONLY (no buttons!)
                // נ¯ User wants ONLY text conversation - NO buttons/preview!
                if (botResponse && botResponse.type === 'pages' && botResponse.pages && botResponse.pages.length > 0) {
                    console.log('ג… Found pages, displaying as TEXT ONLY (no buttons):', botResponse.pages.length);
                    
                    // נ¯ Save pages in context for later use (if user asks for link)
                    // נ¯ FIX: Make a deep copy to prevent reference issues
                    window.stavCurrentPages = botResponse.pages.map(p => ({ ...p }));
                    console.log('נ’¾ Saved', botResponse.pages.length, 'pages to context from botResponse');
                    console.log('נ’¾ Pages saved:', window.stavCurrentPages.map(p => p.title).join(', '));
                    console.log('נ’¾נ’¾נ’¾ CURRENT CONTEXT - window.stavCurrentPages:', window.stavCurrentPages.map(p => p.title).join(' | '));
                    
                    // Remove typing indicator
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) typingIndicator.remove();
                    
                    // נ¯ NEW: If user explicitly requested to see the page, show preview WITHOUT repeating text!
                    console.log('נ“ [PREVIEW DEBUG] needsPreview:', botResponse.needsPreview);
                    console.log('נ“ [PREVIEW DEBUG] includeLinks:', botResponse.includeLinks);
                    console.log('נ“ [PREVIEW DEBUG] pages count:', botResponse.pages?.length);
                    
                    if (botResponse.needsPreview === true) {
                        console.log('נ–¼ן¸ג… SHOWING IFRAME ONLY (no text!) because needsPreview=true');
                        // Show short polite message with LIVE description before iframe
                        const bestPage = botResponse.pages[0];
                        if (bestPage) {
                            let shortMessage = `׳‘׳‘׳§׳©׳”, ׳”׳ ׳” ׳”׳“׳£ ׳©׳ ${bestPage.title}`;
                            
                            // Fetch the page to extract LIVE description
                            const pageUrl = `/users/${bestPage.userId}/${bestPage.pageId}_html`;
                            try {
                                const pageResponse = await fetch(pageUrl);
                                if (pageResponse.ok) {
                                    const html = await pageResponse.text();
                                    const liveDesc = extractLiveDescription(html);
                                    
                                    if (liveDesc && liveDesc.length > 0) {
                                        // Use full description - don't cut it!
                                        shortMessage += ` - ${liveDesc}`;
                                    }
                                }
                            } catch (error) {
                                console.error('ג Error fetching live description:', error);
                            }
                            
                            addStavMessage(shortMessage, false);
                            console.log('ג… Added short intro message with LIVE description:', shortMessage);
                            
                            // נ¯ FIX: Clear input field AFTER bot responds
                            const inputField = document.getElementById('stavChatInput');
                            if (inputField) inputField.value = '';
                        }
                        // Show iframe after short delay
                        setTimeout(async () => {
                            if (bestPage) {
                                await displayPagePreview(bestPage, 'stavChatMessages');
                                console.log('ג… Displayed page preview for:', bestPage.title);
                            }
                        }, 100); // Show immediately
                    } else {
                        console.log('נ“ Showing text response (no preview) because needsPreview=false');
                        
                        // נ¯ FIX: Always show text response (talk about pages), not buttons
                        // User wants conversation, not a list of pages with buttons
                        const messageToPass = botResponse.message || userMessage || `׳׳¦׳׳×׳™ ${botResponse.pages.length} ׳“׳₪׳™׳ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳`;
                        const includeLinks = botResponse.includeLinks || false;
                        
                        // נ¯ Save all results to context for "׳׳—׳¨׳™׳" option
                        window.stavCurrentPages = botResponse.pages;
                        if (botResponse.pages._allResults) {
                            window.stavCurrentPages._allResults = botResponse.pages._allResults;
                            window.stavCurrentPages._currentOffset = botResponse.pages._currentOffset || 0;
                            window.stavCurrentPages._hasMore = botResponse.pages._hasMore || false;
                        }
                        console.log('נ’¾ Saved pages to context for "׳׳—׳¨׳™׳" option:', botResponse.pages.length);
                        
                        const textResponse = await generateTextResponseWithRealData(botResponse.pages, messageToPass, includeLinks);
                        if (textResponse && textResponse.trim().length > 0) {
                            // נ¯ FIX: Remove typing indicator ONLY after bot responds
                            const typingIndicator = document.getElementById('stav-typing-indicator');
                            if (typingIndicator) typingIndicator.remove();
                            
                            addStavMessage(textResponse, false);
                            console.log('ג… Added text response with real data (NO buttons) - talking about pages');
                            
                            // נ¯ FIX: Clear input field AFTER bot responds
                            const inputField = document.getElementById('stavChatInput');
                            if (inputField) inputField.value = '';
                        }
                    }
                    
                    // נ¯ IMPROVED: DON'T send to N8N when we have successful local results!
                    // This prevents timeout/errors and makes the bot faster
                    console.log('ג… Local search successful - NOT sending to N8N (prevents timeout)');
                    stavFirstReplySent = true;
                    return; // Exit - don't send to N8N!
                } else if (botResponse && botResponse.type === 'message') {
                    // Just a text message, display it directly
                    // Remove typing indicator before displaying message
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) typingIndicator.remove();
                    
                    addStavMessage(botResponse.message, false);
                    
                    // נ¯ FIX: Clear input field AFTER bot responds
                    const inputField = document.getElementById('stavChatInput');
                    if (inputField) inputField.value = '';
                    
                    stavFirstReplySent = true;
                    return; // Don't send to N8N for simple messages
                } else if (botResponse === null) {
                    // botResponse is null - this means send to N8N (general questions, etc.)
                    console.log('נ’¬ botResponse is null - sending to N8N for intelligent response');
                    // נ¯ FIX: Keep typing indicator until N8N responds
                } else {
                    // Unknown response type - keep typing indicator until N8N responds
                    console.log('ג ן¸ Unknown botResponse type, sending to N8N');
                    // נ¯ FIX: Don't remove typing indicator here - wait for N8N to respond
                }
                
                // Send to N8N for conversational response (for general questions or context)
                console.log('נ’¬ Sending to N8N webhook for conversational response');
                try {
                    const webhookUrl = '/api/n8n-webhook'; // Use proxy route instead of direct N8N
                    
                    // נ¯ NEW: Add timeout to prevent bot from getting stuck (10 seconds)
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => {
                        controller.abort();
                        // נ¯ FIX: Clear input field on timeout
                        const inputField = document.getElementById('stavChatInput');
                        if (inputField) inputField.value = '';
                        // נ¯ FIX: Remove typing indicator on timeout
                        const typingIndicator = document.getElementById('stav-typing-indicator');
                        if (typingIndicator) typingIndicator.remove();
                    }, 10000); // 10 second timeout
                    
                    // CRITICAL: Reload pages if allPages is empty or not loaded yet
                    if (!allPages || allPages.length === 0) {
                        console.log('ג ן¸ allPages is empty! Reloading pages...');
                        await loadPages();
                        console.log(`ג… Reloaded pages: ${allPages.length} pages available`);
                    }
                    
                    // Check if this is a question about service providers - include ALL serviceProvider pages
                    const isServiceProviderQuestion = /(?:׳›׳׳”|׳׳”|׳™׳©|׳׳—׳₪׳©|׳¦׳¨׳™׳|׳׳™׳–׳”|׳׳™)\s*(?:׳ ׳•׳×׳ ׳™|׳׳¡׳₪׳§׳™|׳‘׳¢׳׳™|׳‘׳¢׳)?\s*(?:׳©׳¨׳•׳×|׳©׳™׳¨׳•׳×|׳׳§׳¦׳•׳¢)/.test(userMessage.toLowerCase()) || 
                                                      /׳‘׳¢׳׳™\s*׳׳§׳¦׳•׳¢|׳‘׳¢׳\s*׳׳§׳¦׳•׳¢/.test(userMessage.toLowerCase());
                    
                    // נ¯ NEW: Check if query looks like a marketplace search (single words like "׳ ׳’׳¨", "׳׳§", "׳¦׳¢׳¦׳•׳¢׳™׳")
                    // Even if processStavMessage didn't catch it, we should find matching pages and send them
                    let matchingPagesForBody = [];
                    const userMessageLower = userMessage.toLowerCase().trim();
                    const isShortQuery = userMessageLower.length > 1 && userMessageLower.length < 30 && 
                                        !userMessageLower.includes('?') && 
                                        !userMessageLower.match(/^(׳׳”|׳׳™׳|׳׳׳”|׳׳“׳•׳¢|׳׳×׳™|׳׳™׳₪׳”)/);
                    
                    // If it's a short query (likely marketplace search), try to find matching pages
                    if (isShortQuery && allPages && allPages.length > 0) {
                        console.log(`נ” Short query detected - checking for matching pages: "${userMessageLower}"`);
                        
                        // נ¯ Get synonyms map for matching
                        const synonymMapForBody = {
                            '׳׳¡׳₪׳¨׳”': ['׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳×׳¡׳₪׳•׳¨׳•׳×', '׳׳¡׳₪׳¨', '׳¡׳₪׳¨ ׳’׳‘׳¨׳™׳', '׳¡׳₪׳¨׳•׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨'],
                            '׳×׳¡׳₪׳•׳¨׳×': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳׳¡׳₪׳¨', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                            '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                            '׳׳¢׳¦׳‘ ׳©׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                            '׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨': ['׳׳¡׳₪׳¨׳”', '׳¡׳₪׳¨', '׳×׳¡׳₪׳•׳¨׳×', '׳׳¢׳¦׳‘ ׳©׳™׳¢׳¨', '׳׳¢׳¦׳‘ ׳©׳¢׳¨', '׳׳¢׳¦׳‘׳× ׳©׳™׳¢׳¨'],
                            '׳׳§': ['׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳׳§ ׳’\'׳', '׳׳§ ׳’׳', '׳¢׳™׳¦׳•׳‘ ׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳'],
                            '׳׳§ ׳’׳': ['׳׳§', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳׳§ ׳’\'׳', '׳¢׳™׳¦׳•׳‘ ׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳'],
                            '׳׳§ ׳’\'׳': ['׳׳§', '׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳', '׳׳ ׳™׳§׳•׳¨', '׳₪׳“׳™׳§׳•׳¨', '׳׳§ ׳’׳', '׳¢׳™׳¦׳•׳‘ ׳¦׳™׳₪׳•׳¨׳ ׳™׳™׳']
                        };
                        
                        // Get synonyms for query
                        const querySynonyms = synonymMapForBody[userMessageLower] || [];
                        const allQueryTerms = [userMessageLower, ...querySynonyms];
                        const queryWords = userMessageLower.split(/\s+/).filter(w => w.length > 1);
                        queryWords.forEach(word => {
                            const wordSynonyms = synonymMapForBody[word] || [];
                            allQueryTerms.push(...wordSynonyms);
                        });
                        const uniqueQueryTerms = [...new Set(allQueryTerms)];
                        
                        for (const page of allPages) {
                            const pageTitle = (page.title || '').toLowerCase();
                            const pageDesc = (page.description || '').toLowerCase();
                            const pageProducts = (page.products || []).map(p => (p.name || '').toLowerCase()).join(' ');
                            const pageCity = (page.city || '').toLowerCase();
                            
                            // נ¯ IMPROVED: Check if query OR any of its synonyms matches page (title, description, products, or city)
                            const hasMatch = uniqueQueryTerms.some(term => 
                                pageTitle.includes(term) || 
                                pageDesc.includes(term) || 
                                pageProducts.includes(term)
                            ) || 
                            pageTitle.includes(userMessageLower) || 
                                pageDesc.includes(userMessageLower) || 
                                pageProducts.includes(userMessageLower) ||
                                userMessageLower.includes(pageTitle.split(' ')[0]) ||
                                pageTitle.split(' ').some(word => word.length > 2 && userMessageLower.includes(word)) ||
                                // Also check if query is in city (e.g., "׳ ׳×׳ ׳™׳”")
                                (pageCity && pageCity.includes(userMessageLower));
                            
                            if (hasMatch) {
                                
                                // נ¯ FIX: Extract products from live page if not in metadata
                                let products = page.products || [];
                                
                                // נ¯ FIX: ALWAYS extract products from live page to get latest prices
                                // User said "׳׳ ׳׳ ׳™ ׳׳©׳ ׳” ׳‘׳“׳₪׳™׳ ׳׳—׳™׳¨׳™׳ ׳”׳‘׳•׳˜ ׳׳׳•׳¨ ׳׳–׳”׳•׳× ׳׳× ׳–׳”" - so we need LIVE data!
                                const alwaysExtractProducts = true; // Always get live data for latest prices!
                                if (alwaysExtractProducts || !products || products.length === 0) {
                                    try {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        const response = await fetch(pageUrl);
                                        if (response.ok) {
                                            const html = await response.text();
                                            const liveProducts = extractLiveProducts(html);
                                            // Always use live products if found (to get latest prices)
                                            if (liveProducts && liveProducts.length > 0) {
                                                products = liveProducts;
                                                console.log(`נ›’ Extracted ${products.length} LIVE products from page for "${page.title}":`, products.map(p => `${p.name} - ג‚×${p.price}`));
                                            } else if (!page.products || page.products.length === 0) {
                                                // Fallback to metadata if live extraction failed
                                                products = page.products || [];
                                            }
                                        }
                                    } catch (error) {
                                        console.error(`Error extracting products for "${page.title}":`, error);
                                        // Fallback to metadata if extraction fails
                                        if (!products || products.length === 0) {
                                            products = page.products || [];
                                        }
                                    }
                                }
                                
                                // Add page to matching pages for body
                                const phone = page.phone || null;
                                const phones = page.phones || [];
                                const email = page.email || null;
                                const city = page.city || null;
                                const address = page.address || null;
                                
                                matchingPagesForBody.push({
                                    title: page.title,
                                    type: page.pageType || 'unknown',
                                    userId: page.userId,
                                    pageId: page.pageId,
                                    description: page.description || '',
                                    url: `/users/${page.userId}/${page.pageId}_html`,
                                    phone: phone,
                                    phones: phones,
                                    email: email,
                                    city: city,
                                    address: address,
                                    products: products.map(prod => ({ name: prod.name, price: prod.price }))
                                });
                                
                                console.log(`ג… Found matching page for body: ${page.title} (${products.length} products)`);
                            }
                        }
                        
                        if (matchingPagesForBody.length > 0) {
                            console.log(`נ“‹ Found ${matchingPagesForBody.length} matching pages for body`);
                        }
                    }
                    
                    // Prepare pages to send - ALWAYS send ALL pages to N8N so it knows what exists
                    // CRITICAL: Include REAL contact info (phone, city, address) so N8N can use REAL data
                    let pagesToSend = [];
                    if (botResponse && botResponse.type === 'pages' && botResponse.pages && botResponse.pages.length > 0) {
                        // Send the actual found pages WITH REAL CONTACT INFO
                        pagesToSend = botResponse.pages.slice(0, 20).map(p => {
                            // Use metadata FIRST, fallback to liveContactInfo
                            const phone = p.phone || (p.liveContactInfo && p.liveContactInfo.phone) || null;
                            const phones = p.phones || (p.liveContactInfo && p.liveContactInfo.phones) || [];
                            const email = p.email || (p.liveContactInfo && p.liveContactInfo.email) || null;
                            const city = p.city || (p.liveContactInfo && p.liveContactInfo.city) || null;
                            const address = p.address || (p.liveContactInfo && p.liveContactInfo.address) || null;
                            const products = p.products || p.liveProducts || [];
                            
                            return {
                                title: p.title,
                                type: p.pageType || 'unknown',
                                userId: p.userId,
                                pageId: p.pageId,
                                description: p.description || '',
                                url: `/users/${p.userId}/${p.pageId}_html`,
                                // Include REAL contact info (from metadata or live data)
                                phone: phone,
                                phones: phones,
                                email: email,
                                city: city,
                                address: address,
                                products: products.map(prod => ({ name: prod.name, price: prod.price }))
                            };
                        });
                        console.log(`נ“₪ Sending ${pagesToSend.length} found pages to N8N WITH REAL CONTACT INFO`);
                    } else {
                        // No specific results OR general question - send ALL pages to N8N so it knows what exists
                        // CRITICAL: Always send all pages, not just 20, so N8N has full context
                        if (allPages && allPages.length > 0) {
                            pagesToSend = allPages.map(p => {
                                const phone = p.phone || null;
                                const phones = p.phones || [];
                                const email = p.email || null;
                                const city = p.city || null;
                                const address = p.address || null;
                                const products = p.products || [];
                                
                                return {
                                    title: p.title,
                                    type: p.pageType || 'unknown',
                                    userId: p.userId,
                                    pageId: p.pageId,
                                    description: p.description || '',
                                    url: `/users/${p.userId}/${p.pageId}_html`,
                                    // Include REAL contact info from metadata
                                    phone: phone,
                                    phones: phones,
                                    email: email,
                                    city: city,
                                    address: address,
                                    products: products.map(prod => ({ name: prod.name, price: prod.price }))
                                };
                            });
                            console.log(`נ“₪ Sending ALL ${pagesToSend.length} pages to N8N WITH REAL CONTACT INFO`);
                        } else {
                            console.error('ג ERROR: allPages is still empty! Cannot send pages to N8N.');
                        }
                    }
                    
                    // If service provider question, filter to service providers WITH REAL CONTACT INFO
                        if (isServiceProviderQuestion && allPages) {
                            const serviceProviderPages = allPages.filter(p => p.pageType === 'serviceProvider');
                            console.log(`נ”§ Found ${serviceProviderPages.length} service provider pages to send to N8N`);
                        pagesToSend = serviceProviderPages.slice(0, 20).map(p => {
                            const phone = p.phone || null;
                            const phones = p.phones || [];
                            const email = p.email || null;
                            const city = p.city || null;
                            const address = p.address || null;
                            const products = p.products || [];
                            
                            return {
                                title: p.title,
                                type: p.pageType || 'serviceProvider',
                                userId: p.userId,
                                pageId: p.pageId,
                                description: p.description || '',
                                url: `/users/${p.userId}/${p.pageId}_html`,
                                // Include REAL contact info from metadata
                                phone: phone,
                                phones: phones,
                                email: email,
                                city: city,
                                address: address,
                                products: products.map(prod => ({ name: prod.name, price: prod.price }))
                            };
                        });
                        console.log(`נ“₪ Sending ${pagesToSend.length} service provider pages WITH REAL CONTACT INFO`);
                        }
                        
                        // נ¯ IMPROVED: If we found matching pages for body, include them even if pagesToSend is empty
                        // This ensures N8N always gets relevant pages for marketplace queries like "׳ ׳’׳¨", "׳׳§", "׳¦׳¢׳¦׳•׳¢׳™׳"
                        if (matchingPagesForBody.length > 0 && pagesToSend.length === 0) {
                            console.log(`נ“‹ Using ${matchingPagesForBody.length} matching pages for body instead of empty pagesToSend`);
                            pagesToSend = matchingPagesForBody;
                        }
                        
                        console.log('נ“₪ Sending to N8N:', {
                            message: userMessage,
                            context: 'stav-marketplace',
                            hasPages: (allPages?.length || 0) > 0,
                            pagesCount: allPages?.length || 0,
                        foundPagesCount: botResponse && botResponse.type === 'pages' ? (botResponse.pages?.length || 0) : 0,
                        pagesToSend: pagesToSend.length,
                        matchingPagesForBody: matchingPagesForBody.length,
                        isServiceProviderQuestion: isServiceProviderQuestion,
                        pagesToSendSample: pagesToSend.slice(0, 3).map(p => ({ title: p.title, type: p.type, city: p.city }))
                        });
                        
                        const webhookResponse = await fetch(webhookUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            signal: controller.signal, // נ¯ NEW: Add timeout signal
                            body: JSON.stringify({ 
                                message: userMessage,
                                context: 'stav-marketplace',
                                availablePages: allPages?.length || 0,
                                pages: pagesToSend.length > 0 ? pagesToSend : (matchingPagesForBody.length > 0 ? matchingPagesForBody : []), // נ¯ Use matching pages if pagesToSend is empty
                            foundPages: botResponse && botResponse.type === 'pages' ? botResponse.pages : [],
                            hasSearchResults: !!(botResponse && botResponse.type === 'pages' && botResponse.pages && botResponse.pages.length > 0) || matchingPagesForBody.length > 0,
                                serviceProviders: isServiceProviderQuestion ? (pagesToSend.length > 0 ? pagesToSend : matchingPagesForBody) : [],
                                matchingPages: matchingPagesForBody // נ¯ NEW: Include matching pages in body
                            })
                        });
                        
                        // נ¯ NEW: Clear timeout if request succeeded
                        clearTimeout(timeoutId);
                        
                        console.log('נ“¥ N8N response status:', webhookResponse.status);
                        
                        if (webhookResponse.ok) {
                            const webhookData = await webhookResponse.json();
                            console.log('נ“¥ N8N response data:', webhookData);
                            // Try multiple response formats
                            let responseMessage = webhookData.message || 
                                                   webhookData.response || 
                                                   webhookData.text || 
                                                   webhookData.output?.message ||
                                                   webhookData.output?.response ||
                                                   (typeof webhookData.output === 'string' ? webhookData.output : null) ||
                                                   (webhookData.data?.message) ||
                                                   '׳׳¦׳˜׳¢׳¨, ׳׳ ׳”׳¦׳׳—׳×׳™ ׳׳¢׳ ׳•׳× ׳¢׳ ׳–׳”. ׳ ׳¡׳” ׳׳—׳₪׳© ׳׳©׳”׳• ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡!';
                            
                            // Clean and translate to pure Hebrew - AGGRESSIVE cleaning
                            if (typeof responseMessage === 'string') {
                                // Remove numbered lists (1. 2. 3. etc.) - replace with just the text
                                responseMessage = responseMessage.replace(/^\d+\.\s*/gm, '');
                                
                                // Remove "׳׳’׳•׳•׳" from the message
                                responseMessage = responseMessage.replace(/׳׳’׳•׳•׳\s*/gi, '');
                                
                                // Split into sentences (by periods, exclamation marks, question marks, or line breaks)
                                const sentences = responseMessage.split(/[.!?\n]\s*/);
                                
                                // Filter: keep only sentences that contain Hebrew characters
                                const hebrewSentences = sentences.filter(sentence => {
                                    const trimmed = sentence.trim();
                                    if (!trimmed) return false; // Skip empty
                                    // Keep if contains Hebrew OR is just punctuation/emojis/numbers
                                    return /[׳-׳×]/.test(trimmed) || /^[\s\*\-\d\s\.\,\:\(\)נ˜נ’ג¨נ¯נ×נ’°ג­נ†נ‘ן¸נ”—נ“נ“§נ“נ™ן¸נ€\-\s]+$/.test(trimmed);
                                });
                                
                                // Reconstruct message from Hebrew sentences only
                                responseMessage = hebrewSentences
                                    .map(s => s.trim())
                                    .filter(s => s.length > 0)
                                    .join('. ')
                                    .replace(/\.\s*\./g, '.') // Remove double periods
                                    .trim();
                                
                                // Additional cleanup - remove common English patterns anywhere in text
                                responseMessage = responseMessage
                                    .replace(/silently[^׳-׳×]*/gi, '')
                                    .replace(/The\s+user[^׳-׳×]*/gi, '')
                                    .replace(/for\s+the\s+[^׳-׳×\.]*/gi, '')
                                    .replace(/after\s+I['ve]*\s+[^׳-׳×\.]*/gi, '')
                                    .replace(/I['ve]*\s+tried[^׳-׳×\.]*/gi, '')
                                    .replace(/[A-Z][a-z]+\s+[^׳-׳×\.]{10,}/g, '') // Remove long English sentences
                                    .replace(/["'][^"']*["']/g, ''); // Remove quoted English text
                                
                                // Replace English/Arabic greetings with Hebrew
                                responseMessage = responseMessage
                                    .replace(/\b׳”׳™׳™\b/g, '׳©׳׳•׳')
                                    .replace(/\bhi\b/gi, '׳©׳׳•׳')
                                    .replace(/\bhello\b/gi, '׳©׳׳•׳')
                                    .replace(/\bhey\b/gi, '׳©׳׳•׳');
                                
                                // Final cleanup - remove any remaining English-only words/phrases
                                const words = responseMessage.split(/\s+/);
                                const hebrewWords = words.filter(word => {
                                    // Keep if contains Hebrew OR is punctuation/number/emoji
                                    return /[׳-׳×]/.test(word) || /^[\*\-\d\.\,\:\(\)נ˜נ’ג¨נ¯נ×נ’°ג­נ†נ‘ן¸נ”—נ“נ“§נ“נ™ן¸\-\s]*$/.test(word);
                                });
                                responseMessage = hebrewWords.join(' ').trim();
                                
                                // נ¯ IMPROVED: Remove repeated sentences/phrases (like "׳¡׳˜׳™׳™׳ ׳–׳” ׳—׳©׳•׳‘" appearing multiple times)
                                const allSentences = responseMessage.split(/[.!?\n]\s*/).filter(s => s.trim().length > 0);
                                const uniqueSentences = [];
                                const seenSentences = new Set();
                                for (const sentence of allSentences) {
                                    const cleanSentence = sentence.trim();
                                    // Check if this sentence (or very similar) was already seen
                                    let isDuplicate = false;
                                    for (const seen of seenSentences) {
                                        const similarity = calculateSimilarity(cleanSentence, seen);
                                        if (similarity > 0.85) { // 85% similarity = duplicate
                                            isDuplicate = true;
                                            break;
                                        }
                                    }
                                    if (!isDuplicate && cleanSentence.length > 5) {
                                        uniqueSentences.push(cleanSentence);
                                        seenSentences.add(cleanSentence);
                                    }
                                }
                                responseMessage = uniqueSentences.join('. ').trim();
                                
                                // Also remove repeated phrases within the same sentence
                                responseMessage = responseMessage.replace(/(.{10,50}?)(\1{2,})/g, '$1');
                                
                                // Clean up multiple spaces and fix punctuation
                                responseMessage = responseMessage
                                    .replace(/\s+/g, ' ')
                                    .replace(/\s*([\.\,\:\!])\s*/g, '$1 ')
                                    .trim();
                                
                                // If result is empty or mostly English, don't use fallback - N8N should handle it
                                // Only use minimal fallback if completely empty
                                if (!responseMessage || responseMessage.length === 0) {
                                    // Try one more time to get response - maybe it's in a different format
                                    const fallbackResponse = webhookData?.text || webhookData?.output || webhookData?.data;
                                    if (fallbackResponse) {
                                        // נ¯ FIX: Ensure response is always a string, not an object
                                        if (typeof fallbackResponse === 'object') {
                                            responseMessage = JSON.stringify(fallbackResponse);
                                        } else {
                                            responseMessage = String(fallbackResponse);
                                        }
                                    } else {
                                        responseMessage = null;
                                    }
                                }
                                
                                // נ¯ FIX: Ensure responseMessage is always a string before displaying
                                if (responseMessage && typeof responseMessage !== 'string') {
                                    console.warn('ג ן¸ responseMessage is not a string, converting:', typeof responseMessage, responseMessage);
                                    if (typeof responseMessage === 'object') {
                                        responseMessage = JSON.stringify(responseMessage);
                                    } else {
                                        responseMessage = String(responseMessage);
                                    }
                                }
                            }
                            
                            // Remove typing indicator right before displaying N8N response
                            const typingIndicator = document.getElementById('stav-typing-indicator');
                            if (typingIndicator) typingIndicator.remove();
                            
                            // נ¯ FIX: Ensure responseMessage is always a string before displaying
                            if (responseMessage && typeof responseMessage !== 'string') {
                                console.warn('ג ן¸ responseMessage is not a string before display, converting:', typeof responseMessage);
                                if (typeof responseMessage === 'object') {
                                    responseMessage = JSON.stringify(responseMessage);
                                } else {
                                    responseMessage = String(responseMessage);
                                }
                            }
                            
                            // ג ן¸ IMPORTANT: Filter out invented contact info from N8N response
                            // N8N sometimes invents phone numbers, addresses, etc.
                            // We should only display REAL data from pages, not invented data
                            const hasInventedContactInfo = responseMessage && /(?:׳˜׳׳₪׳•׳|׳˜׳׳₪׳•׳ ׳™׳|נ“|phone).*?(?:\d{3}[-.\s]?\d{3}[-.\s]?\d{4}|\d{10})/.test(responseMessage) ||
                                                         /(?:׳›׳×׳•׳‘׳×|address|נ ).*?(?:׳¨׳—׳•׳‘|street|׳‘׳™׳×)/i.test(responseMessage) ||
                                                         /(?:׳׳™׳׳™׳™׳|email|נ“§).*?@/.test(responseMessage);
                            
                            // נ¯ FIX: Check if N8N response has missing prices - improved pattern matching
                            // Match patterns like: "׳׳•׳¦׳¨ - *" or "׳׳•׳¦׳¨ -" or "׳׳•׳¦׳¨ - *" or "* ׳׳•׳¦׳¨ - *"
                            const hasMissingPrices = responseMessage && typeof responseMessage === 'string' && (
                                /[׳-׳×]+\s*-\s*\*\s*$/.test(responseMessage) ||  // "׳׳•׳¦׳¨ - *"
                                                     /[׳-׳×]+\s*-\s*\*/.test(responseMessage) ||      // "׳׳•׳¦׳¨ - *"
                                                     /[׳-׳×]+\s*-\s*$/.test(responseMessage) ||         // "׳׳•׳¦׳¨ -" (end of line)
                                                     /\*\s*[׳-׳×]+\s*-\s*\*/.test(responseMessage) ||  // "* ׳׳•׳¦׳¨ - *"
                                /\*\s*[׳-׳×]+\s*-\s*$/.test(responseMessage)       // "* ׳׳•׳¦׳¨ -"
                            );
                            
                            // If N8N returned pages to display, ALWAYS use displayPageOptions with REAL data
                            // Don't display N8N's text if it contains invented contact info OR missing prices
                            if (webhookData && webhookData.pages && Array.isArray(webhookData.pages) && webhookData.pages.length > 0) {
                                console.log('נ“„ N8N returned pages - using displayPageOptions with REAL data');
                                console.log('נ” Checking for missing prices:', hasMissingPrices);
                                
                                // נ¯ IMPORTANT: Save pages to context so "׳›׳" will work!
                                window.stavCurrentPages = webhookData.pages;
                                console.log('נ’¾ Saved', webhookData.pages.length, 'pages from N8N to context');
                                
                                // Display pages with REAL data from metadata/HTML (not invented)
                                // If N8N has missing prices, don't show its text - displayPageOptions will show correct prices
                                // נ¯ FIX: Pass userMessage to detect if user wants full price list
                                const messageToPass = hasMissingPrices ? null : (window.lastUserMessage || userMessage || responseMessage);
                                console.log('נ“₪ Passing message to displayPageOptions:', messageToPass, 'hasMissingPrices:', hasMissingPrices);
                                await displayPageOptions(webhookData.pages, messageToPass);
                                
                                // נ¯ REMOVED: Don't let N8N automatically show preview
                                // Preview should ONLY be shown when user explicitly requests it
                                // by saying "׳×׳¨׳׳” ׳׳™ ׳׳× ׳”׳׳×׳¨" or similar
                                console.log('ג„¹ן¸ N8N sent pages, but NOT showing preview automatically (user must request)');
                                stavFirstReplySent = true;
                            } else if (responseMessage && responseMessage.length > 0 && !hasInventedContactInfo) {
                                // נ¯ FIX: Check if user asked for price list - if so, ALWAYS show pages with prices!
                                const userAskedForPriceList = window.lastUserMessage && (
                                    window.lastUserMessage.toLowerCase().includes('׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳') ||
                                    window.lastUserMessage.toLowerCase().includes('׳¨׳©׳™׳׳× ׳׳•׳¦׳¨׳™׳') ||
                                    window.lastUserMessage.toLowerCase().includes('׳×׳¨׳׳™ ׳׳•׳¦׳¨׳™׳') ||
                                    window.lastUserMessage.toLowerCase().includes('׳×׳¨׳׳™ ׳׳—׳™׳¨׳™׳') ||
                                    window.lastUserMessage.toLowerCase().includes('׳׳•׳¦׳¨׳™׳ ׳•׳׳—׳™׳¨׳™׳') ||
                                    (window.lastUserMessage.toLowerCase().includes('׳×׳¨׳׳™') && 
                                     (window.lastUserMessage.toLowerCase().includes('׳׳•׳¦׳¨') || window.lastUserMessage.toLowerCase().includes('׳׳—׳™׳¨'))) ||
                                    window.lastUserMessage.toLowerCase().includes('׳׳—׳™׳¨׳™׳ ׳©׳') ||
                                    window.lastUserMessage.toLowerCase().includes('׳›׳ ׳”׳׳—׳™׳¨׳™׳') ||
                                    window.lastUserMessage.toLowerCase().includes('׳›׳ ׳”׳׳•׳¦׳¨׳™׳')
                                );
                                
                                // נ¯ FIX: Check if N8N response has missing prices - improved pattern matching
                                const hasMissingPricesInText = /[׳-׳×]+\s*-\s*\*\s*$/.test(responseMessage) ||  // "׳׳•׳¦׳¨ - *"
                                                                /[׳-׳×]+\s*-\s*\*/.test(responseMessage) ||      // "׳׳•׳¦׳¨ - *"
                                                                /[׳-׳×]+\s*-\s*$/.test(responseMessage) ||         // "׳׳•׳¦׳¨ -" (end of line)
                                                                /\*\s*[׳-׳×]+\s*-\s*\*/.test(responseMessage) ||  // "* ׳׳•׳¦׳¨ - *"
                                                                /\*\s*[׳-׳×]+\s*-\s*$/.test(responseMessage) ||   // "* ׳׳•׳¦׳¨ -"
                                                                /׳׳™׳.*׳׳—׳™׳¨/i.test(responseMessage) ||              // "׳׳™׳ ׳׳—׳™׳¨׳™׳"
                                                                /׳׳.*׳׳—׳™׳¨/i.test(responseMessage);                // "׳׳ ׳׳—׳™׳¨׳™׳"
                                
                                // נ¯ FIX: If user asked for price list OR N8N says no prices, show pages with prices anyway!
                                if (userAskedForPriceList || hasMissingPricesInText) {
                                    console.log('נ” User asked for price list or N8N says no prices - showing pages with REAL prices');
                                    console.log('נ” userAskedForPriceList:', userAskedForPriceList, 'hasMissingPricesInText:', hasMissingPricesInText);
                                    console.warn('ג ן¸ N8N response has missing prices - will extract and display from LIVE data');
                                    console.log('נ” Response message:', responseMessage);
                                    console.log('נ” All pages:', (allPages || []).map(p => p.title));
                                    
                                    // Try to find pages mentioned in the response and display them with REAL prices
                                    const pageTitlesMentioned = (allPages || []).filter(p => {
                                        const titleInMessage = responseMessage.includes(p.title);
                                        console.log(`נ” Checking "${p.title}": ${titleInMessage}`);
                                        return titleInMessage;
                                    });
                                    
                                    console.log(`נ“‹ Found ${pageTitlesMentioned.length} pages mentioned in response`);
                                    
                                    if (pageTitlesMentioned.length > 0) {
                                        console.log('ג… Displaying pages with REAL prices - TEXT ONLY (no buttons):', pageTitlesMentioned.map(p => p.title));
                                        
                                        // נ¯ IMPORTANT: Save pages to context so "׳›׳" will work!
                                        // נ¯ FIX: Make a deep copy to prevent reference issues
                                        window.stavCurrentPages = pageTitlesMentioned.map(p => ({ ...p }));
                                        console.log('נ’¾ Saved', pageTitlesMentioned.length, 'pages to context from N8N text response');
                                        console.log('נ’¾ Pages saved:', window.stavCurrentPages.map(p => p.title).join(', '));
                                        
                                        // נ¯ Show ONLY text - NO buttons!
                                        const input = document.getElementById('stavChatInput');
                                        const currentUserMessage = input ? input.value.trim() : (window.lastUserMessage || null);
                                        // נ¯ Check if user wants link
                                        const includeLinks = currentUserMessage && /׳×׳¨׳׳”.*׳׳×׳¨|׳×׳¨׳׳”.*׳“׳£|׳§׳™׳©׳•׳¨|׳₪׳×׳—.*׳׳×׳¨|׳׳™׳ ׳§|link/i.test(currentUserMessage);
                                        const textResponse = await generateTextResponseWithRealData(pageTitlesMentioned, currentUserMessage || '׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳', includeLinks);
                                        if (textResponse && textResponse.trim().length > 0) {
                                            addStavMessage(textResponse, false);
                                            
                                            // נ¯ FIX: Clear input field AFTER bot responds
                                            const inputField = document.getElementById('stavChatInput');
                                            if (inputField) inputField.value = '';
                                        }
                                    } else {
                                        // Can't find pages - try to search by keywords from user's query
                                        // Extract keywords from user's message (e.g., "׳¦׳¢׳¦׳•׳¢׳™׳", "׳—׳׳₪׳™׳", etc.)
                                        const userMessageWords = (window.lastUserMessage || '').toLowerCase().split(/\s+/);
                                        const commonKeywords = ['׳¦׳¢׳¦׳•׳¢', '׳¦׳¢׳¦׳•׳¢׳™׳', '׳—׳׳₪׳™׳', '׳©׳¢׳•׳', '׳©׳¢׳•׳ ׳™׳', '׳׳§', '׳׳ ׳™׳§׳•׳¨', '׳ ׳’׳¨', '׳ ׳’׳¨׳•׳×', '׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨'];
                                        const searchKeywords = [];
                                        
                                        // Add keywords from user's message
                                        userMessageWords.forEach(word => {
                                            if (commonKeywords.some(kw => word.includes(kw) || kw.includes(word))) {
                                                searchKeywords.push(word);
                                            }
                                        });
                                        
                                        // Add default keywords if none found
                                        if (searchKeywords.length === 0) {
                                            searchKeywords.push(...['׳¦׳¢׳¦׳•׳¢', '׳—׳׳₪׳™׳', '׳©׳¢׳•׳']);
                                        }
                                        
                                        console.log('נ” Searching pages by keywords:', searchKeywords);
                                        
                                        const pagesByKeywords = (allPages || []).filter(p => 
                                            searchKeywords.some(keyword => 
                                                p.title.toLowerCase().includes(keyword.toLowerCase()) ||
                                                (p.description && p.description.toLowerCase().includes(keyword.toLowerCase()))
                                            )
                                        );
                                        
                                        if (pagesByKeywords.length > 0) {
                                            console.log('ג… Found pages by keywords:', pagesByKeywords.map(p => p.title));
                                            // נ¯ FIX: Get userMessage from window context
                                            const currentUserMessage = window.lastUserMessage || '׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳';
                                            await displayPageOptions(pagesByKeywords, currentUserMessage);
                                        } else {
                                            // Still can't find - search for all store pages
                                            const allStorePages = (allPages || []).filter(p => p.pageType === 'store');
                                            if (allStorePages.length > 0) {
                                                console.log('ג… Found store pages:', allStorePages.map(p => p.title));
                                                // נ¯ FIX: Get userMessage from window context
                                                const currentUserMessage = window.lastUserMessage || '׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳';
                                                await displayPageOptions(allStorePages, currentUserMessage);
                                            } else {
                                                // Still can't find - show a helpful message
                                                console.warn('ג ן¸ Could not find pages mentioned in response');
                                                addStavMessage('׳׳ ׳™ ׳¢׳•׳‘׳“׳× ׳¢׳ ׳׳”׳‘׳™׳ ׳׳ ׳׳× ׳›׳ ׳”׳׳—׳™׳¨׳™׳... נ˜', false);
                                            }
                                        }
                                    }
                                } else if (!userAskedForPriceList) {
                                    // Only display N8N response if it doesn't contain invented contact info OR missing prices
                                    // AND user didn't ask for price list
                                    // נ¯ FIX: Filter out "׳׳ ׳™ ׳›׳׳ ׳׳¢׳–׳•׳¨" and similar phrases
                                    const hasUnwantedPhrases = responseMessage && typeof responseMessage === 'string' && (
                                        /׳׳ ׳™ ׳›׳׳ (׳׳¢׳–׳•׳¨|׳‘׳©׳‘׳™׳׳|׳‘׳©׳‘׳™׳׳!)/i.test(responseMessage) ||
                                        /׳׳ ׳™ ׳™׳›׳•׳׳” (׳׳¢׳–׳•׳¨|׳׳¢׳–׳•׳¨ ׳׳)/i.test(responseMessage) ||
                                        /׳׳ ׳™ ׳›׳׳ ׳‘׳©׳‘׳™׳׳/i.test(responseMessage)
                                    );
                                    
                                    // נ¯ FIX: Ensure responseMessage is a string before displaying
                                    if (responseMessage && typeof responseMessage === 'string' && responseMessage.trim().length > 0 && !hasUnwantedPhrases) {
                                    addStavMessage(responseMessage, false);
                                        
                                        // נ¯ FIX: Clear input field AFTER bot responds
                                        const inputField = document.getElementById('stavChatInput');
                                        if (inputField) inputField.value = '';
                                    } else if (hasUnwantedPhrases) {
                                        console.warn('ג ן¸ N8N response contains unwanted phrases - skipping:', responseMessage);
                                        // נ¯ FIX: Show a helpful message instead of nothing
                                        addStavMessage('׳׳¦׳˜׳¢׳¨׳×, ׳׳ ׳׳¦׳׳×׳™ ׳׳× ׳׳” ׳©׳—׳™׳₪׳©׳×. ׳׳•׳׳™ ׳×׳ ׳¡׳” ׳׳—׳₪׳© ׳‘׳׳•׳₪׳ ׳׳—׳¨?', false);
                                        // נ¯ FIX: Clear input field AFTER bot responds
                                        const inputField = document.getElementById('stavChatInput');
                                        if (inputField) inputField.value = '';
                                    } else {
                                        console.warn('ג ן¸ responseMessage is not a valid string, skipping:', typeof responseMessage, responseMessage);
                                        // נ¯ FIX: Show a helpful message instead of nothing
                                        addStavMessage('׳׳¦׳˜׳¢׳¨׳×, ׳׳ ׳׳¦׳׳×׳™ ׳׳× ׳׳” ׳©׳—׳™׳₪׳©׳×. ׳׳•׳׳™ ׳×׳ ׳¡׳” ׳׳—׳₪׳© ׳‘׳׳•׳₪׳ ׳׳—׳¨?', false);
                                        // נ¯ FIX: Clear input field AFTER bot responds
                                        const inputField = document.getElementById('stavChatInput');
                                        if (inputField) inputField.value = '';
                                    }
                                } else {
                                    // User asked for price list but we couldn't find pages - show N8N response anyway
                                    console.warn('ג ן¸ User asked for price list but could not find pages');
                                    // נ¯ FIX: Don't add duplicate message here - already added above or will be added by displayPageOptions
                                    // addStavMessage(responseMessage, false);
                                }
                                stavFirstReplySent = true;
                            } else if (responseMessage && responseMessage.length > 0 && hasInventedContactInfo) {
                                // N8N response contains invented contact info - filter it out
                                console.warn('ג ן¸ N8N response contains invented contact info - filtering out');
                                // Remove phone numbers, addresses, emails from response
                                let filteredMessage = responseMessage
                                    .replace(/(?:׳˜׳׳₪׳•׳|׳˜׳׳₪׳•׳ ׳™׳|נ“|phone).*?(?:\d{3}[-.\s]?\d{3}[-.\s]?\d{4}|\d{10})/gi, '')
                                    .replace(/(?:׳›׳×׳•׳‘׳×|address|נ ).*?(?:׳¨׳—׳•׳‘|street|׳‘׳™׳×)[^\.]*/gi, '')
                                    .replace(/(?:׳׳™׳׳™׳™׳|email|נ“§)[^\.]*/gi, '')
                                    .replace(/\*\*׳›׳×׳•׳‘׳×[^:]*:[^\.]*/gi, '')
                                    .replace(/\*\*׳˜׳׳₪׳•׳[^:]*:[^\.]*/gi, '')
                                    .replace(/\*\*׳׳™׳׳™׳™׳[^:]*:[^\.]*/gi, '')
                                    .replace(/\s+/g, ' ')
                                    .trim();
                                
                                if (filteredMessage && filteredMessage.length > 10) {
                                    addStavMessage(filteredMessage, false);
                                    
                                    // נ¯ FIX: Clear input field AFTER bot responds
                                    const inputField = document.getElementById('stavChatInput');
                                    if (inputField) inputField.value = '';
                                    
                                    stavFirstReplySent = true;
                                } else {
                                    // Response was mostly invented contact info - don't display it
                                    console.warn('ג ן¸ N8N response was mostly invented contact info - skipping display');
                                    
                                    // נ¯ FIX: Clear input field even if we don't display message
                                    const inputField = document.getElementById('stavChatInput');
                                    if (inputField) inputField.value = '';
                                    
                                    stavFirstReplySent = true;
                                }
                            }
                        } else {
                            // webhookResponse is not ok - handle error
                            const errorText = await webhookResponse.text().catch(() => '');
                            console.error('ג N8N webhook error:', webhookResponse.status, errorText);
                            // Remove typing indicator on error
                            const typingIndicator = document.getElementById('stav-typing-indicator');
                            if (typingIndicator) typingIndicator.remove();
                            // Only minimal error message - no fallback
                            addStavMessage('׳׳•׳₪׳¡, ׳™׳© ׳‘׳¢׳™׳” ׳¢׳ ׳”׳©׳¨׳×. ׳ ׳¡׳”/׳™ ׳©׳•׳‘ ׳‘׳¢׳•׳“ ׳¨׳’׳¢ נ˜', false);
                            
                            // נ¯ FIX: Clear input field AFTER bot responds
                            const inputField = document.getElementById('stavChatInput');
                            if (inputField) inputField.value = '';
                            stavFirstReplySent = true;
                        }
                    } catch (webhookError) {
                        // נ¯ NEW: Clear timeout on error
                        clearTimeout(timeoutId);
                        
                        console.error('ג Webhook error:', webhookError);
                        console.error('Error details:', webhookError.message, webhookError.stack);
                        
                        // Remove typing indicator on error
                        const typingIndicator = document.getElementById('stav-typing-indicator');
                        if (typingIndicator) typingIndicator.remove();
                        
                        // נ¯ NEW: Handle timeout specifically
                        if (webhookError.name === 'AbortError' || webhookError.message?.includes('aborted')) {
                            console.warn('ג±ן¸ N8N request timed out after 10 seconds');
                            // Try to provide a helpful response based on the query
                            const lowerMessage = userMessage.toLowerCase();
                            if (lowerMessage.includes('׳׳×׳ ׳”') || lowerMessage.includes('׳׳•׳¦׳¨') || lowerMessage.includes('׳¦׳¢׳¦׳•׳¢') || lowerMessage.includes('׳©׳¢׳•׳')) {
                                // If it's a product query, try to search locally
                                console.log('נ” Timeout on product query - trying local search');
                                const localResults = await searchLivePages(userMessage);
                                if (localResults && localResults.length > 0) {
                                    const textResponse = await generateTextResponseWithRealData(localResults, userMessage, false);
                                    if (textResponse && textResponse.trim().length > 0) {
                                        addStavMessage(textResponse, false);
                                        
                                        // נ¯ FIX: Clear input field AFTER bot responds
                                        const inputField = document.getElementById('stavChatInput');
                                        if (inputField) inputField.value = '';
                                        
                                        stavFirstReplySent = true;
                                        return;
                                    }
                                }
                            }
                            addStavMessage('׳׳¦׳˜׳¢׳¨׳×, ׳–׳” ׳׳•׳§׳— ׳™׳•׳×׳¨ ׳׳“׳™ ׳–׳׳. ׳׳•׳׳™ ׳×׳ ׳¡׳”/׳™ ׳׳—׳₪׳© ׳׳©׳”׳• ׳¡׳₪׳¦׳™׳₪׳™ ׳™׳•׳×׳¨? נ˜', false);
                            
                            // נ¯ FIX: Clear input field AFTER bot responds
                            const inputField = document.getElementById('stavChatInput');
                            if (inputField) inputField.value = '';
                        } else {
                            // Other errors
                        addStavMessage('׳׳•׳₪׳¡, ׳™׳© ׳‘׳¢׳™׳” ׳¢׳ ׳”׳—׳™׳‘׳•׳¨. ׳ ׳¡׳”/׳™ ׳©׳•׳‘ ׳‘׳¢׳•׳“ ׳¨׳’׳¢ נ˜', false);
                        
                        // נ¯ FIX: Clear input field AFTER bot responds
                        const inputField = document.getElementById('stavChatInput');
                        if (inputField) inputField.value = '';
                        }
                        stavFirstReplySent = true;
                }
                    
                    // No more built-in responses - everything goes through N8N
                
            } catch (error) {
                console.error('ג Error processing Stav message:', error);
                console.error('ג Error type:', error.name);
                console.error('ג Error message:', error.message);
                console.error('ג Error stack:', error.stack);
                
                // Remove typing indicator (safely)
                const typingIndicator = document.getElementById('stav-typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                }
                
                // נ¯ FIX: Clear input field on error
                const inputField = document.getElementById('stavChatInput');
                if (inputField) {
                    inputField.value = '';
                } else {
                    // Fallback: remove by text content
                const messagesDiv = document.getElementById('stavChatMessages');
                const lastMessage = messagesDiv.lastElementChild;
                    if (lastMessage && (lastMessage.textContent.includes('׳׳§׳׳™׳“׳”') || lastMessage.id === 'stav-typing-indicator')) {
                    lastMessage.remove();
                    }
                }
                
                // נ¯ More specific error messages
                let errorMessage = '׳׳•׳₪׳¡, ׳׳©׳”׳• ׳”׳©׳×׳‘׳©. ׳ ׳¡׳” ׳©׳•׳‘.';
                
                if (error.name === 'TypeError' || error.message.includes('fetch')) {
                    errorMessage = '׳‘׳¢׳™׳” ׳‘׳—׳™׳‘׳•׳¨ ׳׳©׳¨׳×. ׳‘׳“׳•׳§ ׳׳× ׳”׳׳™׳ ׳˜׳¨׳ ׳˜ ׳•׳ ׳¡׳” ׳©׳•׳‘.';
                } else if (error.message.includes('API') || error.message.includes('TTS')) {
                    errorMessage = '׳‘׳¢׳™׳” ׳¢׳ ׳©׳™׳¨׳•׳× ׳”׳“׳™׳‘׳•׳¨. ׳”׳”׳•׳“׳¢׳” ׳×׳•׳¦׳’ ׳‘׳˜׳§׳¡׳˜ ׳‘׳׳‘׳“.';
                } else if (error.message.includes('timeout')) {
                    errorMessage = '׳”׳©׳¨׳× ׳׳ ׳”׳’׳™׳‘. ׳ ׳¡׳” ׳©׳•׳‘ ׳‘׳¢׳•׳“ ׳¨׳’׳¢.';
                }
                
                addStavMessage(errorMessage, false);
            }
        }

        // Helper function to calculate similarity between two strings
        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            if (longer.length === 0) return 1.0;
            const distance = levenshteinDistance(longer, shorter);
            return (longer.length - distance) / longer.length;
        }
        
        // Helper function to calculate Levenshtein distance
        function levenshteinDistance(str1, str2) {
            const matrix = [];
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[str2.length][str1.length];
        }

        function addStavMessage(message, isUser = false) {
            // נ¯ FIX: Prevent duplicate bot messages
            if (!isUser) {
                const now = Date.now();
                const cleanMessage = message
                    .replace(/<[^>]*>/g, '')
                    .replace(/&[^;]+;/g, '')
                    .replace(/[נ˜נ’¡נ“נ“נ“§נ נ’°ג…גנ”—נ“„נ×נ‰נ“נ”§נ‘ן¸נ¯נ”נ“נ“נ”נ₪נ”´]/g, '')
                    .replace(/\*\*/g, '')
                    .replace(/\*/g, '')
                    .replace(/\([^)]*\)/g, '')
                    .replace(/\.{2,}/g, '')
                    .replace(/!+/g, '.')
                    .replace(/\s+/g, ' ')
                    .trim();
                
                // Check if this is the same bot message sent recently
                // נ¯ FIX: Block EXACT duplicates aggressively to prevent double messages
                const timeSinceLastMessage = now - lastSentBotMessageTime;
                const isExactMatch = cleanMessage === lastSentBotMessage;
                
                // Block if EXACT match and within 20 seconds (prevent all duplicates - increased from 15)
                if (isExactMatch && timeSinceLastMessage < 20000) {
                    console.log('ג ן¸ Ignoring duplicate bot message (exact match):', cleanMessage.substring(0, 100));
                    console.log('ג ן¸ Time since last:', timeSinceLastMessage, 'ms');
                    return;
                }
                
                // Also check for very similar messages (first 100 chars match) - increased time window
                if (lastSentBotMessage && cleanMessage.length > 50 && lastSentBotMessage.length > 50) {
                    const first100New = cleanMessage.substring(0, 100);
                    const first100Old = lastSentBotMessage.substring(0, 100);
                    if (first100New === first100Old && timeSinceLastMessage < 10000) {
                        console.log('ג ן¸ Ignoring very similar bot message (first 100 chars match):', first100New);
                        console.log('ג ן¸ Time since last:', timeSinceLastMessage, 'ms');
                        return;
                    }
                }
                
                // נ¯ IMPROVED: Also check if message is very similar (70% match) to prevent near-duplicates - more aggressive
                if (lastSentBotMessage && cleanMessage.length > 30 && lastSentBotMessage.length > 30) {
                    const similarity = calculateSimilarity(cleanMessage, lastSentBotMessage);
                    if (similarity > 0.7 && timeSinceLastMessage < 12000) {
                        console.log('ג ן¸ Ignoring very similar bot message (similarity:', similarity, '):', cleanMessage.substring(0, 50));
                        console.log('ג ן¸ Time since last:', timeSinceLastMessage, 'ms');
                        return;
                    }
                }
                
                // נ¯ IMPROVED: Check if message contains repeated phrases (like "׳¡׳˜׳™׳™׳ ׳–׳” ׳—׳©׳•׳‘" appearing multiple times)
                const repeatedPhrasePattern = /(.{10,50}?)(\1{2,})/;
                if (repeatedPhrasePattern.test(cleanMessage)) {
                    console.log('ג ן¸ Ignoring message with repeated phrases:', cleanMessage.substring(0, 100));
                    return;
                }
                
                // Update last message only if it's different
                if (!isExactMatch) {
                    lastSentBotMessage = cleanMessage;
                    lastSentBotMessageTime = now;
                    // נ¯ NEW: Also save to window for context checking
                    window.lastBotMessage = cleanMessage;
                    console.log('נ’¾ Saved last bot message for context:', cleanMessage.substring(0, 50));
                }
            }
            
            const messagesDiv = document.getElementById('stavChatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `stav-message ${isUser ? 'user' : 'bot'}`;
            
            // Remove emojis, asterisks, excessive punctuation, parentheses, dots, and HTML
            const cleanMessage = message
                .replace(/<[^>]*>/g, '') // Remove ALL HTML tags
                .replace(/&[^;]+;/g, '') // Remove HTML entities
                .replace(/[נ˜נ’¡נ“נ“נ“§נ נ’°ג…גנ”—נ“„נ×נ‰נ“נ”§נ‘ן¸נ¯נ”נ“נ“נ”נ₪נ”´]/g, '')
                .replace(/\*\*/g, '')
                .replace(/\*/g, '')
                .replace(/\([^)]*\)/g, '') // Remove parentheses and content
                .replace(/\.{2,}/g, '') // Remove multiple dots
                .replace(/!+/g, '.') // Replace multiple ! with single .
                .replace(/\s+/g, ' ') // Replace multiple spaces with single
                .trim();
            
            messageDiv.textContent = cleanMessage;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // If this is a bot message AND user used voice input, speak it
            if (!isUser && cleanMessage && lastInputWasVoice) {
                setTimeout(() => {
                    speakText(cleanMessage);
                    // Reset voice flag after speaking starts (ready for next input)
                    lastInputWasVoice = false;
                }, 300);
            } else if (!isUser) {
                // Bot message but user didn't use voice - reset flag
                lastInputWasVoice = false;
            }
        }
        
        // Generate dialogue before showing results - asks clarifying questions
        function generateDialogueBeforeShowing(pages, userQuery) {
            if (!pages || pages.length === 0) return null;
            
            const query = userQuery.toLowerCase();
            const hasMultipleOptions = pages.length > 1;
            
            // If query is vague and has multiple results, ask clarifying question
            if (hasMultipleOptions && (
                query.includes('׳׳×׳ ׳”') || 
                query.includes('׳׳©׳”׳•') || 
                query.includes('׳׳•׳¦׳¨') || 
                query.length < 10
            )) {
                const firstPage = pages[0];
                return `׳׳¦׳׳×׳™ ׳׳ ${pages.length} ׳׳₪׳©׳¨׳•׳™׳•׳× ׳׳¢׳•׳׳•׳×! נ¯\n\n׳׳׳©׳: **${firstPage.title}** ${firstPage.description ? `- ${firstPage.description.substring(0, 60)}...` : ''}\n\n׳׳” ׳‘׳“׳™׳•׳§ ׳׳×/׳” ׳׳—׳₪׳©/׳×? (׳׳•׳¦׳¨ ׳¡׳₪׳¦׳™׳₪׳™, ׳׳—׳™׳¨, ׳׳™׳§׳•׳, ׳•׳›׳•') נ˜`;
            }
            
            // If query is about specific business, verify it's the right one
            const businessPattern = /(?:׳׳”|׳׳™׳₪׳”|׳׳™׳–׳”|׳©׳|׳׳×)\s+([׳-׳×]{2,})/;
            const businessMatch = userQuery.match(businessPattern);
            if (businessMatch && pages.length > 1) {
                const businessName = businessMatch[1].trim();
                const exactMatch = pages.find(p => p.title.toLowerCase().includes(businessName.toLowerCase()));
                if (exactMatch) {
                    return null; // Already have exact match, show it directly
                }
            }
            
            return null; // No dialogue needed
        }
        
        // Generate smart recommendations with selling points
        function generateSmartRecommendation(pages, userQuery) {
            if (!pages || pages.length === 0) return null;
            
            const topPage = pages[0];
            const query = userQuery.toLowerCase();
            
            let recommendation = '';
            
            // Detect user intent
            const isCarProblem = query.includes('׳¨׳›׳‘') || query.includes('׳”׳׳') || query.includes('׳§׳׳§׳•׳') || query.includes('׳×׳§׳׳”');
            const isGift = query.includes('׳׳×׳ ׳”') || query.includes('׳׳×׳ ׳•׳×');
            const isService = query.includes('׳©׳™׳¨׳•׳×') || query.includes('׳¦׳¨׳™׳');
            const isPriceSearch = query.includes('׳›׳׳”') || query.includes('׳׳—׳™׳¨') || query.includes('ג‚×');
            
            // Build smart recommendation based on intent
            if (isCarProblem) {
                recommendation = `נ”§ **׳”׳׳׳¦׳” ׳©׳׳™:** ${topPage.title} ׳ ׳¨׳׳” ׳”׳›׳™ ׳׳×׳׳™׳ ׳׳‘׳¢׳™׳” ׳©׳׳! `;
                if (topPage.liveProducts && topPage.liveProducts.length > 0) {
                    const carProducts = topPage.liveProducts.filter(p => 
                        p.name.toLowerCase().includes('׳—׳׳£') || 
                        p.name.toLowerCase().includes('׳₪׳ ׳¡') || 
                        p.name.toLowerCase().includes('׳׳¦׳‘׳¨') ||
                        p.name.toLowerCase().includes('׳‘׳׳') ||
                        p.name.toLowerCase().includes('׳¦׳׳™׳’')
                    );
                    if (carProducts.length > 0) {
                        recommendation += `׳™׳© ׳׳”׳ ${carProducts.length} ׳׳•׳¦׳¨׳™׳ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳ ׳׳‘׳¢׳™׳” ׳©׳׳, ׳›׳•׳׳: ${carProducts.slice(0, 2).map(p => p.name).join(', ')}. `;
                    }
                }
                if (topPage.liveContactInfo && topPage.liveContactInfo.phone) {
                    recommendation += `נ“ **׳˜׳׳₪׳•׳:** ${topPage.liveContactInfo.phone} - ׳׳×׳” ׳™׳›׳•׳ ׳׳”׳×׳§׳©׳¨ ׳¢׳›׳©׳™׳•!`;
                }
            } else if (isGift) {
                recommendation = `נ **׳”׳׳׳¦׳” ׳׳•׳©׳׳׳×:** ${topPage.title} ׳׳¦׳™׳¢׳™׳ ׳׳×׳ ׳•׳× ׳׳¢׳•׳׳•׳×! `;
                if (topPage.liveProducts && topPage.liveProducts.length > 0) {
                    const cheapest = topPage.liveProducts.reduce((min, p) => p.price < min.price ? p : min, topPage.liveProducts[0]);
                    const expensive = topPage.liveProducts.reduce((max, p) => p.price > max.price ? p : max, topPage.liveProducts[0]);
                    recommendation += `׳™׳© ׳׳”׳ ${topPage.liveProducts.length} ׳׳•׳¦׳¨׳™׳, ׳׳×׳—׳™׳ ׳-ג‚×${cheapest.price} ׳•׳¢׳“ ג‚×${expensive.price}. `;
                }
                if (pages.length > 1) {
                    recommendation += `נ’¡ **׳˜׳™׳₪:** ׳™׳© ׳¢׳•׳“ ${pages.length - 1} ׳¢׳¡׳§׳™׳ ׳©׳׳₪׳©׳¨ ׳׳”׳©׳•׳•׳× - ׳×׳¨׳׳” ׳׳× ׳›׳ ׳”׳׳•׳₪׳¦׳™׳•׳× ׳׳׳˜׳”!`;
                }
            } else if (isPriceSearch) {
                recommendation = `נ’° **׳”׳׳—׳™׳¨׳™׳ ׳”׳˜׳•׳‘׳™׳ ׳‘׳™׳•׳×׳¨:** `;
                const prices = pages.slice(0, 3).flatMap(p => 
                    (p.liveProducts || []).map(prod => ({ page: p.title, product: prod.name, price: prod.price }))
                ).sort((a, b) => a.price - b.price).slice(0, 3);
                
                if (prices.length > 0) {
                    prices.forEach((item, idx) => {
                        recommendation += `${idx + 1}. ${item.product} ׳‘-${item.page} - ג‚×${item.price} | `;
                    });
                    recommendation = recommendation.slice(0, -3) + '.';
                }
            } else {
                // General recommendation - friendlier tone
                recommendation = `ג¨ **׳׳¦׳׳×׳™ ׳׳ ׳׳©׳”׳• ׳׳¢׳•׳׳”!** ${topPage.title} ׳ ׳¨׳׳” ׳”׳›׳™ ׳׳×׳׳™׳ ׳׳׳” ׳©׳׳×/׳” ׳׳—׳₪׳©/׳×! `;
                if (topPage.description) {
                    recommendation += `${topPage.description.substring(0, 80)}... `;
                }
                if (topPage.liveContactInfo && topPage.liveContactInfo.city) {
                    recommendation += `נ“ ׳׳׳•׳§׳ ׳‘-${topPage.liveContactInfo.city}. `;
                }
                if (topPage.liveProducts && topPage.liveProducts.length > 0) {
                    recommendation += `׳™׳© ׳׳”׳ ${topPage.liveProducts.length} ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳ ׳¢׳›׳©׳™׳•! נ˜`;
                }
            }
            
            return recommendation || null;
        }
        
        // נ¯ NEW: Generate text response with REAL data from pages
        async function generateTextResponseWithRealData(pages, userMessage, includeLinks = false, showFullDescription = false) {
            if (!pages || pages.length === 0) return '';
            
            let textResponse = '';
            
            // נ¯ NEW: Check if user asked for "׳›׳" (all) - if so, show ALL pages, not just top 5
            const userWantsAll = userMessage && (
                /׳¨׳©׳™׳׳”.*׳©׳.*׳›׳|׳›׳.*׳”׳¦׳¢׳¦׳•׳¢׳™׳|׳›׳.*׳”׳׳•׳¦׳¨׳™׳|׳׳ ׳™.*׳¨׳•׳¦׳”.*׳¨׳©׳™׳׳”.*׳©׳.*׳›׳/i.test(userMessage)
            );
            
            const pageCount = userWantsAll ? pages.length : Math.min(pages.length, 5); // Limit to top 5 unless "׳›׳" is requested
            
            // נ¯ Check if user is asking to see website/link
            const userWantsLink = includeLinks || (userMessage && (
                /׳×׳¨׳׳”.*׳׳×׳¨|׳×׳¨׳׳”.*׳“׳£|׳×׳¨׳׳™.*׳׳×׳¨|׳×׳¨׳׳™.*׳“׳£|׳”׳¨׳׳”.*׳׳×׳¨|׳׳¨׳׳•׳×.*׳׳×׳¨|׳׳₪׳©׳¨.*׳׳×׳¨|׳§׳™׳©׳•׳¨|׳₪׳×׳—.*׳׳×׳¨|׳׳™׳ ׳§|link|׳׳×׳¨.*׳©׳|׳׳“׳£.*׳©׳|׳₪׳×׳™׳—׳×.*׳׳×׳¨|׳×׳¨׳׳•.*׳׳×׳¨|׳”׳¦׳’.*׳׳×׳¨/i.test(userMessage)
            ));
            
            // נ¯ NEW: Check if user explicitly asked for product list (show ALL products, not summary)
            // נ¯ IMPROVED: Also detect "׳¨׳©׳™׳׳” ׳©׳ ׳›׳ X" and "׳׳ ׳™ ׳¨׳•׳¦׳” ׳¨׳©׳™׳׳” ׳©׳"
            // נ¯ FIX: Also detect "׳׳—׳™׳¨׳™׳ ׳©׳ X" (e.g., "׳׳—׳™׳¨׳™׳ ׳©׳ ׳¦׳¢׳¦׳•׳¢׳™׳") - this should show prices!
            // נ¯ FIX: Also detect "׳׳” ׳”׳¦׳¢׳¦׳•׳¢ ׳”׳›׳™ ׳–׳•׳" - this should show prices!
            const userAskedForProductList = userMessage && (
                /׳×׳ ׳™?.*׳¨׳©׳™׳׳×.*׳׳•׳¦׳¨׳™׳|׳×׳ ׳™?.*׳׳×.*׳¨׳©׳™׳׳×.*׳׳•׳¦׳¨׳™׳|׳×׳‘׳™׳(?:׳™)?\s+׳׳™?\s+׳¨׳©׳™׳(?:׳”|׳×)|׳׳₪׳©׳¨\s+׳¢׳•׳“\s+׳¨׳©׳™׳(?:׳”|׳×)|׳×׳¨׳׳™.*׳׳•׳¦׳¨׳™׳|׳×׳¨׳׳™.*׳׳—׳™׳¨׳™׳|׳¨׳©׳™׳׳×.*׳׳—׳™׳¨׳™׳|׳¨׳©׳™׳(?:׳”|׳×).*׳©׳.*׳׳—׳™׳¨׳™׳|׳¨׳©׳™׳(?:׳”|׳×).*׳©׳.*׳׳•׳¦׳¨׳™׳|׳¨׳©׳™׳(?:׳”|׳×).*׳©׳.*׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳.*׳•׳׳—׳™׳¨׳™׳|׳׳—׳™׳¨׳™׳.*׳•?׳׳•׳¦׳¨׳™׳|׳”׳¨׳׳™.*׳׳•׳¦׳¨׳™׳|(?:׳”)?׳׳—׳™׳¨׳™׳\s+׳©׳|׳׳”.*׳”׳׳•׳¦׳¨׳™׳|׳׳™׳–׳”.*׳׳•׳¦׳¨׳™׳|׳›׳.*׳”׳׳•׳¦׳¨׳™׳|׳¨׳©׳™׳׳”.*׳©׳.*׳›׳|׳׳ ׳™.*׳¨׳•׳¦׳”.*׳¨׳©׳™׳(?:׳”|׳×)|׳¨׳©׳™׳׳”.*׳©׳.*׳›׳.*׳”׳¦׳¢׳¦׳•׳¢׳™׳|׳›׳.*׳”׳¦׳¢׳¦׳•׳¢׳™׳|׳¨׳©׳™׳׳”.*׳©׳.*׳›׳.*׳”׳׳•׳¦׳¨׳™׳|׳׳™׳–׳”\s+(?:׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳™׳©|׳׳”\s+(?:׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)\s+׳™׳©|׳׳—׳™׳¨׳™׳\s+׳©׳\s+(?:׳¦׳¢׳¦׳•׳¢׳™׳|׳׳•׳¦׳¨׳™׳|׳©׳¢׳•׳ ׳™׳|׳׳§)|׳׳”\s+(?:׳”׳׳•׳¦׳¨|׳”׳¦׳¢׳¦׳•׳¢|׳”׳׳×׳ ׳”|׳”׳©׳¢׳•׳)\s+׳”׳›׳™\s+(?:׳–׳•׳|׳–׳•׳׳”|׳™׳§׳¨|׳™׳§׳¨׳”)|׳׳”\s+(?:׳”׳›׳™\s+)?(?:׳–׳•׳|׳–׳•׳׳”|׳™׳§׳¨|׳™׳§׳¨׳”)/i.test(userMessage)
            );
            
            // נ¯ NEW: Check if results are from different city than requested
            const notInRequestedCity = pages[0]?.notInRequestedCity;
            const requestedCity = pages[0]?.requestedCity;
            const actualCity = pages[0]?.actualCity;
            
            // נ¯ Show contact info ONLY if user specifically asks for it
            // Don't show phone/email automatically - only when user asks for details
            const userWantsContactInfo = userMessage && (
                /׳˜׳׳₪׳•׳|׳׳¡׳₪׳¨\s+׳˜׳׳₪׳•׳|׳׳™׳ ׳׳₪׳ ׳•׳×|׳׳™׳ ׳׳™׳¦׳•׳¨ ׳§׳©׳¨|׳›׳×׳•׳‘׳×|׳׳™׳™׳|׳׳™׳₪׳”|׳”׳™׳›׳|׳₪׳¨׳˜׳™ ׳§׳©׳¨|׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳|׳₪׳¨׳˜׳™׳/i.test(userMessage) ||
                userAlreadySaidYes // If user said "yes", show full details including contact info
            );
            
            // Helper function: Convert number to Hebrew words
            const numberToHebrewWords = (num) => {
                const hebrewNumbers = {
                    2: '׳©׳×׳™',
                    3: '׳©׳׳•׳©',
                    4: '׳׳¨׳‘׳¢',
                    5: '׳—׳׳©',
                    6: '׳©׳©',
                    7: '׳©׳‘׳¢',
                    8: '׳©׳׳•׳ ׳”',
                    9: '׳×׳©׳¢',
                    10: '׳¢׳©׳¨'
                };
                return hebrewNumbers[num] || num.toString(); // Fallback to number if > 10
            };
            
            // נ¯ NEW: Group pages by store name to avoid duplicates and organize by store
            // First, collect all pages with their data
            const pagesWithData = [];
            
            for (let i = 0; i < pageCount; i++) {
                const page = pages[i];
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                
                try {
                    // Fetch live data
                    const pageResponse = await fetch(pageUrl);
                    if (!pageResponse.ok) continue;
                    
                    const html = await pageResponse.text();
                    const contactInfo = extractLiveContactInfo(html);
                    let products = extractLiveProducts(html);
                    if (!products || products.length === 0) {
                        const metadataProducts = page.products || page.liveProducts || [];
                        if (metadataProducts && metadataProducts.length > 0) {
                            console.log(`נ§© Using metadata products for "${page.title}" (${metadataProducts.length} items)`);
                            products = metadataProducts;
                        }
                    }
                            const liveDesc = extractLiveDescription(html);
                    
                    // נ¯ Clean title immediately - remove duplicates
                    let cleanPageTitle = page.title.trim();
                    // Remove duplicate patterns in title (e.g., "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢ - ׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢")
                    const titleParts = cleanPageTitle.split(/\s*-\s*/);
                    if (titleParts.length >= 2 && titleParts[0].trim().toLowerCase() === titleParts[1].trim().toLowerCase()) {
                        cleanPageTitle = titleParts[0].trim() + (titleParts.length > 2 ? ' - ' + titleParts.slice(2).join(' - ') : '');
                    }
                    
                    pagesWithData.push({
                        page: page,
                        pageUrl: pageUrl,
                        contactInfo: contactInfo,
                        products: products,
                        description: liveDesc || page.description || '',
                        title: cleanPageTitle, // נ¯ Already cleaned title
                        
                        // נ¯ ׳׳™׳“׳¢ ׳ ׳•׳¡׳£ ׳-metadata (׳—׳“׳©!)
                        category: page.category || null,
                        city: page.city || contactInfo.city || null,
                        address: page.address || contactInfo.address || null,
                        premium: page.premium || false,
                        price: page.price || null,
                        priceRange: page.priceRange || null
                    });
                } catch (error) {
                    console.error(`ג Error fetching data for "${page.title}":`, error);
                }
            }
            
            // נ¯ NEW: Group by store name (case-insensitive, remove duplicates)
            const storesMap = new Map();
            
            for (const pageData of pagesWithData) {
                let storeTitle = pageData.title;
                
                // נ¯ IMPROVED: Remove duplicate title patterns more aggressively
                // Pattern 1: "׳©׳ - ׳©׳" or "׳©׳ - ׳©׳ " -> "׳©׳"
                storeTitle = storeTitle.replace(/^(.+?)\s*-\s*\1(\s|$|-[^-])/, '$1$2');
                // Pattern 2: "׳©׳ - ׳©׳ - ׳×׳™׳׳•׳¨" -> "׳©׳ - ׳×׳™׳׳•׳¨" (if first part matches)
                storeTitle = storeTitle.replace(/^(.+?)\s*-\s*\1\s*-\s*/, '$1 - ');
                // Pattern 3: Remove any duplicate name that appears after a dash (more aggressive)
                // This handles: "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢ - ׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢ - ׳×׳™׳׳•׳¨" -> "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢ - ׳×׳™׳׳•׳¨"
                const parts = storeTitle.split(/\s*-\s*/);
                if (parts.length >= 2) {
                    // Check if first two parts are the same (case-insensitive)
                    if (parts[0].trim().toLowerCase() === parts[1].trim().toLowerCase()) {
                        // Remove duplicate, keep first occurrence and rest
                        storeTitle = parts[0].trim() + (parts.length > 2 ? ' - ' + parts.slice(2).join(' - ') : '');
                    } else {
                        // Check if any subsequent part matches the first
                        const firstPart = parts[0].trim().toLowerCase();
                        const filteredParts = [parts[0]];
                        for (let i = 1; i < parts.length; i++) {
                            if (parts[i].trim().toLowerCase() !== firstPart) {
                                filteredParts.push(parts[i]);
                            }
                        }
                        if (filteredParts.length < parts.length) {
                            storeTitle = filteredParts.join(' - ');
                        }
                    }
                }
                
                // נ¯ Additional cleanup: Remove any trailing spaces and normalize dashes
                const cleanTitle = storeTitle.trim().replace(/\s*-\s*-+\s*/g, ' - ').replace(/\s+/g, ' ');
                
                // נ¯ Use case-insensitive key for grouping (so "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢" and "׳™׳ ׳™׳‘ ׳¦׳¢׳¦׳•׳¢" are same)
                const storeKey = cleanTitle.toLowerCase();
                
                if (!storesMap.has(storeKey)) {
                    storesMap.set(storeKey, {
                        title: cleanTitle, // Keep original casing for display
                        description: pageData.description,
                        contactInfo: pageData.contactInfo,
                        products: [],
                        pageUrl: pageData.pageUrl,
                        page: pageData.page,
                        
                        // נ¯ ׳׳™׳“׳¢ ׳ ׳•׳¡׳£ ׳-metadata (׳—׳“׳©!)
                        category: pageData.category || null,
                        city: pageData.city || null,
                        address: pageData.address || null,
                        premium: pageData.premium || false,
                        price: pageData.price || null,
                        priceRange: pageData.priceRange || null
                    });
                } else {
                    // נ¯ If store already exists, merge products and update description if needed
                    const existingStore = storesMap.get(storeKey);
                    // Keep longer/better description
                    if (!existingStore.description || (pageData.description && pageData.description.length > existingStore.description.length)) {
                        existingStore.description = pageData.description;
                    }
                    // Update contact info if missing
                    if (!existingStore.contactInfo.phone && pageData.contactInfo.phone) {
                        existingStore.contactInfo = pageData.contactInfo;
                    }
                    // Update metadata if missing
                    if (!existingStore.city && pageData.city) {
                        existingStore.city = pageData.city;
                    }
                    if (!existingStore.category && pageData.category) {
                        existingStore.category = pageData.category;
                    }
                    if (pageData.premium && !existingStore.premium) {
                        existingStore.premium = true;
                    }
                }
                
                // Add products from this page to the store (if products list is requested)
                if (userAskedForProductList && pageData.products && pageData.products.length > 0) {
                    const store = storesMap.get(storeKey);
                    // Filter valid products
                    const validProducts = pageData.products.filter(product => {
                        const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                        return price >= 2 && price < 100000;
                    });
                    store.products.push(...validProducts);
                }
            }
            
            // Convert map to array and sort stores (alphabetically by title)
            const stores = Array.from(storesMap.values()).sort((a, b) => {
                return a.title.localeCompare(b.title, 'he');
            });
            
            // נ¯ Sort products within each store by price
            for (const store of stores) {
                if (store.products && store.products.length > 0) {
                    store.products.sort((a, b) => {
                        const priceA = parseFloat(String(a.price || 0).replace(/[,\s]/g, ''));
                        const priceB = parseFloat(String(b.price || 0).replace(/[,\s]/g, ''));
                        return priceA - priceB;
                    });
                }
            }

        // נ¯ Highlight globally cheapest product for price queries
        let globalCheapest = null;
        if (userAskedForProductList) {
            for (const store of stores) {
                if (!store.products || store.products.length === 0) continue;
                for (const product of store.products) {
                    const numericPrice = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                    if (!numericPrice || Number.isNaN(numericPrice)) continue;
                    if (!globalCheapest || numericPrice < globalCheapest.price) {
                        globalCheapest = {
                            price: numericPrice,
                            name: product.name,
                            store: store.title
                        };
                    }
                }
            }
        }
            
            // Friendly opening message - VERY SHORT and conversational
            // נ¯ FIX: Check if user already said "׳›׳" (yes) - if so, show full details
            const userAlreadySaidYes = userMessage && /^(׳›׳|׳‘׳˜׳—|׳׳©׳׳—|yes|ok|׳׳•׳§׳™׳™)$/i.test(userMessage.trim());
            
            // נ¯ FIX: If stores.length === 0, check if pages were provided but failed to process
            if (stores.length === 0) {
                console.log('ג ן¸ No stores found in generateTextResponseWithRealData');
                console.log('נ“ Pages provided:', pages?.length || 0);
                console.log('נ“ pagesWithData:', pagesWithData?.length || 0);
                
                // If pages were provided but stores is empty, it means processing failed
                if (pages && pages.length > 0) {
                    console.log('ג ן¸ Pages were provided but stores is empty - processing may have failed');
                    // Try to show at least the first page if available
                    if (pages[0]) {
                        textResponse += `׳׳¦׳׳×׳™ ׳׳× ${pages[0].title}. ׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?`;
                        return textResponse;
                    }
                }
                
                if (notInRequestedCity && requestedCity) {
                    textResponse += `׳׳ ׳׳¦׳׳×׳™ ׳‘${requestedCity}.`;
                } else {
                    // נ¯ NEW: Suggest similar categories if no results found
                    textResponse += `׳׳ ׳׳¦׳׳×׳™ ׳×׳•׳¦׳׳•׳×`;
                    
                    // Extract category from userMessage to suggest similar
                    const categoryMap = {
                        '׳¦׳¢׳¦׳•׳¢': ['׳׳©׳—׳§׳™׳', '׳‘׳•׳‘׳•׳×', '׳׳©׳—׳§׳™ ׳™׳׳“׳™׳'],
                        '׳©׳¢׳•׳': ['׳×׳›׳©׳™׳˜׳™׳', '׳׳§׳¡׳¡׳•׳¨׳™׳–'],
                        '׳׳§': ['׳§׳•׳¡׳׳˜׳™׳§׳”', '׳™׳•׳₪׳™', '׳׳ ׳™׳§׳•׳¨ ׳₪׳“׳™׳§׳•׳¨'],
                        '׳׳¡׳₪׳¨׳”': ['׳¢׳™׳¦׳•׳‘ ׳©׳™׳¢׳¨', '׳§׳•׳¡׳׳˜׳™׳§׳”', '׳™׳•׳₪׳™'],
                        '׳ ׳’׳¨': ['׳׳™׳ ׳¡׳˜׳׳˜׳•׳¨', '׳—׳©׳׳׳׳™', '׳‘׳¢׳׳™ ׳׳§׳¦׳•׳¢']
                    };
                    
                    let foundCategory = null;
                    for (const [category, similar] of Object.entries(categoryMap)) {
                        if (userMessage && userMessage.toLowerCase().includes(category)) {
                            foundCategory = { category, similar };
                            break;
                        }
                    }
                    
                    if (foundCategory) {
                        textResponse += `.\n\n׳׳•׳׳™ ׳׳¢׳ ׳™׳™׳ ׳׳•׳×׳ ${foundCategory.similar.join(', ')}?`;
                    } else {
                        textResponse += `. ׳ ׳¡׳” ׳׳—׳₪׳© ׳׳©׳”׳• ׳׳—׳¨ ׳‘׳׳¨׳§׳˜׳₪׳׳™׳™׳¡!`;
                    }
                }
                return textResponse;
            }
            
        if (userAskedForProductList && globalCheapest) {
            const cheapestPriceText = Number(globalCheapest.price).toLocaleString('he-IL');
            textResponse += `׳”׳₪׳¨׳™׳˜ ׳”׳›׳™ ׳–׳•׳ ׳©׳׳¦׳׳×׳™ ׳”׳•׳ ${globalCheapest.name} ׳‘-${globalCheapest.store} ׳‘׳׳—׳™׳¨ ג‚×${cheapestPriceText}.\n\n`;
        }
        
            if (notInRequestedCity && requestedCity) {
                // Results found, but not in requested city
                // נ¯ NEW: Don't show results from other cities unless user explicitly asks
                // This prevents confusion where user asks for "׳—׳“׳¨׳”" and gets "׳ ׳×׳ ׳™׳”"
                if (userAlreadySaidYes) {
                    // User explicitly said yes - show details from other cities
                    textResponse += `׳׳ ׳׳¦׳׳×׳™ ׳‘${requestedCity}, ׳׳‘׳ ׳™׳©`;
                    if (actualCity && actualCity !== '׳׳ ׳™׳“׳•׳¢') {
                        textResponse += ` ׳‘${actualCity}:\n\n`;
                    } else {
                        textResponse += `:\n\n`;
                    }
                } else {
                    // User hasn't confirmed - just say "not found"
                    textResponse += `׳׳ ׳׳¦׳׳×׳™ ׳‘${requestedCity}.`;
                    // Only mention other cities if there are actual results
                    if (stores.length > 0 && actualCity && actualCity !== '׳׳ ׳™׳“׳•׳¢') {
                        textResponse += `\n\n׳¨׳•׳¦׳” ׳׳¨׳׳•׳× ׳׳₪׳©׳¨׳•׳™׳•׳× ׳‘${actualCity}?`;
                    }
                    return textResponse;
                }
            } else if (stores.length === 1) {
                // נ¯ FIX: If single result, show it directly (don't ask "׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?")
                // User wants immediate recommendation if found
                // נ¯ FIX: If user asked for prices, show only prices, no description
                if (userAskedForProductList && stores[0].products && stores[0].products.length > 0) {
                    textResponse += `${stores[0].title}\n\n`;
                } else {
                textResponse += `׳׳¦׳׳×׳™ ׳׳× ${stores[0].title}.\n\n`;
                }
            } else {
                // נ¯ FIX: Always show the options list, even if user hasn't said "׳›׳" yet
                // נ¯ FIX: Better wording - "׳׳¦׳׳×׳™" instead of "׳™׳©"
                // נ¯ FIX: If user asked for prices, show only prices, no descriptions
                if (userAskedForProductList) {
                    // User asked for prices - show only store names, products will be shown below
                    textResponse += `׳׳¦׳׳×׳™ ${numberToHebrewWords(stores.length)} ׳׳₪׳©׳¨׳•׳™׳•׳×:\n\n`;
                } else {
                    if (userAlreadySaidYes) {
                        // User said yes - show full details
                        textResponse += `׳׳¦׳׳×׳™ ${numberToHebrewWords(stores.length)} ׳׳₪׳©׳¨׳•׳™׳•׳×:\n\n`;
                    } else {
                        // User hasn't said yes yet - show options list first, then ask
                        textResponse += `׳׳¦׳׳×׳™ ${numberToHebrewWords(stores.length)} ׳׳₪׳©׳¨׳•׳™׳•׳×:\n\n`;
                    }
                }
            }
            
                // נ¯ Display stores in organized way - each store once with all its products
            stores.forEach((store, storeIndex) => {
                // נ¯ FINAL cleanup of store title before display (in case duplicates still exist)
                let displayTitle = store.title;
                // Remove any remaining duplicates (last safety check)
                const finalParts = displayTitle.split(/\s*-\s*/);
                if (finalParts.length >= 2 && finalParts[0].trim().toLowerCase() === finalParts[1].trim().toLowerCase()) {
                    displayTitle = finalParts[0].trim() + (finalParts.length > 2 ? ' - ' + finalParts.slice(2).join(' - ') : '');
                }
                
                // Display store name ONCE (no duplicates)
                if (stores.length === 1 && !showFullDescription) {
                    // Single store - name already shown in opening message, but update if needed
                    if (displayTitle !== store.title) {
                        // Title was cleaned, update opening message
                        const escapedTitle = store.title.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const titleRegex = new RegExp(escapedTitle, 'g');
                        textResponse = textResponse.replace(titleRegex, displayTitle);
                    }
                } else {
                    // נ¯ NEW: Add pause marker between stores for speech (except first store)
                    if (storeIndex > 0) {
                        textResponse += `\n\n`; // Extra newline for visual spacing + speech pause
                        // נ¯ Add special marker for speech pause (will be replaced in speakText)
                        textResponse += `[PAUSE]`;
                    }
                    // נ¯ FIX: Add numbering to options (1., 2., 3...) with period for better speech separation
                    // נ¯ FIX: Convert "AI" to Hebrew "׳‘׳™׳ ׳” ׳׳׳׳›׳•׳×׳™׳×" for better speech
                    let displayTitleFixed = displayTitle.replace(/\bAI\b/gi, '׳‘׳™׳ ׳” ׳׳׳׳›׳•׳×׳™׳×');
                    
                    // נ¯ FIX: If user asked for prices (e.g., "׳׳” ׳”׳¦׳¢׳¦׳•׳¢ ׳”׳›׳™ ׳–׳•׳"), show ONLY prices, no descriptions
                    if (userAskedForProductList && store.products && store.products.length > 0) {
                        // Show only store name and products with prices
                        textResponse += `${storeIndex + 1}. ${displayTitleFixed}`;
                        textResponse += `\n`;
                    } else {
                        // Show store name with description
                        textResponse += `${storeIndex + 1}. ${displayTitleFixed}`;
                    
                    // Add SHORT description (remove "׳׳’׳•׳•׳")
                    // נ¯ Also check if description starts with store name (duplicate)
                    let description = store.description || '';
                    if (description) {
                        // Remove description that starts with store name (duplicate)
                        const descLower = description.toLowerCase().trim();
                        const titleLower = displayTitle.toLowerCase().trim();
                        if (descLower.startsWith(titleLower) && descLower.length > titleLower.length) {
                            // Description starts with title - remove the duplicate part
                            description = description.substring(titleLower.length).replace(/^[\s-]+/, '').trim();
                        }
                    }
                    
                    if (description && !description.includes('page') && description.trim().length > 0) {
                        let shortDesc = description.trim();
                        // Remove "׳׳’׳•׳•׳" from description
                        shortDesc = shortDesc.replace(/׳׳’׳•׳•׳\s*/gi, '').trim();
                            if (shortDesc.length > 60) {
                                const lastSpace = shortDesc.lastIndexOf(' ', 60);
                                shortDesc = lastSpace > 30 ? shortDesc.substring(0, lastSpace) : shortDesc.substring(0, 60);
                            }
                        if (shortDesc.length > 0) {
                            textResponse += ` - ${shortDesc}`;
                        }
                    }
                    
                        // נ¯ FIX: Add period at end of each store description for better speech separation
                        // This ensures the next number (e.g., "2.") doesn't sound connected to previous store
                        textResponse += `.`;
                    textResponse += `\n`;
                    }
                }
                
                // Show full description for single result if requested
                if (stores.length === 1 && showFullDescription && store.description) {
                    textResponse += `${store.description}\n`;
                }
                    
                    // נ¯ Show contact info if user specifically asked for it OR said "yes"/"׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳"
                if (userWantsContactInfo && store.contactInfo) {
                    // נ¯ ׳”׳•׳¡׳£ ׳¡׳׳ ׳₪׳¨׳׳™׳•׳ ׳׳ ׳§׳™׳™׳
                    if (store.premium) {
                        textResponse += `   ג­ ׳₪׳¨׳׳™׳•׳\n`;
                    }
                    
                    // נ¯ ׳”׳•׳¡׳£ ׳§׳˜׳’׳•׳¨׳™׳” ׳׳ ׳§׳™׳™׳׳×
                    if (store.category && store.category !== 'unknown') {
                        textResponse += `   נ·ן¸ ${store.category}\n`;
                    }
                    
                    // Show full contact details with icons
                    if (store.contactInfo.phone) {
                        textResponse += `   נ“ ${store.contactInfo.phone}\n`;
                    }
                    
                    // נ¯ ׳©׳™׳׳•׳© ׳‘׳¢׳™׳¨ ׳-metadata ׳׳• ׳-contactInfo
                    const cityToShow = store.city || store.contactInfo.city;
                    const addressToShow = store.address || store.contactInfo.address;
                    
                    if (cityToShow && !textResponse.includes(cityToShow)) {
                        textResponse += `   נ“ ${cityToShow}`;
                        // Add address if available
                        if (addressToShow && addressToShow !== cityToShow) {
                            textResponse += `, ${addressToShow}`;
                        }
                        textResponse += `\n`;
                    }
                    
                    // נ¯ ׳”׳•׳¡׳£ ׳׳—׳™׳¨ ׳׳ ׳§׳™׳™׳ (׳׳§׳•׳¨׳¡׳™׳, ׳©׳™׳¨׳•׳×׳™׳ ׳•׳›׳•')
                    if (store.price && !userAskedForProductList) {
                        const priceText = store.priceRange || `ג‚×${store.price}`;
                        textResponse += `   נ’° ${priceText}\n`;
                    }
                    
                    if (store.contactInfo.email) {
                        textResponse += `   נ“§ ${store.contactInfo.email}\n`;
                    }
                    }
                    
                    // נ¯ ONLY show products if user explicitly asked for them or for product list
                if (userAskedForProductList && store.products && store.products.length > 0) {
                    // Remove duplicates by product name
                    const uniqueProducts = [];
                    const seenProducts = new Set();
                    
                    for (const product of store.products) {
                        const productKey = `${product.name}-${product.price}`.toLowerCase();
                        if (!seenProducts.has(productKey)) {
                            seenProducts.add(productKey);
                            uniqueProducts.push(product);
                        }
                    }
                    
                    if (uniqueProducts.length > 0) {
                        textResponse += `׳׳•׳¦׳¨׳™׳:\n`;
                        uniqueProducts.forEach((product) => {
                                const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                textResponse += `   ג€¢ ${product.name} - ג‚×${price.toLocaleString('he-IL')}\n`;
                            });
                        }
                    }
                    
                    // נ¯ ONLY show link if user explicitly asked for it AND not showing preview
                    // (Don't show "click here" when iframe is already open!)
                    if (userWantsLink && includeLinks !== 'preview') {
                    textResponse += `נ”— [׳׳—׳¥ ׳›׳׳ ׳׳¦׳₪׳™׳™׳” ׳‘׳׳×׳¨](${store.pageUrl})\n`;
                    }
                    
                    textResponse += `\n`;
            });
            
            // נ¯ Add SHORT friendly hint at the end - ONLY if NOT showing link/contact/products
            // נ¯ FIX: Always add hint if user hasn't said "׳›׳" yet (even if showing multiple options)
            console.log('נ” [HINT CHECK] userWantsLink:', userWantsLink, 'userWantsContactInfo:', userWantsContactInfo, 'userAskedForProductList:', userAskedForProductList, 'storesCount:', stores.length, 'userAlreadySaidYes:', userAlreadySaidYes);
            if (!userWantsLink && !userWantsContactInfo && !userAskedForProductList && stores.length > 0) {
                if (stores.length > 1) {
                    // Multiple options - ask which page to open instead of "׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?"
                    if (!userAlreadySaidYes) {
                        textResponse += `\n\n׳׳™׳–׳” ׳“׳£ ׳׳₪׳×׳•׳—?`;
                        console.log('ג… Added hint: "׳׳™׳–׳” ׳“׳£ ׳׳₪׳×׳•׳—?" (multiple options)');
                    } else {
                        // נ¯ FIX: Better wording - "׳׳™׳–׳” ׳×׳¨׳¦׳”?" sounds better than "׳™׳© 2 ׳׳₪׳©׳¨׳•׳™׳•׳×"
                    textResponse += `\n\n׳׳™׳–׳” ׳×׳¨׳¦׳”?`;
                        console.log('ג… Added hint: "׳׳™׳–׳” ׳×׳¨׳¦׳”?" (user said yes)');
                    }
                } else {
                    // Single option - show hint only if user hasn't said "׳›׳" yet
                    if (!userAlreadySaidYes) {
                    textResponse += `\n\n׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?`;
                        console.log('ג… Added hint: "׳¨׳•׳¦׳” ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳?" (single option)');
                    }
                }
            } else {
                console.log('ג ן¸ Skipped hint - one of conditions failed');
            }
            
            // נ¯ FIX: Remove [PAUSE] markers from text response (they're only for speech)
            textResponse = textResponse.replace(/\[PAUSE\]/g, '');
            
            return textResponse.trim();
        }
        
        // Display page options list (without previews) - ALWAYS fetch fresh data, ORGANIZED BY CATEGORIES
        // message can be the user's query to detect if they want full price list
        // showTextResponseFirst: if true, show text response with real data before buttons
        async function displayPageOptions(pages, message, showTextResponseFirst = false) {
            const messagesDiv = document.getElementById('stavChatMessages');
            
            // נ¯ FIX: If showTextResponseFirst is true, generate and show text response with real data FIRST
            if (showTextResponseFirst) {
                console.log('נ“ Generating text response with real data first...');
                // נ¯ Check if user wants link
                const includeLinks = message && /׳×׳¨׳׳”.*׳׳×׳¨|׳×׳¨׳׳”.*׳“׳£|׳§׳™׳©׳•׳¨|׳₪׳×׳—.*׳׳×׳¨|׳׳™׳ ׳§|link/i.test(message);
                const textResponse = await generateTextResponseWithRealData(pages, message, includeLinks);
                if (textResponse && textResponse.trim().length > 0) {
                    addStavMessage(textResponse, false);
                    console.log('ג… Added text response with real data');
                }
            }
            
            // נ¯ CRITICAL: ALWAYS fetch LIVE data from pages - NO cached metadata!
            // User requirement: "׳©׳•׳ ׳ ׳×׳•׳ ׳׳ ׳׳•׳‘׳ ׳” ׳”׳›׳ ׳¦׳¨׳™׳ ׳׳”׳™׳•׳× ׳“׳™׳ ׳׳™"
            // All data must be DYNAMIC from the actual live HTML pages
            console.log('נ” ALWAYS fetching LIVE data (dynamic) for', pages.length, 'pages - NO cached metadata!');
            for (let i = 0; i < Math.min(pages.length, 5); i++) {
                const page = pages[i];
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                
                // נ¯ ALWAYS fetch live HTML and extract data dynamically (NO metadata!)
                let contactInfo = { phone: null, phones: [], email: null, city: null, address: null };
                let products = [];
                
                try {
                    console.log(`נ” Fetching LIVE data for "${page.title}" from ${pageUrl}`);
                    const pageResponse = await fetch(pageUrl);
                    if (pageResponse.ok) {
                        const html = await pageResponse.text();
                        // Extract LIVE contact info from HTML (dynamic, not cached)
                        contactInfo = extractLiveContactInfo(html);
                        // Extract LIVE products from HTML (dynamic, not cached)
                        products = extractLiveProducts(html);
                        console.log(`ג… Extracted LIVE data for "${page.title}":`, {
                            phone: contactInfo.phone,
                            city: contactInfo.city,
                            productsCount: products.length
                        });
                    } else {
                        console.warn(`ג ן¸ Failed to fetch live data for "${page.title}"`);
                    }
                } catch (error) {
                    console.error(`ג Error fetching live data for "${page.title}":`, error);
                }
                
                // Store live data in page object for later use
                pages[i].liveContactInfo = contactInfo;
                pages[i].liveProducts = products;
            }
            
            // נ¯ FIX: Sort pages by relevance score (if available) to show best recommendations first
            // Limit to top 5 pages for accurate recommendations (not all pages!)
            const sortedPages = [...pages].sort((a, b) => {
                // Sort by matchScore if available (from searchLivePages)
                const scoreA = a.matchScore || 0;
                const scoreB = b.matchScore || 0;
                if (scoreB !== scoreA) return scoreB - scoreA;
                
                // If same score, prefer pages with products
                const productsA = (a.liveProducts || []).length;
                const productsB = (b.liveProducts || []).length;
                if (productsB !== productsA) return productsB - productsA;
                
                // If same products count, prefer pages with contact info
                const contactA = (a.liveContactInfo?.phone ? 1 : 0) + (a.liveContactInfo?.city ? 1 : 0);
                const contactB = (b.liveContactInfo?.phone ? 1 : 0) + (b.liveContactInfo?.city ? 1 : 0);
                return contactB - contactA;
            });
            
            // Limit to top 5 pages for accurate recommendations
            const topPages = sortedPages.slice(0, 5);
            
            // Categorize top pages by type for better organization
            const categories = {
                stores: topPages.filter(p => p.pageType === 'store' || p.pageType === 'onlineStore'),
                services: topPages.filter(p => p.pageType === 'serviceProvider'),
                courses: topPages.filter(p => p.pageType === 'course'),
                events: topPages.filter(p => p.pageType === 'event'),
                other: topPages.filter(p => !['store', 'onlineStore', 'serviceProvider', 'course', 'event'].includes(p.pageType))
            };
            
            // Create options message with categories
            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'stav-message bot';
            optionsDiv.style.cssText = `
                background: #f3f4f6;
                border-radius: 12px;
                padding: 16px;
                margin: 12px 0;
            `;
            
            // נ¯ FIX: Show accurate count - only top 5 recommendations
            const totalPages = topPages.length;
            const messageText = message || (totalPages > 0 ? `׳”׳׳׳¦׳•׳× ׳׳“׳•׳™׳§׳•׳× - ׳׳¦׳׳×׳™ ${totalPages} ${totalPages === 1 ? '׳“׳£' : '׳“׳₪׳™׳'} ׳”׳›׳™ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳:` : '׳׳ ׳׳¦׳׳×׳™ ׳“׳₪׳™׳ ׳¨׳׳•׳•׳ ׳˜׳™׳™׳');
            let optionsHtml = `<div style="font-weight: 600; font-size: 16px; margin-bottom: 16px; color: #1f2937;">${messageText}</div>`;
            
            // Display by categories
            const categoryLabels = {
                stores: { emoji: 'נ×', label: '׳—׳ ׳•׳™׳•׳×', pages: categories.stores },
                services: { emoji: 'נ”§', label: '׳©׳™׳¨׳•׳×׳™׳', pages: categories.services },
                courses: { emoji: 'נ“', label: '׳§׳•׳¨׳¡׳™׳', pages: categories.courses },
                events: { emoji: 'נ‰', label: '׳׳™׳¨׳•׳¢׳™׳', pages: categories.events },
                other: { emoji: 'נ“„', label: '׳׳—׳¨', pages: categories.other }
            };
            
            // נ¯ FIX: Show only top 5 recommendations, not all pages (for accuracy!)
            let pageIndex = 0;
            const maxPagesToShow = 5; // Show only top 5 recommendations for accuracy
            
            Object.entries(categoryLabels).forEach(([key, category]) => {
                if (category.pages.length > 0 && pageIndex < maxPagesToShow) {
                    optionsHtml += `<div style="margin-bottom: 16px;">`;
                    // Show count only if there are more pages in this category than we're showing
                    const showingCount = Math.min(category.pages.length, maxPagesToShow - pageIndex);
                    const countText = category.pages.length > showingCount ? ` (${showingCount} ׳׳×׳•׳ ${category.pages.length})` : ` (${category.pages.length})`;
                    optionsHtml += `<div style="font-weight: 600; font-size: 14px; color: #667eea; margin-bottom: 8px;">${category.emoji} ${category.label}${countText}</div>`;
                    
                    category.pages.forEach((page) => {
                        if (pageIndex >= maxPagesToShow) return;
                        
                        const index = pageIndex++;
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                // ALWAYS use fresh live data (just fetched above, not invented)
                const contact = page.liveContactInfo || {};
                const products = page.liveProducts || [];
                
                optionsHtml += `<div style="background: white; border-radius: 8px; padding: 12px; margin: 8px 0; border: 1px solid #e5e7eb;">`;
                optionsHtml += `<div style="font-weight: 600; font-size: 16px; color: #1f2937; margin-bottom: 8px;">${page.title}</div>`;
                
                // Only show description if it's from the actual page metadata (not invented)
                // Don't show fake descriptions - remove "׳׳’׳•׳•׳"
                if (page.description && page.description.length > 0 && !page.description.includes('page')) {
                    let cleanDesc = page.description.replace(/׳׳’׳•׳•׳\s*/gi, '').trim();
                    if (cleanDesc.length > 0) {
                        optionsHtml += `<div style="color: #6b7280; font-size: 14px; margin-bottom: 8px;">${cleanDesc.substring(0, 100)}${cleanDesc.length > 100 ? '...' : ''}</div>`;
                    }
                }
                
                // Show contact info ONLY if available from REAL metadata (not invented)
                // NEVER show invented contact info - only show if we have REAL data
                const hasRealContactInfo = (contact.phone && contact.phone.length > 0) || 
                                          (contact.city && contact.city.length > 0) || 
                                          (contact.email && contact.email.length > 0 && contact.email.includes('@')) ||
                                          (contact.address && contact.address.length > 0);
                
                if (hasRealContactInfo) {
                    optionsHtml += `<div style="font-size: 13px; color: #1e40af; margin-top: 8px; font-weight: 600;">`;
                    if (contact.phone && contact.phone.length > 0) {
                        optionsHtml += `נ“ ${contact.phone}`;
                        // Add clickable tel link
                        optionsHtml += ` <a href="tel:${contact.phone.replace(/-/g, '')}" style="background: #10b981; color: white; padding: 4px 8px; border-radius: 4px; text-decoration: none; margin-right: 4px; font-size: 11px;">נ“ ׳”׳×׳§׳©׳¨</a>`;
                    }
                    // Don't show additional phones - only show the main phone number
                    if (contact.city && contact.city.length > 0) {
                        optionsHtml += ` נ“ ${contact.city}`;
                    }
                    if (contact.email && contact.email.length > 0 && contact.email.includes('@')) {
                        optionsHtml += ` נ“§ ${contact.email}`;
                    }
                    if (contact.address && contact.address.length > 0) {
                        optionsHtml += ` נ  ${contact.address}`;
                    }
                    optionsHtml += `</div>`;
                } else {
                    // No real contact info available - don't display anything (not even placeholder)
                    console.log(`ג ן¸ No real contact info for "${page.title}" - skipping display`);
                }
                
                // Show product count and highlights ONLY if available from live data (REAL products only)
                if (products && Array.isArray(products) && products.length > 0) {
                    // Validate products are real (have name and price)
                    const validProducts = products.filter(p => p && p.name && p.price && p.price > 0);
                    
                    if (validProducts.length > 0) {
                        // נ¯ FIX: Check if user asked for full price list - if so, show ALL products with prices
                        const messageToCheck = message || window.lastUserMessage || '';
                        const isPriceListQuery = messageToCheck && (
                            messageToCheck.toLowerCase().includes('׳¨׳©׳™׳׳× ׳׳—׳™׳¨׳™׳') ||
                            messageToCheck.toLowerCase().includes('׳×׳¨׳׳™ ׳׳•׳¦׳¨׳™׳') ||
                            messageToCheck.toLowerCase().includes('׳×׳¨׳׳™ ׳׳—׳™׳¨׳™׳') ||
                            messageToCheck.toLowerCase().includes('׳׳•׳¦׳¨׳™׳ ׳•׳׳—׳™׳¨׳™׳') ||
                            (messageToCheck.toLowerCase().includes('׳×׳¨׳׳™') && 
                             (messageToCheck.toLowerCase().includes('׳׳•׳¦׳¨') || messageToCheck.toLowerCase().includes('׳׳—׳™׳¨'))) || 
                            messageToCheck.toLowerCase().includes('׳¨׳©׳™׳׳× ׳׳•׳¦׳¨׳™׳') ||
                            messageToCheck.toLowerCase().includes('׳׳—׳™׳¨׳™׳ ׳©׳') ||
                            messageToCheck.toLowerCase().includes('׳›׳ ׳”׳׳—׳™׳¨׳™׳') ||
                            messageToCheck.toLowerCase().includes('׳›׳ ׳”׳׳•׳¦׳¨׳™׳')
                        );
                        
                        console.log('נ” Checking for price list query:', {
                            message: message,
                            lastUserMessage: window.lastUserMessage,
                            messageToCheck: messageToCheck,
                            isPriceListQuery: isPriceListQuery
                        });
                        
                        if (isPriceListQuery) {
                            // Show ALL products with prices (sorted by price)
                            const sortedByPrice = [...validProducts].sort((a, b) => {
                                const getNumericPrice = (price) => {
                                    if (typeof price === 'number') return price;
                                    const priceStr = String(price).replace(/[ג‚×,\s]/g, '');
                                    const numPrice = parseFloat(priceStr) || 0;
                                    return numPrice;
                                };
                                return getNumericPrice(a.price) - getNumericPrice(b.price);
                            });
                            
                            optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 8px; margin-bottom: 8px;">נ’° ${validProducts.length} ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳:</div>`;
                            optionsHtml += `<div style="margin-top: 4px; margin-bottom: 8px;">`;
                            sortedByPrice.forEach((product, idx) => {
                                optionsHtml += `<div style="font-size: 12px; color: #374151; margin-top: 4px; padding: 4px 0; border-bottom: 1px solid #e5e7eb;">
                                    <span style="font-weight: 600;">${idx + 1}.</span> ${product.name} - <span style="color: #059669; font-weight: 600;">ג‚×${product.price}</span>
                                </div>`;
                            });
                            optionsHtml += `</div>`;
                            
                            // Still show cheapest as highlight
                            const cheapestProduct = sortedByPrice[0];
                            if (cheapestProduct && cheapestProduct.name && cheapestProduct.price) {
                                optionsHtml += `<div style="font-size: 12px; color: #059669; margin-top: 4px; font-weight: 600; padding: 4px 8px; background: #ecfdf5; border-radius: 4px; display: inline-block;">ג­ ׳”׳›׳™ ׳–׳•׳: ${cheapestProduct.name} - ג‚×${cheapestProduct.price}</div>`;
                            }
                        } else {
                            // Normal display - show only cheapest product
                            optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 4px;">נ’° ${validProducts.length} ׳׳•׳¦׳¨׳™׳ ׳–׳׳™׳ ׳™׳</div>`;
                            
                            // Show cheapest product as selling point
                            // Sort by price (numeric) to find the ACTUAL cheapest
                            // נ¯ FIX: Always show cheapest, even if only 1 product
                            const sortedByPrice = [...validProducts].sort((a, b) => {
                                // Extract numeric price value - handle multiple formats
                                const getNumericPrice = (price) => {
                                    if (typeof price === 'number') return price;
                                    const priceStr = String(price).replace(/[ג‚×,\s]/g, '');
                                    const numPrice = parseFloat(priceStr) || 0;
                                    return numPrice;
                                };
                                
                                const priceA = getNumericPrice(a.price);
                                const priceB = getNumericPrice(b.price);
                                return priceA - priceB;
                            });
                            
                            const cheapestProduct = sortedByPrice[0];
                            if (cheapestProduct && cheapestProduct.name && cheapestProduct.price) {
                                // נ¯ FIX: Always show cheapest product, even if only one product
                                optionsHtml += `<div style="font-size: 12px; color: #059669; margin-top: 4px; font-weight: 600;">ג­ ׳”׳›׳™ ׳–׳•׳: ${cheapestProduct.name} - ג‚×${cheapestProduct.price}</div>`;
                            }
                        }
                    } else {
                        // No valid products found (empty array or invalid data)
                        optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 4px; font-style: italic;">נ’¡ ׳׳—׳¥ ׳¢׳ "׳¦׳₪׳” ׳‘׳“׳£" ׳›׳“׳™ ׳׳¨׳׳•׳× ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳</div>`;
                    }
                } else {
                    // No products array or empty - DON'T invent products
                    optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 4px; font-style: italic;">נ’¡ ׳׳—׳¥ ׳¢׳ "׳¦׳₪׳” ׳‘׳“׳£" ׳›׳“׳™ ׳׳¨׳׳•׳× ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳</div>`;
                }
                        
                        // Add selling point badges
                        if (pageIndex === 1) {
                            optionsHtml += `<div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; margin-top: 8px; display: inline-block;">נ† ׳׳•׳׳׳¥ ׳‘׳™׳•׳×׳¨</div>`;
                        }
                        
                        // נ¯ FIX: User wants ONLY text conversation - NO preview buttons!
                        // Only show "׳¦׳₪׳” ׳‘׳“׳£" link
                        const fullPageUrl = `${window.location.origin}${pageUrl}`;
                        optionsHtml += `<div style="margin-top: 12px;">
                            <a href="${fullPageUrl}" target="_blank" style="
                                display: inline-block;
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                color: white;
                                padding: 8px 16px;
                                border-radius: 6px;
                                text-decoration: none;
                                font-weight: 600;
                                font-size: 14px;
                                cursor: pointer;
                            ">נ‘ן¸ ׳¦׳₪׳” ׳‘׳“׳£</a>
                        </div>`;
                        
                        optionsHtml += `</div>`;
                    });
                    
                    optionsHtml += `</div>`; // Close category section
                }
            });
            
            optionsDiv.innerHTML = optionsHtml;
            messagesDiv.appendChild(optionsDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // Store pages in window for preview function
            window.stavCurrentPages = pages;
        }
        
        // Open page preview when user clicks button
        function openPagePreview(index, userId, pageId) {
            const messagesDiv = document.getElementById('stavChatMessages');
            const pages = window.stavCurrentPages || [];
            
            if (pages[index]) {
                const page = pages[index];
                
                // Add confirmation message
                addStavMessage(`׳₪׳•׳×׳— ׳׳× "${page.title}"...`, false);
                
                // Display the preview (async)
                setTimeout(async () => {
                    await displayPagePreview(page, 'stavChatMessages');
                }, 300);
            }
        }
        
        // Ask user if they want to see the website BEFORE showing it
        function askToShowWebsite(pages) {
            const messagesDiv = document.getElementById('stavChatMessages');
            
            const askDiv = document.createElement('div');
            askDiv.className = 'stav-message bot';
            askDiv.style.cssText = `
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border-radius: 12px;
                padding: 16px;
                margin: 12px 0;
            `;
            
            let askHtml = `<div style="font-weight: 600; font-size: 16px; margin-bottom: 12px;">נ‘ן¸ ׳”׳׳ ׳×׳¨׳¦׳” ׳׳¨׳׳•׳× ׳׳× ׳”׳“׳£?</div>`;
            askHtml += `<div style="font-size: 14px; opacity: 0.95; margin-bottom: 16px;">׳׳₪׳©׳¨ ׳׳¨׳׳•׳× ׳₪׳¨׳˜׳™׳ ׳ ׳•׳¡׳₪׳™׳, ׳׳•׳¦׳¨׳™׳ ׳•׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” ׳©׳ ׳”׳“׳£</div>`;
            
            pages.slice(0, 3).forEach((page, index) => {
                askHtml += `<button onclick="confirmShowPage(${index})" style="
                    background: rgba(255,255,255,0.2);
                    color: white;
                    border: 2px solid white;
                    border-radius: 8px;
                    padding: 10px 16px;
                    margin: 4px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 14px;
                    transition: all 0.2s;
                    width: calc(33% - 8px);
                " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">${page.title}</button>`;
            });
            
            askHtml += `<div style="margin-top: 12px; font-size: 12px; opacity: 0.9;">נ’¡ ׳׳• ׳׳—׳¥ ׳¢׳ "׳¦׳₪׳” ׳‘׳“׳£" ׳‘׳×׳׳•׳ ׳” ׳׳׳¢׳׳”</div>`;
            
            askDiv.innerHTML = askHtml;
            messagesDiv.appendChild(askDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // Store pages for confirmShowPage function
            window.stavCurrentPages = pages;
        }
        
        // Confirm and show page when user clicks - FIRST show text details, THEN ask about preview
        async function confirmShowPage(index) {
            const pages = window.stavCurrentPages || [];
            if (pages[index]) {
                const page = pages[index];
                
                // FIRST: Display text details (already extracted in displayPageOptions)
                // Remove the "ask to show" message
                const messagesDiv = document.getElementById('stavChatMessages');
                const askDivs = messagesDiv.querySelectorAll('.stav-message.bot');
                askDivs.forEach(div => {
                    if (div.innerHTML.includes('׳”׳׳ ׳×׳¨׳¦׳” ׳׳¨׳׳•׳× ׳׳× ׳”׳“׳£')) {
                        div.remove();
                    }
                });
                
                // Show text details (fetch fresh if needed)
                await displayPagePreview(page, 'stavChatMessages');
                
                // THEN ask if they want to open the actual website
                const openDiv = document.createElement('div');
                openDiv.className = 'stav-message bot';
                openDiv.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border-radius: 12px;
                    padding: 16px;
                    margin: 12px 0;
                `;
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                openDiv.innerHTML = `
                    <div style="font-weight: 600; font-size: 16px; margin-bottom: 12px;">נ‘ן¸ ׳”׳׳ ׳×׳¨׳¦׳” ׳׳₪׳×׳•׳— ׳׳× ׳”׳׳×׳¨?</div>
                    <div style="font-size: 14px; opacity: 0.95; margin-bottom: 16px;">׳׳₪׳©׳¨ ׳׳₪׳×׳•׳— ׳׳× ׳”׳“׳£ ׳”׳׳׳ ׳‘׳“׳₪׳“׳₪׳</div>
                    <button onclick="window.open('${pageUrl}', '_blank')" style="
                        background: rgba(255,255,255,0.2);
                        color: white;
                        border: 2px solid white;
                        border-radius: 8px;
                        padding: 10px 16px;
                        cursor: pointer;
                        font-weight: 600;
                        font-size: 14px;
                        transition: all 0.2s;
                        margin-right: 8px;
                    " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">׳₪׳×׳— ׳‘׳׳×׳¨</button>
                    <button onclick="this.parentElement.remove()" style="
                        background: rgba(255,255,255,0.1);
                        color: white;
                        border: 1px solid rgba(255,255,255,0.5);
                        border-radius: 8px;
                        padding: 10px 16px;
                        cursor: pointer;
                        font-size: 14px;
                    ">׳׳ ׳¢׳›׳©׳™׳•</button>
                `;
                messagesDiv.appendChild(openDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        }
        
        // Helper: Scroll iframe to main title or hero section
        function scrollIframeToMainTitle(iframe) {
            try {
                if (!iframe) return;
                const doc = iframe.contentDocument || iframe.contentWindow?.document;
                if (!doc) return;
                const selectors = [
                    '[data-main-title]',
                    '[role="heading"][aria-level="1"]',
                    'header h1',
                    'main h1',
                    'h1',
                    'main h2',
                    'h2',
                    'h3', // Added h3 as fallback
                    '[itemprop="name"]',
                    '[data-title], [data-page-title]',
                    "[id*='title' i]", "[class*='title' i]",
                    "[id*='header' i] h1, [class*='header' i] h1",
                    "[id*='hero' i]", "[class*='hero' i]", // More hero selectors
                    '#hero h1, .hero h1, #hero, .hero',
                    "[id*='main' i]", "[class*='main' i]", // More main selectors
                    '#main, main',
                    '.container h1', '.container h2', // Container selectors
                    '#content, .content', // Content area
                    'article h1', 'article h2', 'article' // Article selectors
                ];
                let target = null;
                for (const sel of selectors) {
                    const el = doc.querySelector(sel);
                    if (el) { target = el; break; }
                }
                // Heuristic: find first prominent heading-like element by font-size/weight near top
                if (!target) {
                    try {
                        const walkerRoot = doc.body || doc.documentElement;
                        const candidates = Array.from(walkerRoot.querySelectorAll('h1, h2, h3, h4, div, p, span, [class*="title" i], [class*="heading" i], [class*="hero" i]'));
                        const scored = candidates.map(el => {
                            const cs = iframe.contentWindow.getComputedStyle(el);
                            const fontSize = parseFloat(cs.fontSize) || 0;
                            const fontWeight = parseInt(cs.fontWeight, 10) || 400;
                            const rect = el.getBoundingClientRect();
                            const distance = Math.max(0, rect.top);
                            const textLength = (el.textContent || '').trim().length;
                            // Prefer large, bold, near top, with reasonable text length (10-100 chars)
                            const textScore = (textLength >= 10 && textLength <= 100) ? 15 : 0;
                            const score = fontSize * 3 + (fontWeight >= 600 ? 30 : 0) + textScore - distance * 0.02;
                            return { el, score, fontSize, distance };
                        }).filter(x => {
                            const rect = x.el.getBoundingClientRect();
                            return x.el && x.score > 0 && rect.top >= 0 && rect.top < 1400 && x.fontSize >= 16;
                        });
                        if (scored.length > 0) {
                            scored.sort((a,b) => b.score - a.score);
                            target = scored[0].el;
                            console.log('ג… Found title via smart scoring:', target.tagName, 'fontSize:', scored[0].fontSize, 'score:', scored[0].score);
                        }
                    } catch (_) {}
                }
                // Try match og:title to a heading text
                if (!target) {
                    const og = doc.querySelector('meta[property="og:title"]')?.content || '';
                    const titleTag = doc.querySelector('title')?.textContent || '';
                    const expected = (og || titleTag || '').trim();
                    if (expected) {
                        const headings = Array.from(doc.querySelectorAll('h1, h2, [role="heading"]'));
                        target = headings.find(h => (h.textContent || '').trim().includes(expected)) || null;
                    }
                }
                // Compute sticky header offset if exists
                let offset = 10; // Very small offset to show more content
                try {
                    const sticky = doc.querySelector('header, .sticky, .fixed');
                    if (sticky) {
                        const rect = sticky.getBoundingClientRect();
                        if (rect && rect.height) offset = Math.min(40, Math.max(10, rect.height + 5));
                    }
                } catch (_) {}
                let y = 0;
                if (target) {
                    const rect = target.getBoundingClientRect();
                    y = rect.top + (iframe.contentWindow?.pageYOffset || 0) - offset;
                    console.log('ג… Found title element:', target.tagName, ', scrolling to:', y);
                } else {
                    // If no title found, scroll to a fixed position that shows content
                    y = 400; // Scroll to 400px - should show main content
                    console.log('ג ן¸ No title found, scrolling to fallback position:', y);
                }
                // נ¬ Smooth auto-scroll: scroll directly from top to the main title
                const targetY = Math.max(0, y);
                iframe.contentWindow?.scrollTo({ top: 0, behavior: 'instant' }); // Start from top
                iframe.style.opacity = '1';
                
                // נ¬ Auto-scroll smoothly to the main title (faster, 2 seconds)
                setTimeout(() => {
                    let currentY = 0;
                    const duration = 2000; // 2 seconds (faster!)
                    const startTime = performance.now();
                    
                    function animateScroll(currentTime) {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Ease-in-out function for smooth acceleration/deceleration
                        const easeInOut = progress < 0.5
                            ? 2 * progress * progress
                            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                        
                        currentY = targetY * easeInOut;
                        iframe.contentWindow?.scrollTo({ top: currentY, behavior: 'auto' });
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateScroll);
                        }
                    }
                    
                    requestAnimationFrame(animateScroll);
                }, 300); // Start scrolling faster (300ms delay instead of 500ms)
            } catch (_) {
                if (iframe) iframe.style.opacity = '1';
            }
        }
        
        // Display page preview in Stav chat - ALWAYS fetch fresh data from page
        async function displayPagePreview(page, containerId) {
            console.log('נ–¼ן¸ displayPagePreview() called for:', page?.title);
            
            const container = document.getElementById(containerId);
            if (!container) {
                console.error('ג Container not found:', containerId);
                return;
            }
            
            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
            
            // ALWAYS fetch fresh data from the actual page HTML
            console.log('נ” Fetching fresh page data for preview:', pageUrl);
            try {
                const pageResponse = await fetch(pageUrl);
                if (pageResponse.ok) {
                    const html = await pageResponse.text();
                    
                    // Extract live data from HTML
                    const liveContactInfo = extractLiveContactInfo(html);
                    const liveProducts = extractLiveProducts(html);
                    
                    // Update page with live data
                    page.liveContactInfo = liveContactInfo;
                    page.liveProducts = liveProducts;
                    
                    console.log('ג… Loaded live data:', {
                        contact: liveContactInfo,
                        productsCount: liveProducts.length
                    });
                } else {
                    console.error('ג Failed to fetch page:', pageResponse.status);
                }
            } catch (error) {
                console.error('ג Error fetching page data:', error);
            }
            
            // נ¯ Just show the iframe preview - NO text repetition!
            
            // AUTOMATICALLY show iframe preview at the end - Stav opens it herself
            // LARGER preview - shows more of the website
            const previewDiv = document.createElement('div');
            previewDiv.className = 'stav-message bot';
            previewDiv.style.cssText = `
                margin: 16px 0;
                border: 2px solid #e5e7eb;
                border-radius: 12px;
                overflow: hidden;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                opacity: 0;
                transform: translateY(20px);
                transition: all 0.5s ease;
                height: 800px;
                max-height: 80vh;
            `;
            
            previewDiv.innerHTML = `
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                    <span>נ‘ן¸</span>
                    <span>׳×׳¦׳•׳’׳” ׳׳§׳“׳™׳׳” - ${page.title || '׳”׳“׳£'}</span>
                </div>
                <div style="position: relative; height: calc(100% - 48px); overflow: hidden; background: #f9fafb; display: block;">
                    <iframe id="stav-preview-iframe" src="${pageUrl}" style="width: 100%; height: 100%; border: none; opacity: 0; transition: opacity 0.8s ease; display: block; margin: 0;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
                </div>
            `;
            
            container.appendChild(previewDiv);
            container.scrollTop = container.scrollHeight;
            
            // Animate iframe in after a delay
            setTimeout(() => {
                previewDiv.style.opacity = '1';
                previewDiv.style.transform = 'translateY(0)';
            }, 500);

            // After iframe mounts, adjust height to content and scroll to main heading/center
            setTimeout(() => {
                const iframe = previewDiv.querySelector('#stav-preview-iframe');
                if (!iframe) {
                    console.error('ג Iframe not found!');
                    return;
                }
                
                console.log('נ¬ Iframe element found, waiting for load...');
                
                // Handle iframe load
                iframe.addEventListener('load', () => {
                    console.log('ג… Iframe loaded successfully!');
                    // Fade in the iframe
                    iframe.style.opacity = '1';
                    
                    try {
                        const doc = iframe.contentDocument || iframe.contentWindow?.document;
                        if (doc) {
                            console.log('ג… Can access iframe document - injecting styles');
                            // Inject compact preview styles to reduce visual length
                            const style = doc.createElement('style');
                            style.textContent = `
                                html, body { overscroll-behavior: none; }
                                body { padding-top: min(24px, 4vh); }
                                #hero, .hero { margin-bottom: 12px !important; }
                                section { margin-block: 12px !important; }
                                img, video { max-height: 48vh; object-fit: cover; }
                                header.sticky, header.fixed { position: sticky; top: 0; }
                            `;
                            doc.head && doc.head.appendChild(style);
                            console.log('ג… Styles injected into iframe');
                        } else {
                            console.warn('ג ן¸ Cannot access iframe document (possible CORS issue)');
                        }
                    } catch (error) {
                        console.warn('ג ן¸ Cannot inject styles into iframe:', error.message);
                    }
                    // Always attempt to scroll to main title using robust helper
                    scrollIframeToMainTitle(iframe);
                    // Retry scroll after components/styles settle
                    setTimeout(() => scrollIframeToMainTitle(iframe), 250);
                    setTimeout(() => scrollIframeToMainTitle(iframe), 900);
                }, { once: true });
                
                // Handle iframe errors
                iframe.addEventListener('error', (e) => {
                    console.error('ג Iframe failed to load:', e);
                    // Show error message in iframe
                    iframe.style.display = 'none';
                    const errorMsg = document.createElement('div');
                    errorMsg.style.cssText = 'padding: 40px; text-align: center; color: #dc2626; background: #fef2f2; border-radius: 8px; margin: 20px;';
                    errorMsg.innerHTML = `
                        <div style="font-size: 48px; margin-bottom: 16px;">ג ן¸</div>
                        <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">׳©׳’׳™׳׳” ׳‘׳˜׳¢׳™׳ ׳× ׳”׳“׳£</div>
                        <div style="font-size: 14px; color: #991b1b;">׳׳ ׳”׳¦׳׳—׳ ׳• ׳׳˜׳¢׳•׳ ׳׳× ׳×׳¦׳•׳’׳× ׳”׳“׳£. ׳ ׳¡׳” ׳׳׳—׳•׳¥ ׳¢׳ ׳”׳§׳™׳©׳•׳¨ ׳׳׳¢׳׳”.</div>
                    `;
                    iframe.parentElement.appendChild(errorMsg);
                });
            }, 50);
        }

        // Handle Enter key in Stav input
        // Check Stav status and hide if inactive
        async function checkStavStatus() {
            try {
                const response = await fetch('/api/stav/status');
                const data = await response.json();
                
                // Hide Stav if not active or not enabled
                if (!data.active || !data.enabled) {
                    // Hide Stav button (find by text content)
                    const stavButtons = Array.from(document.querySelectorAll('button')).filter(btn => btn.textContent.includes('׳¡׳×׳™׳•'));
                    stavButtons.forEach(btn => btn.style.display = 'none');
                    
                    // Hide Stav chat window
                    const stavWindow = document.getElementById('stavChatWindow');
                    if (stavWindow) {
                        stavWindow.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Error checking Stav status:', error);
                // If error, show Stav by default (fail open)
            }
        }
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Check Stav status first
            await checkStavStatus();
            
            const stavInput = document.getElementById('stavChatInput');
            if (stavInput) {
                stavInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault(); // נ¯ FIX: Prevent form submission (which might clear the field)
                        sendStavMessage();
                    }
                });
                // נ¯ FIX: Also prevent form submission on Enter (in case input is in a form)
                stavInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault(); // Prevent form submission
                    }
                });
            }
            // Open Stav in fullscreen when toggled
            const win = document.getElementById('stavChatWindow');
            if (win) {
                const origToggle = window.toggleStavChat;
                window.toggleStavChat = function() {
                    if (typeof origToggle === 'function') origToggle();
                    win.classList.add('fullscreen');
                }
            }
        });
      </script>
  </body>
</html>
