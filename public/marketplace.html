<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AutoPage Marketplace</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .hero-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .page-card {
            transition: all 0.3s ease;
        }
        .page-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .ai-bot-bubble {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .ai-bot-bubble:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
        }
        
        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }
            100% {
                background-position: 200% 0;
            }
        }
        
        .ai-chat-window {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 350px;
            height: 500px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        
        .ai-chat-window.active {
            display: flex;
        }
        
        .ai-chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .ai-chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: #f8f9fa;
        }
        
        .page-preview {
            margin-top: 15px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .preview-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            font-weight: 600;
        }
        
        .preview-header h3 {
            margin: 0;
            font-size: 16px;
        }
        
        .preview-content {
            padding: 0;
            background: white;
        }
        
        .preview-content iframe {
            border: none;
            border-radius: 0 0 12px 12px;
        }
        
        .ai-message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 10px;
            max-width: 80%;
        }
        
        .ai-message.user {
            background: #667eea;
            color: white;
            margin-left: auto;
        }
        
        .ai-message.bot {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
        }
        
        .typing-text {
            display: inline-block;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .ai-chat-input {
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }
        
        .ai-chat-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
        }
        
        .ai-chat-input button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        
        .typing-dots {
            animation: typing 1.5s infinite;
        }
        
        @keyframes typing {
            0%, 60%, 100% { opacity: 0; }
            30% { opacity: 1; }
        }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Hero Header with Purple Background -->
    <div class="hero-gradient text-white">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
            <div class="text-center">
                <h1 class="text-4xl md:text-6xl font-bold mb-4">AutoPage Marketplace</h1>
                <p class="text-xl md:text-2xl mb-8 opacity-90">××¦× ××ª ×”×“×£ ×”××•×©×œ× ×©×œ×š</p>
                
                <!-- Search Bar -->
                <div class="max-w-2xl mx-auto mb-8">
                    <div class="relative">
                        <input type="text" id="search-input" placeholder="×—×¤×© ×“×¤×™×, ×¢×¡×§×™×, ×©×™×¨×•×ª×™×..." 
                               class="w-full px-6 py-4 text-gray-900 text-lg rounded-full focus:ring-4 focus:ring-white focus:ring-opacity-50 focus:outline-none">
                        <button onclick="searchPages()" class="absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- Create Page Button -->
                <div class="flex justify-center gap-4">
                    <button onclick="goToFullApp()" class="bg-white text-indigo-600 px-8 py-4 rounded-full font-bold text-lg hover:bg-gray-100 transition-all transform hover:scale-105 flex items-center gap-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                        </svg>
                        ×¦×•×¨ ×“×£ ×¢×›×©×™×•
                    </button>
                </div>
                
                <!-- View Toggle Buttons -->
                <div class="flex justify-center gap-2 mt-4">
                    <button id="grid-view-btn" onclick="setView('grid')" class="p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path>
                        </svg>
                    </button>
                    <button id="table-view-btn" onclick="setView('table')" class="p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Filter Buttons -->
    <div class="bg-white border-b">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
            <div class="flex flex-wrap justify-center gap-3">
                <button onclick="filterByType('all')" class="px-6 py-3 bg-indigo-500 text-white rounded-full hover:bg-indigo-600 transition-all">×”×›×œ</button>
                <button onclick="filterByType('store')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">ğŸª ×—× ×•×™×•×ª</button>
                <button onclick="filterByType('event')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">ğŸ‰ ××™×¨×•×¢×™×</button>
                <button onclick="filterByType('course')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">ğŸ“ ×§×•×¨×¡×™×</button>
                <button onclick="filterByType('serviceProvider')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">ğŸ”§ ×‘×¢×œ×™ ××§×¦×•×¢</button>
            </div>
            <div class="text-center mt-4">
                <p id="pages-count" class="text-gray-600">×˜×•×¢×Ÿ ×“×¤×™×...</p>
            </div>
        </div>
    </div>

    <!-- Loading State -->
    <div id="loading-state" class="text-center py-12">
        <div class="text-lg text-gray-600">×˜×•×¢×Ÿ ×“×¤×™×...</div>
    </div>

    <!-- Pages Grid -->
    <div id="pages-grid" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- Pages will be loaded here -->
    </div>
    
    <!-- Pages Table -->
    <div id="pages-table" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 hidden">
        <div class="bg-white shadow overflow-hidden sm:rounded-md">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×ª××•× ×”</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×›×•×ª×¨×ª</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×¡×•×’</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×ª×™××•×¨</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×ª××¨×™×š ×™×¦×™×¨×”</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×¤×¢×•×œ×•×ª</th>
                    </tr>
                </thead>
                <tbody id="table-body" class="bg-white divide-y divide-gray-200">
                    <!-- Table rows will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- AI Search Bot -->
    <div class="ai-bot-bubble" id="aiBotBubble" title="×¢×–×¨×” ×—×›××”">
        ğŸ¤–
    </div>

    <div class="ai-chat-window" id="aiChatWindow">
        <div class="ai-chat-header">
            <span>ğŸ¤– ×”×¢×•×–×¨×ª ×”×—×›××”</span>
            <button id="closeAiChat" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">Ã—</button>
        </div>
        <div class="ai-chat-messages" id="aiChatMessages">
            <div class="ai-message bot">
                ×©×œ×•×! ğŸ˜Š ××™×š ×× ×™ ×™×›×•×œ×” ×œ×¢×–×•×¨ ×œ×š?
            </div>
        </div>
        <div class="ai-chat-input">
            <input type="text" id="aiChatInput" placeholder="×›×ª×•×‘ ×”×•×“×¢×”...">
            <button onclick="sendAIMessage()">×©×œ×—</button>
        </div>
    </div>

    <script>
        const AI_WEBHOOK = 'https://n8n-service-how4.onrender.com/webhook/jhfuhgufkhlkuho8erhf757754jhldkbsjkbmreketpg';
        
        function toggleAIChat() {
            const chatWindow = document.getElementById('aiChatWindow');
            chatWindow.classList.toggle('active');
            
            if (chatWindow.classList.contains('active')) {
                document.getElementById('aiChatInput').focus();
            }
        }
        
        // Add event listener for AI bot bubble
        document.addEventListener('DOMContentLoaded', function() {
            const aiBotBubble = document.getElementById('aiBotBubble');
            if (aiBotBubble) {
                aiBotBubble.addEventListener('click', toggleAIChat);
            }
            
            const closeAiChat = document.getElementById('closeAiChat');
            if (closeAiChat) {
                closeAiChat.addEventListener('click', toggleAIChat);
            }
        });
        
        function addAIMessage(message, isUser = false) {
            const messagesDiv = document.getElementById('aiChatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${isUser ? 'user' : 'bot'}`;
            
            if (isUser) {
                messageDiv.textContent = message;
            } else {
                // Convert markdown-style links to clickable links
                let processedMessage = message.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" style="color: #667eea; text-decoration: underline;">$1</a>');
                
                // Add animated typing effect for bot messages
                messageDiv.innerHTML = '<span class="typing-text"></span>';
                messagesDiv.appendChild(messageDiv);
                
                // Animate typing effect
                const typingSpan = messageDiv.querySelector('.typing-text');
                let i = 0;
                const typeMessage = () => {
                    if (i < processedMessage.length) {
                        typingSpan.innerHTML += processedMessage.charAt(i);
                        i++;
                        setTimeout(typeMessage, 50); // 50ms delay between characters
                    }
                };
                typeMessage();
                
                // Fix image URLs to be absolute and add error handling
                processedMessage = processedMessage.replace(/src="([^"]+)"/g, (match, src) => {
                    let fullSrc = src;
                    if (src.startsWith('/')) {
                        fullSrc = `${window.location.origin}${src}`;
                    }
                    return `src="${fullSrc}" onerror="this.style.display='none'" onload="this.style.display='block'"`;
                });
                
                messageDiv.innerHTML = processedMessage;
            }
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function removeTypingIndicator() {
            const messagesDiv = document.getElementById('aiChatMessages');
            if (messagesDiv.lastChild && messagesDiv.lastChild.textContent.includes('××§×œ×™×“×”')) {
                messagesDiv.removeChild(messagesDiv.lastChild);
            }
        }
        
        // Global variables
        let allPages = [];
        let filteredPages = [];
        let currentType = 'all';
        let currentView = 'grid';
        
        // Load pages on page load
        document.addEventListener('DOMContentLoaded', async function() {
            await loadPages();
        });
        
        // Search functionality
        document.getElementById('search-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPages();
            }
        });
        
        async function loadPages() {
            try {
                const response = await fetch('/api/public-pages');
                const data = await response.json();
                
                // Handle both array and object with pages property
                allPages = Array.isArray(data) ? data : (data.pages || []);
                filteredPages = [...allPages];
                
                console.log('Loaded pages:', allPages);
                console.log('Page types:', [...new Set(allPages.map(p => p.pageType))]);
                
                displayPages();
                updatePagesCount();
                
                // Hide loading state
                document.getElementById('loading-state').style.display = 'none';
            } catch (error) {
                console.error('Error loading pages:', error);
                document.getElementById('loading-state').innerHTML = `
                    <div class="text-red-500 text-lg">×œ× ×”×¦×œ×—×ª×™ ×œ×˜×¢×•×Ÿ ×“×¤×™×. ×‘×“×§×™ ×©×”×©×¨×ª ×¨×¥ ×•×¢×“×›× ×™ ××ª ×”×“×¤×“×¤×Ÿ.</div>
                `;
            }
        }
        
        function filterByType(type) {
            currentType = type;
            
            // Update button styles
            document.querySelectorAll('button[onclick^="filterByType"]').forEach(btn => {
                btn.className = 'px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all';
            });
            event.target.className = 'px-6 py-3 bg-indigo-500 text-white rounded-full hover:bg-indigo-600 transition-all';
            
            console.log('Filtering by type:', type);
            console.log('All pages:', allPages);
            console.log('Page types found:', [...new Set(allPages.map(p => p.pageType))]);
            
            if (type === 'all') {
                filteredPages = [...allPages];
            } else {
                filteredPages = allPages.filter(page => {
                    console.log(`Page: ${page.title}, pageType: ${page.pageType}, matches: ${page.pageType === type}`);
                    return page.pageType === type;
                });
            }
            
            console.log('Filtered pages:', filteredPages);
            displayPages();
            updatePagesCount();
        }
        
        function searchPages() {
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            
            if (searchTerm === '') {
                filteredPages = [...allPages];
            } else {
                filteredPages = allPages.filter(page => 
                    page.title.toLowerCase().includes(searchTerm) ||
                    (page.description && page.description.toLowerCase().includes(searchTerm))
                );
            }
            
            displayPages();
            updatePagesCount();
        }
        
        function displayPages() {
            if (currentView === 'grid') {
                displayGrid();
            } else {
                displayTable();
            }
        }
        
        function displayGrid() {
            const grid = document.getElementById('pages-grid');
            const table = document.getElementById('pages-table');
            
            grid.classList.remove('hidden');
            table.classList.add('hidden');
            
            grid.innerHTML = '';
            
            if (filteredPages.length === 0) {
                grid.innerHTML = '<div class="col-span-full text-center text-gray-500 py-8">×œ× × ××¦××• ×“×¤×™×</div>';
                return;
            }
            
            filteredPages.forEach(page => {
                const pageCard = createPageCard(page);
                grid.appendChild(pageCard);
            });
        }
        
        function displayTable() {
            const grid = document.getElementById('pages-grid');
            const table = document.getElementById('pages-table');
            const tbody = document.getElementById('table-body');
            
            grid.classList.add('hidden');
            table.classList.remove('hidden');
            
            tbody.innerHTML = '';
            
            if (filteredPages.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="px-6 py-4 text-center text-gray-500">×œ× × ××¦××• ×“×¤×™×</td></tr>';
                return;
            }
            
            filteredPages.forEach(page => {
                const row = createTableRow(page);
                tbody.appendChild(row);
            });
        }
        
        function setView(view) {
            currentView = view;
            
            // Update button styles
            document.getElementById('grid-view-btn').className = view === 'grid' ? 
                'p-3 rounded-full bg-white bg-opacity-30 text-white hover:bg-opacity-40 transition-all' :
                'p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all';
            document.getElementById('table-view-btn').className = view === 'table' ? 
                'p-3 rounded-full bg-white bg-opacity-30 text-white hover:bg-opacity-40 transition-all' :
                'p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all';
            
            displayPages();
        }
        
        function createPageCard(page) {
            const card = document.createElement('div');
            card.className = 'page-card bg-white rounded-lg shadow-md overflow-hidden';
            
            const typeIcons = {
                'store': 'ğŸª',
                'event': 'ğŸ‰',
                'course': 'ğŸ“',
                'serviceProvider': 'ğŸ”§',
                'other': 'ğŸ“„'
            };
            
            const icon = typeIcons[page.pageType] || 'ğŸ“„';
            const typeName = getTypeName(page.pageType);
            
            // Fix image URL - convert relative paths to absolute
            let imageUrl = page.thumbnail || '';
            if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
                imageUrl = `/output/${page.userId}/${imageUrl}`;
            }
            
            
            // Use /users/ route like in the main interface
            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
            
            // Try to find a screenshot image - only for courses
            const screenshotUrl = page.pageType === 'course' ? page.thumbnail : null;
            
            card.innerHTML = `
                <!-- ×ª×¦×•×’×” ××§×“×™××” ×©×œ ×”××ª×¨ -->
                <div class="relative rounded-t-xl overflow-hidden bg-gradient-to-br from-gray-50 to-gray-100" style="height: 200px; flex-shrink: 0;">
                    ${screenshotUrl ? `
                        <!-- ×ª×¦×•×’×” ××§×“×™××” ×¢× ×ª××•× ×” -->
                        <img 
                            src="${screenshotUrl}" 
                            alt="${page.title}"
                            class="w-full h-full object-cover"
                            onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                        />
                        <div class="absolute inset-0 bg-gradient-to-br from-indigo-500/10 to-purple-500/10 hidden items-center justify-center">
                            <div class="text-center">
                                <div class="w-16 h-16 bg-white/90 rounded-full flex items-center justify-center mx-auto mb-3 shadow-lg border-2 border-indigo-200">
                                    <span class="text-2xl font-bold text-indigo-600">${icon}</span>
                                </div>
                                <div class="text-sm font-medium text-gray-700 bg-white/90 px-3 py-1 rounded-full shadow-sm border border-gray-200">
                                    ${typeName}
                                </div>
                            </div>
                        </div>
                    ` : `
                        <!-- ×ª×¦×•×’×” ××§×“×™××” ×¢× iframe -->
                        <div class="absolute inset-2 bg-white rounded-lg overflow-hidden shadow-lg border border-gray-300">
                            <iframe 
                                src="${window.location.origin}${pageUrl}" 
                                class="w-full h-full border-0"
                                style="pointer-events: none; transform: scale(0.6) translateX(65%); transform-origin: top left; width: 166.67%; height: 166.67%;"
                                title="×ª×¦×•×’×” ××§×“×™××” ×©×œ ${page.title}"
                                loading="lazy"
                                importance="low"
                                sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-downloads allow-modals allow-top-navigation allow-presentation">
                            </iframe>
                        </div>
                    `}
                </div>
                <div class="p-6">
                    <h3 class="text-xl font-semibold text-gray-900 mb-2">${page.title}</h3>
                    <p class="text-gray-600 mb-4">${page.description || '×œ×œ× ×ª×™××•×¨'}</p>
                    <div class="flex items-center justify-between">
                        <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-indigo-100 text-indigo-800">
                            ${icon} ${typeName}
                        </span>
                        <a href="/view/${page.userId}/${page.pageId}_html" target="_blank" 
                           class="text-indigo-600 hover:text-indigo-800 font-medium">
                            ×¦×¤×” ×‘×“×£ â†’
                        </a>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createTableRow(page) {
            const row = document.createElement('tr');
            row.className = 'hover:bg-gray-50';
            
            const typeIcons = {
                'store': 'ğŸª',
                'event': 'ğŸ‰',
                'course': 'ğŸ“',
                'serviceProvider': 'ğŸ”§',
                'other': 'ğŸ“„'
            };
            
            const icon = typeIcons[page.pageType] || 'ğŸ“„';
            const typeName = getTypeName(page.pageType);
            
            // Fix image URL
            let imageUrl = page.thumbnail || '';
            if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
                imageUrl = `/output/${page.userId}/${imageUrl}`;
            }
            
            const createdDate = new Date(page.created_at).toLocaleDateString('he-IL');
            
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap">
                    <div class="flex-shrink-0 h-16 w-16">
                        ${pageUrl ? `
                            <div class="h-16 w-16 rounded-lg overflow-hidden border border-gray-300 bg-white">
                                <iframe 
                                    src="${window.location.origin}${pageUrl}" 
                                    class="w-full h-full border-0"
                                    style="pointer-events: none; transform: scale(0.3) translateX(100%); transform-origin: top left; width: 333.33%; height: 333.33%;"
                                    title="×ª×¦×•×’×” ××§×“×™××” ×©×œ ${page.title}"
                                    loading="lazy"
                                    importance="low"
                                    sandbox="allow-same-origin allow-scripts allow-popups allow-forms">
                                </iframe>
                            </div>
                        ` : `
                            <div class="h-16 w-16 rounded-lg bg-gray-200 flex items-center justify-center text-2xl">${icon}</div>
                        `}
                    </div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <div class="text-sm font-medium text-gray-900">${page.title}</div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800">
                        ${icon} ${typeName}
                    </span>
                </td>
                <td class="px-6 py-4">
                    <div class="text-sm text-gray-500 max-w-xs truncate">${page.description || '×œ×œ× ×ª×™××•×¨'}</div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    ${createdDate}
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                    <a href="/view/${page.userId}/${page.pageId}_html" target="_blank" 
                       class="text-indigo-600 hover:text-indigo-900">
                        ×¦×¤×” ×‘×“×£
                    </a>
                </td>
            `;
            
            return row;
        }
        
        function getTypeName(type) {
            const names = {
                'store': '×—× ×•×ª',
                'event': '××™×¨×•×¢',
                'course': '×§×•×¨×¡',
                'serviceProvider': '×‘×¢×œ ××§×¦×•×¢',
                'other': '××—×¨'
            };
            return names[type] || '××—×¨';
        }
        
        function updatePagesCount() {
            const count = filteredPages.length;
            const total = allPages.length;
            document.getElementById('pages-count').textContent = 
                `××¦×™×’ ${count} ××ª×•×š ${total} ×“×¤×™×`;
        }
        
        
        // Extract product info from description and HTML content
        async function extractProductInfo(description, keyword, pageUrl = null) {
            if (!description) return null;
            
            const desc = description.toLowerCase();
            const keywordLower = keyword.toLowerCase();
            
            // Look for price patterns - more comprehensive
            const pricePatterns = [
                /(\d+)\s*â‚ª/g,
                /(\d+)\s*×©×§×œ/g,
                /(\d+)\s*×©"×—/g,
                /××—×™×¨[:\s]*(\d+)/g,
                /(\d+)\s*-\s*(\d+)\s*â‚ª/g,
                /××—×™×¨[:\s]*(\d+)\s*-\s*(\d+)/g,
                /(\d+)\s*×œ×××”/g,
                /(\d+)\s*×œ××˜×”/g,
                /(\d+)\s*×œ××¢×œ×”/g
            ];
            
            let price = null;
            for (const pattern of pricePatterns) {
                const match = pattern.exec(desc);
                if (match) {
                    if (match[2]) {
                        price = `${match[1]}-${match[2]}â‚ª`;
                    } else {
                        price = `${match[1]}â‚ª`;
                    }
                    break;
                }
            }
            
            // Look for location patterns
            const locationPatterns = [
                /××™×§×•×[:\s]*([^,.\n]{2,50})/g,
                /×›×ª×•×‘×ª[:\s]*([^,.\n]{2,50})/g,
                /× ××¦×[:\s]*([^,.\n]{2,50})/g,
                /×‘[:\s]*([^,.\n]{2,50})/g
            ];
            
            let location = null;
            for (const pattern of locationPatterns) {
                const match = pattern.exec(desc);
                if (match && match[1] && match[1].length > 2) {
                    location = match[1].trim();
                    break;
                }
            }
            
            // Look for product name patterns - more specific
            let productName = null;
            if (keywordLower === '×©×¢×•×Ÿ') {
                const watchPatterns = [
                    /×©×¢×•×Ÿ\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*×©×¢×•×Ÿ/g,
                    /×©×¢×•×Ÿ\s+([×-×ª\s]{2,30})/g,
                    /([×-×ª\s]{2,30})\s*×©×¢×•×Ÿ\s+([×-×ª\s]{2,30})/g
                ];
                for (const pattern of watchPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            } else if (keywordLower === '×ª×›×©×™×˜') {
                const jewelryPatterns = [
                    /×ª×›×©×™×˜\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*×ª×›×©×™×˜/g,
                    /([^,.\n]{2,30})\s*×–×”×‘/g,
                    /([^,.\n]{2,30})\s*×›×¡×£/g
                ];
                for (const pattern of jewelryPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            } else if (keywordLower === '×¦×¢×¦×•×¢') {
                const toyPatterns = [
                    /×¦×¢×¦×•×¢\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*×¦×¢×¦×•×¢/g,
                    /([^,.\n]{2,30})\s*××©×—×§/g
                ];
                for (const pattern of toyPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            }
            
            // If we have a page URL, try to fetch the HTML content to find more prices
            if (pageUrl && (!price || !productName)) {
                try {
                    console.log('ğŸ” Fetching HTML for:', pageUrl);
                    const response = await fetch(pageUrl);
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    
                    console.log('ğŸ“„ HTML length:', html.length);
                    
                    // Look for prices in HTML content
                    if (!price) {
                        console.log('ğŸ’° Looking for prices in HTML...');
                        const htmlPricePatterns = [
                            /<p class="product-price[^"]*"[^>]*>â‚ª(\d+(?:,\d+)?)<\/p>/g,
                            /class="product-price[^"]*"[^>]*>â‚ª(\d+(?:,\d+)?)/g,
                            /â‚ª\s*(\d+(?:,\d+)?)/g,
                            /(\d+(?:,\d+)?)\s*â‚ª/g
                        ];
                        
                        for (const pattern of htmlPricePatterns) {
                            const matches = [...html.matchAll(pattern)];
                            console.log('ğŸ” Pattern matches:', pattern, matches.length);
                            if (matches.length > 0) {
                                // Get the first price found
                                const firstPrice = matches[0][1] || matches[0][0].match(/(\d+(?:,\d+)?)/)?.[1];
                                console.log('ğŸ’° Found price:', firstPrice);
                                if (firstPrice) {
                                    price = `â‚ª${firstPrice}`;
                                    break;
                                }
                            }
                        }
                        
                        // If still no price, try a simpler approach
                        if (!price) {
                            console.log('ğŸ” Trying simple price search...');
                            const simplePriceMatch = html.match(/â‚ª\s*(\d+(?:,\d+)?)/);
                            console.log('ğŸ’° Simple match result:', simplePriceMatch);
                            if (simplePriceMatch) {
                                price = `â‚ª${simplePriceMatch[1]}`;
                            }
                        }
                        
                        console.log('ğŸ’° Final price found:', price);
                    }
                    
                    // Look for product names in HTML content
                    if (!productName && keywordLower === '×©×¢×•×Ÿ') {
                        const watchPatterns = [
                            /×©×¢×•×Ÿ\s+([^<>{}\n]{2,30})/g,
                            /([^<>{}\n]{2,30})\s*×©×¢×•×Ÿ/g,
                            /<h[1-6][^>]*>.*?×©×¢×•×Ÿ\s+([^<]{2,30})/g,
                            /class="[^"]*product-name[^"]*"[^>]*>([^<]+)/g,
                            /<h3[^>]*>([^<]*×©×¢×•×Ÿ[^<]*)<\/h3>/g
                        ];
                        
                        for (const pattern of watchPatterns) {
                            const matches = [...html.matchAll(pattern)];
                            if (matches.length > 0) {
                                productName = matches[0][1].trim();
                                break;
                            }
                        }
                    }
                } catch (error) {
                    console.log('Could not fetch HTML content:', error);
                }
            }
            
            if (productName || price || location) {
                return {
                    name: productName || `${keyword} ××™×•×—×“`,
                    price: price || '××—×™×¨ ×œ×¤×™ ×‘×§×©×”',
                    location: location || '××™×§×•× ×œ× ×¦×•×™×Ÿ'
                };
            }
            
            return null;
        }

        // Smart search functionality - copied from Stav the Great
        let lastSearchContext = null; // Remember last search context
        let lastSearchResults = []; // Remember last search results
        
        async function handleSmartSearch(message, allPages) {
            const lowerMessage = message.toLowerCase();
            
            // Handle greetings and personal questions
            if (lowerMessage.includes('×©×œ×•×') || lowerMessage.includes('×”×™×™') || lowerMessage.includes('×”×™') || 
                lowerMessage.includes('×©××™') || lowerMessage.includes('×§×•×¨××™× ×œ×™') || lowerMessage.includes('×× ×™') ||
                lowerMessage.includes('××” ×©×œ×•××š') || lowerMessage.includes('××™×š ××ª×”') || lowerMessage.includes('××™×š ××ª')) {
                return { message: `×”×™×™! ğŸ˜Š × ×—××“ ×œ×”×›×™×¨! ××™×š ×× ×™ ×™×›×•×œ×” ×œ×¢×–×•×¨ ×œ×š ×”×™×•×?`, action: { type: 'none' } };
            }
            
            // Handle context switching (e.g., "×•×œ×’×‘×¨" after "××ª× ×” ×œ×™×œ×“")
            if (lowerMessage.includes('×•×œ×’×‘×¨') || lowerMessage.includes('×•×œ××™×©×”') || lowerMessage.includes('×•×œ×™×œ×“') || 
                lowerMessage.includes('×•×œ×’×‘×¨×™×') || lowerMessage.includes('×•×œ× ×©×™×') || lowerMessage.includes('×•×œ×™×œ×“×™×')) {
                // Extract the gift type from context
                let giftType = '××ª× ×”';
                if (lowerMessage.includes('×’×‘×¨') || lowerMessage.includes('×’×‘×¨×™×')) giftType = '××ª× ×” ×œ×’×‘×¨';
                else if (lowerMessage.includes('××™×©×”') || lowerMessage.includes('× ×©×™×')) giftType = '××ª× ×” ×œ××™×©×”';
                else if (lowerMessage.includes('×™×œ×“') || lowerMessage.includes('×™×œ×“×™×')) giftType = '××ª× ×” ×œ×™×œ×“';
                
                // Process as gift search
                const giftResult = await handleSmartSearch(giftType, allPages);
                if (giftResult) return giftResult;
            }
            
            // Only search for pages if user is specifically looking for something
            if (!lowerMessage.includes('××ª× ×”') && !lowerMessage.includes('×œ×§') && !lowerMessage.includes('×©×¢×•×Ÿ') && !lowerMessage.includes('×¦×¢×¦×•×¢') && !lowerMessage.includes('×§×•×¨×¡') && !lowerMessage.includes('×—× ×•×ª') && !lowerMessage.includes('×©×™×¨×•×ª') && !lowerMessage.includes('××™×¨×•×¢') && !lowerMessage.includes('××—×™×¨') && !lowerMessage.includes('×›××”') && !lowerMessage.includes('×¢×•×œ×”') && !lowerMessage.includes('â‚ª') && !lowerMessage.includes('×©×§×œ') && !lowerMessage.includes('×”×›×™ ×–×•×œ') && !lowerMessage.includes('×”×›×™ ×™×§×¨') && !lowerMessage.includes('×”×©×•×•××”') && !lowerMessage.includes('× ×’×™×“') && !lowerMessage.includes('×•×œ×§') && !lowerMessage.includes('×•×©×¢×•×Ÿ') && !lowerMessage.includes('×•×¦×¢×¦×•×¢') && !lowerMessage.includes('×¦×¢×¦×•×¢×™×') && !lowerMessage.includes('×©×¢×•× ×™×')) {
                // For general questions, show available pages instead of letting N8N invent
                if (allPages.length > 0) {
                    let response = `ğŸ¯ **×”× ×” ×”×“×¤×™× ×”×–××™× ×™× ×‘××¢×¨×›×ª ×©×œ× ×•:**\n\n`;
                    allPages.slice(0, 8).forEach(page => {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        const emoji = page.pageType === 'store' ? 'ğŸ›ï¸' : page.pageType === 'event' ? 'ğŸ‰' : page.pageType === 'course' ? 'ğŸ“' : page.pageType === 'serviceProvider' ? 'ğŸ”§' : 'ğŸ“„';
                        response += `â€¢ **${page.title}** ${emoji}\n`;
                        response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                    });
                    response += `\nğŸ’¡ **×¨×•×¦×” ×œ×—×¤×© ××©×”×• ×¡×¤×¦×™×¤×™?** ×›×ª×•×‘ "××ª× ×”", "×œ×§", "×©×¢×•×Ÿ", "×¦×¢×¦×•×¢" ××• "×§×•×¨×¡"!`;
                    return { message: response, action: { type: 'none' } };
                }
                return null; // Let N8N handle general questions only if no pages available
            }
            
            // Reset search context if user is searching for something new
            if (lowerMessage.includes('××—×¤×©') || lowerMessage.includes('×”××œ×¦') || lowerMessage.includes('×œ×') || lowerMessage.includes('×œ× ') || lowerMessage.includes('× ×’×™×“') || lowerMessage.includes('×•×œ×§') || lowerMessage.includes('×•×©×¢×•×Ÿ') || lowerMessage.includes('×•×¦×¢×¦×•×¢') || lowerMessage.includes('×¦×¢×¦×•×¢×™×') || lowerMessage.includes('×¦×¢×¦×•×¢') || lowerMessage.includes('×©×¢×•× ×™×') || lowerMessage.includes('×©×¢×•×Ÿ')) {
                lastSearchContext = null;
                lastSearchResults = [];
                console.log('ğŸ”„ Reset search context for new search or rejection');
            }
            
            // Special handling for "cheapest" or "most expensive" across all pages
            if (lowerMessage.includes('×”×›×™ ×–×•×œ') || lowerMessage.includes('×”×›×™ ×™×§×¨') || lowerMessage.includes('×”×©×•×•××”')) {
                console.log('ğŸ” Cheapest/expensive search triggered:', lowerMessage);
                
                // Determine what product they're looking for
                let searchKeyword = '';
                if (lowerMessage.includes('×©×¢×•×Ÿ') || lowerMessage.includes('×©×¢×•× ×™×')) searchKeyword = '×©×¢×•×Ÿ';
                else if (lowerMessage.includes('×¦×¢×¦×•×¢') || lowerMessage.includes('×¦×¢×¦×•×¢×™×')) searchKeyword = '×¦×¢×¦×•×¢';
                else if (lowerMessage.includes('×œ×§')) searchKeyword = '×œ×§';
                else if (lowerMessage.includes('×ª×›×©×™×˜') || lowerMessage.includes('×ª×›×©×™×˜×™×')) searchKeyword = '×ª×›×©×™×˜';
                else if (lastSearchContext) searchKeyword = lastSearchContext;
                else searchKeyword = '××•×¦×¨';
                
                console.log('ğŸ” Search keyword for comparison:', searchKeyword);
                
                // Find all relevant pages
                let relevantPages = allPages.filter(page => {
                    if (searchKeyword === '××•×¦×¨') {
                        return page.pageType === 'store';
                    }
                    
                    const titleLower = page.title.toLowerCase();
                    const descLower = (page.description || '').toLowerCase();
                    const pluralKeyword = searchKeyword + '×™×';
                    
                    const hasKeywordInTitle = titleLower.includes(searchKeyword) || titleLower.includes(pluralKeyword);
                    const hasKeywordInDesc = descLower.includes(searchKeyword) || descLower.includes(pluralKeyword);
                    
                    let hasKeywordInProducts = false;
                    if (page.products && page.products.length > 0) {
                        hasKeywordInProducts = page.products.some(product => 
                            product.name.toLowerCase().includes(searchKeyword) || 
                            product.name.toLowerCase().includes(pluralKeyword)
                        );
                    }
                    
                    // Search in all page types, not just stores
                    return (hasKeywordInTitle || hasKeywordInDesc || hasKeywordInProducts);
                });
                
                if (relevantPages.length > 0) {
                    // Collect all products from all relevant pages
                    let allProducts = [];
                    
                    for (const page of relevantPages) {
                        if (page.products && page.products.length > 0) {
                            // Use existing products data
                            page.products.forEach(product => {
                                allProducts.push({
                                    ...product,
                                    pageTitle: page.title,
                                    pageUrl: `/users/${page.userId}/${page.pageId}_html`
                                });
                            });
                        } else {
                            // Extract products from page content
                            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                            const productInfo = await extractProductInfo(page.description, searchKeyword, pageUrl);
                            
                            if (productInfo && productInfo.prices && productInfo.prices.length > 0) {
                                productInfo.prices.forEach((price, index) => {
                                    const name = productInfo.names && productInfo.names[index] 
                                        ? productInfo.names[index] 
                                        : `${searchKeyword} ${index + 1}`;
                                    
                                    allProducts.push({
                                        name: name,
                                        price: price,
                                        pageTitle: page.title,
                                        pageUrl: pageUrl
                                    });
                                });
                            }
                        }
                    }
                    
                    if (allProducts.length > 0) {
                        // Sort by price
                        allProducts.sort((a, b) => {
                            const priceA = parseInt(a.price.replace(',', ''));
                            const priceB = parseInt(b.price.replace(',', ''));
                            return priceA - priceB;
                        });
                        
                        const cheapest = allProducts[0];
                        const mostExpensive = allProducts[allProducts.length - 1];
                        
                        let response = `ğŸ† **${searchKeyword === '××•×¦×¨' ? '×”×©×•×•××ª ××—×™×¨×™×' : `×”×©×•×•××ª ××—×™×¨×™× ×¢×‘×•×¨ ${searchKeyword}`}:**\n\n`;
                        
                        if (lowerMessage.includes('×”×›×™ ×–×•×œ')) {
                            response += `ğŸ¥‡ **×”×›×™ ×–×•×œ ×‘××¨×§×˜:**\n`;
                            response += `â€¢ **${cheapest.name}** - â‚ª${cheapest.price}\n`;
                            response += `ğŸ“ **×:** ${cheapest.pageTitle}\n`;
                            response += `ğŸ”— [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${cheapest.pageUrl})\n\n`;
                        } else if (lowerMessage.includes('×”×›×™ ×™×§×¨')) {
                            response += `ğŸ’ **×”×›×™ ×™×§×¨ ×‘××¨×§×˜:**\n`;
                            response += `â€¢ **${mostExpensive.name}** - â‚ª${mostExpensive.price}\n`;
                            response += `ğŸ“ **×:** ${mostExpensive.pageTitle}\n`;
                            response += `ğŸ”— [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${mostExpensive.pageUrl})\n\n`;
                        } else {
                            response += `ğŸ¥‡ **×”×›×™ ×–×•×œ:** ${cheapest.name} - â‚ª${cheapest.price} (${cheapest.pageTitle})\n`;
                            response += `ğŸ’ **×”×›×™ ×™×§×¨:** ${mostExpensive.name} - â‚ª${mostExpensive.price} (${mostExpensive.pageTitle})\n\n`;
                        }
                        
                        response += `ğŸ“Š **×¡×”"×› ${allProducts.length} ××•×¦×¨×™× ×-${relevantPages.length} ×—× ×•×™×•×ª**\n`;
                        response += `ğŸ’° **×˜×•×•×— ××—×™×¨×™×:** â‚ª${cheapest.price} - â‚ª${mostExpensive.price}\n`;
                        
                        // Add page preview after comparison
                        if (lowerMessage.includes('×”×›×™ ×–×•×œ')) {
                            response += `\n\nğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ×”×“×£ ×”×–×•×œ ×‘×™×•×ª×¨:**\n`;
                            response += `![${cheapest.pageTitle}](${cheapest.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>ğŸ“± ×ª×¦×•×’×” ××§×“×™××”: ${cheapest.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${cheapest.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        } else if (lowerMessage.includes('×”×›×™ ×™×§×¨')) {
                            response += `\n\nğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ×”×“×£ ×”×™×§×¨ ×‘×™×•×ª×¨:**\n`;
                            response += `![${mostExpensive.pageTitle}](${mostExpensive.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>ğŸ“± ×ª×¦×•×’×” ××§×“×™××”: ${mostExpensive.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${mostExpensive.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        } else {
                            response += `\n\nğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ×”×“×£ ×”×–×•×œ ×‘×™×•×ª×¨:**\n`;
                            response += `![${cheapest.pageTitle}](${cheapest.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>ğŸ“± ×ª×¦×•×’×” ××§×“×™××”: ${cheapest.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${cheapest.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        }
                        
                        return response;
                    }
                }
                
                return `âŒ **×œ× ××¦××ª×™ ××•×¦×¨×™× ×œ×”×©×•×•××” ×‘××¢×¨×›×ª ×©×œ× ×•.**\n\nğŸ’¡ **××” ×©×™×© ×œ× ×•:**\n${allPages.slice(0, 4).map(page => `â€¢ ${page.title} - ${page.pageType === 'store' ? '×—× ×•×ª' : page.pageType === 'course' ? '×§×•×¨×¡' : page.pageType === 'event' ? '××™×¨×•×¢' : '×©×™×¨×•×ª'}`).join('\n')}\n\nğŸ” **× ×¡×”:** "××—×™×¨×™×" ××• "××” ×™×© ×œ×›×"`;
            }
            
            
            
            // Price search - look for specific products
            if (lowerMessage.includes('××—×™×¨') || lowerMessage.includes('×›××”') || lowerMessage.includes('×¢×•×œ×”') || lowerMessage.includes('â‚ª') || lowerMessage.includes('×©×§×œ')) {
                console.log('ğŸ’° Price search triggered:', lowerMessage);
                
                // Determine what product they're looking for
                let searchKeyword = '';
                if (lowerMessage.includes('×©×¢×•×Ÿ') || lowerMessage.includes('×©×¢×•× ×™×')) {
                    searchKeyword = '×©×¢×•×Ÿ';
                    console.log('ğŸ” Detected watch search');
                }
                else if (lowerMessage.includes('×œ×§')) searchKeyword = '×œ×§';
                else if (lowerMessage.includes('×¦×¢×¦×•×¢') || lowerMessage.includes('×¦×¢×¦×•×¢×™×')) searchKeyword = '×¦×¢×¦×•×¢';
                else if (lowerMessage.includes('×ª×›×©×™×˜') || lowerMessage.includes('×ª×›×©×™×˜×™×')) searchKeyword = '×ª×›×©×™×˜';
                else if (lastSearchContext) {
                    searchKeyword = lastSearchContext;
                    console.log('ğŸ” Using last search context:', lastSearchContext);
                }
                else if (lastSearchResults.length > 0) {
                    // Use last search results if available
                    relevantPages = lastSearchResults;
                    searchKeyword = lastSearchContext || '××•×¦×¨';
                    console.log('ğŸ” Using last search results:', relevantPages.length, 'pages');
                }
                else searchKeyword = '××•×¦×¨';
                
                console.log('ğŸ” Final search keyword:', searchKeyword);
                
                // Filter pages by specific keyword if mentioned - STRICT FILTERING
                let relevantPages = [];
                
                // Only search if we don't have results from previous search
                if (lastSearchResults.length === 0) {
                    relevantPages = allPages.filter(page => {
                    if (searchKeyword === '××•×¦×¨') {
                        return page.pageType === 'store';
                    }
                    
                    const titleLower = page.title.toLowerCase();
                    const descLower = (page.description || '').toLowerCase();
                    
                    // Check for both singular and plural forms
                    const pluralKeyword = searchKeyword + '×™×'; // e.g., ×©×¢×•×Ÿ -> ×©×¢×•× ×™×
                    
                    // Only show pages that actually contain the keyword in title OR description OR products (singular or plural)
                    const hasKeywordInTitle = titleLower.includes(searchKeyword) || titleLower.includes(pluralKeyword);
                    const hasKeywordInDesc = descLower.includes(searchKeyword) || descLower.includes(pluralKeyword);
                    
                    // Check if keyword exists in any product name
                    let hasKeywordInProducts = false;
                    if (page.products && page.products.length > 0) {
                        hasKeywordInProducts = page.products.some(product => 
                            product.name.toLowerCase().includes(searchKeyword) || 
                            product.name.toLowerCase().includes(pluralKeyword)
                        );
                    }
                    
                    // Search in all page types, not just stores
                    const matches = (hasKeywordInTitle || hasKeywordInDesc || hasKeywordInProducts);
                    
                    if (matches) {
                        console.log('âœ… Found matching page:', page.title, '(searching for:', searchKeyword, 'or', pluralKeyword + ')');
                    }
                    
                    return matches;
                    });
                } else {
                    // Use previous search results
                    relevantPages = lastSearchResults;
                }
                
                // If no specific keyword found, show all stores
                if (relevantPages.length === 0 && searchKeyword === '××•×¦×¨') {
                    relevantPages = allPages.filter(page => page.pageType === 'store');
                }
                
                console.log(`ğŸ” Searching for "${searchKeyword}" - found ${relevantPages.length} pages`);
                
                    if (relevantPages.length > 0) {
                        // Save search results for context
                        lastSearchResults = relevantPages;
                        
                        let response = `ğŸ’° **××—×™×¨×™× ×¢×‘×•×¨ ${searchKeyword}:**\n\n`;
                        
                        // Add smart recommendations before showing prices
                        if (searchKeyword === '××ª× ×”' || searchKeyword === '××ª× ×•×ª') {
                            response += `ğŸ **×”××œ×¦×•×ª ××ª× ×•×ª ××•×©×œ××•×ª:**\n\n`;
                            
                            // Categorize pages by type for better recommendations
                            const storePages = relevantPages.filter(p => p.pageType === 'store');
                            const servicePages = relevantPages.filter(p => p.pageType === 'serviceProvider');
                            const coursePages = relevantPages.filter(p => p.pageType === 'course');
                            const eventPages = relevantPages.filter(p => p.pageType === 'event');
                            
                            if (storePages.length > 0) {
                                response += `ğŸ›ï¸ **××ª× ×•×ª ××—× ×•×™×•×ª:**\n`;
                                storePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `â€¢ **${page.title}** - ××ª× ×•×ª ××™×›×•×ª×™×•×ª! ğŸª\n`;
                                    response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (servicePages.length > 0) {
                                response += `ğŸ’… **××ª× ×•×ª ×—×•×•×™×”:**\n`;
                                servicePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `â€¢ **${page.title}** - ×—×•×•×™×” ××¤× ×§×ª! ğŸ’…\n`;
                                    response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (coursePages.length > 0) {
                                response += `ğŸ“ **××ª× ×•×ª ×”×¢×©×¨×”:**\n`;
                                coursePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `â€¢ **${page.title}** - ××ª× ×” ×©×ª×©× ×” ×—×™×™×! ğŸ“\n`;
                                    response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (eventPages.length > 0) {
                                response += `ğŸ‰ **××ª× ×•×ª ××™×¨×•×¢×™×:**\n`;
                                eventPages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `â€¢ **${page.title}** - ×—×•×•×™×” ×‘×œ×ª×™ × ×©×›×—×ª! ğŸ‰\n`;
                                    response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            response += `ğŸ’¡ **×˜×™×¤:** ×œ×›×œ ××ª× ×” ×™×© ××—×™×¨×™× ×©×•× ×™× - ×›×ª×•×‘ "××—×™×¨×™×" ×›×“×™ ×œ×¨××•×ª ××ª ×›×œ ×”××—×™×¨×™×!\n\n`;
                        }
                        
                        for (const page of relevantPages.slice(0, 3)) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        
                        response += `â€¢ **${page.title}** ğŸª\n`;
                        response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                        
                        // Use products from metadata if available - ENHANCED PRODUCT INFO
                        if (page.products && page.products.length > 0) {
                            response += `\n  **ğŸ›ï¸ ××•×¦×¨×™× ×–××™× ×™×:**\n`;
                            
                            // Sort products by price for better recommendations
                            const sortedProducts = [...page.products].sort((a, b) => 
                                parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                            );
                            
                            sortedProducts.slice(0, 5).forEach((product, index) => {
                                const price = parseInt(product.price.replace(',', ''));
                                let priceEmoji = 'ğŸ’°';
                                if (price < 100) priceEmoji = 'ğŸ’š';
                                else if (price < 500) priceEmoji = 'ğŸ’›';
                                else if (price < 1000) priceEmoji = 'ğŸ§¡';
                                else priceEmoji = 'â¤ï¸';
                                
                                response += `  ${priceEmoji} **${product.name}** - â‚ª${product.price}`;
                                
                                // Add availability status
                                if (index === 0) response += ` â­ **×”×›×™ ×–×•×œ!**`;
                                if (index === sortedProducts.length - 1) response += ` ğŸ’ **×¤×¨×™××™×•×**`;
                                
                                response += `\n`;
                            });
                            
                            // Smart recommendations based on user intent
                            if (lowerMessage.includes('×–×•×œ') || lowerMessage.includes('×”×›×™ ×–×•×œ')) {
                                const cheapest = sortedProducts[0];
                                response += `\n  ğŸ¯ **×”××œ×¦×” ×—×›××”:** ${cheapest.name} - ×”×›×™ ××©×ª×œ×! â‚ª${cheapest.price}\n`;
                            } else if (lowerMessage.includes('×™×§×¨') || lowerMessage.includes('×™×•×§×¨×”')) {
                                const mostExpensive = sortedProducts[sortedProducts.length - 1];
                                response += `\n  ğŸ’ **×”××œ×¦×” ×™×•×§×¨×”:** ${mostExpensive.name} - ×”×›×™ ××™×›×•×ª×™! â‚ª${mostExpensive.price}\n`;
                            } else if (lowerMessage.includes('××ª× ×”') || lowerMessage.includes('××ª× ×ª')) {
                                const midRange = sortedProducts[Math.floor(sortedProducts.length / 2)];
                                response += `\n  ğŸ **××ª× ×” ××•×©×œ××ª:** ${midRange.name} - ××™×–×•×Ÿ ××•×©×œ×! â‚ª${midRange.price}\n`;
                            }
                            
                            // Add total products count
                            if (page.products.length > 5) {
                                response += `\n  ğŸ“Š **×¡×”"×› ${page.products.length} ××•×¦×¨×™× ×–××™× ×™×** - [ğŸ‘ï¸ ×¦×¤×” ×‘×›×•×œ×](${pageUrl})\n`;
                            }
                            
                            response += `\n`;
                        } else {
                            // Try to extract real data from the page
                            const productInfo = await extractProductInfo(page.description, searchKeyword, pageUrl);
                            
                            if (productInfo) {
                                if (productInfo.prices && productInfo.prices.length > 0) {
                                    response += `\n  **ğŸ’° ××—×™×¨×™× ×–××™× ×™×:**\n`;
                                    productInfo.prices.forEach((price, index) => {
                                        const priceNum = parseFloat(price.replace(',', ''));
                                        let priceEmoji = 'ğŸ’°';
                                        if (priceNum < 100) priceEmoji = 'ğŸ’š';
                                        else if (priceNum < 500) priceEmoji = 'ğŸ’›';
                                        else if (priceNum < 1000) priceEmoji = 'ğŸ§¡';
                                        else priceEmoji = 'â¤ï¸';
                                        
                                        response += `  ${priceEmoji} **â‚ª${price}**\n`;
                                    });
                                }
                                
                                if (productInfo.names && productInfo.names.length > 0) {
                                    response += `\n  **ğŸ·ï¸ ×©×™×¨×•×ª×™×/××•×¦×¨×™×:**\n`;
                                    productInfo.names.forEach(name => {
                                        response += `  â€¢ ${name}\n`;
                                    });
                                }
                                
                                if (productInfo.location) {
                                    response += `\n  ğŸ“ **××™×§×•×:** ${productInfo.location}\n`;
                                }
                                
                                if (productInfo.descriptions && productInfo.descriptions.length > 0) {
                                    response += `\n  **ğŸ“ ×ª×™××•×¨×™×:**\n`;
                                    productInfo.descriptions.slice(0, 3).forEach(desc => {
                                        response += `  â€¢ ${desc.substring(0, 100)}...\n`;
                                    });
                                }
                            } else {
                                response += `  ğŸ’¡ **×˜×™×¤:** ×œ×—×¥ ×¢×œ ×”×§×™×©×•×¨ ×›×“×™ ×œ×¨××•×ª ××—×™×¨×™× ××“×•×™×§×™×!\n`;
                            }
                        }
                        
                        response += `\n`;
                    }
                    
                    if (searchKeyword !== '××•×¦×¨') {
                        response += `ğŸ” **×¨×•×¦×” ×—×™×¤×•×© ×¡×¤×¦×™×¤×™?** ×›×ª×•×‘ "×©×¢×•×Ÿ" ××• "×ª×›×©×™×˜" ×•×× ×™ ××—×¤×© ×¢×‘×•×¨×š!`;
                    }
                    
                    // Add page preview after recommendations
                    if (relevantPages.length > 0) {
                        const firstPage = relevantPages[0];
                        const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                        response += `\n\nğŸ“± **×ª×¦×•×’×” ××§×“×™××”:**\n`;
                        response += `![${firstPage.title}](${pageUrl})\n`;
                        
                        // Add delay and then show preview
                        setTimeout(() => {
                            const chatContainer = document.querySelector('.ai-chat-messages');
                            if (chatContainer) {
                                const previewDiv = document.createElement('div');
                                previewDiv.className = 'page-preview';
                                previewDiv.innerHTML = `
                                    <div class="preview-header">
                                        <h3>ğŸ“± ×ª×¦×•×’×” ××§×“×™××”: ${firstPage.title}</h3>
                                    </div>
                                    <div class="preview-content">
                                        <iframe src="${pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                    </div>
                                `;
                                chatContainer.appendChild(previewDiv);
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                                
                                // Add animation
                                previewDiv.style.opacity = '0';
                                previewDiv.style.transform = 'translateY(20px)';
                                setTimeout(() => {
                                    previewDiv.style.transition = 'all 0.5s ease';
                                    previewDiv.style.opacity = '1';
                                    previewDiv.style.transform = 'translateY(0)';
                                }, 100);
                            }
                        }, 2000); // Wait 2 seconds before showing preview
                    }
                    
                    // Send to N8N for smart response with real data
                    const contextText = `×”××©×ª××© ×©××œ ×¢×œ ${searchKeyword}. ×”× ×” ×”× ×ª×•× ×™× ×”×××™×ª×™×™× ××”××¢×¨×›×ª:
${relevantPages.map(page => {
    let pageInfo = `×“×£: ${page.title}\n`;
    if (page.products && page.products.length > 0) {
        pageInfo += `××•×¦×¨×™×:\n`;
        page.products.forEach(product => {
            pageInfo += `- ${product.name}: â‚ª${product.price}\n`;
        });
    }
    return pageInfo;
}).join('\n')}

×ª×Ÿ ×”××œ×¦×” ×—×›××” ××‘×•×¡×¡×ª ×¢×œ ×”× ×ª×•× ×™× ×”×××™×ª×™×™× ×”××œ×”.`;
                    
                    try {
                        const n8nResponse = await fetch('https://n8n-service-how4.onrender.com/webhook/jhfuhgufkhlkuho8erhf757754jhldkbsjkbmreketpg', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                message: userMessage,
                                context: contextText
                            })
                        });
                        
                        if (n8nResponse.ok) {
                            const n8nData = await n8nResponse.json();
                            if (n8nData.response) {
                                return {
                                    message: n8nData.response,
                                    action: { type: 'none' }
                                };
                            }
                        }
                    } catch (error) {
                        console.log('N8N error:', error);
                    }
                    
                    return {
                        message: response,
                        action: { type: 'none' }
                    };
                } else {
                    // No relevant pages found - be honest
                    return {
                        message: `âŒ **×œ× ××¦××ª×™ ×“×¤×™× ×¢× "${searchKeyword}" ×‘××¢×¨×›×ª ×©×œ× ×•.**\n\nğŸ’¡ **××” ×©×™×© ×œ× ×•:**\nâ€¢ red - ×—× ×•×ª ×©×¢×•× ×™×\nâ€¢ ×™× ×™×‘ ×¦×¢×¦×•×¢ AI - ×¢×•×œ× ×”×¦×¢×¦×•×¢×™× ×”×—×›×\nâ€¢ ×™× ×™×‘ ×¦×¢×¦×•×¢ - ×¦×¢×¦×•×¢×™× ×œ×™×œ×“×™×\nâ€¢ ×™× ×™×‘ ×ª×›×©×™×˜×™× - ×ª×›×©×™×˜×™ ×™×•×§×¨×”\n\nğŸ” **× ×¡×”:** "××—×™×¨×™×" ××• "××” ×™×© ×œ×›×"`,
                        action: { type: 'none' }
                    };
                }
            }
            
            
            // Check for specific keywords and search
            const keywords = {
                '××ª× ×”': 'store',
                '××ª× ×•×ª': 'store',
                '×œ×§': 'serviceProvider',
                '×× ×™×§×•×¨': 'serviceProvider', 
                '×¤×“×™×§×•×¨': 'serviceProvider',
                '×¦×¢×¦×•×¢': 'store',
                '×™×œ×“': 'store',
                '×—× ×•×ª': 'store',
                '×§×•×¨×¡': 'course',
                '×œ×™××•×“': 'course',
                '××™×¨×•×¢': 'event',
                '×—×ª×•× ×”': 'event',
                '×©×¢×•×Ÿ': 'store',
                '×©×¢×•× ×™×': 'store',
                '×ª×›×©×™×˜': 'store',
                '×ª×›×©×™×˜×™×': 'store',
                '×–×”×‘': 'store',
                '×›×¡×£': 'store',
                '×™×”×œ×•×': 'store',
                '×™×”×œ×•××™×': 'store',
                '×¢×’×™×œ': 'store',
                '×¢×’×™×œ×™×': 'store',
                '×¦××™×“': 'store',
                '×¦××™×“×™×': 'store',
                '×©×¨×©×¨×ª': 'store',
                '×©×¨×©×¨××•×ª': 'store',
                '×˜×‘×¢×ª': 'store',
                '×˜×‘×¢×•×ª': 'store'
            };
            
            // Check for specific needs and provide focused recommendations
            const specificNeeds = {
                '×–×•×œ': { type: 'price', focus: 'cheapest' },
                '×™×§×¨': { type: 'price', focus: 'expensive' },
                '××ª× ×” ×œ×™×œ×“': { type: 'gift', focus: 'child' },
                '××ª× ×” ×œ××™×©×”': { type: 'gift', focus: 'woman' },
                '××ª× ×” ×œ×’×‘×¨': { type: 'gift', focus: 'man' },
                '××ª× ×” ×œ×–×•×’': { type: 'gift', focus: 'couple' },
                '××ª× ×” ×œ×™×•× ×”×•×œ×“×ª': { type: 'gift', focus: 'birthday' },
                '××ª× ×” ×œ×—×’': { type: 'gift', focus: 'holiday' },
                '××ª× ×” ××™×•×—×“×ª': { type: 'gift', focus: 'special' },
                '××ª×œ×‘×˜': { type: 'help', focus: 'undecided' },
                '×œ× ×™×•×“×¢': { type: 'help', focus: 'undecided' },
                '××” ×œ×‘×—×•×¨': { type: 'help', focus: 'undecided' },
                '××™×–×”': { type: 'help', focus: 'choice' },
                '××™×š ×œ×‘×—×•×¨': { type: 'help', focus: 'choice' }
            };
            
            // Smart keyword matching - find related words
            const smartKeywords = {
                '××ª× ×”': ['××ª× ×”', '××ª× ×•×ª', '××ª× ×ª', '××ª× ×•×ª', '××ª× ×” ×œ', '××ª× ×” ×œ×™×œ×“', '××ª× ×” ×œ××™×©×”', '××ª× ×” ×œ×’×‘×¨', '××ª× ×” ×œ×™×•× ×”×•×œ×“×ª', '××ª× ×” ×œ×—×’', '××ª× ×” ××™×•×—×“×ª'],
                '×©×¢×•×Ÿ': ['×©×¢×•×Ÿ', '×©×¢×•× ×™×', '×–××Ÿ', '×–×× ×™×', '×™×“', '×™×“×™×™×', '××‘×•×’×¨', '××‘×•×’×¨×™×', '×§×œ××¡×™', '×¡×¤×•×¨×˜', '×™×•×§×¨×”', '×¡×××¨×˜'],
                '×ª×›×©×™×˜': ['×ª×›×©×™×˜', '×ª×›×©×™×˜×™×', '×–×”×‘', '×›×¡×£', '×™×”×œ×•×', '×™×”×œ×•××™×', '×¢×’×™×œ', '×¢×’×™×œ×™×', '×¦××™×“', '×¦××™×“×™×', '×©×¨×©×¨×ª', '×©×¨×©×¨××•×ª', '×˜×‘×¢×ª', '×˜×‘×¢×•×ª'],
                '×¦×¢×¦×•×¢': ['×¦×¢×¦×•×¢', '×¦×¢×¦×•×¢×™×', '×™×œ×“', '×™×œ×“×™×', '××©×—×§', '××©×—×§×™×', '×‘×•×‘×”', '×‘×•×‘×•×ª', '×¨×›×‘', '××›×•× ×™×ª'],
                '×œ×§': ['×œ×§', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '×¦×™×¤×•×¨× ×™×™×', '×™×•×¤×™', '×™×•×¤×™', '×¡×¤×', '×˜×™×¤×•×—'],
                '×§×•×¨×¡': ['×§×•×¨×¡', '×§×•×¨×¡×™×', '×œ×™××•×“', '×œ×™××•×“×™×', '×”×“×¨×›×”', '×”×“×¨×›×•×ª', '×¡××™× ×¨', '×¡××™× ×¨×™×']
            };
            
            // Check for specific needs first - DISABLED TO PREVENT INVENTING
            let specificNeed = null;
            // for (const [need, config] of Object.entries(specificNeeds)) {
            //     if (lowerMessage.includes(need)) {
            //         specificNeed = config;
            //         break;
            //     }
            // }
            
            // Smart search - check for any related keywords
            for (const [mainKeyword, relatedWords] of Object.entries(smartKeywords)) {
                const hasRelatedWord = relatedWords.some(word => lowerMessage.includes(word));
                if (hasRelatedWord) {
                    const type = keywords[mainKeyword] || 'store';
                    
                    // Remember search context for future price queries
                    lastSearchContext = mainKeyword;
                    
                    // More precise search - look in title and description with better matching
                    let matchingPages = allPages.filter(page => {
                        const titleLower = page.title.toLowerCase();
                        const descLower = (page.description || '').toLowerCase();
                        
                        // Check if any related word appears in title or description
                        const titleMatch = relatedWords.some(word => titleLower.includes(word));
                        const descMatch = relatedWords.some(word => descLower.includes(word));
                        
                        // Also check for partial matches and synonyms
                        const partialMatch = relatedWords.some(word => {
                            const wordParts = word.split(' ');
                            return wordParts.some(part => 
                                titleLower.includes(part) || descLower.includes(part)
                            );
                        });
                        
                        return page.pageType === type && (titleMatch || descMatch || partialMatch);
                    });
                    
                    // DISABLED - No more inventing recommendations
                    // Apply specific filtering based on user needs
                    // if (specificNeed) { ... }
                    
                    console.log(`ğŸ” Searching for "${mainKeyword}" in type "${type}"`, { matchingPages: matchingPages.length, allPages: allPages.length });
                    
                    if (matchingPages.length > 0) {
                        let response = '';
                        
                        // Simple response - no more inventing
                        response = `ğŸ¯ **××¦××ª×™ ${matchingPages.length} ×“×¤×™× ×¨×œ×•×•× ×˜×™×™× ×œ"${mainKeyword}":**\n\n`;
                        
                        // Add smart recommendations for gifts
                        if (mainKeyword === '××ª× ×”' || mainKeyword === '××ª× ×•×ª') {
                            response += `ğŸ **××ª× ×•×ª ××•×©×œ××•×ª! ×‘×•××• × ××¦× ××ª ×”××ª× ×” ×”××•×©×œ××ª:**\n\n`;
                            
                            // Show specific products with prices for children
                            if (lowerMessage.includes('×™×œ×“') || lowerMessage.includes('×™×œ×“×™×') || lowerMessage.includes('×™×œ×“×”') || lowerMessage.includes('×™×œ×“×•×ª')) {
                                response += `ğŸ‘¶ **××ª× ×•×ª ××•×©×œ××•×ª ×œ×™×œ×“×™× - ×”× ×” ×”××œ×¦×” ×¡×¤×¦×™×¤×™×ª:**\n\n`;
                                
                                // Find toy pages specifically - exclude services
                                const toyPages = matchingPages.filter(p => 
                                    p.pageType === 'store' && 
                                    p.pageType !== 'serviceProvider' &&
                                    (p.title.toLowerCase().includes('×¦×¢×¦×•×¢') || 
                                     p.title.toLowerCase().includes('toy') ||
                                     p.description?.toLowerCase().includes('×¦×¢×¦×•×¢') ||
                                     p.title.toLowerCase().includes('××©×—×§') ||
                                     p.description?.toLowerCase().includes('××©×—×§') ||
                                     p.title.toLowerCase().includes('×‘×•×‘×”') ||
                                     p.description?.toLowerCase().includes('×‘×•×‘×”') ||
                                     p.title.toLowerCase().includes('×¨×›×‘') ||
                                     p.description?.toLowerCase().includes('×¨×›×‘') ||
                                     p.title.toLowerCase().includes('×™× ×™×‘') ||
                                     p.description?.toLowerCase().includes('×™×œ×“×™×') ||
                                     p.description?.toLowerCase().includes('×™×œ×“')) &&
                                    !p.title.toLowerCase().includes('×œ×§') &&
                                    !p.title.toLowerCase().includes('×’×œ') &&
                                    !p.title.toLowerCase().includes('×©×¢×•×Ÿ') &&
                                    !p.title.toLowerCase().includes('×ª×›×©×™×˜')
                                );
                                
                                if (toyPages.length > 0) {
                                    // Show ONLY ONE specific product with price
                                    const firstPage = toyPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `ğŸ§¸ **${firstPage.title}**\n`;
                                    
                                    // Try to get real product info - only show if we have real data
                                    if (firstPage.products && firstPage.products.length > 0) {
                                        const sortedProducts = [...firstPage.products].sort((a, b) => 
                                            parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                                        );
                                        
                                        // Show only the cheapest product as recommendation
                                        const cheapestProduct = sortedProducts[0];
                                        const price = parseInt(cheapestProduct.price.replace(',', ''));
                                        let priceEmoji = 'ğŸ’°';
                                        if (price < 100) priceEmoji = 'ğŸ’š';
                                        else if (price < 500) priceEmoji = 'ğŸ’›';
                                        else if (price < 1000) priceEmoji = 'ğŸ§¡';
                                        else priceEmoji = 'â¤ï¸';
                                        
                                        response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                        response += `  ${priceEmoji} **${cheapestProduct.name}** - â‚ª${cheapestProduct.price} â­ **×”×›×™ ×–×•×œ!**\n`;
                                        response += `  ğŸ“Š **×¡×”"×› ${sortedProducts.length} ××•×¦×¨×™× ×–××™× ×™×**\n`;
                                    } else if (firstPage.description) {
                                        // Try to extract product info from description
                                        const productInfo = await extractProductInfo(firstPage.description, '×¦×¢×¦×•×¢', pageUrl);
                                        if (productInfo && productInfo.price) {
                                            response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                            response += `  ğŸ’° **${productInfo.name || '×¦×¢×¦×•×¢ ××™×•×—×“'}** - ${productInfo.price}\n`;
                                        } else {
                                            response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                            response += `  ğŸ§¸ **×¦×¢×¦×•×¢×™× ×—×›××™× ×•××”× ×™×** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                        }
                                    } else {
                                        response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                        response += `  ğŸ§¸ **×¦×¢×¦×•×¢×™× ×—×›××™× ×•××”× ×™×** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                    }
                                    
                                    response += `ğŸª **×—× ×•×ª:** ${firstPage.title}\n`;
                                    response += `ğŸ”— [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n\n`;
                                    
                                    response += `ğŸ’¡ **×¨×•×¦×” ×œ×¨××•×ª ×¢×•×“?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×”×›×™ ×–×•×œ"!\n\n`;
                                    
                                    // Add iframe preview after recommendations
                                    response += `ğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                } else {
                                    // Fallback to general pages
                                    response += `ğŸ¯ **×”××œ×¦×•×ª ×›×œ×œ×™×•×ª ×œ×™×œ×“×™×:**\n`;
                                    matchingPages.slice(0, 2).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `â€¢ **${page.title}** - ××ª× ×” ××•×©×œ××ª! ğŸ\n`;
                                        response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                    });
                                }
                                
                            } else if (lowerMessage.includes('××™×©×”') || lowerMessage.includes('× ×©×™×') || lowerMessage.includes('××™×©×”') || lowerMessage.includes('× ×©×™×')) {
                                response += `ğŸ‘© **××ª× ×•×ª ××•×©×œ××•×ª ×œ× ×©×™× - ×”× ×” ×”××œ×¦×•×ª ×¡×¤×¦×™×¤×™×•×ª:**\n\n`;
                                
                                // Find beauty/service pages
                                const beautyPages = matchingPages.filter(p => 
                                    p.pageType === 'serviceProvider' || 
                                    (p.title.toLowerCase().includes('×œ×§') || 
                                     p.title.toLowerCase().includes('×’×œ') ||
                                     p.title.toLowerCase().includes('×™×•×¤×™') ||
                                     p.title.toLowerCase().includes('×©×™×¢×¨') ||
                                     p.title.toLowerCase().includes('×¢×™×¦×•×‘') ||
                                     p.title.toLowerCase().includes('×—×’×™×ª') ||
                                     p.title.toLowerCase().includes('× ×™×™×œ×¡') ||
                                     p.description?.toLowerCase().includes('×™×•×¤×™') ||
                                     p.description?.toLowerCase().includes('×©×™×¢×¨') ||
                                     p.description?.toLowerCase().includes('×œ×§') ||
                                     p.description?.toLowerCase().includes('×’×œ'))
                                );
                                
                                if (beautyPages.length > 0) {
                                    // Show specific services with prices
                                    for (const page of beautyPages.slice(0, 2)) {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `ğŸ’… **${page.title}**\n`;
                                        
                                        // Try to extract service info
                                        if (page.description) {
                                            const serviceInfo = await extractProductInfo(page.description, '×œ×§', pageUrl);
                                            if (serviceInfo && serviceInfo.price) {
                                                response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™:**\n`;
                                                response += `  ğŸ’° **${serviceInfo.name || '×©×™×¨×•×ª ×™×•×¤×™'}** - ${serviceInfo.price}\n`;
                                            } else {
                                                response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™:**\n`;
                                                response += `  ğŸ’… **×©×™×¨×•×ª×™ ×™×•×¤×™ ××¤× ×§×™×** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                            }
                                        } else {
                                            response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™:**\n`;
                                            response += `  ğŸ’… **×©×™×¨×•×ª×™ ×™×•×¤×™ ××¤× ×§×™×** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                        }
                                        
                                        response += `ğŸª **×—× ×•×ª:** ${page.title}\n`;
                                        response += `ğŸ”— [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n\n`;
                                    }
                                } else {
                                    // Fallback to general pages
                                    response += `ğŸ¯ **×”××œ×¦×•×ª ×›×œ×œ×™×•×ª ×œ× ×©×™×:**\n`;
                                    matchingPages.slice(0, 2).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `â€¢ **${page.title}** - ××ª× ×” ××•×©×œ××ª! ğŸ\n`;
                                        response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                    });
                                }
                                
                                response += `ğŸ’¡ **×¨×•×¦×” ×œ×¨××•×ª ×¢×•×“?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×”×›×™ ×–×•×œ"!\n\n`;
                                
                            } else if (lowerMessage.includes('×’×‘×¨') || lowerMessage.includes('×’×‘×¨×™×') || lowerMessage.includes('××‘') || lowerMessage.includes('××‘×')) {
                                response += `ğŸ‘¨ **××ª× ×•×ª ××•×©×œ××•×ª ×œ×’×‘×¨×™× - ×”× ×” ×”××œ×¦×” ×¡×¤×¦×™×¤×™×ª:**\n\n`;
                                
                                // Find tech/accessory pages
                                const techPages = matchingPages.filter(p => 
                                    p.pageType === 'store' && 
                                    (p.title.toLowerCase().includes('×˜×›× ×•×œ×•×’×™×”') || 
                                     p.title.toLowerCase().includes('×©×¢×•×Ÿ') ||
                                     p.title.toLowerCase().includes('×ª×›×©×™×˜') ||
                                     p.title.toLowerCase().includes('×’××“×’\'×˜') ||
                                     p.title.toLowerCase().includes('×¨×•×‘×•×˜') ||
                                     p.title.toLowerCase().includes('red') ||
                                     p.title.toLowerCase().includes('×¦×™×¤×™') ||
                                     p.description?.toLowerCase().includes('×©×¢×•×Ÿ') ||
                                     p.description?.toLowerCase().includes('×ª×›×©×™×˜') ||
                                     p.description?.toLowerCase().includes('×¨×•×‘×•×˜') ||
                                     p.description?.toLowerCase().includes('×˜×›× ×•×œ×•×’×™×”'))
                                );
                                
                                if (techPages.length > 0) {
                                    // Show ONLY ONE specific product with price
                                    const firstPage = techPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    response += `âŒš **${firstPage.title}**\n`;
                                    
                                    // Try to get real product info - only show if we have real data
                                    if (firstPage.products && firstPage.products.length > 0) {
                                        const sortedProducts = [...firstPage.products].sort((a, b) => 
                                            parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                                        );
                                        
                                        // Show only the cheapest product as recommendation
                                        const cheapestProduct = sortedProducts[0];
                                        const price = parseInt(cheapestProduct.price.replace(',', ''));
                                        let priceEmoji = 'ğŸ’°';
                                        if (price < 100) priceEmoji = 'ğŸ’š';
                                        else if (price < 500) priceEmoji = 'ğŸ’›';
                                        else if (price < 1000) priceEmoji = 'ğŸ§¡';
                                        else priceEmoji = 'â¤ï¸';
                                        
                                        response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                        response += `  ${priceEmoji} **${cheapestProduct.name}** - â‚ª${cheapestProduct.price} â­ **×”×›×™ ×–×•×œ!**\n`;
                                        response += `  ğŸ“Š **×¡×”"×› ${sortedProducts.length} ××•×¦×¨×™× ×–××™× ×™×**\n`;
                                    } else if (firstPage.description) {
                                        // Try to extract product info from description
                                        const productInfo = await extractProductInfo(firstPage.description, '×©×¢×•×Ÿ', pageUrl);
                                        if (productInfo && productInfo.price) {
                                            response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                            response += `  ğŸ’° **${productInfo.name || '×’××“×’\'×˜ ××™×•×—×“'}** - ${productInfo.price}\n`;
                                        } else {
                                            response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                            response += `  âŒš **×’××“×’\'×˜×™× ×•×˜×›× ×•×œ×•×’×™×” ××ª×§×“××ª** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                        }
                                    } else {
                                        response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                        response += `  âŒš **×’××“×’\'×˜×™× ×•×˜×›× ×•×œ×•×’×™×” ××ª×§×“××ª** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                    }
                                    
                                    response += `ğŸª **×—× ×•×ª:** ${firstPage.title}\n`;
                                    response += `ğŸ”— [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n\n`;
                                    
                                    response += `ğŸ’¡ **×¨×•×¦×” ×œ×¨××•×ª ×¢×•×“?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×”×›×™ ×–×•×œ"!\n\n`;
                                } else {
                                    // Fallback to general pages
                                    response += `ğŸ¯ **×”××œ×¦×•×ª ×›×œ×œ×™×•×ª ×œ×’×‘×¨×™×:**\n`;
                                    matchingPages.slice(0, 3).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `â€¢ **${page.title}** - ××ª× ×” ××•×©×œ××ª! ğŸ\n`;
                                        response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                    });
                                }
                                
                                response += `ğŸ’¡ **×¨×•×¦×” ×œ×¨××•×ª ×¢×•×“?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×”×›×™ ×–×•×œ"!\n\n`;
                                
                                // Add iframe preview after recommendations
                                if (techPages.length > 0) {
                                    const firstPage = techPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `ğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                    
                                    // Add delayed iframe preview
                                    setTimeout(() => {
                                        const chatContainer = document.querySelector('.ai-chat-messages');
                                        if (chatContainer) {
                                            const previewDiv = document.createElement('div');
                                            previewDiv.className = 'page-preview';
                                            previewDiv.style.cssText = `
                                                margin: 16px 0;
                                                border: 2px solid #e5e7eb;
                                                border-radius: 12px;
                                                overflow: hidden;
                                                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                                                position: relative;
                                                width: 100%;
                                                height: 300px;
                                                opacity: 0;
                                                transform: translateY(20px);
                                                transition: all 0.5s ease;
                                            `;
                                            previewDiv.innerHTML = `
                                                <div class="preview-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                                    <span>ğŸ</span>
                                                    <span>${firstPage.title}</span>
                                                </div>
                                                <div class="preview-content" style="position: relative; height: 276px; overflow: hidden;">
                                                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c);"></div>
                                                    <iframe src="${pageUrl}" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top left; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>
                                                </div>
                                            `;
                                            chatContainer.appendChild(previewDiv);
                                            chatContainer.scrollTop = chatContainer.scrollHeight;
                                            
                                            // Animate in gradually
                                            setTimeout(() => {
                                                previewDiv.style.opacity = '1';
                                                previewDiv.style.transform = 'translateY(0)';
                                            }, 200);
                                        }
                                    }, 2000);
                                }
                                
                            } else {
                                // General gift recommendations - only show real pages
                                response += `ğŸ¯ **××™×–×” ×¡×•×’ ××ª× ×” ××ª× ××—×¤×©×™×?**\n\n`;
                                
                                // Show only real pages from matchingPages
                                if (matchingPages.length > 0) {
                                    response += `ğŸ **×”×“×¤×™× ×”×–××™× ×™× ×‘××¢×¨×›×ª:**\n`;
                                    matchingPages.slice(0, 5).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        const emoji = page.pageType === 'store' ? 'ğŸ›ï¸' : page.pageType === 'event' ? 'ğŸ‰' : page.pageType === 'course' ? 'ğŸ“' : page.pageType === 'serviceProvider' ? 'ğŸ”§' : 'ğŸ“„';
                                        response += `â€¢ **${page.title}** ${emoji} - ${page.description || '××ª× ×” ××•×©×œ××ª'}\n`;
                                        response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                    });
                                    response += `\n`;
                                    
                                    // Add iframe preview for first page
                                    const firstPage = matchingPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `ğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                    
                                    // Add delayed iframe preview
                                    setTimeout(() => {
                                        const chatContainer = document.querySelector('.ai-chat-messages');
                                        if (chatContainer) {
                                            const previewDiv = document.createElement('div');
                                            previewDiv.className = 'page-preview';
                                            previewDiv.style.cssText = `
                                                margin: 16px 0;
                                                border: 2px solid #e5e7eb;
                                                border-radius: 12px;
                                                overflow: hidden;
                                                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                                                position: relative;
                                                width: 100%;
                                                height: 300px;
                                                opacity: 0;
                                                transform: translateY(20px);
                                                transition: all 0.5s ease;
                                            `;
                                            previewDiv.innerHTML = `
                                                <div class="preview-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                                    <span>ğŸ</span>
                                                    <span>${firstPage.title}</span>
                                                </div>
                                                <div class="preview-content" style="position: relative; height: 276px; overflow: hidden;">
                                                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c);"></div>
                                                    <iframe src="${pageUrl}" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top left; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>
                                                </div>
                                            `;
                                            chatContainer.appendChild(previewDiv);
                                            chatContainer.scrollTop = chatContainer.scrollHeight;
                                            
                                            // Animate in gradually
                                            setTimeout(() => {
                                                previewDiv.style.opacity = '1';
                                                previewDiv.style.transform = 'translateY(0)';
                                            }, 200);
                                        }
                                    }, 2000);
                                } else {
                                    response += `âŒ **×œ× ××¦××ª×™ ×“×¤×™× ×‘××¢×¨×›×ª ×©×œ× ×•.**\n\n`;
                                }
                                
                                response += `â“ **×¢×–×•×¨ ×œ×™ ×œ×”××œ×™×¥ ×œ×š:**\n`;
                                response += `â€¢ **×œ××™ ×”××ª× ×”?** (×™×œ×“, ××™×©×”, ×’×‘×¨, ×–×•×’) ğŸ‘¥\n`;
                                response += `â€¢ **××™×–×” ×¡×•×’?** (×¦×¢×¦×•×¢×™×, ×™×•×¤×™, ×˜×›× ×•×œ×•×’×™×”, ×§×•×¨×¡×™×) ğŸ¯\n`;
                                response += `â€¢ **×ª×§×¦×™×‘?** (×–×•×œ, ×‘×™× ×•× ×™, ×¤×¨×™××™×•×) ğŸ’°\n\n`;
                            }
                            
                            response += `ğŸ’¡ **×¨×•×¦×” ×œ×¨××•×ª ××—×™×¨×™×?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×›××” ×–×” ×¢×•×œ×”"!\n`;
                            response += `ğŸ **×¨×•×¦×” ×”××œ×¦×” ×¡×¤×¦×™×¤×™×ª?** ×ª×’×™×“ ×œ×™ ×™×•×ª×¨ ×¤×¨×˜×™×!\n\n`;
                            
                        } else {
                            // Show actual available pages with specific recommendations
                            response += `ğŸ“‹ **×”××œ×¦×•×ª ×¡×¤×¦×™×¤×™×•×ª:**\n\n`;
                        }
                        
                        // Only show pages if it's not a gift search (gift search shows questions instead)
                        if (mainKeyword !== '××ª× ×”' && mainKeyword !== '××ª× ×•×ª') {
                            // Show more results if user asks for specific number
                            let maxResults = 3;
                            if (lowerMessage.includes('×›××”') || lowerMessage.includes('×”×¨×‘×”') || lowerMessage.includes('×›×œ')) {
                                maxResults = Math.min(matchingPages.length, 5);
                            }
                            
                            for (const page of matchingPages.slice(0, maxResults)) {
                            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                            // Use real page preview with iframe
                            const emoji = page.pageType === 'store' ? 'ğŸª' : page.pageType === 'event' ? 'ğŸ‰' : page.pageType === 'course' ? 'ğŸ“' : page.pageType === 'serviceProvider' ? 'ğŸ”§' : 'ğŸ“„';
                            response += `â€¢ **${page.title}** ${emoji}\n`;
                            response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                            
                            // Add specific product info if available
                            if (page.pageType === 'store' && page.products && page.products.length > 0) {
                                response += `\n  **ğŸ›ï¸ ××•×¦×¨×™× ×–××™× ×™×:**\n`;
                                
                                // Sort products by price for better recommendations
                                const sortedProducts = [...page.products].sort((a, b) => 
                                    parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                                );
                                
                                sortedProducts.slice(0, 3).forEach((product, index) => {
                                    const price = parseInt(product.price.replace(',', ''));
                                    let priceEmoji = 'ğŸ’°';
                                    if (price < 100) priceEmoji = 'ğŸ’š';
                                    else if (price < 500) priceEmoji = 'ğŸ’›';
                                    else if (price < 1000) priceEmoji = 'ğŸ§¡';
                                    else priceEmoji = 'â¤ï¸';
                                    
                                    response += `  ${priceEmoji} **${product.name}** - â‚ª${product.price}`;
                                    
                                    if (index === 0) response += ` â­ **×”×›×™ ×–×•×œ!**`;
                                    if (index === sortedProducts.length - 1) response += ` ğŸ’ **×¤×¨×™××™×•×**`;
                                    
                                    response += `\n`;
                                });
                                
                                // Smart recommendations
                                if (lowerMessage.includes('×–×•×œ') || lowerMessage.includes('×”×›×™ ×–×•×œ')) {
                                    const cheapest = sortedProducts[0];
                                    response += `\n  ğŸ¯ **×”××œ×¦×” ×—×›××”:** ${cheapest.name} - ×”×›×™ ××©×ª×œ×! â‚ª${cheapest.price}\n`;
                                }
                                
                                response += `\n`;
                            } else if (page.pageType === 'serviceProvider') {
                                // Enhanced service provider info
                                response += `\n  **ğŸ”§ ×©×™×¨×•×ª×™× ×–××™× ×™×:**\n`;
                                
                                // Check for appointment availability
                                if (page.description && page.description.includes('×ª×•×¨')) {
                                    response += `  ğŸ“… **×ª×•×¨×™× ×¤× ×•×™×™×** - ×–××™×Ÿ ×œ×”×–×× ×”!\n`;
                                }
                                
                                // Check for pricing info
                                if (page.description && page.description.includes('â‚ª')) {
                                    const priceMatch = page.description.match(/â‚ª(\d+)/);
                                    if (priceMatch) {
                                        response += `  ğŸ’° **××—×™×¨:** â‚ª${priceMatch[1]}\n`;
                                    }
                                }
                                
                                // Check for location
                                if (page.description && (page.description.includes('×¨×—×•×‘') || page.description.includes('×¢×™×¨') || page.description.includes('×›×ª×•×‘×ª'))) {
                                    response += `  ğŸ“ **××™×§×•×:** ×–××™×Ÿ ×‘××–×•×¨\n`;
                                }
                                
                                // Add service description
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  ğŸ“ **×ª×™××•×¨:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  ğŸ¯ **×¨×•×¦×” ×œ×”×–××™×Ÿ?** [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl}) ××• ×”×ª×§×©×¨ ×™×©×™×¨×•×ª!\n\n`;
                            } else if (page.pageType === 'event') {
                                // Enhanced event info
                                response += `\n  **ğŸ‰ ×¤×¨×˜×™ ×”××™×¨×•×¢:**\n`;
                                
                                if (page.expectedGuests && page.expectedGuests > 0) {
                                    response += `  ğŸ‘¥ **××§×•××•×ª ×¤× ×•×™×™×:** ${page.expectedGuests} ××§×•××•×ª\n`;
                                }
                                
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  ğŸ“ **×ª×™××•×¨:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  ğŸ¯ **×¨×•×¦×” ×œ×”×¦×˜×¨×£?** [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl}) ×•×”×¨×©×!\n\n`;
                            } else if (page.pageType === 'course') {
                                // Enhanced course info
                                response += `\n  **ğŸ“ ×¤×¨×˜×™ ×”×§×•×¨×¡:**\n`;
                                
                                if (page.expectedGuests && page.expectedGuests > 0) {
                                    response += `  ğŸ‘¥ **××§×•××•×ª ×¤× ×•×™×™×:** ${page.expectedGuests} ××§×•××•×ª\n`;
                                }
                                
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  ğŸ“ **×ª×™××•×¨:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  ğŸ¯ **×¨×•×¦×” ×œ×”×™×¨×©×?** [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl}) ×•×”×ª×—×œ ×œ×œ××•×“!\n\n`;
                            } else if (page.pageType === 'store' && page.description) {
                                const productInfo = await extractProductInfo(page.description, mainKeyword, pageUrl);
                                if (productInfo) {
                                    if (productInfo.price) {
                                        response += `  ğŸ’° **××—×™×¨:** ${productInfo.price}\n`;
                                    }
                                    if (productInfo.name) {
                                        response += `  ğŸ·ï¸ **××•×¦×¨:** ${productInfo.name}\n`;
                                    }
                                    if (productInfo.location) {
                                        response += `  ğŸ“ **××™×§×•×:** ${productInfo.location}\n`;
                                    }
                                }
                            }
                            
                            response += `  <div style="margin: 8px 0; border: 2px solid #e5e7eb; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1); position: relative; width: 100%; height: 300px;">`;
                            response += `    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c);"></div>`;
                            response += `    <iframe src="${pageUrl}" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top left; position: absolute; top: 0; left: 0;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>`;
                            response += `  </div>\n\n`;
                        }
                        } // Close the if statement for non-gift searches
                        
                        if (matchingPages.length > 3) {
                            response += `×•×¢×•×“ ${matchingPages.length - 3} ×“×¤×™×...`;
                        }
                        
                        // DISABLED - No more inventing help messages
                        
                        // Add price information request
                        if (type === 'store') {
                            response += `\nğŸ’° **×¨×•×¦×” ×œ×“×¢×ª ×¢×œ ××—×™×¨×™×?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×›××” ×–×” ×¢×•×œ×”" ×•×× ×™ ××—×¤×© ×¢×‘×•×¨×š!`;
                        }
                        
                        return {
                            message: response,
                            action: { type: 'change_category_and_highlight', category: type, highlight_pages: matchingPages.slice(0, 3).map(p => p.pageId) }
                        };
                    } else {
                        // NO PAGES FOUND - Don't invent pages!
                        return {
                            message: `ğŸ˜” **×œ× ××¦××ª×™ ×“×¤×™× ×¨×œ×•×•× ×˜×™×™× ×œ"${mainKeyword}".**\n\n××‘×œ ×™×© ×œ× ×• ×“×¤×™× ××—×¨×™× ×©×™×›×•×œ×™× ×œ×¢× ×™×™×Ÿ ××•×ª×š:\n\nğŸª **×—× ×•×™×•×ª:** ${allPages.filter(p => p.pageType === 'store').length} ×“×¤×™×\nğŸ“ **×§×•×¨×¡×™×:** ${allPages.filter(p => p.pageType === 'course').length} ×“×¤×™×\nğŸ”§ **×©×™×¨×•×ª×™×:** ${allPages.filter(p => p.pageType === 'serviceProvider').length} ×“×¤×™×\nğŸ‰ **××™×¨×•×¢×™×:** ${allPages.filter(p => p.pageType === 'event').length} ×“×¤×™×\n\n**×¨×•×¦×” ×œ×¨××•×ª ×”×›×œ?** ×œ×—×¥ ×¢×œ "×”×›×œ" ×œ××¢×œ×”!`,
                            action: { type: 'none' }
                        };
                    }
                }
            }
            
            // Search by title
            const matchingPages = allPages.filter(page => 
                page.title.toLowerCase().includes(lowerMessage)
            );
            
            if (matchingPages.length > 0) {
                let response = `××¦××ª×™ ${matchingPages.length} ×“×¤×™× ×¢× "${message}":\n\n`;
                
                matchingPages.slice(0, 3).forEach(page => {
                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                    // Use real page preview with iframe
                    const emoji = page.pageType === 'store' ? 'ğŸª' : page.pageType === 'event' ? 'ğŸ‰' : page.pageType === 'course' ? 'ğŸ“' : page.pageType === 'serviceProvider' ? 'ğŸ”§' : 'ğŸ“„';
                    response += `â€¢ **${page.title}** ${emoji}\n`;
                    response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                    response += `  <div style="margin: 8px 0; border: 2px solid #e5e7eb; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1); animation: fadeInUp 0.6s ease-out, pulse 2s infinite; position: relative; width: 100%; height: 200px;">`;
                    response += `    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c); animation: shimmer 2s infinite;"></div>`;
                    response += `    <iframe src="${pageUrl}" style="width: 200%; height: 400px; border: none; transform: scale(0.5); transform-origin: top left; transition: all 0.3s ease; position: absolute; top: 0; left: 0;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>`;
                    response += `  </div>\n\n`;
                });
                
                if (matchingPages.length > 3) {
                    response += `×•×¢×•×“ ${matchingPages.length - 3} ×“×¤×™×...`;
                }
                
                return {
                    message: response,
                    action: { type: 'change_category_and_highlight', category: matchingPages[0].pageType, highlight_pages: matchingPages.slice(0, 3).map(p => p.pageId) }
                };
            }
            
            // If no local match, prepare real data for N8N
            const realData = {
                availablePages: allPages.map(p => ({
                    title: p.title,
                    type: p.pageType,
                    products: p.products || []
                }))
            };
            
            return null; // No quick response, send to N8N with real data
        }
        
        // Function to extract product info from page content
        async function extractProductInfo(description, keyword, pageUrl) {
            console.log('ğŸ” extractProductInfo called with:', { description: description?.substring(0, 100), keyword, pageUrl });
            
            if (!description && !pageUrl) return null;
            
            const lowerKeyword = keyword.toLowerCase();
            
            // If we have a page URL, fetch the actual content
            if (pageUrl) {
                console.log('ğŸ” Fetching HTML for:', pageUrl);
                try {
                    const response = await fetch(pageUrl);
                    if (response.ok) {
                        const html = await response.text();
                        console.log('ğŸ“„ HTML fetched, length:', html.length);
                        
                        // Extract all prices from HTML
                        const pricePatterns = [
                            /â‚ª\s*(\d+(?:[.,]\d+)?)/g,
                            /×-?\s*(\d+(?:[.,]\d+)?)\s*â‚ª/g,
                            /(\d+(?:[.,]\d+)?)\s*â‚ª/g,
                            /××—×™×¨[^<]*?(\d+(?:[.,]\d+)?)/gi
                        ];
                        
                        let allPrices = [];
                        pricePatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            allPrices.push(...matches.map(m => m[1] || m[0]));
                        });
                        
                        // Remove duplicates and sort
                        allPrices = [...new Set(allPrices)].sort((a, b) => parseFloat(a) - parseFloat(b));
                        
                        console.log('ğŸ’° All prices found:', allPrices);
                        
                        // Extract service/product names
                        const namePatterns = [
                            /<h[1-6][^>]*>([^<]+)<\/h[1-6]>/gi,
                            /<div[^>]*class="[^"]*title[^"]*"[^>]*>([^<]+)<\/div>/gi,
                            /<span[^>]*class="[^"]*name[^"]*"[^>]*>([^<]+)<\/span>/gi
                        ];
                        
                        let allNames = [];
                        namePatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            allNames.push(...matches.map(m => m[1].trim()));
                        });
                        
                        // Filter names that contain the keyword
                        const relevantNames = allNames.filter(name => 
                            name.toLowerCase().includes(lowerKeyword)
                        );
                        
                        console.log('ğŸ·ï¸ Relevant names found:', relevantNames);
                        
                        // Extract location
                        const locationPatterns = [
                            /(?:×‘×›×ª×•×‘×ª|×›×ª×•×‘×ª|××™×§×•×|×‘××–×•×¨|×‘× ×ª× ×™×”|×‘×ª×œ ××‘×™×‘|×‘×™×¨×•×©×œ×™×)[^<]*?([×-×ª\s]+)/gi,
                            /<meta[^>]*name="[^"]*location[^"]*"[^>]*content="([^"]+)"/gi
                        ];
                        
                        let location = null;
                        locationPatterns.forEach(pattern => {
                            const match = html.match(pattern);
                            if (match && !location) {
                                location = match[1].trim();
                            }
                        });
                        
                        // Extract descriptions
                        const descPatterns = [
                            /<p[^>]*class="[^"]*desc[^"]*"[^>]*>([^<]+)<\/p>/gi,
                            /<div[^>]*class="[^"]*description[^"]*"[^>]*>([^<]+)<\/div>/gi
                        ];
                        
                        let descriptions = [];
                        descPatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            descriptions.push(...matches.map(m => m[1].trim()));
                        });
                        
                        return {
                            prices: allPrices.length > 0 ? allPrices : null,
                            names: relevantNames.length > 0 ? relevantNames : null,
                            location: location,
                            descriptions: descriptions.length > 0 ? descriptions : null,
                            allNames: allNames.length > 0 ? allNames : null
                        };
                    }
                } catch (error) {
                    console.error('âŒ Error fetching HTML:', error);
                }
            }
            
            // Fallback to description parsing
            if (description) {
                const lowerDesc = description.toLowerCase();
                
                // Look for price patterns in description
                const priceRegex = /[\d,]+â‚ª|[\d,]+ ×©"×—|[\d,]+ ×©×§×œ|[\d,]+ â‚ª/g;
                const prices = [];
                let match;
                while ((match = priceRegex.exec(description)) !== null) {
                    prices.push(match[0]);
                }
                
                console.log('ğŸ’° Prices found in description:', prices);
                
                if (prices.length > 0) {
                    // Try to find product name near the keyword
                    const keywordIndex = lowerDesc.indexOf(lowerKeyword);
                    if (keywordIndex !== -1) {
                        const start = Math.max(0, keywordIndex - 50);
                        const end = Math.min(description.length, keywordIndex + 50);
                        const context = description.substring(start, end);
                        
                        return {
                            name: context.trim(),
                            price: prices[0]
                        };
                    }
                }
            }
            
            return null;
        }
        
        // Enhanced sendAIMessage with smart search
        async function sendAIMessageEnhanced() {
            try {
                const input = document.getElementById('aiChatInput');
                const userMessage = input.value.trim();
                
                if (!userMessage) return;
                
                // Display user message
                addAIMessage(userMessage, true);
                input.value = '';
                
                // Show typing indicator
                addAIMessage('ğŸ¤– ×¡×ª×™×• ××§×œ×™×“×”<span class="typing-dots">...</span>', false);
                
                // Make sure we have pages loaded
                if (allPages.length === 0) {
                    await loadPages();
                }
                
                // Try smart search first for real page results
                const smartResult = await handleSmartSearch(userMessage, allPages);
                if (smartResult) {
                    // Remove typing indicator
                    removeTypingIndicator();
                    
                    // Display smart search result
                    addAIMessage(smartResult.message, false);
                    
                    // Add iframe preview for gift recommendations
                    if (smartResult.message.includes('××ª× ×•×ª ××•×©×œ××•×ª') && smartResult.message.includes('×”××œ×¦×” ×©×œ×™')) {
                        setTimeout(() => {
                            const chatContainer = document.querySelector('.ai-chat-messages');
                            if (chatContainer) {
                                // Find the first page mentioned in the message
                                const pageMatch = smartResult.message.match(/\*\*([^*]+)\*\*/);
                                if (pageMatch) {
                                    const pageTitle = pageMatch[1];
                                    // Find the page in allPages
                                    const page = allPages.find(p => p.title === pageTitle);
                                    if (page) {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        
                                        const previewDiv = document.createElement('div');
                                        previewDiv.className = 'page-preview';
                                        previewDiv.style.cssText = `
                                            margin: 16px 0;
                                            border: 2px solid #e5e7eb;
                                            border-radius: 12px;
                                            overflow: hidden;
                                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                                            position: relative;
                                            width: 100%;
                                            height: 300px;
                                            opacity: 0;
                                            transform: translateY(20px);
                                            transition: all 0.5s ease;
                                        `;
                                        previewDiv.innerHTML = `
                                            <div class="preview-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                                <span>ğŸ</span>
                                                <span>${page.title}</span>
                                            </div>
                                            <div class="preview-content" style="position: relative; height: 276px; overflow: hidden;">
                                                <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c);"></div>
                                                <iframe src="${pageUrl}" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top left; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>
                                            </div>
                                        `;
                                        chatContainer.appendChild(previewDiv);
                                        chatContainer.scrollTop = chatContainer.scrollHeight;
                                        
                                        // Animate in gradually
                                        setTimeout(() => {
                                            previewDiv.style.opacity = '1';
                                            previewDiv.style.transform = 'translateY(0)';
                                        }, 200);
                                    }
                                }
                            }
                        }, 2000);
                    }
                    
                    // Execute action if any
                    if (smartResult.action && smartResult.action.type !== 'none') {
                        await executeAction(smartResult.action);
                    }
                    
                    return; // Don't send to N8N
                }
                
                // If no smart search result, send to N8N with REAL DATA
                try {
                    // Prepare real data context for N8N
                    const realDataContext = `××ª×” ×¢×•×–×¨ ×‘××¨×§×˜×¤×œ×™×™×¡. ×¢× ×” ×¢×œ ×©××œ×•×ª ×‘×¦×•×¨×” ×™×“×™×“×•×ª×™×ª ×‘×”×ª×‘×¡×¡ ×¢×œ ×”× ×ª×•× ×™× ×”×××™×ª×™×™× ×”×‘××™×:

**×“×¤×™× ×–××™× ×™× ×‘××¢×¨×›×ª:**
${allPages.map(page => {
    let pageInfo = `- ${page.title} (${page.pageType === 'store' ? '×—× ×•×ª' : page.pageType === 'course' ? '×§×•×¨×¡' : page.pageType === 'event' ? '××™×¨×•×¢' : '×©×™×¨×•×ª'})`;
    if (page.products && page.products.length > 0) {
        pageInfo += '\n  ××•×¦×¨×™×:';
        page.products.forEach(product => {
            pageInfo += `\n  * ${product.name} - â‚ª${product.price}`;
        });
    }
    return pageInfo;
}).join('\n')}

**×—×©×•×‘:** ×”×©×ª××© ×¨×§ ×‘× ×ª×•× ×™× ×××™×ª×™×™× ××”×¨×©×™××” ×œ××¢×œ×”. ××œ ×ª××¦×™× ×“×¤×™×, ×—× ×•×™×•×ª ××• ××•×¦×¨×™× ×©×œ× ××•×¤×™×¢×™× ×‘×¨×©×™××”. ×× ××™×Ÿ ××™×“×¢ ×–××™×Ÿ, ×××•×¨ ×–××ª ×‘×›× ×•×ª.`;

                    const response = await fetch('https://n8n-service-how4.onrender.com/webhook/jhfuhgufkhlkuho8erhf757754jhldkbsjkbmreketpg', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            message: userMessage,
                            context: 'marketplace',
                            contextText: realDataContext
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        removeTypingIndicator();
                        addAIMessage(data.message || '×¡×œ×™×—×”, ×§×¨×ª×” ×©×’×™××”. × ×¡×” ×©×•×‘!', false);
                        return;
                    }
                } catch (error) {
                    console.error('Error calling N8N:', error);
                }
                
                // Fallback if N8N fails
                removeTypingIndicator();
                addAIMessage("×× ×™ ×›××Ÿ ×œ×¢×–×•×¨ ×œ×š! ğŸ˜Š ×× ××ª×” ××—×¤×© ××©×”×• ×¡×¤×¦×™×¤×™, ×ª×•×›×œ ×œ×©××•×œ ××•×ª×™ ×¢×œ ××ª× ×•×ª, ×œ×§, ×©×¢×•× ×™×, ×¦×¢×¦×•×¢×™× ××• ×§×•×¨×¡×™×.", false);
                return;
                
                // OLD N8N CODE - DISABLED TO PREVENT INVENTING PAGES
                /*
                // Continue with original AI logic...
                const allPagesContext = allPages.map(page => ({
                    title: page.title,
                    description: page.description,
                    pageType: page.pageType,
                    userId: page.userId,
                    pageId: page.pageId
                }));
                
                // N8N CODE REMOVED - NO MORE INVENTING PAGES!
                */
                
                // N8N CODE REMOVED - NO MORE INVENTING PAGES!
                
                // N8N CODE REMOVED - NO MORE INVENTING PAGES!
                
                // N8N CODE REMOVED - NO MORE INVENTING PAGES!
            } catch (error) {
                console.error('âŒ Error in sendAIMessageEnhanced:', error);
                removeTypingIndicator();
                addAIMessage('×¡×œ×™×—×”, ×§×¨×ª×” ×©×’×™××”. × ×¡×” ×©×•×‘!', false);
            }
        }
        
        // Execute actions
        async function executeAction(action) {
            if (action.type === 'change_category') {
                console.log('ğŸ·ï¸ Changing to category:', action.category);
                
                // Map category names
                const categoryMap = {
                    'store': 'store',
                    'stores': 'store',
                    '×—× ×•×ª': 'store',
                    '×—× ×•×™×•×ª': 'store',
                    'event': 'event',
                    'events': 'event',
                    '××™×¨×•×¢': 'event',
                    '××™×¨×•×¢×™×': 'event',
                    'course': 'course',
                    'courses': 'course',
                    '×§×•×¨×¡': 'course',
                    '×§×•×¨×¡×™×': 'course',
                    'serviceProvider': 'serviceProvider',
                    'service': 'serviceProvider',
                    '×‘×¢×œ×™ ××§×¦×•×¢': 'serviceProvider',
                    'all': 'all',
                    '×”×›×œ': 'all'
                };
                
                const mappedCategory = categoryMap[action.category.toLowerCase()] || action.category;
                console.log('ğŸ“‚ Mapped category:', mappedCategory);
                
                // Update UI buttons - use the existing filterByType function
                filterByType(mappedCategory);
                
                // Scroll to top to see results
                setTimeout(() => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    console.log('âœ… Category changed to:', mappedCategory);
                    console.log('ğŸ“Š New filteredPages length:', filteredPages.length);
                    
                    // Show success message
                    addAIMessage(`âœ… ×¢×‘×¨×ª×™ ×œ×§×˜×’×•×¨×™×™×ª ${getTypeName(mappedCategory)}! ××¦× ${filteredPages.length} ×“×¤×™×.`, false);
                }, 100);
            } else if (action.type === 'change_category_and_highlight') {
                console.log('ğŸ·ï¸ Changing to category and highlighting pages:', action.category, action.highlight_pages);
                
                // Map category names
                const categoryMap = {
                    'store': 'store',
                    'stores': 'store',
                    '×—× ×•×ª': 'store',
                    '×—× ×•×™×•×ª': 'store',
                    'event': 'event',
                    'events': 'event',
                    '××™×¨×•×¢': 'event',
                    '××™×¨×•×¢×™×': 'event',
                    'course': 'course',
                    'courses': 'course',
                    '×§×•×¨×¡': 'course',
                    '×§×•×¨×¡×™×': 'course',
                    'serviceProvider': 'serviceProvider',
                    'service': 'serviceProvider',
                    '×‘×¢×œ×™ ××§×¦×•×¢': 'serviceProvider',
                    'all': 'all',
                    '×”×›×œ': 'all'
                };
                
                const mappedCategory = categoryMap[action.category.toLowerCase()] || action.category;
                console.log('ğŸ“‚ Mapped category:', mappedCategory);
                
                // Update UI buttons - use the existing filterByType function
                filterByType(mappedCategory);
                
                // Scroll to top and highlight pages
                setTimeout(() => {
                    // Highlight matching pages first
                    if (action.highlight_pages && action.highlight_pages.length > 0) {
                        action.highlight_pages.forEach((pageId, index) => {
                            const pageCard = document.querySelector(`[data-page-id="${pageId}"]`);
                            if (pageCard) {
                                pageCard.style.outline = '3px solid #667eea';
                                pageCard.style.transform = 'scale(1.05)';
                                pageCard.style.transition = 'all 0.3s ease';
                                pageCard.style.boxShadow = '0 10px 25px rgba(102, 126, 234, 0.3)';
                                
                                // Scroll to first highlighted page with delay
                                if (index === 0) {
                                    setTimeout(() => {
                                        pageCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    }, 200);
                                }
                                
                                setTimeout(() => {
                                    pageCard.style.outline = '';
                                    pageCard.style.transform = '';
                                    pageCard.style.boxShadow = '';
                                }, 5000);
                            }
                        });
                    }
                    
                    console.log('âœ… Category changed to:', mappedCategory);
                    console.log('ğŸ“Š New filteredPages length:', filteredPages.length);
                    
                    // Show success message
                    addAIMessage(`âœ… ×¢×‘×¨×ª×™ ×œ×§×˜×’×•×¨×™×™×ª ${getTypeName(mappedCategory)}! ××¦× ${filteredPages.length} ×“×¤×™×.`, false);
                }, 100);
            } else if (action.type === 'scroll_to_page' && action.page_id) {
                console.log('ğŸ” Looking for page card with ID:', action.page_id);
                
                // Find the page card and scroll to it
                setTimeout(() => {
                    const pageCard = document.querySelector(`[data-page-id="${action.page_id}"]`);
                    if (pageCard) {
                        pageCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        pageCard.style.outline = '3px solid #667eea';
                        pageCard.style.transform = 'scale(1.05)';
                        pageCard.style.transition = 'all 0.3s ease';
                        pageCard.style.boxShadow = '0 10px 25px rgba(102, 126, 234, 0.3)';
                        
                        setTimeout(() => {
                            pageCard.style.outline = '';
                            pageCard.style.transform = '';
                            pageCard.style.boxShadow = '';
                        }, 3000);
                    } else {
                        console.error('âŒ Page card not found for:', action.page_id);
                        addAIMessage('ğŸ” ××¦××ª×™ ××ª ×”×“×£ ××‘×œ ×œ× ×”×¦×œ×—×ª×™ ×œ×’×œ×•×œ ××œ×™×•. ×—×¤×© ××•×ª×• ×‘×¨×©×™××” ×œ××¢×œ×”!', false);
                    }
                }, 500);
            } else if (action.type === 'show_page' && action.page_id) {
                // Open page in new tab
                const page = allPages.find(p => p.pageId === action.page_id);
                if (page) {
                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                    window.open(pageUrl, '_blank');
                }
            }
        }
        
        // Function to extract prices from page content
        async function extractPricesFromPage(page) {
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (!response.ok) return null;
                
                const htmlContent = await response.text();
                const priceRegex = /â‚ª\s*(\d+(?:,\d{3})*(?:\.\d{2})?)/g;
                const prices = [];
                let match;
                
                while ((match = priceRegex.exec(htmlContent)) !== null) {
                    prices.push(match[0]);
                }
                
                return prices.length > 0 ? prices : null;
            } catch (error) {
                console.error('Error extracting prices:', error);
                return null;
            }
        }
        
        // Enhanced search with price information - DISABLED, everything goes to N8N
        async function searchWithPrices(message) {
            // Everything goes to N8N now
            return null;
        }
        
        // Fix the filterByCategory function
        function filterByCategory(category) {
            currentType = category;
            
            if (category === 'all') {
                filteredPages = [...allPages];
            } else {
                filteredPages = allPages.filter(page => page.pageType === category);
            }
            
            displayPages();
            updatePagesCount();
        }
        
        // Replace the original sendAIMessage with enhanced version
        window.sendAIMessage = sendAIMessageEnhanced;
        
        // Allow Enter key in chat input
        document.getElementById('aiChatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendAIMessage();
            }
        });
        
        // Go to full app function
        function goToFullApp() {
            window.location.href = '/';
        }
      </script>
  </body>
</html>