<!DOCTYPE html>
<html lang="he" dir="rtl">
    <!-- Updated: 2024-12-28 21:50:00 -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AutoPage Marketplace</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .hero-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .page-card {
            transition: all 0.3s ease;
        }
        .page-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .ai-bot-bubble {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer !important;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            z-index: 1000;
            transition: all 0.3s ease;
            pointer-events: auto !important;
        }
        
        .ai-bot-bubble:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
        }
        
        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }
            100% {
                background-position: 200% 0;
            }
        }
        
        .ai-chat-window {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 350px;
            height: 500px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        
        .ai-chat-window.active {
            display: flex;
        }
        
        .ai-chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .ai-chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: #f8f9fa;
        }
        
        .page-preview{
            margin-top: 15px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            width: 100% !important;
            max-width: 100% !important;
            height: 300px !important;
            text-align: right !important;
            direction: rtl !important;
            display: block !important;
            align-self: flex-end !important;
        }
        
        .preview-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            font-weight: 600;
        }
        
        .preview-header h3 {
            margin: 0;
            font-size: 16px;
        }
        
        .preview-content {
            padding: 0;
            background: white;
        }
        
        .preview-content iframe {
            border: none;
            border-radius: 0 0 12px 12px;
        }
        
        .ai-message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 10px;
            max-width: 80%;
        }
        
        .ai-message.user {
            background: #667eea;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .ai-message.bot {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
            margin-left: auto;
            margin-right: 0;
            text-align: right !important;
            direction: rtl !important;
            display: block !important;
            width: 100% !important;
            padding: 12px 16px !important;
            text-align: right !important;
            align-self: flex-end !important;
            max-width: none !important;
        }
        
        .typing-text {
            display: inline-block;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .ai-chat-input {
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }
        
        .ai-chat-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
        }
        
        .ai-chat-input button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        
        .typing-dots {
            animation: typing 1.5s infinite;
        }
        
        @keyframes typing {
            0%, 60%, 100% { opacity: 0; }
            30% { opacity: 1; }
        }

        /* Stav typing animation with spinning loader */
        .stav-typing-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            font-style: italic;
            color: #6b7280;
        }
        
        .stav-loader {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            perspective: 300px;
            position: relative;
            flex-shrink: 0;
        }
        
        .stav-loader .inner {
            position: absolute;
            box-sizing: border-box;
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }
        
        .stav-loader .inner.one {
            left: 0%;
            top: 0%;
            animation: stav-rotate-one 1.5s linear infinite;
            border-bottom: 3px solid #8b5cf6;
        }
        
        .stav-loader .inner.two {
            right: 0%;
            top: 0%;
            animation: stav-rotate-two 1.5s linear infinite;
            border-right: 3px solid #ec4899;
        }
        
        .stav-loader .inner.three {
            right: 0%;
            bottom: 0%;
            animation: stav-rotate-three 1.5s linear infinite;
            border-top: 3px solid #3b82f6;
        }
        
        @keyframes stav-rotate-one {
            0% { transform: rotateX(35deg) rotateY(-45deg) rotateZ(0deg); }
            100% { transform: rotateX(35deg) rotateY(-45deg) rotateZ(360deg); }
        }
        
        @keyframes stav-rotate-two {
            0% { transform: rotateX(50deg) rotateY(10deg) rotateZ(0deg); }
            100% { transform: rotateX(50deg) rotateY(10deg) rotateZ(360deg); }
        }
        
        @keyframes stav-rotate-three {
            0% { transform: rotateX(35deg) rotateY(55deg) rotateZ(0deg); }
            100% { transform: rotateX(35deg) rotateY(55deg) rotateZ(360deg); }
        }

        /* === STAV CHAT WINDOW === */
        .stav-chat-window {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .stav-chat-window.active {
            display: flex;
        }
        
        .stav-chat-container {
            width: 95%;
            max-width: 1400px;
            height: 90%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .stav-chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stav-chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8fafc;
        }
        
        .stav-message {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
        }
        
        .stav-message.user {
            background: #667eea;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .stav-message.bot {
            background: white;
            color: #333;
            margin-left: auto;
            margin-right: 0;
            text-align: right !important;
            direction: rtl !important;
            display: block !important;
            width: 100% !important;
            border: 1px solid #e5e7eb;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 12px 16px !important;
            text-align: right !important;
            align-self: flex-end !important;
            max-width: none !important;
        }
        
        .typing-text {
            display: inline-block;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .stav-chat-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 10px;
        }
        
        .stav-chat-input input {
            flex: 1;
            padding: 15px;
            border: 2px solid #e5e7eb;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }
        
        .stav-chat-input input:focus {
            border-color: #667eea;
        }
        
        .stav-chat-input button {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .stav-chat-input button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Hero Header with Purple Background -->
    <div class="hero-gradient text-white">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
            <div class="text-center">
                <h1 class="text-4xl md:text-6xl font-bold mb-4">AutoPage Marketplace</h1>
                <p class="text-xl md:text-2xl mb-8 opacity-90">××¦× ××ª ×”×“×£ ×”××•×©×œ× ×©×œ×š</p>
                
                <!-- Search Bar -->
                <div class="max-w-2xl mx-auto mb-8">
                    <div class="relative">
                        <input type="text" id="search-input" placeholder="×—×¤×© ×“×¤×™×, ×¢×¡×§×™×, ×©×™×¨×•×ª×™×..." 
                               class="w-full px-6 py-4 text-gray-900 text-lg rounded-full focus:ring-4 focus:ring-white focus:ring-opacity-50 focus:outline-none">
                        <button onclick="searchPages()" class="absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- Create Page Button -->
                <div class="flex justify-center gap-4">
                    <button onclick="goToFullApp()" class="bg-white text-indigo-600 px-8 py-4 rounded-full font-bold text-lg hover:bg-gray-100 transition-all transform hover:scale-105 flex items-center gap-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                        </svg>
                        ×¦×•×¨ ×“×£ ×¢×›×©×™×•
                    </button>
                    <button onclick="toggleStavChat()" class="bg-purple-600 text-white px-8 py-4 rounded-full font-bold text-lg hover:bg-purple-700 transition-all transform hover:scale-105 flex items-center gap-2">
                        ğŸ¤– ×¡×ª×™×•
                    </button>
                </div>
                
                <!-- View Toggle Buttons -->
                <div class="flex justify-center gap-2 mt-4">
                    <button id="grid-view-btn" onclick="setView('grid')" class="p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path>
                        </svg>
                    </button>
                    <button id="table-view-btn" onclick="setView('table')" class="p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Filter Buttons -->
    <div class="bg-white border-b">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
            <div class="flex flex-wrap justify-center gap-3">
                <button onclick="filterByType('all')" class="px-6 py-3 bg-indigo-500 text-white rounded-full hover:bg-indigo-600 transition-all">×”×›×œ</button>
                <button onclick="filterByType('store')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">ğŸª ×—× ×•×™×•×ª</button>
                <button onclick="filterByType('event')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">ğŸ‰ ××™×¨×•×¢×™×</button>
                <button onclick="filterByType('course')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">ğŸ“ ×§×•×¨×¡×™×</button>
                <button onclick="filterByType('serviceProvider')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">ğŸ”§ ×‘×¢×œ×™ ××§×¦×•×¢</button>
            </div>
            <div class="text-center mt-4">
                <p id="pages-count" class="text-gray-600">×˜×•×¢×Ÿ ×“×¤×™×...</p>
            </div>
        </div>
    </div>

    <!-- Loading State -->
    <div id="loading-state" class="text-center py-12">
        <div class="text-lg text-gray-600">×˜×•×¢×Ÿ ×“×¤×™×...</div>
    </div>

    <!-- Pages Grid -->
    <div id="pages-grid" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- Pages will be loaded here -->
    </div>
    
    <!-- Pages Table -->
    <div id="pages-table" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 hidden">
        <div class="bg-white shadow overflow-hidden sm:rounded-md">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×ª××•× ×”</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×›×•×ª×¨×ª</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×¡×•×’</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×ª×™××•×¨</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×ª××¨×™×š ×™×¦×™×¨×”</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">×¤×¢×•×œ×•×ª</th>
                    </tr>
                </thead>
                <tbody id="table-body" class="bg-white divide-y divide-gray-200">
                    <!-- Table rows will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Stav Chat Window (Main Bot) -->
    <div class="stav-chat-window" id="stavChatWindow">
        <div class="stav-chat-container">
            <div class="stav-chat-header">
                <h2>ğŸ¤– ×¡×ª×™×•</h2>
                <button onclick="toggleStavChat()" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">Ã—</button>
            </div>
        <div class="stav-chat-messages" id="stavChatMessages">
            <div class="stav-message bot">
                ×©×œ×•×, ××” ×©×œ×•××š?
            </div>
        </div>
            <div class="stav-chat-input">
                <button id="micButton" onclick="toggleSpeechRecognition()" style="background: #667eea; color: white; border: none; padding: 15px; border-radius: 8px; margin-left: 10px; cursor: pointer; font-size: 20px;">ğŸ¤</button>
                <input type="text" id="stavChatInput" placeholder="×›×ª×•×‘ ×”×•×“×¢×” ××• ×œ×—×¥ ×¢×œ ×”××™×§×¨×•×¤×•×Ÿ...">
                <button onclick="sendStavMessage()">×©×œ×—</button>
            </div>
        </div>
    </div>

    <!-- Responsive overrides for Stav chat (marketplace) -->
    <style>
        .stav-chat-window { z-index: 9999; position: fixed; right: 24px; bottom: 24px; }
        .stav-chat-window.fullscreen { inset: 0 !important; right: 0 !important; left: 0 !important; top: 0 !important; bottom: 0 !important; width: 100vw !important; height: 100vh !important; margin: 0 !important; padding: 0 !important; }
        .stav-chat-container { display: flex !important; flex-direction: column !important; }
        .stav-chat-window.fullscreen .stav-chat-container { width: 100% !important; max-width: none !important; height: 100% !important; margin: 0 !important; border-radius: 0 !important; }
        .stav-chat-header { flex: 0 0 auto !important; }
        .stav-chat-messages { flex: 1 1 auto !important; overflow-y: auto !important; }
        .stav-chat-input { flex: 0 0 auto !important; }
        @media (max-width: 640px) {
            .stav-chat-window { left: 4vw; right: 4vw; bottom: calc(16px + env(safe-area-inset-bottom)); }
            .stav-chat-container { width: 100%; max-height: min(70vh, 560px); border-radius: 16px; overflow: hidden; }
            .stav-chat-messages { max-height: none !important; }
            .stav-chat-input { padding-bottom: max(8px, env(safe-area-inset-bottom)); }
        }
    </style>

    <!-- AI Search Bot (Old Marketplace Bot - Keep for legacy) -->
    <div class="ai-bot-bubble" id="aiBotBubble" title="×¢×–×¨×” ×—×›××”" onclick="toggleAIChat()" style="cursor: pointer !important; pointer-events: auto !important; display: none;">
        ğŸ¤–
    </div>

    <div class="ai-chat-window" id="aiChatWindow" style="display: none;">
        <div class="ai-chat-header">
            <span>ğŸ¤– ×”×¢×•×–×¨×ª ×”×—×›××”</span>
            <button id="closeAiChat" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">Ã—</button>
        </div>
        <div class="ai-chat-messages" id="aiChatMessages">
        </div>
        <div class="ai-chat-input">
            <input type="text" id="aiChatInput" placeholder="×›×ª×•×‘ ×”×•×“×¢×”...">
            <button onclick="sendAIMessage()">×©×œ×—</button>
        </div>
    </div>

    <script>
        // --- N8N Webhook URL (single source of truth) ---
        const N8N_WEBHOOK_URL = 'https://n8n-service-how4.onrender.com/webhook/jhfuhgufkhlkuho8erhf757754jhldkbsjkbmreketpg';
        
        // --- Local fallback logic to avoid repeating the same greeting and answer simple queries ---
        let stavFirstReplySent = false;
        function stavLocalFallbackReply(message) {
            // MINIMAL fallback - only for basic greetings when N8N completely fails
            // All other queries should be handled by N8N
            try {
                const raw = (message || '').toString();
                const msg = raw.trim();

                // Only handle basic greetings - everything else should go to N8N
                if (/^(×”×™×™|×”×™|×©×œ×•×)[!\s\u200f\u200e]*$/i.test(msg)) {
                    return stavFirstReplySent
                        ? '×”×™×™! ×›××Ÿ ×‘×©×‘×™×œ×š ğŸ˜Š'
                        : '×”×™×™! ğŸ˜Š ××™×š ×× ×™ ×™×›×•×œ×” ×œ×¢×–×•×¨?';
                }

                // Minimal fallback for everything else - just acknowledge
                // All queries should be handled by N8N, not here
                return '×× ×™ ×›××Ÿ ×‘×©×‘×™×œ×š! ğŸ˜Š × ×¡×”/×™ ×©×•×‘ ××• ×›×ª×•×‘/×™ ××” ××ª/×” ××—×¤×©/×ª.';
            } catch (_) {
                return '×× ×™ ×›××Ÿ ×‘×©×‘×™×œ×š! ğŸ˜Š';
            }
        }
        const AI_WEBHOOK = N8N_WEBHOOK_URL; // Use the same N8N webhook
        
        // Simple toggle function
        function toggleAIChat() {
            console.log('ğŸ”§ toggleAIChat called');
            const chatWindow = document.getElementById('aiChatWindow');
            if (chatWindow) {
                chatWindow.classList.toggle('active');
                console.log('ğŸ”§ Chat window toggled, active:', chatWindow.classList.contains('active'));
                
                if (chatWindow.classList.contains('active')) {
                    const input = document.getElementById('aiChatInput');
                    if (input) {
                        input.focus();
                    }
                }
            } else {
                console.error('âŒ Chat window not found');
            }
        }
        
        // Add event listener for AI bot bubble
        document.addEventListener('DOMContentLoaded', function() {
            const aiBotBubble = document.getElementById('aiBotBubble');
            if (aiBotBubble) {
                aiBotBubble.addEventListener('click', toggleAIChat);
                aiBotBubble.addEventListener('touchstart', toggleAIChat);
            }
            
            const closeAiChat = document.getElementById('closeAiChat');
            if (closeAiChat) {
                closeAiChat.addEventListener('click', toggleAIChat);
            }
        });
        
        // Also add click event directly to the bubble
        function addBotBubbleClick() {
            const aiBotBubble = document.getElementById('aiBotBubble');
            if (aiBotBubble) {
                aiBotBubble.onclick = toggleAIChat;
                aiBotBubble.addEventListener('click', toggleAIChat);
                aiBotBubble.addEventListener('touchstart', toggleAIChat);
            }
        }
        
        // Call the function after DOM is loaded
        setTimeout(addBotBubbleClick, 1000);
        
        // Also try to add click event after page loads
        window.addEventListener('load', function() {
            const aiBotBubble = document.getElementById('aiBotBubble');
            if (aiBotBubble) {
                aiBotBubble.onclick = toggleAIChat;
                aiBotBubble.addEventListener('click', toggleAIChat);
            }
        });
        
        function addAIMessage(message, isUser = false) {
            const messagesDiv = document.getElementById('aiChatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${isUser ? 'user' : 'bot'}`;
            
            if (isUser) {
                messageDiv.textContent = message;
            } else {
                // Convert markdown-style links to clickable links
                let processedMessage = message.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, text, url) => {
                    // Make sure URL is full URL (add origin if needed)
                    const fullUrl = url.startsWith('http') ? url : (url.startsWith('/') ? `${window.location.origin}${url}` : url);
                    return `<a href="${fullUrl}" target="_blank" onclick="event.preventDefault(); window.open('${fullUrl}', '_blank'); return false;" style="color: #667eea; text-decoration: underline; cursor: pointer;">${text}</a>`;
                });
                
                // ğŸ¯ FIX: Also convert plain text links like "ğŸ”— ×¦×¤×” ×‘×“×£: /users/..." to clickable links
                // Match patterns like "ğŸ”— ×¦×¤×” ×‘×“×£: /users/..." or "×¦×¤×” ×‘×“×£: /users/..."
                processedMessage = processedMessage.replace(
                    /(ğŸ”—\s*)?×¦×¤×”\s+×‘×“×£\s*:\s*(\/users\/[^\s\)<>]+)/g,
                    (match, emoji, url) => {
                        const fullUrl = url.startsWith('http') ? url : `${window.location.origin}${url}`;
                        return `<a href="${fullUrl}" target="_blank" onclick="event.preventDefault(); window.open('${fullUrl}', '_blank'); return false;" style="color: #667eea; text-decoration: underline; cursor: pointer;">ğŸ‘ï¸ ×¦×¤×” ×‘×“×£</a>`;
                    }
                );
                
                // Also match standalone URLs like "/users/..." at the end of sentences (but not already in links)
                processedMessage = processedMessage.replace(
                    /(\/users\/[^\s\)<>]+)(?![^<]*<\/a>)/g,
                    (match, url) => {
                        // Make sure it's not already a link
                        if (!processedMessage.includes(`<a href="${url}"`)) {
                            const fullUrl = url.startsWith('http') ? url : `${window.location.origin}${url}`;
                            return `<a href="${fullUrl}" target="_blank" onclick="event.preventDefault(); window.open('${fullUrl}', '_blank'); return false;" style="color: #667eea; text-decoration: underline; cursor: pointer;">ğŸ”— ×¦×¤×” ×‘×“×£</a>`;
                        }
                        return match;
                    }
                );
                
                // Add animated typing effect for bot messages
                messageDiv.innerHTML = '<span class="typing-text"></span>';
                messagesDiv.appendChild(messageDiv);
                
                // Animate typing effect
                const typingSpan = messageDiv.querySelector('.typing-text');
                let i = 0;
                const typeMessage = () => {
                    if (i < processedMessage.length) {
                        // Get current position in HTML string
                        const htmlToAdd = processedMessage.substring(0, i + 1);
                        typingSpan.innerHTML = htmlToAdd;
                        
                        // ğŸ¯ FIX: Re-attach click handlers to links after they're added
                        typingSpan.querySelectorAll('a').forEach(link => {
                            if (!link.dataset.handlerAttached) {
                                link.dataset.handlerAttached = 'true';
                                const href = link.getAttribute('href');
                                if (href) {
                                    link.addEventListener('click', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        window.open(href, '_blank');
                                        return false;
                                    });
                                }
                            }
                        });
                        
                        i++;
                        setTimeout(typeMessage, 50); // 50ms delay between characters
                    } else {
                        // After typing is complete, ensure all links have handlers
                        setTimeout(() => {
                            typingSpan.querySelectorAll('a').forEach(link => {
                                if (!link.dataset.handlerAttached) {
                                    link.dataset.handlerAttached = 'true';
                                    const href = link.getAttribute('href');
                                    if (href) {
                                        link.addEventListener('click', (e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            window.open(href, '_blank');
                                            return false;
                                        });
                                    }
                                }
                            });
                        }, 100);
                    }
                };
                typeMessage();
                
                // Fix image URLs to be absolute and add error handling
                processedMessage = processedMessage.replace(/src="([^"]+)"/g, (match, src) => {
                    let fullSrc = src;
                    if (src.startsWith('/')) {
                        fullSrc = `${window.location.origin}${src}`;
                    }
                    return `src="${fullSrc}" onerror="this.style.display='none'" onload="this.style.display='block'"`;
                });
                
                messageDiv.innerHTML = processedMessage;
            }
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function removeTypingIndicator() {
            const messagesDiv = document.getElementById('aiChatMessages');
            if (messagesDiv.lastChild && messagesDiv.lastChild.textContent.includes('××§×œ×™×“×”')) {
                messagesDiv.removeChild(messagesDiv.lastChild);
            }
        }
        
        // Global variables
        let allPages = [];
        let filteredPages = [];
        let currentType = 'all';
        let currentView = 'grid';
        
        // Load pages on page load
        document.addEventListener('DOMContentLoaded', async function() {
            await loadPages();
        });
        
        // Search functionality
        document.getElementById('search-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPages();
            }
        });
        
        async function loadPages() {
            try {
                const response = await fetch('/api/pages/all/marketplace');
                const data = await response.json();
                
                // Handle both array and object with pages property
                allPages = Array.isArray(data) ? data : (data.pages || []);
                filteredPages = [...allPages];
                
                console.log('Loaded pages:', allPages);
                console.log('Page types:', [...new Set(allPages.map(p => p.pageType))]);
                
                displayPages();
                updatePagesCount();
                
                // Hide loading state
                document.getElementById('loading-state').style.display = 'none';
            } catch (error) {
                console.error('Error loading pages:', error);
                document.getElementById('loading-state').innerHTML = `
                    <div class="text-red-500 text-lg">×œ× ×”×¦×œ×—×ª×™ ×œ×˜×¢×•×Ÿ ×“×¤×™×. ×‘×“×§×™ ×©×”×©×¨×ª ×¨×¥ ×•×¢×“×›× ×™ ××ª ×”×“×¤×“×¤×Ÿ.</div>
                `;
            }
        }
        
        function filterByType(type) {
            currentType = type;
            
            // Update button styles
            document.querySelectorAll('button[onclick^="filterByType"]').forEach(btn => {
                btn.className = 'px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all';
            });
            event.target.className = 'px-6 py-3 bg-indigo-500 text-white rounded-full hover:bg-indigo-600 transition-all';
            
            console.log('Filtering by type:', type);
            console.log('All pages:', allPages);
            console.log('Page types found:', [...new Set(allPages.map(p => p.pageType))]);
            
            if (type === 'all') {
                filteredPages = [...allPages];
            } else {
                filteredPages = allPages.filter(page => {
                    console.log(`Page: ${page.title}, pageType: ${page.pageType}, matches: ${page.pageType === type}`);
                    return page.pageType === type;
                });
            }
            
            console.log('Filtered pages:', filteredPages);
            displayPages();
            updatePagesCount();
        }
        
        async function searchPages() {
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            
            if (searchTerm === '') {
                filteredPages = [...allPages];
            } else {
                // Enhanced search that ALWAYS reads from live pages
                filteredPages = [];
                
                // Extract city and service/product from search term
                const cities = [
                    '×ª×œ ××‘×™×‘', '×™×¨×•×©×œ×™×', '×—×™×¤×”', '×‘××¨ ×©×‘×¢', '× ×ª× ×™×”', '××©×“×•×“', '×¨××ª ×’×Ÿ', '×¤×ª×— ×ª×§×•×•×”', 
                    '×‘× ×™ ×‘×¨×§', '×—×•×œ×•×Ÿ', '×¨×—×•×‘×•×ª', '×›×¤×¨ ×¡×‘×', '××™×œ×ª', '×¨×¢× × ×”', '×”×¨×¦×œ×™×”', '×—×“×¨×”', 
                    '×§×¨×™×™×ª ×‘×™××œ×™×§', '×§×¨×™×™×ª ××•×¦×§×™×Ÿ', '×¨××©×•×Ÿ ×œ×¦×™×•×Ÿ', '× ×”×¨×™×”', '×”×•×“ ×”×©×¨×•×Ÿ', '×’×‘×¢×ª×™×™×', 
                    '×§×¨×™×™×ª ××ª×', '×§×¨×™×™×ª ×©××•× ×”', '×‘×™×ª ×©××Ÿ', '×¢×¤×•×œ×”'
                ];
                
                let requiredCity = null;
                let serviceOrProduct = searchTerm;
                
                // Try multiple patterns to extract city
                // Pattern 1: "× ×’×¨ ×‘× ×ª× ×™×”" or "×©×™×¨×•×ª ×‘× ×ª× ×™×”" (service ×‘ city)
                const patternWithBe = /([×-×ª\s]+)\s+×‘([×-×ª]+)/;
                const matchWithBe = searchTerm.match(patternWithBe);
                if (matchWithBe && matchWithBe[2]) {
                    const potentialCity = matchWithBe[2].trim();
                    // Check if it's a known city
                    for (const city of cities) {
                        if (city.toLowerCase() === potentialCity.toLowerCase() || 
                            city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                            potentialCity.toLowerCase().includes(city.toLowerCase())) {
                            requiredCity = city;
                            // Extract service/product (what comes before "×‘")
                            serviceOrProduct = matchWithBe[1].trim();
                            serviceOrProduct = serviceOrProduct.replace(/^(×‘|×‘×ª×•×š|×‘×©×“×”|×©×œ|××ª|×¢×œ)\s+/g, '').trim();
                            console.log(`ğŸ™ï¸ Found city (×‘ pattern): "${city}", service/product: "${serviceOrProduct}"`);
                            break;
                        }
                    }
                    // If no match but it looks like a city (Hebrew word 2-15 chars), use it
                    if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15 && /^[×-×ª\s]+$/.test(potentialCity)) {
                        requiredCity = potentialCity;
                        serviceOrProduct = matchWithBe[1].trim();
                        serviceOrProduct = serviceOrProduct.replace(/^(×‘|×‘×ª×•×š|×‘×©×“×”|×©×œ|××ª|×¢×œ)\s+/g, '').trim();
                        console.log(`ğŸ™ï¸ Found city (new from ×‘ pattern): "${potentialCity}", service/product: "${serviceOrProduct}"`);
                    }
                }
                
                // Pattern 2: Exact city name in query
                if (!requiredCity) {
                    for (const city of cities) {
                        if (searchTerm.includes(city.toLowerCase())) {
                            requiredCity = city;
                            // Remove city from search term to get service/product
                            serviceOrProduct = searchTerm.replace(city.toLowerCase(), '').trim();
                            // Remove common prepositions
                            serviceOrProduct = serviceOrProduct.replace(/^(×‘|×‘×ª×•×š|×‘×©×“×”|×©×œ|××ª|×¢×œ)\s+/g, '').trim();
                            console.log(`ğŸ™ï¸ Found city (exact): "${city}", service/product: "${serviceOrProduct}"`);
                            break;
                        }
                    }
                }
                
                // Pattern 3: "(×‘|×‘×ª×•×š|×‘×©×“×”) ×¢×™×¨" pattern
                if (!requiredCity) {
                    const cityPattern = /(?:×‘|×‘×ª×•×š|×‘×©×“×”)\s+([×-×ª]{2,})/;
                    const cityMatch = searchTerm.match(cityPattern);
                    if (cityMatch && cityMatch[1]) {
                        const potentialCity = cityMatch[1].trim();
                        // Check if it's a known city (partial match)
                        for (const city of cities) {
                            if (city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                                potentialCity.toLowerCase().includes(city.toLowerCase())) {
                                requiredCity = city;
                                serviceOrProduct = searchTerm.replace(/(?:×‘|×‘×ª×•×š|×‘×©×“×”)\s*[×-×ª]+/g, '').trim();
                                serviceOrProduct = serviceOrProduct.replace(/^(×‘|×‘×ª×•×š|×‘×©×“×”|×©×œ|××ª|×¢×œ)\s+/g, '').trim();
                                console.log(`ğŸ™ï¸ Found city (pattern): "${city}", service/product: "${serviceOrProduct}"`);
                                break;
                            }
                        }
                        // If no match but it looks like a city, use it
                        if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15) {
                            requiredCity = potentialCity;
                            serviceOrProduct = searchTerm.replace(/(?:×‘|×‘×ª×•×š|×‘×©×“×”)\s*[×-×ª]+/g, '').trim();
                            serviceOrProduct = serviceOrProduct.replace(/^(×‘|×‘×ª×•×š|×‘×©×“×”|×©×œ|××ª|×¢×œ)\s+/g, '').trim();
                            console.log(`ğŸ™ï¸ Found city (new): "${potentialCity}", service/product: "${serviceOrProduct}"`);
                        }
                    }
                }
                
                // If service/product is empty after removing city, use full search term
                if (!serviceOrProduct || serviceOrProduct.length < 2) {
                    serviceOrProduct = searchTerm;
                }
                
                // Check if this is a "×—× ×•×™×•×ª ×‘..." or "× ×•×ª× ×™ ×©×¨×•×ª ×‘..." query
                const isStoresInCityQuery = /^×—× ×•×™×•×ª\s+×‘([×-×ª]+)$/.test(searchTerm);
                const isServicesInCityQuery = /^(?:× ×•×ª× ×™\s+×©×¨×•×ª|×‘×¢×œ×™\s+××§×¦×•×¢|×©×™×¨×•×ª×™×)\s+×‘([×-×ª]+)$/.test(searchTerm);
                
                if (isStoresInCityQuery || isServicesInCityQuery) {
                    // For "×—× ×•×™×•×ª ×‘× ×ª× ×™×”" or "× ×•×ª× ×™ ×©×¨×•×ª ×‘× ×ª× ×™×”" queries
                    const cityMatch = searchTerm.match(/×‘([×-×ª]+)$/);
                    if (cityMatch && cityMatch[1]) {
                        const queryCity = cityMatch[1].trim();
                        // Find the city in the cities list
                        for (const city of cities) {
                            if (city.toLowerCase() === queryCity.toLowerCase() || 
                                city.toLowerCase().includes(queryCity.toLowerCase()) || 
                                queryCity.toLowerCase().includes(city.toLowerCase())) {
                                requiredCity = city;
                                // Set service/product based on query type
                                if (isStoresInCityQuery) {
                                    serviceOrProduct = '×—× ×•×ª'; // Filter for stores
                                } else if (isServicesInCityQuery) {
                                    serviceOrProduct = '×©×™×¨×•×ª'; // Filter for services
                                }
                                console.log(`ğŸ™ï¸ Special query detected: "${isStoresInCityQuery ? '×—× ×•×™×•×ª' : '× ×•×ª× ×™ ×©×¨×•×ª'}" in "${city}"`);
                                break;
                            }
                        }
                        // If city not found in list, use it as-is
                        if (!requiredCity && queryCity.length >= 2 && queryCity.length <= 15) {
                            requiredCity = queryCity;
                            if (isStoresInCityQuery) {
                                serviceOrProduct = '×—× ×•×ª';
                            } else if (isServicesInCityQuery) {
                                serviceOrProduct = '×©×™×¨×•×ª';
                            }
                            console.log(`ğŸ™ï¸ Special query (new city): "${isStoresInCityQuery ? '×—× ×•×™×•×ª' : '× ×•×ª× ×™ ×©×¨×•×ª'}" in "${queryCity}"`);
                        }
                    }
                }
                
                for (const page of allPages) {
                    let matches = false;
                    
                    // For "×—× ×•×™×•×ª ×‘..." queries, check if page is a store
                    if (isStoresInCityQuery && page.pageType !== 'store') {
                        continue; // Skip non-store pages
                    }
                    
                    // For "× ×•×ª× ×™ ×©×¨×•×ª ×‘..." queries, check if page is a service provider
                    if (isServicesInCityQuery && page.pageType !== 'serviceProvider') {
                        continue; // Skip non-service pages
                    }
                    
                    // Check title and description for service/product
                    const titleMatch = page.title.toLowerCase().includes(serviceOrProduct);
                    const descriptionMatch = page.description && page.description.toLowerCase().includes(serviceOrProduct);
                    
                    // Check products from metadata (much faster!)
                    let productMatch = false;
                    if (page.products && Array.isArray(page.products) && page.products.length > 0) {
                        productMatch = page.products.some(product => 
                            product.name && product.name.toLowerCase().includes(serviceOrProduct)
                        );
                    }
                    
                    // For "×—× ×•×™×•×ª ×‘..." queries, match any store in the city (service/product can be empty)
                    // For "× ×•×ª× ×™ ×©×¨×•×ª ×‘..." queries, match any service provider in the city
                    const serviceMatches = isStoresInCityQuery || isServicesInCityQuery || titleMatch || descriptionMatch || productMatch;
                    
                    // If city is required, must check both service AND city
                    if (requiredCity) {
                        // Check city from metadata first (much faster!)
                        let cityMatches = false;
                        if (page.city) {
                            cityMatches = page.city.toLowerCase().includes(requiredCity.toLowerCase()) || 
                                         requiredCity.toLowerCase().includes(page.city.toLowerCase());
                        }
                        
                        // If no city in metadata, check HTML (for old pages)
                        if (!cityMatches) {
                            cityMatches = await checkPageHasCity(page, requiredCity);
                        }
                        
                        // Both service AND city must match
                        if (serviceMatches && cityMatches) {
                            matches = true;
                        } else if (serviceMatches && !cityMatches) {
                            // Service matches but city doesn't - try live content (might have different city)
                            const liveContentMatch = await checkLivePageContentWithCity(page, serviceOrProduct, requiredCity);
                            if (liveContentMatch) {
                                matches = true;
                            }
                        }
                    } else {
                        // No city requirement - check service/product only
                        if (serviceMatches) {
                            matches = true;
                        } else {
                            // Check live page content (for old pages without metadata)
                            const liveContentMatch = await checkLivePageContent(page, serviceOrProduct);
                            if (liveContentMatch) {
                                matches = true;
                            }
                        }
                    }
                    
                    if (matches) {
                        filteredPages.push(page);
                    }
                }
            }
            
            displayPages();
            updatePagesCount();
        }
        
        // Check if page has specific city (using metadata first, fallback to HTML)
        async function checkPageHasCity(page, requiredCity) {
            // First check metadata (much faster!)
            if (page.city) {
                return page.city.toLowerCase().includes(requiredCity.toLowerCase()) || 
                       requiredCity.toLowerCase().includes(page.city.toLowerCase());
            }
            
            // Fallback: check HTML (for old pages without metadata)
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (response.ok) {
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    const cityLower = requiredCity.toLowerCase();
                    
                    // Check if city appears in page content
                    return htmlLower.includes(cityLower);
                }
            } catch (error) {
                console.error('Error checking page city:', error);
            }
            return false;
        }
        
        // Enhanced version that also checks for city
        async function checkLivePageContentWithCity(page, searchTerm, requiredCity) {
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (response.ok) {
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    
                    // Check if search term appears in page content
                    const found = htmlLower.includes(searchTerm.toLowerCase());
                    
                    // If city is required, verify it exists in page
                    if (requiredCity && found) {
                        const cityFound = htmlLower.includes(requiredCity.toLowerCase());
                        return cityFound;
                    }
                    
                    // Also check for price patterns
                    if (searchTerm.includes('â‚ª') || searchTerm.includes('×©×§×œ')) {
                        const priceMatch = htmlLower.match(/â‚ª\d+/g);
                        if (priceMatch) {
                            console.log(`ğŸ’° Found prices in ${page.title}:`, priceMatch);
                            return true;
                        }
                    }
                    
                    return found;
                }
            } catch (error) {
                console.error('Error checking live page content:', error);
            }
            return false;
        }
        
        // New function to check live page content
        async function checkLivePageContent(page, searchTerm) {
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (response.ok) {
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    
                    // Check if search term appears in page content
                    const found = htmlLower.includes(searchTerm.toLowerCase());
                    console.log(`ğŸ” Live search for "${searchTerm}" in ${page.title}: ${found}`);
                    
                    // Also check for price patterns
                    if (searchTerm.includes('â‚ª') || searchTerm.includes('×©×§×œ')) {
                        const priceMatch = htmlLower.match(/â‚ª\d+/g);
                        if (priceMatch) {
                            console.log(`ğŸ’° Found prices in ${page.title}:`, priceMatch);
                            return true;
                        }
                    }
                    
                    return found;
                }
            } catch (error) {
                console.error('Error checking live page content:', error);
            }
            return false;
        }
        
        function displayPages() {
            if (currentView === 'grid') {
                displayGrid();
            } else {
                displayTable();
            }
        }
        
        function displayGrid() {
            const grid = document.getElementById('pages-grid');
            const table = document.getElementById('pages-table');
            
            grid.classList.remove('hidden');
            table.classList.add('hidden');
            
            grid.innerHTML = '';
            
            if (filteredPages.length === 0) {
                grid.innerHTML = '<div class="col-span-full text-center text-gray-500 py-8">×œ× × ××¦××• ×“×¤×™×</div>';
                return;
            }
            
            filteredPages.forEach(page => {
                const pageCard = createPageCard(page);
                grid.appendChild(pageCard);
            });
        }
        
        function displayTable() {
            const grid = document.getElementById('pages-grid');
            const table = document.getElementById('pages-table');
            const tbody = document.getElementById('table-body');
            
            grid.classList.add('hidden');
            table.classList.remove('hidden');
            
            tbody.innerHTML = '';
            
            if (filteredPages.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="px-6 py-4 text-center text-gray-500">×œ× × ××¦××• ×“×¤×™×</td></tr>';
                return;
            }
            
            filteredPages.forEach(page => {
                const row = createTableRow(page);
                tbody.appendChild(row);
            });
        }
        
        function setView(view) {
            currentView = view;
            
            // Update button styles
            document.getElementById('grid-view-btn').className = view === 'grid' ? 
                'p-3 rounded-full bg-white bg-opacity-30 text-white hover:bg-opacity-40 transition-all' :
                'p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all';
            document.getElementById('table-view-btn').className = view === 'table' ? 
                'p-3 rounded-full bg-white bg-opacity-30 text-white hover:bg-opacity-40 transition-all' :
                'p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all';
            
            displayPages();
        }
        
        function createPageCard(page) {
            const card = document.createElement('div');
            card.className = 'page-card bg-white rounded-lg shadow-md overflow-hidden';
            
            const typeIcons = {
                'store': 'ğŸª',
                'event': 'ğŸ‰',
                'course': 'ğŸ“',
                'serviceProvider': 'ğŸ”§',
                'other': 'ğŸ“„'
            };
            
            const icon = typeIcons[page.pageType] || 'ğŸ“„';
            const typeName = getTypeName(page.pageType);
            
            // Fix image URL - convert relative paths to absolute
            let imageUrl = page.thumbnail || '';
            if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
                imageUrl = `/output/${page.userId}/${imageUrl}`;
            }
            
            
            // Use /users/ route like in the main interface
            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
            
            // Try to find a screenshot image - only for courses
            const screenshotUrl = page.pageType === 'course' ? page.thumbnail : null;
            
            card.innerHTML = `
                <!-- ×ª×¦×•×’×” ××§×“×™××” ×©×œ ×”××ª×¨ -->
                <div class="relative rounded-t-xl overflow-hidden bg-gradient-to-br from-gray-50 to-gray-100" style="height: 200px; flex-shrink: 0;">
                    ${screenshotUrl ? `
                        <!-- ×ª×¦×•×’×” ××§×“×™××” ×¢× ×ª××•× ×” -->
                        <img 
                            src="${screenshotUrl}" 
                            alt="${page.title}"
                            class="w-full h-full object-cover"
                            onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                        />
                        <div class="absolute inset-0 bg-gradient-to-br from-indigo-500/10 to-purple-500/10 hidden items-center justify-center">
                            <div class="text-center">
                                <div class="w-16 h-16 bg-white/90 rounded-full flex items-center justify-center mx-auto mb-3 shadow-lg border-2 border-indigo-200">
                                    <span class="text-2xl font-bold text-indigo-600">${icon}</span>
                                </div>
                                <div class="text-sm font-medium text-gray-700 bg-white/90 px-3 py-1 rounded-full shadow-sm border border-gray-200">
                                    ${typeName}
                                </div>
                            </div>
                        </div>
                    ` : `
                        <!-- ×ª×¦×•×’×” ××§×“×™××” ×¢× iframe -->
                        <div class="absolute inset-2 bg-white rounded-lg overflow-hidden shadow-lg border border-gray-300">
                            <iframe 
                                src="${window.location.origin}${pageUrl}" 
                                class="w-full h-full border-0"
                                style="pointer-events: none; transform: scale(0.6) translateX(65%); transform-origin: top left; width: 166.67%; height: 166.67%;"
                                title="×ª×¦×•×’×” ××§×“×™××” ×©×œ ${page.title}"
                                loading="lazy"
                                importance="low"
                                sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-downloads allow-modals allow-top-navigation allow-presentation">
                            </iframe>
                        </div>
                    `}
                </div>
                <div class="p-6">
                    <h3 class="text-xl font-semibold text-gray-900 mb-2">${page.title}</h3>
                    <p class="text-gray-600 mb-4">${page.description || '×œ×œ× ×ª×™××•×¨'}</p>
                    <div class="flex items-center justify-between">
                        <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-indigo-100 text-indigo-800">
                            ${icon} ${typeName}
                        </span>
                        <a href="/view/${page.userId}/${page.pageId}_html" target="_blank" 
                           class="text-indigo-600 hover:text-indigo-800 font-medium">
                            ×¦×¤×” ×‘×“×£ â†’
                        </a>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createTableRow(page) {
            const row = document.createElement('tr');
            row.className = 'hover:bg-gray-50';
            
            const typeIcons = {
                'store': 'ğŸª',
                'event': 'ğŸ‰',
                'course': 'ğŸ“',
                'serviceProvider': 'ğŸ”§',
                'other': 'ğŸ“„'
            };
            
            const icon = typeIcons[page.pageType] || 'ğŸ“„';
            const typeName = getTypeName(page.pageType);
            
            // Fix image URL
            let imageUrl = page.thumbnail || '';
            if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
                imageUrl = `/output/${page.userId}/${imageUrl}`;
            }
            
            // Use /users/ route like in the main interface
            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
            
            const createdDate = new Date(page.created_at).toLocaleDateString('he-IL');
            
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap">
                    <div class="flex-shrink-0 h-16 w-16">
                        ${imageUrl ? `
                            <!-- ×ª×¦×•×’×” ××§×“×™××” ×¢× ×ª××•× ×” -->
                            <div class="h-16 w-16 rounded-lg overflow-hidden border border-gray-300 bg-white shadow-sm">
                                <img 
                                    src="${imageUrl}" 
                                    alt="${page.title}"
                                    class="w-full h-full object-cover"
                                    onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                />
                                <div class="h-16 w-16 rounded-lg bg-gradient-to-br from-indigo-100 to-purple-100 flex items-center justify-center text-2xl hidden">${icon}</div>
                            </div>
                        ` : `
                            <!-- Placeholder ×¢× ××™×™×§×•×Ÿ - ×œ× iframe ×›×™ ×–×” ×œ× ×¢×•×‘×“ ×˜×•×‘ ×‘×˜×‘×œ×” ×§×˜× ×” -->
                            <div class="h-16 w-16 rounded-lg bg-gradient-to-br from-indigo-100 via-purple-50 to-pink-100 border-2 border-indigo-200 shadow-sm flex flex-col items-center justify-center">
                                <div class="text-3xl mb-1">${icon}</div>
                                <div class="text-[10px] font-medium text-indigo-700 text-center px-1 truncate w-full">${typeName}</div>
                            </div>
                        `}
                    </div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <div class="text-sm font-medium text-gray-900">${page.title}</div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800">
                        ${icon} ${typeName}
                    </span>
                </td>
                <td class="px-6 py-4">
                    <div class="text-sm text-gray-500 max-w-xs truncate">${page.description || '×œ×œ× ×ª×™××•×¨'}</div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    ${createdDate}
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                    <a href="/view/${page.userId}/${page.pageId}_html" target="_blank" 
                       class="text-indigo-600 hover:text-indigo-900">
                        ×¦×¤×” ×‘×“×£
                    </a>
                </td>
            `;
            
            return row;
        }
        
        function getTypeName(type) {
            const names = {
                'store': '×—× ×•×ª',
                'event': '××™×¨×•×¢',
                'course': '×§×•×¨×¡',
                'serviceProvider': '×‘×¢×œ ××§×¦×•×¢',
                'other': '××—×¨'
            };
            return names[type] || '××—×¨';
        }
        
        function updatePagesCount() {
            const count = filteredPages.length;
            const total = allPages.length;
            document.getElementById('pages-count').textContent = 
                `××¦×™×’ ${count} ××ª×•×š ${total} ×“×¤×™×`;
        }
        
        
        // Extract product info from description and HTML content
        async function extractProductInfo(description, keyword, pageUrl = null) {
            if (!description) return null;
            
            const desc = description.toLowerCase();
            const keywordLower = keyword.toLowerCase();
            
            // Look for price patterns - more comprehensive
            const pricePatterns = [
                /(\d+)\s*â‚ª/g,
                /(\d+)\s*×©×§×œ/g,
                /(\d+)\s*×©"×—/g,
                /××—×™×¨[:\s]*(\d+)/g,
                /(\d+)\s*-\s*(\d+)\s*â‚ª/g,
                /××—×™×¨[:\s]*(\d+)\s*-\s*(\d+)/g,
                /(\d+)\s*×œ×××”/g,
                /(\d+)\s*×œ××˜×”/g,
                /(\d+)\s*×œ××¢×œ×”/g
            ];
            
            let price = null;
            for (const pattern of pricePatterns) {
                const match = pattern.exec(desc);
                if (match) {
                    if (match[2]) {
                        price = `${match[1]}-${match[2]}â‚ª`;
                    } else {
                        price = `${match[1]}â‚ª`;
                    }
                    break;
                }
            }
            
            // Look for location patterns
            const locationPatterns = [
                /××™×§×•×[:\s]*([^,.\n]{2,50})/g,
                /×›×ª×•×‘×ª[:\s]*([^,.\n]{2,50})/g,
                /× ××¦×[:\s]*([^,.\n]{2,50})/g,
                /×‘[:\s]*([^,.\n]{2,50})/g
            ];
            
            let location = null;
            for (const pattern of locationPatterns) {
                const match = pattern.exec(desc);
                if (match && match[1] && match[1].length > 2) {
                    location = match[1].trim();
                    break;
                }
            }
            
            // Look for product name patterns - more specific
            let productName = null;
            if (keywordLower === '×©×¢×•×Ÿ') {
                const watchPatterns = [
                    /×©×¢×•×Ÿ\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*×©×¢×•×Ÿ/g,
                    /×©×¢×•×Ÿ\s+([×-×ª\s]{2,30})/g,
                    /([×-×ª\s]{2,30})\s*×©×¢×•×Ÿ\s+([×-×ª\s]{2,30})/g
                ];
                for (const pattern of watchPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            } else if (keywordLower === '×ª×›×©×™×˜') {
                const jewelryPatterns = [
                    /×ª×›×©×™×˜\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*×ª×›×©×™×˜/g,
                    /([^,.\n]{2,30})\s*×–×”×‘/g,
                    /([^,.\n]{2,30})\s*×›×¡×£/g
                ];
                for (const pattern of jewelryPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            } else if (keywordLower === '×¦×¢×¦×•×¢') {
                const toyPatterns = [
                    /×¦×¢×¦×•×¢\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*×¦×¢×¦×•×¢/g,
                    /([^,.\n]{2,30})\s*××©×—×§/g
                ];
                for (const pattern of toyPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            }
            
            // If we have a page URL, try to fetch the HTML content to find more prices
            if (pageUrl && (!price || !productName)) {
                try {
                    console.log('ğŸ” Fetching HTML for:', pageUrl);
                    const response = await fetch(pageUrl);
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    
                    console.log('ğŸ“„ HTML length:', html.length);
                    
                    // Look for prices in HTML content
                    if (!price) {
                        console.log('ğŸ’° Looking for prices in HTML...');
                        const htmlPricePatterns = [
                            /<p class="product-price[^"]*"[^>]*>â‚ª(\d+(?:,\d+)?)<\/p>/g,
                            /class="product-price[^"]*"[^>]*>â‚ª(\d+(?:,\d+)?)/g,
                            /â‚ª\s*(\d+(?:,\d+)?)/g,
                            /(\d+(?:,\d+)?)\s*â‚ª/g
                        ];
                        
                        for (const pattern of htmlPricePatterns) {
                            const matches = [...html.matchAll(pattern)];
                            console.log('ğŸ” Pattern matches:', pattern, matches.length);
                            if (matches.length > 0) {
                                // Get the first price found
                                const firstPrice = matches[0][1] || matches[0][0].match(/(\d+(?:,\d+)?)/)?.[1];
                                console.log('ğŸ’° Found price:', firstPrice);
                                if (firstPrice) {
                                    price = `â‚ª${firstPrice}`;
                                    break;
                                }
                            }
                        }
                        
                        // If still no price, try a simpler approach
                        if (!price) {
                            console.log('ğŸ” Trying simple price search...');
                            const simplePriceMatch = html.match(/â‚ª\s*(\d+(?:,\d+)?)/);
                            console.log('ğŸ’° Simple match result:', simplePriceMatch);
                            if (simplePriceMatch) {
                                price = `â‚ª${simplePriceMatch[1]}`;
                            }
                        }
                        
                        console.log('ğŸ’° Final price found:', price);
                    }
                    
                    // Look for product names in HTML content
                    if (!productName && keywordLower === '×©×¢×•×Ÿ') {
                        const watchPatterns = [
                            /×©×¢×•×Ÿ\s+([^<>{}\n]{2,30})/g,
                            /([^<>{}\n]{2,30})\s*×©×¢×•×Ÿ/g,
                            /<h[1-6][^>]*>.*?×©×¢×•×Ÿ\s+([^<]{2,30})/g,
                            /class="[^"]*product-name[^"]*"[^>]*>([^<]+)/g,
                            /<h3[^>]*>([^<]*×©×¢×•×Ÿ[^<]*)<\/h3>/g
                        ];
                        
                        for (const pattern of watchPatterns) {
                            const matches = [...html.matchAll(pattern)];
                            if (matches.length > 0) {
                                productName = matches[0][1].trim();
                                break;
                            }
                        }
                    }
                } catch (error) {
                    console.log('Could not fetch HTML content:', error);
                }
            }
            
            if (productName || price || location) {
                return {
                    name: productName || `${keyword} ××™×•×—×“`,
                    price: price || '××—×™×¨ ×œ×¤×™ ×‘×§×©×”',
                    location: location || '××™×§×•× ×œ× ×¦×•×™×Ÿ'
                };
            }
            
            return null;
        }

        // Smart search functionality - copied from Stav the Great
        let lastSearchContext = null; // Remember last search context
        let lastSearchResults = []; // Remember last search results
        
        async function handleSmartSearch(message, allPages) {
            const lowerMessage = message.toLowerCase();
            
            // Handle greetings and personal questions - NO FIXED MESSAGES
            if (lowerMessage.includes('×©×œ×•×') || lowerMessage.includes('×”×™×™') || lowerMessage.includes('×”×™') || 
                lowerMessage.includes('×©××™') || lowerMessage.includes('×§×•×¨××™× ×œ×™') || lowerMessage.includes('×× ×™') ||
                lowerMessage.includes('××” ×©×œ×•××š') || lowerMessage.includes('××™×š ××ª×”') || lowerMessage.includes('××™×š ××ª')) {
                return null; // Send to N8N instead of fixed message
            }
            
            // Handle context switching (e.g., "×•×œ×’×‘×¨" after "××ª× ×” ×œ×™×œ×“")
            if (lowerMessage.includes('×•×œ×’×‘×¨') || lowerMessage.includes('×•×œ××™×©×”') || lowerMessage.includes('×•×œ×™×œ×“') || 
                lowerMessage.includes('×•×œ×’×‘×¨×™×') || lowerMessage.includes('×•×œ× ×©×™×') || lowerMessage.includes('×•×œ×™×œ×“×™×')) {
                // Extract the gift type from context
                let giftType = '××ª× ×”';
                if (lowerMessage.includes('×’×‘×¨') || lowerMessage.includes('×’×‘×¨×™×')) giftType = '××ª× ×” ×œ×’×‘×¨';
                else if (lowerMessage.includes('××™×©×”') || lowerMessage.includes('× ×©×™×')) giftType = '××ª× ×” ×œ××™×©×”';
                else if (lowerMessage.includes('×™×œ×“') || lowerMessage.includes('×™×œ×“×™×')) giftType = '××ª× ×” ×œ×™×œ×“';
                
                // Process as gift search
                const giftResult = await handleSmartSearch(giftType, allPages);
                if (giftResult) return giftResult;
            }
            
            // Handle greetings and personal questions - NO FIXED MESSAGES
            if (lowerMessage.includes('×©×œ×•×') || lowerMessage.includes('×”×™×™') || lowerMessage.includes('×”×™') || 
                lowerMessage.includes('××” ×©×œ×•××š') || lowerMessage.includes('××™×š ××ª×”') || lowerMessage.includes('××™×š ××ª') ||
                lowerMessage.includes('×©××™') || lowerMessage.includes('×§×•×¨××™× ×œ×™') || lowerMessage.includes('×× ×™ ×™× ×™×‘') || lowerMessage.includes('×× ×™ ×™××—×ª')) {
                return null; // Send to N8N instead of fixed message
            }
            
            // ğŸ¯ FIX: FIRST check if this is a marketplace query - handle locally, don't send to N8N!
            const isMarketplacePriceQuery = lowerMessage.includes('××” ×”××•×¦×¨') || lowerMessage.includes('××” ××—×™×¨') || 
                                            lowerMessage.includes('××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ') || lowerMessage.includes('××” ×”××•×¦×¨ ×”×›×™ ×™×§×¨') ||
                                            lowerMessage.includes('×”××•×¦×¨ ×”×›×™ ×–×•×œ ×‘××¨×§×˜') || lowerMessage.includes('×”××•×¦×¨ ×”×›×™ ×–×•×œ ×‘××¨×§×˜×¤×œ×™×™×¡') ||
                                            (lowerMessage.includes('××”') && (lowerMessage.includes('×‘××¨×§×˜') || lowerMessage.includes('×¨×§×˜×¤×œ×™×™×¡') || lowerMessage.includes('×”×›×™ ×–×•×œ') || lowerMessage.includes('×”×›×™ ×™×§×¨')));
            
            // Handle knowledge questions - send to N8N (but NOT marketplace queries!)
            // ğŸ¯ FIX: "××” ×’×•×“×œ ×™×¤×Ÿ", "××” ×–×” X" are general knowledge, NOT marketplace!
            // BUT: "××” ××—×™×¨", "××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ" ARE marketplace!
            const isGeneralKnowledgeQuery = (lowerMessage.includes('××” ×’×•×“×œ') ||  // "××” ×’×•×“×œ ×™×¤×Ÿ"
                                             lowerMessage.includes('××” ×–×”') ||    // "××” ×–×” X"
                                             lowerMessage === '××”' ||             // Just "××”"
                                             (lowerMessage.includes('××”') &&      // "××” X" where X is NOT marketplace-related
                                              !lowerMessage.includes('××—×™×¨') && 
                                              !lowerMessage.includes('××•×¦×¨') && 
                                              !lowerMessage.includes('××ª× ×”') && 
                                              !lowerMessage.includes('×‘××¨×§×˜') &&
                                              !lowerMessage.includes('×¨×§×˜×¤×œ×™×™×¡') &&
                                              !lowerMessage.includes('×—× ×•×ª') &&
                                              !lowerMessage.includes('×©×™×¨×•×ª') &&
                                              !lowerMessage.includes('×œ×§') &&
                                              !lowerMessage.includes('×©×¢×•×Ÿ') &&
                                              !lowerMessage.includes('×¦×¢×¦×•×¢'))) &&
                                             !isMarketplacePriceQuery;
            
            if (isGeneralKnowledgeQuery || 
                (!isMarketplacePriceQuery && (lowerMessage.includes('××™×š') || 
                 lowerMessage.includes('××ª×™') || 
                 (lowerMessage.includes('××™×¤×”') && !lowerMessage.includes('×—× ×•×ª') && !lowerMessage.includes('×œ×§') && !lowerMessage.includes('×©×¢×•×Ÿ')) ||
                 lowerMessage.includes('×œ××”') ||
                 (lowerMessage.includes('×›××”') && !lowerMessage.includes('××—×™×¨') && !lowerMessage.includes('××•×¦×¨') && !lowerMessage.includes('×¢×•×œ×”')) ||
                 lowerMessage.includes('××™') || 
                 lowerMessage.includes('××™×–×”')))) {
                console.log('ğŸ“š General knowledge query detected - sending to N8N');
                return null; // Send to N8N for general knowledge questions
            }
            
            // Only search for pages if user is specifically looking for something
            // ğŸ¯ FIX: Also catch "××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ ×‘××¨×§×˜" variations - handle locally, don't send to N8N!
            // ğŸ¯ NEW: Add "×ª××œ×™×¦×™", "××ª× ×” ×œ", "××•×¦×¨ ×œ" as marketplace queries
            const isMarketplaceQuery = isMarketplacePriceQuery || 
                lowerMessage.includes('××ª× ×”') || lowerMessage.includes('×œ×§') || lowerMessage.includes('×©×¢×•×Ÿ') || 
                lowerMessage.includes('×¦×¢×¦×•×¢') || lowerMessage.includes('×§×•×¨×¡') || lowerMessage.includes('×—× ×•×ª') || 
                lowerMessage.includes('×©×™×¨×•×ª') || lowerMessage.includes('××™×¨×•×¢') || lowerMessage.includes('××—×™×¨') || 
                lowerMessage.includes('×›××”') || lowerMessage.includes('×¢×•×œ×”') || lowerMessage.includes('â‚ª') || 
                lowerMessage.includes('×©×§×œ') || lowerMessage.includes('×”×›×™ ×–×•×œ') || lowerMessage.includes('×”×›×™ ×™×§×¨') || 
                lowerMessage.includes('×”×©×•×•××”') || lowerMessage.includes('× ×’×™×“') || lowerMessage.includes('×•×œ×§') || 
                lowerMessage.includes('×•×©×¢×•×Ÿ') || lowerMessage.includes('×•×¦×¢×¦×•×¢') || lowerMessage.includes('×¦×¢×¦×•×¢×™×') || 
                lowerMessage.includes('×©×¢×•× ×™×') || lowerMessage.includes('×‘××¨×§×˜') || lowerMessage.includes('×¨×§×˜×¤×œ×™×™×¡') ||
                // ğŸ¯ NEW: Handle "×ª××œ×™×¦×™", "××ª× ×” ×œ", "××•×¦×¨ ×œ", "×ª×¨××™ ××•×¦×¨×™×" queries
                lowerMessage.includes('×ª××œ×™×¦×™') || lowerMessage.includes('×ª××œ×™×¥') || lowerMessage.includes('×”××œ×¦') ||
                lowerMessage.includes('×ª×¨××™ ××•×¦×¨×™×') || lowerMessage.includes('×ª×¨××™ ××—×™×¨×™×') ||
                lowerMessage.includes('××•×¦×¨×™× ×•××—×™×¨×™×') ||
                (lowerMessage.includes('×ª×¨××™') && (lowerMessage.includes('××•×¦×¨') || lowerMessage.includes('××—×™×¨'))) ||
                (lowerMessage.includes('××ª× ×”') && (lowerMessage.includes('×œ') || lowerMessage.includes('×œ××™×©×”') || 
                 lowerMessage.includes('×œ×‘×—×•×¨×”') || lowerMessage.includes('×œ××©×”') ||
                 lowerMessage.includes('×œ×’×‘×¨') || lowerMessage.includes('×œ×‘×—×•×¨') || 
                 lowerMessage.includes('×œ×‘×¢×œ') || lowerMessage.includes('×œ×‘×¢×œ×™') ||
                 lowerMessage.includes('×œ×™×œ×“'))) ||
                (lowerMessage.includes('××•×¦×¨') && (lowerMessage.includes('×œ') || lowerMessage.includes('×œ××™×©×”') || 
                 lowerMessage.includes('×œ×‘×—×•×¨×”') || lowerMessage.includes('×œ××©×”') ||
                 lowerMessage.includes('×œ×’×‘×¨') || lowerMessage.includes('×œ×‘×—×•×¨') ||
                 lowerMessage.includes('×œ×‘×¢×œ') || lowerMessage.includes('×œ×‘×¢×œ×™') ||
                 lowerMessage.includes('×œ×™×œ×“'))) ||
                (lowerMessage.includes('××¨×§×˜') || lowerMessage.includes('××¨×§×˜×¤×œ×™×™×¡')) && 
                 (lowerMessage.includes('×ª××œ×™×¦×™') || lowerMessage.includes('×ª××œ×™×¥') || lowerMessage.includes('××•×¦×¨') || 
                  lowerMessage.includes('××ª× ×”') || lowerMessage.includes('×”××œ×¦'));
            
            if (!isMarketplaceQuery) {
                // For other general questions, send to N8N
                return null; // Let N8N handle general questions
            }
            
            // Reset search context if user is searching for something new
            if (lowerMessage.includes('××—×¤×©') || lowerMessage.includes('×”××œ×¦') || lowerMessage.includes('×œ×') || lowerMessage.includes('×œ× ') || lowerMessage.includes('× ×’×™×“') || lowerMessage.includes('×•×œ×§') || lowerMessage.includes('×•×©×¢×•×Ÿ') || lowerMessage.includes('×•×¦×¢×¦×•×¢') || lowerMessage.includes('×¦×¢×¦×•×¢×™×') || lowerMessage.includes('×¦×¢×¦×•×¢') || lowerMessage.includes('×©×¢×•× ×™×') || lowerMessage.includes('×©×¢×•×Ÿ')) {
                lastSearchContext = null;
                lastSearchResults = [];
                console.log('ğŸ”„ Reset search context for new search or rejection');
            }
            
            // Special handling for "cheapest" or "most expensive" across all pages
            // âœ… Added more variations like "××•×¦×¨ ×–×•×œ", "××•×¦×¨ ×”×–×•×œ", "×”××•×¦×¨ ×”×–×•×œ"
            // ğŸ¯ FIX: Also handle "××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ ×‘××¨×§×˜" and variations
            if (lowerMessage.includes('×”×›×™ ×–×•×œ') || lowerMessage.includes('×”×›×™ ×™×§×¨') || lowerMessage.includes('×”×©×•×•××”') || 
                lowerMessage.includes('××•×¦×¨ ×–×•×œ') || lowerMessage.includes('××•×¦×¨ ×”×–×•×œ') || lowerMessage.includes('×”××•×¦×¨ ×”×–×•×œ') ||
                lowerMessage.includes('××•×¦×¨ ×™×§×¨') || lowerMessage.includes('××•×¦×¨ ×”×™×§×¨') || lowerMessage.includes('×”××•×¦×¨ ×”×™×§×¨') ||
                lowerMessage.includes('××” ×”×–×•×œ') || lowerMessage.includes('××” ×”×™×§×¨') || lowerMessage.includes('×–×•×œ ×‘×™×•×ª×¨') || lowerMessage.includes('×™×§×¨ ×‘×™×•×ª×¨') ||
                lowerMessage.includes('××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ') || lowerMessage.includes('××” ×”××•×¦×¨ ×”×›×™ ×™×§×¨') ||
                lowerMessage.includes('×”××•×¦×¨ ×”×›×™ ×–×•×œ ×‘××¨×§×˜') || lowerMessage.includes('×”××•×¦×¨ ×”×›×™ ×–×•×œ ×‘××¨×§×˜×¤×œ×™×™×¡') ||
                lowerMessage.includes('××—×™×¨×™×') || lowerMessage.includes('××—×™×¨') || lowerMessage.includes('×›××” ×¢×•×œ×”') || 
                lowerMessage.includes('×”×©×•×•×') || lowerMessage.includes('×”×©×•×•×™×”')) {
                console.log('ğŸ” Price comparison search triggered:', lowerMessage);
                
                // Determine what product they're looking for
                let searchKeyword = '';
                
                // ğŸ§  FIRST: Check conversation context (if user already said what they want)
                if (window.marketplaceConversationContext && window.marketplaceConversationContext.lastSearchCategory) {
                    const lastCategory = window.marketplaceConversationContext.lastSearchCategory.toLowerCase();
                    // If last search was for a specific category, use it!
                    if (lastCategory.includes('×¦×¢×¦×•×¢')) searchKeyword = '×¦×¢×¦×•×¢';
                    else if (lastCategory.includes('×©×¢×•×Ÿ')) searchKeyword = '×©×¢×•×Ÿ';
                    else if (lastCategory.includes('×œ×§')) searchKeyword = '×œ×§';
                    else if (lastCategory.includes('×ª×›×©×™×˜')) searchKeyword = '×ª×›×©×™×˜';
                    else if (lastCategory.includes('×˜×›× ×•×œ×•×’×™×”')) searchKeyword = '×˜×›× ×•×œ×•×’×™×”';
                    
                    console.log('ğŸ§  Using last search context:', searchKeyword);
                }
                
                // If no context, check the current message
                if (!searchKeyword) {
                    // âœ… Check for product keywords (including "×”" prefix like "×”×¦×¢×¦×•×¢", "×”×ª×›×©×™×˜")
                    if (lowerMessage.includes('×©×¢×•×Ÿ') || lowerMessage.includes('×©×¢×•× ×™×') || lowerMessage.includes('×”×©×¢×•×Ÿ')) searchKeyword = '×©×¢×•×Ÿ';
                    else if (lowerMessage.includes('×¦×¢×¦×•×¢') || lowerMessage.includes('×¦×¢×¦×•×¢×™×') || lowerMessage.includes('×”×¦×¢×¦×•×¢')) searchKeyword = '×¦×¢×¦×•×¢';
                    else if (lowerMessage.includes('×œ×§') || lowerMessage.includes('×”×œ×§')) searchKeyword = '×œ×§';
                    else if (lowerMessage.includes('×ª×›×©×™×˜') || lowerMessage.includes('×ª×›×©×™×˜×™×') || lowerMessage.includes('×”×ª×›×©×™×˜')) searchKeyword = '×ª×›×©×™×˜';
                    else if (lowerMessage.includes('×˜×›× ×•×œ×•×’×™×”') || lowerMessage.includes('×”×˜×›× ×•×œ×•×’×™×”')) searchKeyword = '×˜×›× ×•×œ×•×’×™×”';
                    else if (lowerMessage.includes('× ×§×™×•×Ÿ') || lowerMessage.includes('× ×§×”') || lowerMessage.includes('× ×™×§×•×™')) searchKeyword = '× ×§×™×•×Ÿ';
                    else if (lowerMessage.includes('× ×’×¨') || lowerMessage.includes('×ª×™×§×•×Ÿ') || lowerMessage.includes('×‘×¢×™×•×ª ××™×')) searchKeyword = '×©×™×¨×•×ª×™×';
                    else searchKeyword = '××•×¦×¨';
                }
                
                console.log('ğŸ” Search keyword for comparison:', searchKeyword);
                console.log('ğŸ“Š Original message:', userMessage);
                console.log('ğŸ“Š Lowercase message:', lowerMessage);
                
                // ğŸ’¾ SAVE the search category for future reference
                window.marketplaceConversationContext.lastSearchCategory = searchKeyword;
                console.log('ğŸ’¾ Saved search category:', searchKeyword);
                
                // ğŸ”¥ NEW APPROACH: Filter pages AFTER reading their live content!
                let relevantPages = [];
                
                if (searchKeyword === '××•×¦×¨') {
                    // For general "××•×¦×¨" - include all store pages AND messageInBottle
                    relevantPages = allPages.filter(page => page.pageType === 'store' || page.pageType === 'messageInBottle');
                } else {
                    // ğŸ”¥ FOR SPECIFIC CATEGORIES - Read LIVE HTML and check!
                    const pluralKeyword = searchKeyword + '×™×';
                    
                    for (const page of allPages) {
                        // Include both store pages AND messageInBottle pages
                        if (page.pageType !== 'store' && page.pageType !== 'messageInBottle') continue;
                        
                        const titleLower = page.title.toLowerCase();
                        const descLower = (page.description || '').toLowerCase();
                        const requestLower = (page.request || '').toLowerCase();
                        
                        // Quick check: Title, description, or request match
                        if (titleLower.includes(searchKeyword) || titleLower.includes(pluralKeyword) ||
                            descLower.includes(searchKeyword) || descLower.includes(pluralKeyword) ||
                            requestLower.includes(searchKeyword) || requestLower.includes(pluralKeyword)) {
                            relevantPages.push(page);
                            console.log(`âœ… Page "${page.title}" matched by title/description/request`);
                            continue;
                        }
                        
                        // ğŸ”¥ If not in title/desc, check LIVE products!
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            
                            // ğŸ”¥ Extract LIVE products and check if ANY product matches the keyword!
                            const liveProducts = extractLiveProducts(html);
                            const hasMatchingProduct = liveProducts.some(product => {
                                const productName = product.name.toLowerCase();
                                return productName.includes(searchKeyword) || productName.includes(pluralKeyword);
                            });
                            
                            if (hasMatchingProduct) {
                                relevantPages.push(page);
                                console.log(`âœ… Page "${page.title}" matched by LIVE products`);
                            } else {
                                console.log(`âŒ Page "${page.title}" has NO products matching "${searchKeyword}"`);
                            }
                        } catch (error) {
                            console.error('Error checking page:', page.title, error);
                        }
                    }
                }
                
                console.log(`ğŸ” Found ${relevantPages.length} pages matching "${searchKeyword}":`, relevantPages.map(p => p.title));
                
                if (relevantPages.length > 0) {
                    // Check if we have messageInBottle pages
                    const messageInBottlePages = relevantPages.filter(page => page.pageType === 'messageInBottle');
                    const storePages = relevantPages.filter(page => page.pageType === 'store');
                    
                    // Handle messageInBottle pages differently
                    if (messageInBottlePages.length > 0) {
                        let response = '';
                        
                        if (messageInBottlePages.length === 1) {
                            const page = messageInBottlePages[0];
                            response = `ğŸ¾ **××¦××ª×™ ××¡×¨ ×‘×‘×§×‘×•×§ ×¨×œ×•×•× ×˜×™!**\n\n`;
                            response += `**${page.name}** - ${page.request}\n`;
                            response += `ğŸ“ **××–×•×¨:** ${page.area}\n`;
                            if (page.phone) {
                                response += `ğŸ“ **×˜×œ×¤×•×Ÿ:** ${page.phone}\n`;
                            }
                            if (page.price) {
                                response += `ğŸ’° **××—×™×¨:** â‚ª${page.price} ${page.priceType || '×›×œ×œ×™'}\n`;
                            }
                            response += `\nğŸ”— [×¦×¤×” ×‘×“×£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                            response += `ğŸ’¬ **×”×©××¨ ×¤×¨×˜×™× ×•×× ×™ ×××¡×•×¨ ××•×ª×!**`;
                        } else {
                            response = `ğŸ¾ **××¦××ª×™ ${messageInBottlePages.length} ××¡×¨×™× ×‘×‘×§×‘×•×§ ×¨×œ×•×•× ×˜×™×™×!**\n\n`;
                            
                            messageInBottlePages.forEach((page, index) => {
                                response += `**${index + 1}. ${page.name}** - ${page.request}\n`;
                                response += `ğŸ“ **××–×•×¨:** ${page.area}\n`;
                                if (page.phone) {
                                    response += `ğŸ“ **×˜×œ×¤×•×Ÿ:** ${page.phone}\n`;
                                }
                                if (page.price) {
                                    response += `ğŸ’° **××—×™×¨:** â‚ª${page.price} ${page.priceType || '×›×œ×œ×™'}\n`;
                                }
                                response += `ğŸ”— [×¦×¤×” ×‘×“×£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                            });
                            
                            response += `ğŸ’¬ **×”×©××¨ ×¤×¨×˜×™× ×•×× ×™ ×××¡×•×¨ ××•×ª× ×œ××™ ×©××ª××™×!**`;
                        }
                        
                        return response;
                    }
                    
                    // Handle store pages (existing logic)
                    let allProducts = [];
                    
                    // ğŸ”¥ READ LIVE PRODUCTS FROM EACH PAGE (not from old metadata)!
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        
                        try {
                            // ğŸ”¥ Fetch the LIVE HTML page
                            const response = await fetch(pageUrl);
                            if (!response.ok) {
                                console.warn('Failed to fetch page:', pageUrl);
                                continue;
                            }
                            
                            const html = await response.text();
                            
                            // ğŸ”¥ Extract LIVE products from HTML
                            const liveProducts = extractLiveProducts(html);
                            console.log(`ğŸ”¥ Extracted ${liveProducts.length} LIVE products from ${page.title}:`, liveProducts);
                            
                            if (liveProducts.length > 0) {
                                // ğŸ¯ FOR SPECIFIC CATEGORIES: Include ALL products from relevant pages!
                                // The page itself is already filtered by category, so we trust the products in it
                                if (searchKeyword !== '××•×¦×¨') {
                                    console.log(`ğŸ¯ Including ALL ${liveProducts.length} products from "${page.title}" (category: ${searchKeyword})`);
                                    liveProducts.forEach(product => {
                                        allProducts.push({
                                            ...product,
                                            pageTitle: page.title,
                                            pageUrl: pageUrl,
                                            pageName: page.title
                                        });
                                    });
                                } else {
                                    // For general "××•×¦×¨", include all products
                                    liveProducts.forEach(product => {
                                        allProducts.push({
                                            ...product,
                                            pageTitle: page.title,
                                            pageUrl: pageUrl,
                                            pageName: page.title
                                        });
                                    });
                                }
                            }
                        } catch (error) {
                            console.error('Error extracting live products from', pageUrl, ':', error);
                        }
                    }
                    
                    // If we have both messageInBottle pages and store products, combine them
                    if (messageInBottlePages.length > 0 && allProducts.length > 0) {
                        let response = '';
                        
                        // Add messageInBottle pages
                        response += `ğŸ¾ **××¦××ª×™ ${messageInBottlePages.length} ××¡×¨×™× ×‘×‘×§×‘×•×§ ×¨×œ×•×•× ×˜×™×™×!**\n\n`;
                        
                        messageInBottlePages.forEach((page, index) => {
                            response += `**${index + 1}. ${page.name}** - ${page.request}\n`;
                            response += `ğŸ“ **××–×•×¨:** ${page.area}\n`;
                            if (page.phone) {
                                response += `ğŸ“ **×˜×œ×¤×•×Ÿ:** ${page.phone}\n`;
                            }
                            if (page.price) {
                                response += `ğŸ’° **××—×™×¨:** â‚ª${page.price} ${page.priceType || '×›×œ×œ×™'}\n`;
                            }
                            response += `ğŸ”— [×¦×¤×” ×‘×“×£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                        });
                        
                        response += `\nğŸ›ï¸ **×•×’× ×™×© ×œ×™ ${allProducts.length} ××•×¦×¨×™× ×¨×œ×•×•× ×˜×™×™×:**\n\n`;
                        
                        // Add store products
                        allProducts.slice(0, 3).forEach((product, index) => {
                            response += `**${index + 1}. ${product.name}** - â‚ª${product.price}\n`;
                            response += `ğŸª **×—× ×•×ª:** ${product.pageTitle}\n`;
                            response += `ğŸ”— [×¦×¤×” ×‘×“×£](${product.pageUrl})\n\n`;
                        });
                        
                        if (allProducts.length > 3) {
                            response += `... ×•×¢×•×“ ${allProducts.length - 3} ××•×¦×¨×™× × ×•×¡×¤×™×!\n\n`;
                        }
                        
                        response += `ğŸ’¬ **×”×©××¨ ×¤×¨×˜×™× ×•×× ×™ ×××¡×•×¨ ××•×ª× ×œ××™ ×©××ª××™×!**`;
                        
                        return response;
                    }
                    
                    // If we only have store products, continue with existing logic
                    if (allProducts.length > 0) {
                        // Sort by price
                        allProducts.sort((a, b) => {
                            const priceA = parseInt(a.price.replace(',', ''));
                            const priceB = parseInt(b.price.replace(',', ''));
                            return priceA - priceB;
                        });
                        
                        const cheapest = allProducts[0];
                        const mostExpensive = allProducts[allProducts.length - 1];
                        
                        // ğŸ¯ FIX: Ensure we only use REAL products, not invented ones
                        if (!cheapest || !cheapest.name || !cheapest.price) {
                            console.error('âŒ Invalid cheapest product:', cheapest);
                            return `××¦×˜×¢×¨, ×œ× ××¦××ª×™ ××™×“×¢ ×¢×œ ××•×¦×¨×™× ×–××™× ×™× ×›×¨×’×¢ ×‘××¨×§×˜×¤×œ×™×™×¡. × ×¡×” ×œ×—×¤×© ××•×¦×¨ ×¡×¤×¦×™×¤×™ ××• ×‘×“×•×§ ××ª ×”×“×¤×™× ×”×–××™× ×™×.`;
                        }
                        
                        // ğŸ¤– CONVERSATIONAL RESPONSE - Talk like a friend!
                        let response = '';
                        
                        // ğŸ¯ FIX: Also handle "××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ ×‘××¨×§×˜" variations
                        if (lowerMessage.includes('×”×›×™ ×–×•×œ') || lowerMessage.includes('××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ') || lowerMessage.includes('×”××•×¦×¨ ×”×›×™ ×–×•×œ ×‘××¨×§×˜')) {
                            // ğŸ¯ FIX: Use REAL product name and price only
                            const productName = cheapest.name || '××•×¦×¨';
                            const productPrice = cheapest.price || '××—×™×¨ ×œ×¤×™ ×‘×§×©×”';
                            const pageTitle = cheapest.pageTitle || cheapest.pageName || '×—× ×•×ª';
                            
                            // ğŸ¯ FIX: Get page URL for link - find the page from allPages
                            const cleanPageTitle = pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                            let pageUrl = '';
                            
                            // Try to find page from allPages using userId and pageId if available
                            if (cheapest.userId && cheapest.pageId) {
                                pageUrl = `/users/${cheapest.userId}/${cheapest.pageId}_html`;
                            } else if (cheapest.pageUrl) {
                                pageUrl = cheapest.pageUrl;
                            } else {
                                // Fallback: find page from allPages by title
                                for (const page of allPages) {
                                    if (page.title === pageTitle || page.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === cleanPageTitle) {
                                        pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        break;
                                    }
                                }
                            }
                            
                            response += `ğŸ¤– **×™×© ×œ×™ "${productName}" ×‘××—×™×¨ â‚ª${productPrice}** - ×–×” ${searchKeyword === '××•×¦×¨' ? '×”××•×¦×¨' : `×”${searchKeyword}`} ×”×›×™ ×–×•×œ ×‘××¨×§×˜!\n\n`;
                            response += `ğŸ“ ×”×•× × ××¦× ×‘**${cleanPageTitle}**\n`;
                            if (pageUrl) {
                                response += `ğŸ”— **×¦×¤×” ×‘×“×£:** ${pageUrl}\n\n`;
                            }
                            response += `ğŸ’¡ **×¨×•×¦×” ×©××—×¤×© ×œ×š ×¢×•×“ ××©×”×•?** ××• ×¨×•×¦×” ×œ×¨××•×ª ××ª ×”×“×£?`;
                            
                            console.log('âœ… Returning REAL cheapest product:', {
                                name: productName,
                                price: productPrice,
                                pageTitle: cleanPageTitle,
                                pageUrl: pageUrl
                            });
                        } else if (lowerMessage.includes('×”×›×™ ×™×§×¨') || lowerMessage.includes('××” ×”××•×¦×¨ ×”×›×™ ×™×§×¨')) {
                            // ğŸ¯ FIX: Use REAL product name and price only, with link
                            const productName = mostExpensive.name || '××•×¦×¨';
                            const productPrice = mostExpensive.price || '××—×™×¨ ×œ×¤×™ ×‘×§×©×”';
                            const pageTitle = mostExpensive.pageTitle || mostExpensive.pageName || '×—× ×•×ª';
                            const cleanPageTitle = pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                            
                            // ğŸ¯ FIX: Get page URL for link
                            let pageUrl = '';
                            if (mostExpensive.userId && mostExpensive.pageId) {
                                pageUrl = `/users/${mostExpensive.userId}/${mostExpensive.pageId}_html`;
                            } else if (mostExpensive.pageUrl) {
                                pageUrl = mostExpensive.pageUrl;
                            } else {
                                // Fallback: find page from allPages by title
                                for (const page of allPages) {
                                    if (page.title === pageTitle || page.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === cleanPageTitle) {
                                        pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        break;
                                    }
                                }
                            }
                            
                            response += `ğŸ¤– **×™×© ×œ×™ "${productName}" ×‘××—×™×¨ â‚ª${productPrice}** - ×–×” ${searchKeyword === '××•×¦×¨' ? '×”××•×¦×¨' : `×”${searchKeyword}`} ×”×›×™ ×™×§×¨ ×‘××¨×§×˜!\n\n`;
                            response += `ğŸ“ ×”×•× × ××¦× ×‘**${cleanPageTitle}**\n`;
                            if (pageUrl) {
                                response += `ğŸ”— **×¦×¤×” ×‘×“×£:** ${pageUrl}\n\n`;
                            }
                            response += `ğŸ’¡ **×¨×•×¦×” ×©××—×¤×© ×œ×š ×¢×•×“ ××©×”×•?** ××• ×¨×•×¦×” ×œ×¨××•×ª ××ª ×”×“×£?`;
                        } else {
                            response += `ğŸ¤– **××¦××ª×™ ${allProducts.length} ××•×¦×¨×™× ×‘-${relevantPages.length} ×—× ×•×™×•×ª!**\n\n`;
                            response += `ğŸ¥‡ **×”×›×™ ×–×•×œ:** ${cheapest.name} - â‚ª${cheapest.price}\n`;
                            response += `ğŸ’ **×”×›×™ ×™×§×¨:** ${mostExpensive.name} - â‚ª${mostExpensive.price}\n\n`;
                            response += `ğŸ’¡ **×¨×•×¦×” ×œ×¨××•×ª ××ª ×”××•×¦×¨×™×? ××• ×©××—×¤×© ×œ×š ××©×”×• ××—×¨?**`;
                        }
                        
                        // ğŸ’¾ SAVE the recommended page in context so we can open it if user says "yes"
                        const recommendedProduct = lowerMessage.includes('×”×›×™ ×–×•×œ') ? cheapest : (lowerMessage.includes('×”×›×™ ×™×§×¨') ? mostExpensive : cheapest);
                        const firstRelevantPage = relevantPages[0];
                        
                        // ğŸ¯ CLEAN the title - remove timestamp (e.g., "1761023899504")
                        const cleanTitle = firstRelevantPage.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                        
                        window.marketplaceConversationContext.recommendedPage = {
                            title: cleanTitle,
                            url: firstRelevantPage.url,
                            pageId: firstRelevantPage.pageId
                        };
                        console.log('ğŸ’¾ Saved recommended page (Marketplace):', window.marketplaceConversationContext.recommendedPage);
                        
                        addAIMessage(response, false);
                        return; // STOP HERE - We showed price comparison
                        
                        // OLD CODE - Remove automatic preview:
                        // Add page preview after comparison
                        if (false && lowerMessage.includes('×”×›×™ ×–×•×œ')) {
                            response += `\n\nğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ×”×“×£ ×”×–×•×œ ×‘×™×•×ª×¨:**\n`;
                            response += `![${cheapest.pageTitle}](${cheapest.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>ğŸ“± ×ª×¦×•×’×” ××§×“×™××”: ${cheapest.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${cheapest.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        } else if (lowerMessage.includes('×”×›×™ ×™×§×¨')) {
                            response += `\n\nğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ×”×“×£ ×”×™×§×¨ ×‘×™×•×ª×¨:**\n`;
                            response += `![${mostExpensive.pageTitle}](${mostExpensive.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>ğŸ“± ×ª×¦×•×’×” ××§×“×™××”: ${mostExpensive.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${mostExpensive.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        } else {
                            response += `\n\nğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ×”×“×£ ×”×–×•×œ ×‘×™×•×ª×¨:**\n`;
                            response += `![${cheapest.pageTitle}](${cheapest.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>ğŸ“± ×ª×¦×•×’×” ××§×“×™××”: ${cheapest.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${cheapest.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        }
                        
                        return response;
                    }
                }
                
                return `âŒ **×œ× ××¦××ª×™ ×ª×•×¦××•×ª ×¨×œ×•×•× ×˜×™×•×ª ×‘××¢×¨×›×ª ×©×œ× ×•.**\n\nğŸ’¡ **××” ×©×™×© ×œ× ×•:**\n${allPages.slice(0, 4).map(page => `â€¢ ${page.title} - ${page.pageType === 'store' ? '×—× ×•×ª' : page.pageType === 'course' ? '×§×•×¨×¡' : page.pageType === 'event' ? '××™×¨×•×¢' : page.pageType === 'messageInBottle' ? '××¡×¨ ×‘×‘×§×‘×•×§' : '×©×™×¨×•×ª'}`).join('\n')}\n\nğŸ” **× ×¡×”:** "××—×™×¨×™×", "××” ×™×© ×œ×›×", ××• "××—×¤×© ×©×™×¨×•×ª"`;
            }
            
            
            
            // Price search - look for specific products
            if (lowerMessage.includes('××—×™×¨') || lowerMessage.includes('×›××”') || lowerMessage.includes('×¢×•×œ×”') || lowerMessage.includes('â‚ª') || lowerMessage.includes('×©×§×œ')) {
                console.log('ğŸ’° Price search triggered:', lowerMessage);
                
                // Determine what product they're looking for
                let searchKeyword = '';
                if (lowerMessage.includes('×©×¢×•×Ÿ') || lowerMessage.includes('×©×¢×•× ×™×')) {
                    searchKeyword = '×©×¢×•×Ÿ';
                    console.log('ğŸ” Detected watch search');
                }
                else if (lowerMessage.includes('×œ×§')) searchKeyword = '×œ×§';
                else if (lowerMessage.includes('×¦×¢×¦×•×¢') || lowerMessage.includes('×¦×¢×¦×•×¢×™×')) searchKeyword = '×¦×¢×¦×•×¢';
                else if (lowerMessage.includes('×ª×›×©×™×˜') || lowerMessage.includes('×ª×›×©×™×˜×™×')) searchKeyword = '×ª×›×©×™×˜';
                else if (lastSearchContext) {
                    searchKeyword = lastSearchContext;
                    console.log('ğŸ” Using last search context:', lastSearchContext);
                }
                else if (lastSearchResults.length > 0) {
                    // Use last search results if available
                    relevantPages = lastSearchResults;
                    searchKeyword = lastSearchContext || '××•×¦×¨';
                    console.log('ğŸ” Using last search results:', relevantPages.length, 'pages');
                }
                else searchKeyword = '××•×¦×¨';
                
                console.log('ğŸ” Final search keyword:', searchKeyword);
                
                // Filter pages by specific keyword if mentioned - STRICT FILTERING
                let relevantPages = [];
                
                // Only search if we don't have results from previous search
                if (lastSearchResults.length === 0) {
                    relevantPages = allPages.filter(page => {
                    if (searchKeyword === '××•×¦×¨') {
                        return page.pageType === 'store' || page.pageType === 'messageInBottle';
                    }
                    
                    const titleLower = page.title.toLowerCase();
                    const descLower = (page.description || '').toLowerCase();
                    const requestLower = (page.request || '').toLowerCase();
                    
                    // Check for both singular and plural forms
                    const pluralKeyword = searchKeyword + '×™×'; // e.g., ×©×¢×•×Ÿ -> ×©×¢×•× ×™×
                    
                    // Only show pages that actually contain the keyword in title OR description OR request OR products (singular or plural)
                    const hasKeywordInTitle = titleLower.includes(searchKeyword) || titleLower.includes(pluralKeyword);
                    const hasKeywordInDesc = descLower.includes(searchKeyword) || descLower.includes(pluralKeyword);
                    const hasKeywordInRequest = requestLower.includes(searchKeyword) || requestLower.includes(pluralKeyword);
                    
                    // Check if keyword exists in any product name
                    let hasKeywordInProducts = false;
                    if (page.products && page.products.length > 0) {
                        hasKeywordInProducts = page.products.some(product => 
                            product.name.toLowerCase().includes(searchKeyword) || 
                            product.name.toLowerCase().includes(pluralKeyword)
                        );
                    }
                    
                    // Search in all page types, not just stores
                    const matches = (hasKeywordInTitle || hasKeywordInDesc || hasKeywordInProducts);
                    
                    if (matches) {
                        console.log('âœ… Found matching page:', page.title, '(searching for:', searchKeyword, 'or', pluralKeyword + ')');
                    }
                    
                    return matches;
                    });
                } else {
                    // Use previous search results
                    relevantPages = lastSearchResults;
                }
                
                // If no specific keyword found, show all stores and messageInBottle
                if (relevantPages.length === 0 && searchKeyword === '××•×¦×¨') {
                    relevantPages = allPages.filter(page => page.pageType === 'store' || page.pageType === 'messageInBottle');
                }
                
                console.log(`ğŸ” Searching for "${searchKeyword}" - found ${relevantPages.length} pages`);
                
                    if (relevantPages.length > 0) {
                        // Save search results for context
                        lastSearchResults = relevantPages;
                        
                        let response = `ğŸ’° **××—×™×¨×™× ×¢×‘×•×¨ ${searchKeyword}:**\n\n`;
                        
                        // Add smart recommendations before showing prices
                        if (searchKeyword === '××ª× ×”' || searchKeyword === '××ª× ×•×ª') {
                            response += `ğŸ **×”××œ×¦×•×ª ××ª× ×•×ª ××•×©×œ××•×ª:**\n\n`;
                            
                            // Categorize pages by type for better recommendations
                            const storePages = relevantPages.filter(p => p.pageType === 'store');
                            const servicePages = relevantPages.filter(p => p.pageType === 'serviceProvider');
                            const coursePages = relevantPages.filter(p => p.pageType === 'course');
                            const eventPages = relevantPages.filter(p => p.pageType === 'event');
                            const messageInBottlePages = relevantPages.filter(p => p.pageType === 'messageInBottle');
                            
                            if (storePages.length > 0) {
                                response += `ğŸ›ï¸ **××ª× ×•×ª ××—× ×•×™×•×ª:**\n`;
                                storePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `â€¢ **${page.title}** - ××ª× ×•×ª ××™×›×•×ª×™×•×ª! ğŸª\n`;
                                    response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (servicePages.length > 0) {
                                response += `ğŸ’… **××ª× ×•×ª ×—×•×•×™×”:**\n`;
                                servicePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `â€¢ **${page.title}** - ×—×•×•×™×” ××¤× ×§×ª! ğŸ’…\n`;
                                    response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (coursePages.length > 0) {
                                response += `ğŸ“ **××ª× ×•×ª ×”×¢×©×¨×”:**\n`;
                                coursePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `â€¢ **${page.title}** - ××ª× ×” ×©×ª×©× ×” ×—×™×™×! ğŸ“\n`;
                                    response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (eventPages.length > 0) {
                                response += `ğŸ‰ **××ª× ×•×ª ××™×¨×•×¢×™×:**\n`;
                                eventPages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `â€¢ **${page.title}** - ×—×•×•×™×” ×‘×œ×ª×™ × ×©×›×—×ª! ğŸ‰\n`;
                                    response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (messageInBottlePages.length > 0) {
                                response += `ğŸ¾ **××¡×¨×™× ×‘×‘×§×‘×•×§:**\n`;
                                messageInBottlePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `â€¢ **${page.name}** - ${page.request} ğŸ¾\n`;
                                    if (page.price) {
                                        response += `  ğŸ’° **××—×™×¨:** â‚ª${page.price} ${page.priceType || '×›×œ×œ×™'}\n`;
                                    }
                                    response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            response += `ğŸ’¡ **×˜×™×¤:** ×œ×›×œ ××ª× ×” ×™×© ××—×™×¨×™× ×©×•× ×™× - ×›×ª×•×‘ "××—×™×¨×™×" ×›×“×™ ×œ×¨××•×ª ××ª ×›×œ ×”××—×™×¨×™×!\n\n`;
                        }
                        
                        for (const page of relevantPages.slice(0, 3)) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        
                        if (page.pageType === 'messageInBottle') {
                            response += `â€¢ **${page.name}** ğŸ¾\n`;
                            response += `  **${page.request}**\n`;
                            response += `  ğŸ“ **××–×•×¨:** ${page.area}\n`;
                            if (page.price) {
                                response += `  ğŸ’° **××—×™×¨:** â‚ª${page.price} ${page.priceType || '×›×œ×œ×™'}\n`;
                            }
                            response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n\n`;
                        } else {
                        response += `â€¢ **${page.title}** ğŸª\n`;
                        response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                        
                        // Use products from metadata if available - ENHANCED PRODUCT INFO
                        if (page.products && page.products.length > 0) {
                            response += `\n  **ğŸ›ï¸ ××•×¦×¨×™× ×–××™× ×™×:**\n`;
                            
                            // Sort products by price for better recommendations
                            const sortedProducts = [...page.products].sort((a, b) => 
                                parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                            );
                            
                            sortedProducts.slice(0, 5).forEach((product, index) => {
                                const price = parseInt(product.price.replace(',', ''));
                                let priceEmoji = 'ğŸ’°';
                                if (price < 100) priceEmoji = 'ğŸ’š';
                                else if (price < 500) priceEmoji = 'ğŸ’›';
                                else if (price < 1000) priceEmoji = 'ğŸ§¡';
                                else priceEmoji = 'â¤ï¸';
                                
                                response += `  ${priceEmoji} **${product.name}** - â‚ª${product.price}`;
                                
                                // Add availability status
                                if (index === 0) response += ` â­ **×”×›×™ ×–×•×œ!**`;
                                if (index === sortedProducts.length - 1) response += ` ğŸ’ **×¤×¨×™××™×•×**`;
                                
                                response += `\n`;
                            });
                            
                            // Smart recommendations based on user intent
                            if (lowerMessage.includes('×–×•×œ') || lowerMessage.includes('×”×›×™ ×–×•×œ')) {
                                const cheapest = sortedProducts[0];
                                response += `\n  ğŸ¯ **×”××œ×¦×” ×—×›××”:** ${cheapest.name} - ×”×›×™ ××©×ª×œ×! â‚ª${cheapest.price}\n`;
                            } else if (lowerMessage.includes('×™×§×¨') || lowerMessage.includes('×™×•×§×¨×”')) {
                                const mostExpensive = sortedProducts[sortedProducts.length - 1];
                                response += `\n  ğŸ’ **×”××œ×¦×” ×™×•×§×¨×”:** ${mostExpensive.name} - ×”×›×™ ××™×›×•×ª×™! â‚ª${mostExpensive.price}\n`;
                            } else if (lowerMessage.includes('××ª× ×”') || lowerMessage.includes('××ª× ×ª')) {
                                const midRange = sortedProducts[Math.floor(sortedProducts.length / 2)];
                                response += `\n  ğŸ **××ª× ×” ××•×©×œ××ª:** ${midRange.name} - ××™×–×•×Ÿ ××•×©×œ×! â‚ª${midRange.price}\n`;
                            }
                            
                            // Add total products count
                            if (page.products.length > 5) {
                                response += `\n  ğŸ“Š **×¡×”"×› ${page.products.length} ××•×¦×¨×™× ×–××™× ×™×** - [ğŸ‘ï¸ ×¦×¤×” ×‘×›×•×œ×](${pageUrl})\n`;
                            }
                            
                            response += `\n`;
                            }
                        }
                        
                        response += `\nğŸ’¡ **×˜×™×¤:** ×›×ª×•×‘ "××—×™×¨×™×" ×›×“×™ ×œ×¨××•×ª ××ª ×›×œ ×”××—×™×¨×™× ××• "×”×›×™ ×–×•×œ" ×œ××—×™×¨ ×”×˜×•×‘ ×‘×™×•×ª×¨!\n`;
                    }
                    
                    if (searchKeyword !== '××•×¦×¨') {
                        response += `ğŸ” **×¨×•×¦×” ×—×™×¤×•×© ×¡×¤×¦×™×¤×™?** ×›×ª×•×‘ "×©×¢×•×Ÿ" ××• "×ª×›×©×™×˜" ×•×× ×™ ××—×¤×© ×¢×‘×•×¨×š!`;
                    }
                    
                    // Add page preview after recommendations
                    if (relevantPages.length > 0) {
                        const firstPage = relevantPages[0];
                        const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                        response += `\n\nğŸ“± **×ª×¦×•×’×” ××§×“×™××”:**\n`;
                        response += `![${firstPage.title}](${pageUrl})\n`;
                        
                        // Add delay and then show preview
                        setTimeout(() => {
                            const chatContainer = document.querySelector('.ai-chat-messages');
                            if (chatContainer) {
                                const previewDiv = document.createElement('div');
                                previewDiv.className = 'page-preview';
                                previewDiv.innerHTML = `
                                    <div class="preview-header">
                                        <h3>ğŸ“± ×ª×¦×•×’×” ××§×“×™××”: ${firstPage.title}</h3>
                                    </div>
                                    <div class="preview-content">
                                        <iframe src="${pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                    </div>
                                `;
                                chatContainer.appendChild(previewDiv);
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                                
                                // Add animation
                                previewDiv.style.opacity = '0';
                                previewDiv.style.transform = 'translateY(20px)';
                                setTimeout(() => {
                                    previewDiv.style.transition = 'all 0.5s ease';
                                    previewDiv.style.opacity = '1';
                                    previewDiv.style.transform = 'translateY(0)';
                                }, 100);
                            }
                        }, 2000); // Wait 2 seconds before showing preview
                    }
                    
                    return response;
                }
                
                return `âŒ **×œ× ××¦××ª×™ ×ª×•×¦××•×ª ×¨×œ×•×•× ×˜×™×•×ª ×‘××¢×¨×›×ª ×©×œ× ×•.**\n\nğŸ’¡ **××” ×©×™×© ×œ× ×•:**\n${allPages.slice(0, 4).map(page => `â€¢ ${page.title} - ${page.pageType === 'store' ? '×—× ×•×ª' : page.pageType === 'course' ? '×§×•×¨×¡' : page.pageType === 'event' ? '××™×¨×•×¢' : page.pageType === 'messageInBottle' ? '××¡×¨ ×‘×‘×§×‘×•×§' : '×©×™×¨×•×ª'}`).join('\n')}\n\nğŸ” **× ×¡×”:** "××—×™×¨×™×", "××” ×™×© ×œ×›×", ××• "××—×¤×© ×©×™×¨×•×ª"`;
            }
            
            
            // Check for specific keywords and search
            const keywords = {
                '××ª× ×”': 'store',
                '××ª× ×•×ª': 'store',
                '×œ×§': 'serviceProvider',
                '×× ×™×§×•×¨': 'serviceProvider', 
                '×¤×“×™×§×•×¨': 'serviceProvider',
                '×¦×¢×¦×•×¢': 'store',
                '×™×œ×“': 'store',
                '×—× ×•×ª': 'store',
                '×§×•×¨×¡': 'course',
                '×œ×™××•×“': 'course',
                '××™×¨×•×¢': 'event',
                '×—×ª×•× ×”': 'event',
                '×©×¢×•×Ÿ': 'store',
                '×©×¢×•× ×™×': 'store',
                '×ª×›×©×™×˜': 'store',
                '×ª×›×©×™×˜×™×': 'store',
                '×–×”×‘': 'store',
                '×›×¡×£': 'store',
                '×™×”×œ×•×': 'store',
                '×™×”×œ×•××™×': 'store',
                '×¢×’×™×œ': 'store',
                '×¢×’×™×œ×™×': 'store',
                '×¦××™×“': 'store',
                '×¦××™×“×™×': 'store',
                '×©×¨×©×¨×ª': 'store',
                '×©×¨×©×¨××•×ª': 'store',
                '×˜×‘×¢×ª': 'store',
                '×˜×‘×¢×•×ª': 'store'
            };
            
            // Check for specific needs and provide focused recommendations
            const specificNeeds = {
                '×–×•×œ': { type: 'price', focus: 'cheapest' },
                '×™×§×¨': { type: 'price', focus: 'expensive' },
                '××ª× ×” ×œ×™×œ×“': { type: 'gift', focus: 'child' },
                '××ª× ×” ×œ××™×©×”': { type: 'gift', focus: 'woman' },
                '××ª× ×” ×œ×’×‘×¨': { type: 'gift', focus: 'man' },
                '××ª× ×” ×œ×–×•×’': { type: 'gift', focus: 'couple' },
                '××ª× ×” ×œ×™×•× ×”×•×œ×“×ª': { type: 'gift', focus: 'birthday' },
                '××ª× ×” ×œ×—×’': { type: 'gift', focus: 'holiday' },
                '××ª× ×” ××™×•×—×“×ª': { type: 'gift', focus: 'special' },
                '××ª×œ×‘×˜': { type: 'help', focus: 'undecided' },
                '×œ× ×™×•×“×¢': { type: 'help', focus: 'undecided' },
                '××” ×œ×‘×—×•×¨': { type: 'help', focus: 'undecided' },
                '××™×–×”': { type: 'help', focus: 'choice' },
                '××™×š ×œ×‘×—×•×¨': { type: 'help', focus: 'choice' }
            };
            
            // Smart keyword matching - find related words
            const smartKeywords = {
                '××ª× ×”': ['××ª× ×”', '××ª× ×•×ª', '××ª× ×ª', '××ª× ×•×ª', '××ª× ×” ×œ', '××ª× ×” ×œ×™×œ×“', '××ª× ×” ×œ××™×©×”', '××ª× ×” ×œ×’×‘×¨', '××ª× ×” ×œ×™×•× ×”×•×œ×“×ª', '××ª× ×” ×œ×—×’', '××ª× ×” ××™×•×—×“×ª'],
                '×©×¢×•×Ÿ': ['×©×¢×•×Ÿ', '×©×¢×•× ×™×', '×–××Ÿ', '×–×× ×™×', '×™×“', '×™×“×™×™×', '××‘×•×’×¨', '××‘×•×’×¨×™×', '×§×œ××¡×™', '×¡×¤×•×¨×˜', '×™×•×§×¨×”', '×¡×××¨×˜'],
                '×ª×›×©×™×˜': ['×ª×›×©×™×˜', '×ª×›×©×™×˜×™×', '×–×”×‘', '×›×¡×£', '×™×”×œ×•×', '×™×”×œ×•××™×', '×¢×’×™×œ', '×¢×’×™×œ×™×', '×¦××™×“', '×¦××™×“×™×', '×©×¨×©×¨×ª', '×©×¨×©×¨××•×ª', '×˜×‘×¢×ª', '×˜×‘×¢×•×ª'],
                '×¦×¢×¦×•×¢': ['×¦×¢×¦×•×¢', '×¦×¢×¦×•×¢×™×', '×™×œ×“', '×™×œ×“×™×', '××©×—×§', '××©×—×§×™×', '×‘×•×‘×”', '×‘×•×‘×•×ª', '×¨×›×‘', '××›×•× ×™×ª'],
                '×œ×§': ['×œ×§', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '×¦×™×¤×•×¨× ×™×™×', '×™×•×¤×™', '×™×•×¤×™', '×¡×¤×', '×˜×™×¤×•×—'],
                '×§×•×¨×¡': ['×§×•×¨×¡', '×§×•×¨×¡×™×', '×œ×™××•×“', '×œ×™××•×“×™×', '×”×“×¨×›×”', '×”×“×¨×›×•×ª', '×¡××™× ×¨', '×¡××™× ×¨×™×']
            };
            
            // Check for specific needs first - DISABLED TO PREVENT INVENTING
            let specificNeed = null;
            // for (const [need, config] of Object.entries(specificNeeds)) {
            //     if (lowerMessage.includes(need)) {
            //         specificNeed = config;
            //         break;
            //     }
            // }
            
            // Smart search - check for any related keywords
            for (const [mainKeyword, relatedWords] of Object.entries(smartKeywords)) {
                const hasRelatedWord = relatedWords.some(word => lowerMessage.includes(word));
                if (hasRelatedWord) {
                    const type = keywords[mainKeyword] || 'store';
                    
                    // Remember search context for future price queries
                    lastSearchContext = mainKeyword;
                    
                    // More precise search - look in title and description with better matching
                    let matchingPages = allPages.filter(page => {
                        const titleLower = page.title.toLowerCase();
                        const descLower = (page.description || '').toLowerCase();
                        
                        // Check if any related word appears in title or description
                        const titleMatch = relatedWords.some(word => titleLower.includes(word));
                        const descMatch = relatedWords.some(word => descLower.includes(word));
                        
                        // Also check for partial matches and synonyms
                        const partialMatch = relatedWords.some(word => {
                            const wordParts = word.split(' ');
                            return wordParts.some(part => 
                                titleLower.includes(part) || descLower.includes(part)
                            );
                        });
                        
                        return page.pageType === type && (titleMatch || descMatch || partialMatch);
                    });
                    
                    // DISABLED - No more inventing recommendations
                    // Apply specific filtering based on user needs
                    // if (specificNeed) { ... }
                    
                    console.log(`ğŸ” Searching for "${mainKeyword}" in type "${type}"`, { matchingPages: matchingPages.length, allPages: allPages.length });
                    
                    if (matchingPages.length > 0) {
                        let response = '';
                        
                        // Simple response - no more inventing
                        response = `ğŸ¯ **××¦××ª×™ ${matchingPages.length} ×“×¤×™× ×¨×œ×•×•× ×˜×™×™× ×œ"${mainKeyword}":**\n\n`;
                        
                        // Add smart recommendations for gifts
                        if (mainKeyword === '××ª× ×”' || mainKeyword === '××ª× ×•×ª') {
                            response += `ğŸ **××ª× ×•×ª ××•×©×œ××•×ª! ×‘×•××• × ××¦× ××ª ×”××ª× ×” ×”××•×©×œ××ª:**\n\n`;
                            
                            // Show specific products with prices for children
                            if (lowerMessage.includes('×™×œ×“') || lowerMessage.includes('×™×œ×“×™×') || lowerMessage.includes('×™×œ×“×”') || lowerMessage.includes('×™×œ×“×•×ª')) {
                                response += `ğŸ‘¶ **××ª× ×•×ª ××•×©×œ××•×ª ×œ×™×œ×“×™× - ×”× ×” ×”××œ×¦×” ×¡×¤×¦×™×¤×™×ª:**\n\n`;
                                
                                // Find toy pages specifically - exclude services
                                const toyPages = matchingPages.filter(p => 
                                    p.pageType === 'store' && 
                                    p.pageType !== 'serviceProvider' &&
                                    (p.title.toLowerCase().includes('×¦×¢×¦×•×¢') || 
                                     p.title.toLowerCase().includes('toy') ||
                                     p.description?.toLowerCase().includes('×¦×¢×¦×•×¢') ||
                                     p.title.toLowerCase().includes('××©×—×§') ||
                                     p.description?.toLowerCase().includes('××©×—×§') ||
                                     p.title.toLowerCase().includes('×‘×•×‘×”') ||
                                     p.description?.toLowerCase().includes('×‘×•×‘×”') ||
                                     p.title.toLowerCase().includes('×¨×›×‘') ||
                                     p.description?.toLowerCase().includes('×¨×›×‘') ||
                                     p.title.toLowerCase().includes('×™× ×™×‘') ||
                                     p.description?.toLowerCase().includes('×™×œ×“×™×') ||
                                     p.description?.toLowerCase().includes('×™×œ×“')) &&
                                    !p.title.toLowerCase().includes('×œ×§') &&
                                    !p.title.toLowerCase().includes('×’×œ') &&
                                    !p.title.toLowerCase().includes('×©×¢×•×Ÿ') &&
                                    !p.title.toLowerCase().includes('×ª×›×©×™×˜')
                                );
                                
                                if (toyPages.length > 0) {
                                    // Show ONLY ONE specific product with price
                                    const firstPage = toyPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `ğŸ§¸ **${firstPage.title}**\n`;
                                    
                                    // Try to get real product info - only show if we have real data
                                    if (firstPage.products && firstPage.products.length > 0) {
                                        const sortedProducts = [...firstPage.products].sort((a, b) => 
                                            parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                                        );
                                        
                                        // Show only the cheapest product as recommendation
                                        const cheapestProduct = sortedProducts[0];
                                        const price = parseInt(cheapestProduct.price.replace(',', ''));
                                        let priceEmoji = 'ğŸ’°';
                                        if (price < 100) priceEmoji = 'ğŸ’š';
                                        else if (price < 500) priceEmoji = 'ğŸ’›';
                                        else if (price < 1000) priceEmoji = 'ğŸ§¡';
                                        else priceEmoji = 'â¤ï¸';
                                        
                                        response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                        response += `  ${priceEmoji} **${cheapestProduct.name}** - â‚ª${cheapestProduct.price} â­ **×”×›×™ ×–×•×œ!**\n`;
                                        response += `  ğŸ“Š **×¡×”"×› ${sortedProducts.length} ××•×¦×¨×™× ×–××™× ×™×**\n`;
                                    } else if (firstPage.description) {
                                        // Try to extract product info from description
                                        const productInfo = await extractProductInfo(firstPage.description, '×¦×¢×¦×•×¢', pageUrl);
                                        if (productInfo && productInfo.price) {
                                            response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                            response += `  ğŸ’° **${productInfo.name || '×¦×¢×¦×•×¢ ××™×•×—×“'}** - ${productInfo.price}\n`;
                                        } else {
                                            response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                            response += `  ğŸ§¸ **×¦×¢×¦×•×¢×™× ×—×›××™× ×•××”× ×™×** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                        }
                                    } else {
                                        response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                        response += `  ğŸ§¸ **×¦×¢×¦×•×¢×™× ×—×›××™× ×•××”× ×™×** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                    }
                                    
                                    response += `ğŸª **×—× ×•×ª:** ${firstPage.title}\n`;
                                    response += `ğŸ”— [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n\n`;
                                    
                                    response += `ğŸ’¡ **×¨×•×¦×” ×œ×¨××•×ª ×¢×•×“?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×”×›×™ ×–×•×œ"!\n\n`;
                                    
                                    // Add iframe preview after recommendations
                                    response += `ğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                } else {
                                    // Fallback to general pages
                                    response += `ğŸ¯ **×”××œ×¦×•×ª ×›×œ×œ×™×•×ª ×œ×™×œ×“×™×:**\n`;
                                    matchingPages.slice(0, 2).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `â€¢ **${page.title}** - ××ª× ×” ××•×©×œ××ª! ğŸ\n`;
                                        response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                    });
                                }
                                
                            } else if (lowerMessage.includes('××™×©×”') || lowerMessage.includes('× ×©×™×') || lowerMessage.includes('××™×©×”') || lowerMessage.includes('× ×©×™×')) {
                                response += `ğŸ‘© **××ª× ×•×ª ××•×©×œ××•×ª ×œ× ×©×™× - ×”× ×” ×”××œ×¦×•×ª ×¡×¤×¦×™×¤×™×•×ª:**\n\n`;
                                
                                // Find beauty/service pages
                                const beautyPages = matchingPages.filter(p => 
                                    p.pageType === 'serviceProvider' || 
                                    (p.title.toLowerCase().includes('×œ×§') || 
                                     p.title.toLowerCase().includes('×’×œ') ||
                                     p.title.toLowerCase().includes('×™×•×¤×™') ||
                                     p.title.toLowerCase().includes('×©×™×¢×¨') ||
                                     p.title.toLowerCase().includes('×¢×™×¦×•×‘') ||
                                     p.title.toLowerCase().includes('×—×’×™×ª') ||
                                     p.title.toLowerCase().includes('× ×™×™×œ×¡') ||
                                     p.description?.toLowerCase().includes('×™×•×¤×™') ||
                                     p.description?.toLowerCase().includes('×©×™×¢×¨') ||
                                     p.description?.toLowerCase().includes('×œ×§') ||
                                     p.description?.toLowerCase().includes('×’×œ'))
                                );
                                
                                if (beautyPages.length > 0) {
                                    // Show specific services with prices
                                    for (const page of beautyPages.slice(0, 2)) {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `ğŸ’… **${page.title}**\n`;
                                        
                                        // Try to extract service info
                                        if (page.description) {
                                            const serviceInfo = await extractProductInfo(page.description, '×œ×§', pageUrl);
                                            if (serviceInfo && serviceInfo.price) {
                                                response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™:**\n`;
                                                response += `  ğŸ’° **${serviceInfo.name || '×©×™×¨×•×ª ×™×•×¤×™'}** - ${serviceInfo.price}\n`;
                                            } else {
                                                response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™:**\n`;
                                                response += `  ğŸ’… **×©×™×¨×•×ª×™ ×™×•×¤×™ ××¤× ×§×™×** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                            }
                                        } else {
                                            response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™:**\n`;
                                            response += `  ğŸ’… **×©×™×¨×•×ª×™ ×™×•×¤×™ ××¤× ×§×™×** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                        }
                                        
                                        response += `ğŸª **×—× ×•×ª:** ${page.title}\n`;
                                        response += `ğŸ”— [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n\n`;
                                    }
                                } else {
                                    // Fallback to general pages
                                    response += `ğŸ¯ **×”××œ×¦×•×ª ×›×œ×œ×™×•×ª ×œ× ×©×™×:**\n`;
                                    matchingPages.slice(0, 2).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `â€¢ **${page.title}** - ××ª× ×” ××•×©×œ××ª! ğŸ\n`;
                                        response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                    });
                                }
                                
                                response += `ğŸ’¡ **×¨×•×¦×” ×œ×¨××•×ª ×¢×•×“?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×”×›×™ ×–×•×œ"!\n\n`;
                                
                            } else if (lowerMessage.includes('×’×‘×¨') || lowerMessage.includes('×’×‘×¨×™×') || lowerMessage.includes('××‘') || lowerMessage.includes('××‘×')) {
                                response += `ğŸ‘¨ **××ª× ×•×ª ××•×©×œ××•×ª ×œ×’×‘×¨×™× - ×”× ×” ×”××œ×¦×” ×¡×¤×¦×™×¤×™×ª:**\n\n`;
                                
                                // Find tech/accessory pages
                                const techPages = matchingPages.filter(p => 
                                    p.pageType === 'store' && 
                                    (p.title.toLowerCase().includes('×˜×›× ×•×œ×•×’×™×”') || 
                                     p.title.toLowerCase().includes('×©×¢×•×Ÿ') ||
                                     p.title.toLowerCase().includes('×ª×›×©×™×˜') ||
                                     p.title.toLowerCase().includes('×’××“×’\'×˜') ||
                                     p.title.toLowerCase().includes('×¨×•×‘×•×˜') ||
                                     p.title.toLowerCase().includes('red') ||
                                     p.title.toLowerCase().includes('×¦×™×¤×™') ||
                                     p.description?.toLowerCase().includes('×©×¢×•×Ÿ') ||
                                     p.description?.toLowerCase().includes('×ª×›×©×™×˜') ||
                                     p.description?.toLowerCase().includes('×¨×•×‘×•×˜') ||
                                     p.description?.toLowerCase().includes('×˜×›× ×•×œ×•×’×™×”'))
                                );
                                
                                if (techPages.length > 0) {
                                    // Show ONLY ONE specific product with price
                                    const firstPage = techPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    response += `âŒš **${firstPage.title}**\n`;
                                    
                                    // Try to get real product info - only show if we have real data
                                    if (firstPage.products && firstPage.products.length > 0) {
                                        const sortedProducts = [...firstPage.products].sort((a, b) => 
                                            parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                                        );
                                        
                                        // Show only the cheapest product as recommendation
                                        const cheapestProduct = sortedProducts[0];
                                        const price = parseInt(cheapestProduct.price.replace(',', ''));
                                        let priceEmoji = 'ğŸ’°';
                                        if (price < 100) priceEmoji = 'ğŸ’š';
                                        else if (price < 500) priceEmoji = 'ğŸ’›';
                                        else if (price < 1000) priceEmoji = 'ğŸ§¡';
                                        else priceEmoji = 'â¤ï¸';
                                        
                                        response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                        response += `  ${priceEmoji} **${cheapestProduct.name}** - â‚ª${cheapestProduct.price} â­ **×”×›×™ ×–×•×œ!**\n`;
                                        response += `  ğŸ“Š **×¡×”"×› ${sortedProducts.length} ××•×¦×¨×™× ×–××™× ×™×**\n`;
                                    } else if (firstPage.description) {
                                        // Try to extract product info from description
                                        const productInfo = await extractProductInfo(firstPage.description, '×©×¢×•×Ÿ', pageUrl);
                                        if (productInfo && productInfo.price) {
                                            response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                            response += `  ğŸ’° **${productInfo.name || '×’××“×’\'×˜ ××™×•×—×“'}** - ${productInfo.price}\n`;
                                        } else {
                                            response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                            response += `  âŒš **×’××“×’\'×˜×™× ×•×˜×›× ×•×œ×•×’×™×” ××ª×§×“××ª** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                        }
                                    } else {
                                        response += `ğŸ¯ **×”××œ×¦×” ×©×œ×™ - ××•×¦×¨ ××—×“ ××•×©×œ×:**\n`;
                                        response += `  âŒš **×’××“×’\'×˜×™× ×•×˜×›× ×•×œ×•×’×™×” ××ª×§×“××ª** - ××—×™×¨ ×œ×¤×™ ×‘×§×©×”\n`;
                                    }
                                    
                                    response += `ğŸª **×—× ×•×ª:** ${firstPage.title}\n`;
                                    response += `ğŸ”— [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n\n`;
                                    
                                    response += `ğŸ’¡ **×¨×•×¦×” ×œ×¨××•×ª ×¢×•×“?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×”×›×™ ×–×•×œ"!\n\n`;
                                } else {
                                    // Fallback to general pages
                                    response += `ğŸ¯ **×”××œ×¦×•×ª ×›×œ×œ×™×•×ª ×œ×’×‘×¨×™×:**\n`;
                                    matchingPages.slice(0, 3).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `â€¢ **${page.title}** - ××ª× ×” ××•×©×œ××ª! ğŸ\n`;
                                        response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                    });
                                }
                                
                                response += `ğŸ’¡ **×¨×•×¦×” ×œ×¨××•×ª ×¢×•×“?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×”×›×™ ×–×•×œ"!\n\n`;
                                
                                // Add iframe preview after recommendations
                                if (techPages.length > 0) {
                                    const firstPage = techPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `ğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                    
                                    // Add delayed iframe preview
                                    setTimeout(() => {
                                        const chatContainer = document.querySelector('.ai-chat-messages');
                                        if (chatContainer) {
                                            const previewDiv = document.createElement('div');
                                            previewDiv.className = 'page-preview';
                                            previewDiv.style.cssText = `
                                                margin: 16px 0;
                                                border: 2px solid #e5e7eb;
                                                border-radius: 12px;
                                                overflow: hidden;
                                                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                                                position: relative;
                                                width: 100vw !important;
                                                position: absolute !important;
                                                left: 0 !important;
                                                right: 0 !important;
                                                max-width: 100% !important;
                                                margin-left: calc(-50vw + 50%) !important;
                                                text-align: right !important;
                                                direction: rtl !important;
                                                height: 300px;
                                                opacity: 0;
                                                transform: translateY(20px);
                                                transition: all 0.5s ease;
                                            `;
                                            previewDiv.innerHTML = `
                                                <div class="preview-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                                    <span>ğŸ</span>
                                                    <span>${firstPage.title}</span>
                                                </div>
                                                <div class="preview-content" style="position: relative; height: 276px; overflow: hidden;">
                                                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c);"></div>
                                                    <iframe src="${pageUrl}" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top left; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>
                                                </div>
                                            `;
                                            chatContainer.appendChild(previewDiv);
                                            chatContainer.scrollTop = chatContainer.scrollHeight;
                                            
                                            // Animate in gradually
                                            setTimeout(() => {
                                                previewDiv.style.opacity = '1';
                                                previewDiv.style.transform = 'translateY(0)';
                                            }, 200);
                                        }
                                    }, 2000);
                                }
                                
                            } else {
                                // General gift recommendations - only show real pages
                                response += `ğŸ¯ **××™×–×” ×¡×•×’ ××ª× ×” ××ª× ××—×¤×©×™×?**\n\n`;
                                
                                // Show only real pages from matchingPages
                                if (matchingPages.length > 0) {
                                    response += `ğŸ **×”×“×¤×™× ×”×–××™× ×™× ×‘××¢×¨×›×ª:**\n`;
                                    matchingPages.slice(0, 5).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        const emoji = page.pageType === 'store' ? 'ğŸ›ï¸' : page.pageType === 'event' ? 'ğŸ‰' : page.pageType === 'course' ? 'ğŸ“' : page.pageType === 'serviceProvider' ? 'ğŸ”§' : 'ğŸ“„';
                                        response += `â€¢ **${page.title}** ${emoji} - ${page.description || '××ª× ×” ××•×©×œ××ª'}\n`;
                                        response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                                    });
                                    response += `\n`;
                                    
                                    // Add iframe preview for first page
                                    const firstPage = matchingPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `ğŸ“± **×ª×¦×•×’×” ××§×“×™××” ×©×œ ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                    
                                    // Add delayed iframe preview
                                    setTimeout(() => {
                                        const chatContainer = document.querySelector('.ai-chat-messages');
                                        if (chatContainer) {
                                            const previewDiv = document.createElement('div');
                                            previewDiv.className = 'page-preview';
                                            previewDiv.style.cssText = `
                                                margin: 16px 0;
                                                border: 2px solid #e5e7eb;
                                                border-radius: 12px;
                                                overflow: hidden;
                                                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                                                position: relative;
                                                width: 100vw !important;
                                                position: absolute !important;
                                                left: 0 !important;
                                                right: 0 !important;
                                                max-width: 100% !important;
                                                margin-left: calc(-50vw + 50%) !important;
                                                text-align: right !important;
                                                direction: rtl !important;
                                                height: 300px;
                                                opacity: 0;
                                                transform: translateY(20px);
                                                transition: all 0.5s ease;
                                            `;
                                            previewDiv.innerHTML = `
                                                <div class="preview-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                                    <span>ğŸ</span>
                                                    <span>${firstPage.title}</span>
                                                </div>
                                                <div class="preview-content" style="position: relative; height: 276px; overflow: hidden;">
                                                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c);"></div>
                                                    <iframe src="${pageUrl}" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top left; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>
                                                </div>
                                            `;
                                            chatContainer.appendChild(previewDiv);
                                            chatContainer.scrollTop = chatContainer.scrollHeight;
                                            
                                            // Animate in gradually
                                            setTimeout(() => {
                                                previewDiv.style.opacity = '1';
                                                previewDiv.style.transform = 'translateY(0)';
                                            }, 200);
                                        }
                                    }, 2000);
                                } else {
                                    response += `âŒ **×œ× ××¦××ª×™ ×“×¤×™× ×‘××¢×¨×›×ª ×©×œ× ×•.**\n\n`;
                                }
                                
                                response += `â“ **×¢×–×•×¨ ×œ×™ ×œ×”××œ×™×¥ ×œ×š:**\n`;
                                response += `â€¢ **×œ××™ ×”××ª× ×”?** (×™×œ×“, ××™×©×”, ×’×‘×¨, ×–×•×’) ğŸ‘¥\n`;
                                response += `â€¢ **××™×–×” ×¡×•×’?** (×¦×¢×¦×•×¢×™×, ×™×•×¤×™, ×˜×›× ×•×œ×•×’×™×”, ×§×•×¨×¡×™×) ğŸ¯\n`;
                                response += `â€¢ **×ª×§×¦×™×‘?** (×–×•×œ, ×‘×™× ×•× ×™, ×¤×¨×™××™×•×) ğŸ’°\n\n`;
                            }
                            
                            response += `ğŸ’¡ **×¨×•×¦×” ×œ×¨××•×ª ××—×™×¨×™×?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×›××” ×–×” ×¢×•×œ×”"!\n`;
                            response += `ğŸ **×¨×•×¦×” ×”××œ×¦×” ×¡×¤×¦×™×¤×™×ª?** ×ª×’×™×“ ×œ×™ ×™×•×ª×¨ ×¤×¨×˜×™×!\n\n`;
                            
                        } else {
                            // Show actual available pages with specific recommendations
                            response += `ğŸ“‹ **×”××œ×¦×•×ª ×¡×¤×¦×™×¤×™×•×ª:**\n\n`;
                        }
                        
                        // Only show pages if it's not a gift search (gift search shows questions instead)
                        if (mainKeyword !== '××ª× ×”' && mainKeyword !== '××ª× ×•×ª') {
                            // Show more results if user asks for specific number
                            let maxResults = 3;
                            if (lowerMessage.includes('×›××”') || lowerMessage.includes('×”×¨×‘×”') || lowerMessage.includes('×›×œ')) {
                                maxResults = Math.min(matchingPages.length, 5);
                            }
                            
                            for (const page of matchingPages.slice(0, maxResults)) {
                            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                            // Use real page preview with iframe
                            const emoji = page.pageType === 'store' ? 'ğŸª' : page.pageType === 'event' ? 'ğŸ‰' : page.pageType === 'course' ? 'ğŸ“' : page.pageType === 'serviceProvider' ? 'ğŸ”§' : 'ğŸ“„';
                            response += `â€¢ **${page.title}** ${emoji}\n`;
                            response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                            
                            // Add specific product info if available
                            if (page.pageType === 'store' && page.products && page.products.length > 0) {
                                response += `\n  **ğŸ›ï¸ ××•×¦×¨×™× ×–××™× ×™×:**\n`;
                                
                                // Sort products by price for better recommendations
                                const sortedProducts = [...page.products].sort((a, b) => 
                                    parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                                );
                                
                                sortedProducts.slice(0, 3).forEach((product, index) => {
                                    const price = parseInt(product.price.replace(',', ''));
                                    let priceEmoji = 'ğŸ’°';
                                    if (price < 100) priceEmoji = 'ğŸ’š';
                                    else if (price < 500) priceEmoji = 'ğŸ’›';
                                    else if (price < 1000) priceEmoji = 'ğŸ§¡';
                                    else priceEmoji = 'â¤ï¸';
                                    
                                    response += `  ${priceEmoji} **${product.name}** - â‚ª${product.price}`;
                                    
                                    if (index === 0) response += ` â­ **×”×›×™ ×–×•×œ!**`;
                                    if (index === sortedProducts.length - 1) response += ` ğŸ’ **×¤×¨×™××™×•×**`;
                                    
                                    response += `\n`;
                                });
                                
                                // Smart recommendations
                                if (lowerMessage.includes('×–×•×œ') || lowerMessage.includes('×”×›×™ ×–×•×œ')) {
                                    const cheapest = sortedProducts[0];
                                    response += `\n  ğŸ¯ **×”××œ×¦×” ×—×›××”:** ${cheapest.name} - ×”×›×™ ××©×ª×œ×! â‚ª${cheapest.price}\n`;
                                }
                                
                                response += `\n`;
                            } else if (page.pageType === 'serviceProvider') {
                                // Enhanced service provider info
                                response += `\n  **ğŸ”§ ×©×™×¨×•×ª×™× ×–××™× ×™×:**\n`;
                                
                                // Check for appointment availability
                                if (page.description && page.description.includes('×ª×•×¨')) {
                                    response += `  ğŸ“… **×ª×•×¨×™× ×¤× ×•×™×™×** - ×–××™×Ÿ ×œ×”×–×× ×”!\n`;
                                }
                                
                                // Check for pricing info
                                if (page.description && page.description.includes('â‚ª')) {
                                    const priceMatch = page.description.match(/â‚ª(\d+)/);
                                    if (priceMatch) {
                                        response += `  ğŸ’° **××—×™×¨:** â‚ª${priceMatch[1]}\n`;
                                    }
                                }
                                
                                // Check for location
                                if (page.description && (page.description.includes('×¨×—×•×‘') || page.description.includes('×¢×™×¨') || page.description.includes('×›×ª×•×‘×ª'))) {
                                    response += `  ğŸ“ **××™×§×•×:** ×–××™×Ÿ ×‘××–×•×¨\n`;
                                }
                                
                                // Add service description
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  ğŸ“ **×ª×™××•×¨:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  ğŸ¯ **×¨×•×¦×” ×œ×”×–××™×Ÿ?** [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl}) ××• ×”×ª×§×©×¨ ×™×©×™×¨×•×ª!\n\n`;
                            } else if (page.pageType === 'event') {
                                // Enhanced event info
                                response += `\n  **ğŸ‰ ×¤×¨×˜×™ ×”××™×¨×•×¢:**\n`;
                                
                                if (page.expectedGuests && page.expectedGuests > 0) {
                                    response += `  ğŸ‘¥ **××§×•××•×ª ×¤× ×•×™×™×:** ${page.expectedGuests} ××§×•××•×ª\n`;
                                }
                                
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  ğŸ“ **×ª×™××•×¨:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  ğŸ¯ **×¨×•×¦×” ×œ×”×¦×˜×¨×£?** [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl}) ×•×”×¨×©×!\n\n`;
                            } else if (page.pageType === 'course') {
                                // Enhanced course info
                                response += `\n  **ğŸ“ ×¤×¨×˜×™ ×”×§×•×¨×¡:**\n`;
                                
                                if (page.expectedGuests && page.expectedGuests > 0) {
                                    response += `  ğŸ‘¥ **××§×•××•×ª ×¤× ×•×™×™×:** ${page.expectedGuests} ××§×•××•×ª\n`;
                                }
                                
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  ğŸ“ **×ª×™××•×¨:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  ğŸ¯ **×¨×•×¦×” ×œ×”×™×¨×©×?** [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl}) ×•×”×ª×—×œ ×œ×œ××•×“!\n\n`;
                            } else if (page.pageType === 'store' && page.description) {
                                const productInfo = await extractProductInfo(page.description, mainKeyword, pageUrl);
                                if (productInfo) {
                                    if (productInfo.price) {
                                        response += `  ğŸ’° **××—×™×¨:** ${productInfo.price}\n`;
                                    }
                                    if (productInfo.name) {
                                        response += `  ğŸ·ï¸ **××•×¦×¨:** ${productInfo.name}\n`;
                                    }
                                    if (productInfo.location) {
                                        response += `  ğŸ“ **××™×§×•×:** ${productInfo.location}\n`;
                                    }
                                }
                            }
                            
                            response += `  <div style="margin: 8px 0; border: 2px solid #e5e7eb; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1); position: relative; width: 100vw !important; max-width: 100% !important; height: 300px !important; margin-left: calc(-50vw + 50%) !important; text-align: right !important; direction: rtl !important;">`;
                            response += `    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c);"></div>`;
                            response += `    <iframe src="${pageUrl}" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top left; position: absolute; top: 0; left: 0;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>`;
                            response += `  </div>\n\n`;
                        }
                        } // Close the if statement for non-gift searches
                        
                        if (matchingPages.length > 3) {
                            response += `×•×¢×•×“ ${matchingPages.length - 3} ×“×¤×™×...`;
                        }
                        
                        // DISABLED - No more inventing help messages
                        
                        // Add price information request
                        if (type === 'store') {
                            response += `\nğŸ’° **×¨×•×¦×” ×œ×“×¢×ª ×¢×œ ××—×™×¨×™×?** ×›×ª×•×‘ "××—×™×¨×™×" ××• "×›××” ×–×” ×¢×•×œ×”" ×•×× ×™ ××—×¤×© ×¢×‘×•×¨×š!`;
                        }
                        
                        return {
                            message: response,
                            action: { type: 'change_category_and_highlight', category: type, highlight_pages: matchingPages.slice(0, 3).map(p => p.pageId) }
                        };
                    } else {
                        // NO PAGES FOUND - Don't invent pages!
                        return {
                            message: `ğŸ˜” **×œ× ××¦××ª×™ ×“×¤×™× ×¨×œ×•×•× ×˜×™×™× ×œ"${mainKeyword}".**\n\n××‘×œ ×™×© ×œ× ×• ×“×¤×™× ××—×¨×™× ×©×™×›×•×œ×™× ×œ×¢× ×™×™×Ÿ ××•×ª×š:\n\nğŸª **×—× ×•×™×•×ª:** ${allPages.filter(p => p.pageType === 'store').length} ×“×¤×™×\nğŸ“ **×§×•×¨×¡×™×:** ${allPages.filter(p => p.pageType === 'course').length} ×“×¤×™×\nğŸ”§ **×©×™×¨×•×ª×™×:** ${allPages.filter(p => p.pageType === 'serviceProvider').length} ×“×¤×™×\nğŸ‰ **××™×¨×•×¢×™×:** ${allPages.filter(p => p.pageType === 'event').length} ×“×¤×™×\n\n**×¨×•×¦×” ×œ×¨××•×ª ×”×›×œ?** ×œ×—×¥ ×¢×œ "×”×›×œ" ×œ××¢×œ×”!`,
                            action: { type: 'none' }
                        };
                    }
                }
            }
            
            // Search by title
            const matchingPages = allPages.filter(page => 
                page.title.toLowerCase().includes(lowerMessage)
            );
            
            if (matchingPages.length > 0) {
                let response = `××¦××ª×™ ${matchingPages.length} ×“×¤×™× ×¢× "${message}":\n\n`;
                
                matchingPages.slice(0, 3).forEach(page => {
                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                    // Use real page preview with iframe
                    const emoji = page.pageType === 'store' ? 'ğŸª' : page.pageType === 'event' ? 'ğŸ‰' : page.pageType === 'course' ? 'ğŸ“' : page.pageType === 'serviceProvider' ? 'ğŸ”§' : 'ğŸ“„';
                    response += `â€¢ **${page.title}** ${emoji}\n`;
                    response += `  [ğŸ‘ï¸ ×¦×¤×” ×‘×“×£](${pageUrl})\n`;
                    response += `  <div style="margin: 8px 0; border: 2px solid #e5e7eb; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1); animation: fadeInUp 0.6s ease-out, pulse 2s infinite; position: relative; width: 100vw !important; max-width: 100% !important; height: 200px !important; margin-left: calc(-50vw + 50%) !important; text-align: right !important; direction: rtl !important;">`;
                    response += `    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c); animation: shimmer 2s infinite;"></div>`;
                    response += `    <iframe src="${pageUrl}" style="width: 200%; height: 400px; border: none; transform: scale(0.5); transform-origin: top left; transition: all 0.3s ease; position: absolute; top: 0; left: 0;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>`;
                    response += `  </div>\n\n`;
                });
                
                if (matchingPages.length > 3) {
                    response += `×•×¢×•×“ ${matchingPages.length - 3} ×“×¤×™×...`;
                }
                
                return {
                    message: response,
                    action: { type: 'change_category_and_highlight', category: matchingPages[0].pageType, highlight_pages: matchingPages.slice(0, 3).map(p => p.pageId) }
                };
            }
            
            // If no local match, prepare real data for N8N
            const realData = {
                availablePages: allPages.map(p => ({
                    title: p.title,
                    type: p.pageType,
                    products: p.products || []
                }))
            };
            
            return null; // No quick response, send to N8N with real data
        }
        
        // Function to extract product info from page content
        async function extractProductInfo(description, keyword, pageUrl) {
            console.log('ğŸ” extractProductInfo called with:', { description: description?.substring(0, 100), keyword, pageUrl });
            
            if (!description && !pageUrl) return null;
            
            const lowerKeyword = keyword.toLowerCase();
            
            // If we have a page URL, fetch the actual content
            if (pageUrl) {
                console.log('ğŸ” Fetching HTML for:', pageUrl);
                try {
                    const response = await fetch(pageUrl);
                    if (response.ok) {
                        const html = await response.text();
                        console.log('ğŸ“„ HTML fetched, length:', html.length);
                        
                        // Extract all prices from HTML
                        const pricePatterns = [
                            /â‚ª\s*(\d+(?:[.,]\d+)?)/g,
                            /×-?\s*(\d+(?:[.,]\d+)?)\s*â‚ª/g,
                            /(\d+(?:[.,]\d+)?)\s*â‚ª/g,
                            /××—×™×¨[^<]*?(\d+(?:[.,]\d+)?)/gi
                        ];
                        
                        let allPrices = [];
                        pricePatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            allPrices.push(...matches.map(m => m[1] || m[0]));
                        });
                        
                        // Remove duplicates and sort
                        allPrices = [...new Set(allPrices)].sort((a, b) => parseFloat(a) - parseFloat(b));
                        
                        console.log('ğŸ’° All prices found:', allPrices);
                        
                        // Extract service/product names
                        const namePatterns = [
                            /<h[1-6][^>]*>([^<]+)<\/h[1-6]>/gi,
                            /<div[^>]*class="[^"]*title[^"]*"[^>]*>([^<]+)<\/div>/gi,
                            /<span[^>]*class="[^"]*name[^"]*"[^>]*>([^<]+)<\/span>/gi
                        ];
                        
                        let allNames = [];
                        namePatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            allNames.push(...matches.map(m => m[1].trim()));
                        });
                        
                        // Filter names that contain the keyword
                        const relevantNames = allNames.filter(name => 
                            name.toLowerCase().includes(lowerKeyword)
                        );
                        
                        console.log('ğŸ·ï¸ Relevant names found:', relevantNames);
                        
                        // Extract location
                        const locationPatterns = [
                            /(?:×‘×›×ª×•×‘×ª|×›×ª×•×‘×ª|××™×§×•×|×‘××–×•×¨|×‘× ×ª× ×™×”|×‘×ª×œ ××‘×™×‘|×‘×™×¨×•×©×œ×™×)[^<]*?([×-×ª\s]+)/gi,
                            /<meta[^>]*name="[^"]*location[^"]*"[^>]*content="([^"]+)"/gi
                        ];
                        
                        let location = null;
                        locationPatterns.forEach(pattern => {
                            const match = html.match(pattern);
                            if (match && !location) {
                                location = match[1].trim();
                            }
                        });
                        
                        // Extract descriptions
                        const descPatterns = [
                            /<p[^>]*class="[^"]*desc[^"]*"[^>]*>([^<]+)<\/p>/gi,
                            /<div[^>]*class="[^"]*description[^"]*"[^>]*>([^<]+)<\/div>/gi
                        ];
                        
                        let descriptions = [];
                        descPatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            descriptions.push(...matches.map(m => m[1].trim()));
                        });
                        
                        return {
                            prices: allPrices.length > 0 ? allPrices : null,
                            names: relevantNames.length > 0 ? relevantNames : null,
                            location: location,
                            descriptions: descriptions.length > 0 ? descriptions : null,
                            allNames: allNames.length > 0 ? allNames : null
                        };
                    }
                } catch (error) {
                    console.error('âŒ Error fetching HTML:', error);
                }
            }
            
            // Fallback to description parsing
            if (description) {
                const lowerDesc = description.toLowerCase();
                
                // Look for price patterns in description
                const priceRegex = /[\d,]+â‚ª|[\d,]+ ×©"×—|[\d,]+ ×©×§×œ|[\d,]+ â‚ª/g;
                const prices = [];
                let match;
                while ((match = priceRegex.exec(description)) !== null) {
                    prices.push(match[0]);
                }
                
                console.log('ğŸ’° Prices found in description:', prices);
                
                if (prices.length > 0) {
                    // Try to find product name near the keyword
                    const keywordIndex = lowerDesc.indexOf(lowerKeyword);
                    if (keywordIndex !== -1) {
                        const start = Math.max(0, keywordIndex - 50);
                        const end = Math.min(description.length, keywordIndex + 50);
                        const context = description.substring(start, end);
                        
                        return {
                            name: context.trim(),
                            price: prices[0]
                        };
                    }
                }
            }
            
            return null;
        }
        
        // ğŸ§  CONVERSATION CONTEXT MEMORY for Marketplace (global variable)
        if (!window.marketplaceConversationContext) {
            window.marketplaceConversationContext = {
                lastSearchCategory: null,      // Last category user searched for (e.g., "×¦×¢×¦×•×¢")
                lastShownPages: [],            // Last pages we showed
                rejectedCategories: [],        // Categories user said "no" to
                conversationHistory: [],       // Full conversation history
                recommendedPage: null          // Page we recommended for user to visit
            };
        }

        // Enhanced sendAIMessage with smart search
        async function sendAIMessageEnhanced() {
            try {
                const input = document.getElementById('aiChatInput');
                const userMessage = input.value.trim();
                
                if (!userMessage) return;
                
                // âœ… CHECK if user is confirming to visit a recommended page (e.g., "×›×Ÿ", "××•×§×™×™", "×‘×˜×—")
                const confirmations = ['×›×Ÿ', '×‘×˜×—', '××•×§×™×™', '××•×§×™', 'ok', 'yes', '×™××œ×œ×”', '×‘×•×', '×ª×¨××”', '×ª×¨××™', '×”×¦×’', '×”×¦×™×’×™'];
                const isConfirmation = confirmations.some(c => userMessage.toLowerCase().trim() === c || userMessage.toLowerCase().includes(c));
                
                // ğŸŒ IF USER CONFIRMED and we have a recommended page - OPEN IT!
                if (isConfirmation && window.marketplaceConversationContext.recommendedPage) {
                    console.log('âœ… USER CONFIRMED - Opening recommended page:', window.marketplaceConversationContext.recommendedPage);
                    
                    const recommendedPage = window.marketplaceConversationContext.recommendedPage;
                    
                    // Display user message
                    addAIMessage(userMessage, true);
                    input.value = '';
                    
                    // Show a confirmation message
                    addAIMessage(`âœ… **×¤×•×ª×— ××ª "${recommendedPage.title}"...**`, false);
                    
                    // Show the preview with animation
                    const chatMessages = document.getElementById('aiChatMessages');
                    if (chatMessages) {
                        const previewDiv = document.createElement('div');
                        previewDiv.className = 'ai-message bot';
                        previewDiv.style.cssText = `
                            margin: 16px 0;
                            border: 2px solid #e5e7eb;
                            border-radius: 12px;
                            overflow: hidden;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            width: 100%;
                            max-width: 100%;
                            height: 500px;
                            opacity: 0;
                            transform: translateY(20px);
                            transition: all 0.5s ease;
                        `;
                        
                        previewDiv.innerHTML = `
                            <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                <span>ğŸŒ</span>
                                <span>${recommendedPage.title}</span>
                            </div>
                            <div style="position: relative; height: 450px; overflow: hidden;">
                                <iframe src="` + recommendedPage.url + `" style="width: 200%; height: 900px; border: none; transform: scale(0.5); transform-origin: top right; position: absolute; top: 0; right: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';"></iframe>
                            </div>
                        `;
                        
                        chatMessages.appendChild(previewDiv);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        
                        setTimeout(() => {
                            previewDiv.style.opacity = '1';
                            previewDiv.style.transform = 'translateY(0)';
                        }, 100);
                    }
                    
                    // Clear the recommended page from context
                    window.marketplaceConversationContext.recommendedPage = null;
                    
                    return; // STOP HERE
                }
                
                // Display user message
                addAIMessage(userMessage, true);
                input.value = '';
                
                // Show typing indicator
                addAIMessage('ğŸ¤– ×¡×ª×™×• ××§×œ×™×“×”<span class="typing-dots">...</span>', false);
                
                // Always reload pages to get latest pages
                console.log('ğŸ”„ Reloading pages to get latest...');
                await loadPages();
                
                // Try smart search first for real page results
                try {
                    // FORCE LIVE DATA SEARCH - NO FIXED MESSAGES
                    console.log('ğŸ” FORCING LIVE SEARCH for:', userMessage);
                    const liveResults = await searchLivePages(userMessage);
                    
                    if (liveResults.length > 0) {
                        // Remove typing indicator
                        removeTypingIndicator();
                        
                        // Display live results
                        let response = `××¦××ª×™ ${liveResults.length} ×“×¤×™× ×¨×œ×•×•× ×˜×™×™×:\n\n`;
                        liveResults.forEach(page => {
                            response += `ğŸª **${page.title}**\n`;
                            if (page.description) {
                                response += `${page.description}\n`;
                            }
                            
                            // Show live product data if available
                            if (page.liveProducts && page.liveProducts.length > 0) {
                                response += `ğŸ’° ××•×¦×¨×™× ×—×™×™×:\n`;
                                page.liveProducts.forEach(product => {
                                    response += `â€¢ ${product.name} - â‚ª${product.price}\n`;
                                });
                            }
                            
                            response += `ğŸ”— [×¦×¤×” ×‘×“×£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                        });
                        
                        addAIMessage(response, false);
                        return;
                    }
                } catch (error) {
                    console.error('Error in live search:', error);
                }
                
                // If no smart search result, send to N8N with REAL DATA
                try {
                    // Prepare real data context for N8N
                    const realDataContext = `××ª×” ×¢×•×–×¨ ×‘××¨×§×˜×¤×œ×™×™×¡. ×¢× ×” ×¢×œ ×©××œ×•×ª ×‘×¦×•×¨×” ×™×“×™×“×•×ª×™×ª ×‘×”×ª×‘×¡×¡ ×¢×œ ×”× ×ª×•× ×™× ×”×××™×ª×™×™× ×”×‘××™×:

**×“×¤×™× ×–××™× ×™× ×‘××¢×¨×›×ª:**
${allPages.map(page => {
    let pageInfo = `- ${page.title} (${page.pageType === 'store' ? '×—× ×•×ª' : page.pageType === 'course' ? '×§×•×¨×¡' : page.pageType === 'event' ? '××™×¨×•×¢' : '×©×™×¨×•×ª'})`;
    if (page.products && page.products.length > 0) {
        pageInfo += '\n  ××•×¦×¨×™×:';
        page.products.forEach(product => {
            pageInfo += `\n  * ${product.name} - â‚ª${product.price}`;
        });
    }
    return pageInfo;
}).join('\n')}

**×—×©×•×‘:** ×”×©×ª××© ×¨×§ ×‘× ×ª×•× ×™× ×××™×ª×™×™× ××”×¨×©×™××” ×œ××¢×œ×”. ××œ ×ª××¦×™× ×“×¤×™×, ×—× ×•×™×•×ª ××• ××•×¦×¨×™× ×©×œ× ××•×¤×™×¢×™× ×‘×¨×©×™××”. ×× ××™×Ÿ ××™×“×¢ ×–××™×Ÿ, ×××•×¨ ×–××ª ×‘×›× ×•×ª.`;

                    const response = await fetch('https://n8n-service-how4.onrender.com/webhook/jhfuhgufkhlkuho8erhf757754jhldkbsjkbmreketpg', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            message: userMessage,
                            context: 'marketplace',
                            contextText: realDataContext
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        removeTypingIndicator();
                        
                        // âœ… Display N8N response
                        addAIMessage(data.message || '×¡×œ×™×—×”, ×§×¨×ª×” ×©×’×™××”. × ×¡×” ×©×•×‘!', false);
                        
                        // ğŸ EXTRACT page names from N8N response and show PREVIEW for each!
                        // Example: "ğŸª **×™× ×™×‘ ×¦×¢×¦×•×¢ AI 1760965952188** store page"
                        const pagePattern = /ğŸª\s+\*\*([^\*]+)\*\*/g;
                        const pageMatches = [...data.message.matchAll(pagePattern)];
                        
                        if (pageMatches.length > 0) {
                            console.log('ğŸ Found', pageMatches.length, 'pages in N8N response - showing previews!');
                            
                            const chatMessages = document.getElementById('aiChatMessages');
                            const displayedPages = new Set(); // ğŸš« Track displayed pages to avoid duplicates
                            let previewIndex = 0;
                            
                            for (const match of pageMatches) {
                                const pageTitle = match[1].trim();
                                console.log('ğŸ” Looking for page:', pageTitle);
                                
                                // Find the page in allPages
                                const foundPage = allPages.find(p => 
                                    p.title === pageTitle || 
                                    p.pageId === pageTitle ||
                                    pageTitle.includes(p.pageId)
                                );
                                
                                if (foundPage && chatMessages) {
                                    const pageId = foundPage.pageId;
                                    
                                    // ğŸš« SKIP if we already displayed this page
                                    if (displayedPages.has(pageId)) {
                                        console.log('â­ï¸  Skipping duplicate page:', foundPage.title);
                                        continue;
                                    }
                                    
                                    displayedPages.add(pageId); // Mark as displayed
                                    
                                    const pageUrl = `/users/${foundPage.userId}/${foundPage.pageId}_html`;
                                    console.log('âœ… Found page! Creating preview for:', foundPage.title);
                                    
                                    // Create animated preview
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'ai-message bot';
                                    previewDiv.style.cssText = `
                                        margin: 16px 0;
                                        border: 2px solid #e5e7eb;
                                        border-radius: 12px;
                                        overflow: hidden;
                                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                                        width: 100%;
                                        max-width: 100%;
                                        height: 350px;
                                        opacity: 0;
                                        transform: translateY(20px);
                                        transition: all 0.5s ease;
                                    `;
                                    
                                    previewDiv.innerHTML = `
                                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                            <span>ğŸ</span>
                                            <span>${foundPage.title}</span>
                                        </div>
                                        <div style="position: relative; height: 300px; overflow: hidden;">
                                            <iframe src="` + pageUrl + `" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top right; position: absolute; top: 0; right: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';"></iframe>
                                        </div>
                                    `;
                                    
                                    chatMessages.appendChild(previewDiv);
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                    
                                    // Animate in with stagger
                                    setTimeout(() => {
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 100 * (previewIndex + 1)); // Stagger animation based on actual displayed index
                                    
                                    previewIndex++; // Increment for next preview
                                }
                            }
                        }
                        
                        return;
                    }
                } catch (error) {
                    console.error('Error calling N8N:', error);
                }
                
                // Fallback if N8N fails - try to search live pages
                removeTypingIndicator();
                
                // Try to search live pages for the user's query
                console.log(`ğŸ” Searching for: "${userMessage}"`);
                try {
                    // Auto-reload pages to get latest pages
                    console.log('ğŸ”„ Auto-reloading pages to get latest...');
                    await loadPages();
                    
                    const liveSearchResult = await searchLivePages(userMessage);
                    if (liveSearchResult && liveSearchResult.length > 0) {
                        let response = `××¦××ª×™ ${liveSearchResult.length} ×“×¤×™× ×¨×œ×•×•× ×˜×™×™×:\n\n`;
                        liveSearchResult.forEach(page => {
                            response += `ğŸª **${page.title}**\n`;
                            if (page.description) {
                                response += `${page.description}\n`;
                            }
                            
                            // Show live product data if available
                            if (page.liveProducts && page.liveProducts.length > 0) {
                                response += `ğŸ’° ××•×¦×¨×™× ×—×™×™×:\n`;
                                page.liveProducts.forEach(product => {
                                    response += `â€¢ ${product.name} - â‚ª${product.price}\n`;
                                });
                            }
                            
                            response += `ğŸ”— [×¦×¤×” ×‘×“×£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                        });
                        addAIMessage(response, false);
                    } else {
                        addAIMessage("×× ×™ ×›××Ÿ ×œ×¢×–×•×¨ ×œ×š! ğŸ˜Š ×× ××ª×” ××—×¤×© ××©×”×• ×¡×¤×¦×™×¤×™, ×ª×•×›×œ ×œ×©××•×œ ××•×ª×™ ×¢×œ ××ª× ×•×ª, ×œ×§, ×©×¢×•× ×™×, ×¦×¢×¦×•×¢×™× ××• ×§×•×¨×¡×™×.", false);
                    }
                } catch (error) {
                    console.error('Error in live search:', error);
                    addAIMessage("×× ×™ ×›××Ÿ ×œ×¢×–×•×¨ ×œ×š! ğŸ˜Š ×× ××ª×” ××—×¤×© ××©×”×• ×¡×¤×¦×™×¤×™, ×ª×•×›×œ ×œ×©××•×œ ××•×ª×™ ×¢×œ ××ª× ×•×ª, ×œ×§, ×©×¢×•× ×™×, ×¦×¢×¦×•×¢×™× ××• ×§×•×¨×¡×™×.", false);
                }
                return;
                
            } catch (error) {
                console.error('âŒ Error in sendAIMessageEnhanced:', error);
                removeTypingIndicator();
                addAIMessage('×¡×œ×™×—×”, ×§×¨×ª×” ×©×’×™××”. × ×¡×” ×©×•×‘!', false);
            }
        }
        
        // Execute actions
        async function executeAction(action) {
            if (action.type === 'change_category') {
                console.log('ğŸ·ï¸ Changing to category:', action.category);
                
                // Map category names
                const categoryMap = {
                    'store': 'store',
                    'stores': 'store',
                    '×—× ×•×ª': 'store',
                    '×—× ×•×™×•×ª': 'store',
                    'event': 'event',
                    'events': 'event',
                    '××™×¨×•×¢': 'event',
                    '××™×¨×•×¢×™×': 'event',
                    'course': 'course',
                    'courses': 'course',
                    '×§×•×¨×¡': 'course',
                    '×§×•×¨×¡×™×': 'course',
                    'serviceProvider': 'serviceProvider',
                    'service': 'serviceProvider',
                    '×‘×¢×œ×™ ××§×¦×•×¢': 'serviceProvider',
                    'all': 'all',
                    '×”×›×œ': 'all'
                };
                
                const mappedCategory = categoryMap[action.category.toLowerCase()] || action.category;
                console.log('ğŸ“‚ Mapped category:', mappedCategory);
                
                // Update UI buttons - use the existing filterByType function
                filterByType(mappedCategory);
                
                // Scroll to top to see results
                setTimeout(() => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    console.log('âœ… Category changed to:', mappedCategory);
                    console.log('ğŸ“Š New filteredPages length:', filteredPages.length);
                    
                    // Show success message
                    addAIMessage(`âœ… ×¢×‘×¨×ª×™ ×œ×§×˜×’×•×¨×™×™×ª ${getTypeName(mappedCategory)}! ××¦× ${filteredPages.length} ×“×¤×™×.`, false);
                }, 100);
            } else if (action.type === 'change_category_and_highlight') {
                console.log('ğŸ·ï¸ Changing to category and highlighting pages:', action.category, action.highlight_pages);
                
                // Map category names
                const categoryMap = {
                    'store': 'store',
                    'stores': 'store',
                    '×—× ×•×ª': 'store',
                    '×—× ×•×™×•×ª': 'store',
                    'event': 'event',
                    'events': 'event',
                    '××™×¨×•×¢': 'event',
                    '××™×¨×•×¢×™×': 'event',
                    'course': 'course',
                    'courses': 'course',
                    '×§×•×¨×¡': 'course',
                    '×§×•×¨×¡×™×': 'course',
                    'serviceProvider': 'serviceProvider',
                    'service': 'serviceProvider',
                    '×‘×¢×œ×™ ××§×¦×•×¢': 'serviceProvider',
                    'all': 'all',
                    '×”×›×œ': 'all'
                };
                
                const mappedCategory = categoryMap[action.category.toLowerCase()] || action.category;
                console.log('ğŸ“‚ Mapped category:', mappedCategory);
                
                // Update UI buttons - use the existing filterByType function
                filterByType(mappedCategory);
                
                // Scroll to top and highlight pages
                setTimeout(() => {
                    // Highlight matching pages first
                    if (action.highlight_pages && action.highlight_pages.length > 0) {
                        action.highlight_pages.forEach((pageId, index) => {
                            const pageCard = document.querySelector(`[data-page-id="${pageId}"]`);
                            if (pageCard) {
                                pageCard.style.outline = '3px solid #667eea';
                                pageCard.style.transform = 'scale(1.05)';
                                pageCard.style.transition = 'all 0.3s ease';
                                pageCard.style.boxShadow = '0 10px 25px rgba(102, 126, 234, 0.3)';
                                
                                // Scroll to first highlighted page with delay
                                if (index === 0) {
                                    setTimeout(() => {
                                        pageCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    }, 200);
                                }
                                
                                setTimeout(() => {
                                    pageCard.style.outline = '';
                                    pageCard.style.transform = '';
                                    pageCard.style.boxShadow = '';
                                }, 5000);
                            }
                        });
                    }
                    
                    console.log('âœ… Category changed to:', mappedCategory);
                    console.log('ğŸ“Š New filteredPages length:', filteredPages.length);
                    
                    // Show success message
                    addAIMessage(`âœ… ×¢×‘×¨×ª×™ ×œ×§×˜×’×•×¨×™×™×ª ${getTypeName(mappedCategory)}! ××¦× ${filteredPages.length} ×“×¤×™×.`, false);
                }, 100);
            } else if (action.type === 'scroll_to_page' && action.page_id) {
                console.log('ğŸ” Looking for page card with ID:', action.page_id);
                
                // Find the page card and scroll to it
                setTimeout(() => {
                    const pageCard = document.querySelector(`[data-page-id="${action.page_id}"]`);
                    if (pageCard) {
                        pageCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        pageCard.style.outline = '3px solid #667eea';
                        pageCard.style.transform = 'scale(1.05)';
                        pageCard.style.transition = 'all 0.3s ease';
                        pageCard.style.boxShadow = '0 10px 25px rgba(102, 126, 234, 0.3)';
                        
                        setTimeout(() => {
                            pageCard.style.outline = '';
                            pageCard.style.transform = '';
                            pageCard.style.boxShadow = '';
                        }, 3000);
                    } else {
                        console.error('âŒ Page card not found for:', action.page_id);
                        addAIMessage('ğŸ” ××¦××ª×™ ××ª ×”×“×£ ××‘×œ ×œ× ×”×¦×œ×—×ª×™ ×œ×’×œ×•×œ ××œ×™×•. ×—×¤×© ××•×ª×• ×‘×¨×©×™××” ×œ××¢×œ×”!', false);
                    }
                }, 500);
            } else if (action.type === 'show_page' && action.page_id) {
                // Open page in new tab
                const page = allPages.find(p => p.pageId === action.page_id);
                if (page) {
                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                    window.open(pageUrl, '_blank');
                }
            }
        }
        
        // Function to extract prices from page content
        async function extractPricesFromPage(page) {
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (!response.ok) return null;
                
                const htmlContent = await response.text();
                const priceRegex = /â‚ª\s*(\d+(?:,\d{3})*(?:\.\d{2})?)/g;
                const prices = [];
                let match;
                
                while ((match = priceRegex.exec(htmlContent)) !== null) {
                    prices.push(match[0]);
                }
                
                return prices.length > 0 ? prices : null;
            } catch (error) {
                console.error('Error extracting prices:', error);
                return null;
            }
        }
        
        // Enhanced search with price information - LIVE VERSION
        async function searchWithPrices(message) {
            // Enhanced search that reads from live pages
            const searchResults = [];
            
            for (const page of allPages) {
                if (page.pageType === 'store') {
                    // Always check live page content for products
                    const productInfo = await extractProductInfo(page.description, message, `/users/${page.userId}/${page.pageId}_html`);
                    
                    if (productInfo && productInfo.price) {
                        searchResults.push({
                            ...page,
                            productInfo: productInfo
                        });
                    }
                }
            }
            
            console.log(`ğŸ” Live search results for "${message}":`, searchResults);
            return searchResults;
        }
        
        // Fix the filterByCategory function
        function filterByCategory(category) {
            currentType = category;
            
            if (category === 'all') {
                filteredPages = [...allPages];
            } else {
                filteredPages = allPages.filter(page => page.pageType === category);
            }
            
            displayPages();
            updatePagesCount();
        }
        
        // New function to search live pages - FORCE LIVE DATA VERSION
        async function searchLivePages(query) {
            try {
                // ğŸ¯ NEW: Fix common typos before search
                const typoFixes = {
                    '×©×¢×˜× ×™×': '×©×¢×•× ×™×',
                    '×©×¢×˜×•×Ÿ': '×©×¢×•×Ÿ',
                    '×¦×¢×¦×•×˜×™×': '×¦×¢×¦×•×¢×™×',
                    '×¦×¢×¦×˜×•×¢': '×¦×¢×¦×•×¢',
                    '××¡×¢×“×': '××¡×¢×“×”',
                    '××¡×“×¢×”': '××¡×¢×“×”'
                };
                
                let fixedQuery = query;
                for (const [typo, correct] of Object.entries(typoFixes)) {
                    if (fixedQuery.toLowerCase().includes(typo)) {
                        fixedQuery = fixedQuery.replace(new RegExp(typo, 'gi'), correct);
                        console.log(`ğŸ”§ Fixed typo: "${typo}" â†’ "${correct}" in query: "${query}" â†’ "${fixedQuery}"`);
                    }
                }
                
                const searchTerm = fixedQuery.toLowerCase();
                let results = []; // Changed from const to let - need to reassign for city filtering
                
                console.log(`ğŸ” FORCING LIVE DATA SEARCH for: "${searchTerm}"`);
            
            // Extract location from query - expanded city list
            const cities = [
                '×ª×œ ××‘×™×‘', '×™×¨×•×©×œ×™×', '×—×™×¤×”', '×‘××¨ ×©×‘×¢', '× ×ª× ×™×”', '××©×“×•×“', '×¨××ª ×’×Ÿ', '×¤×ª×— ×ª×§×•×•×”', 
                '×‘× ×™ ×‘×¨×§', '×—×•×œ×•×Ÿ', '×¨×—×•×‘×•×ª', '×›×¤×¨ ×¡×‘×', '××™×œ×ª', '×¨×¢× × ×”', '×”×¨×¦×œ×™×”', '×‘×œ×•××¤×™×œ×“', 
                '×¨××ª ×—×Ÿ', '×—×“×¨×”', '×§×¨×™×™×ª ×‘×™××œ×™×§', '×§×¨×™×™×ª ××•×¦×§×™×Ÿ', '×¨××©×•×Ÿ ×œ×¦×™×•×Ÿ', '× ×”×¨×™×”', 
                '×”×•×“ ×”×©×¨×•×Ÿ', '×’×‘×¢×ª×™×™×', '×§×¨×™×™×ª ××ª×', '×§×¨×™×™×ª ×©××•× ×”', '×‘×™×ª ×©××Ÿ', '×¢×¤×•×œ×”',
                '×—×“×¨×”', '×¨××ª ×”×©×¨×•×Ÿ', '×¨×¢× × ×”', '×¨××ª ×’×Ÿ', '×¤×ª×— ×ª×§×•×•×”', '×›×¤×¨ ×¡×‘×'
            ];
            
            // Common typos/variations map
            const cityTypos = {
                '×§×™×¨×™×ª': '×§×¨×™×™×ª',
                '×§×¨×™×ª': '×§×¨×™×™×ª',
                '×§×™×¨×™×™×ª': '×§×¨×™×™×ª',
                '×ª×œ-××‘×™×‘': '×ª×œ ××‘×™×‘',
                '×ª×œ××‘×™×‘': '×ª×œ ××‘×™×‘',
                '×ª"×': '×ª×œ ××‘×™×‘',
                '×‘××¨-×©×‘×¢': '×‘××¨ ×©×‘×¢',
                '×‘××¨×©×‘×¢': '×‘××¨ ×©×‘×¢',
                '×‘"×©': '×‘××¨ ×©×‘×¢'
            };
            
            let requiredCity = null;
            
            // Try multiple patterns to extract city
            // Pattern 1: "×©×™×¨×•×ª ×‘× ×ª× ×™×”" or "× ×’×¨ ×‘× ×ª× ×™×”" (service ×‘ city)
            const patternWithBe = /([×-×ª\s]+)\s+×‘([×-×ª\s]+)/;
            const matchWithBe = searchTerm.match(patternWithBe);
            if (matchWithBe && matchWithBe[2]) {
                let potentialCity = matchWithBe[2].trim();
                
                // ğŸ¯ FIX: Check for typos first
                for (const [typo, correct] of Object.entries(cityTypos)) {
                    if (potentialCity.includes(typo)) {
                        potentialCity = potentialCity.replace(typo, correct);
                        console.log(`ğŸ“ Fixed city typo: "${matchWithBe[2]}" â†’ "${potentialCity}"`);
                        break;
                    }
                }
                
                // Check if it's a known city
                for (const city of cities) {
                    if (city.toLowerCase() === potentialCity.toLowerCase() || 
                        city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                        potentialCity.toLowerCase().includes(city.toLowerCase())) {
                        requiredCity = city;
                        console.log(`âœ… Location specified (×‘ pattern): "${matchWithBe[2]}" â†’ ${city}`);
                        break;
                    }
                }
                // If no match but it looks like a city (Hebrew word 2-15 chars), use it
                if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15 && /^[×-×ª\s]+$/.test(potentialCity)) {
                    requiredCity = potentialCity;
                    console.log(`ğŸ“ Location specified (new city from ×‘ pattern): ${potentialCity}`);
                }
            }
            
            // Pattern 2: Exact city name in query
            if (!requiredCity) {
                for (const city of cities) {
                    if (searchTerm.includes(city.toLowerCase())) {
                        requiredCity = city;
                        console.log(`ğŸ“ Location specified (exact): ${city}`);
                        break;
                    }
                }
            }
            
            // Pattern 3: "(×‘|×‘×ª×•×š|×‘×©×“×”) ×¢×™×¨" pattern
            if (!requiredCity) {
                const cityPattern = /(?:×‘|×‘×ª×•×š|×‘×©×“×”)\s+([×-×ª]{2,})/;
                const cityMatch = searchTerm.match(cityPattern);
                if (cityMatch && cityMatch[1]) {
                    const potentialCity = cityMatch[1].trim();
                    // Check if it's a known city (partial match)
                    for (const city of cities) {
                        if (city.toLowerCase().includes(potentialCity.toLowerCase()) || potentialCity.toLowerCase().includes(city.toLowerCase())) {
                            requiredCity = city;
                            console.log(`ğŸ“ Location specified (partial): ${potentialCity} â†’ ${city}`);
                            break;
                        }
                    }
                    // If no match found but it's a city query, use it as-is
                    if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15) {
                        requiredCity = potentialCity;
                        console.log(`ğŸ“ Location specified (new city): ${potentialCity}`);
                    }
                }
            }
            
            // SMART KEYWORD MAPPING - ××™×œ×•×ª ××¤×ª×— ×œ×§×˜×’×•×¨×™×•×ª ×¢× ×”×§×©×¨×™× ×—×›××™×
            const smartKeywords = {
                // ××ª× ×•×ª
                '××ª× ×” ×œ×™×œ×“': {categories: ['×¦×¢×¦×•×¢', '××©×—×§'], excludeTypes: ['serviceProvider']},
                '××ª× ×” ×œ×™×œ×“×™×': {categories: ['×¦×¢×¦×•×¢', '××©×—×§'], excludeTypes: ['serviceProvider']},
                '××ª× ×” ×œ×‘×Ÿ': {categories: ['×¦×¢×¦×•×¢', '××©×—×§'], excludeTypes: ['serviceProvider']},
                '××ª× ×” ×œ×‘×ª': {categories: ['×¦×¢×¦×•×¢', '××©×—×§', '×œ×§'], excludeTypes: ['serviceProvider']},
                '××ª× ×” ×œ××™×©×”': {categories: ['×©×¢×•×Ÿ', '×ª×›×©×™×˜', '×œ×§', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '×§×•×¡××˜×™×§×”'], excludeTypes: ['serviceProvider']},
                '××ª× ×” ×œ×‘×—×•×¨×”': {categories: ['×©×¢×•×Ÿ', '×ª×›×©×™×˜', '×œ×§', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '×§×•×¡××˜×™×§×”'], excludeTypes: ['serviceProvider']},
                '××ª× ×” ×œ××©×”': {categories: ['×©×¢×•×Ÿ', '×ª×›×©×™×˜', '×œ×§', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '×§×•×¡××˜×™×§×”'], excludeTypes: ['serviceProvider']},
                '××ª× ×” ×œ×‘×¢×œ': {categories: ['×©×¢×•×Ÿ', '×˜×›× ×•×œ×•×’×™×”', '×¨×•×‘×•×˜', '×’××“×’×˜'], excludeTypes: ['serviceProvider'], excludeWords: ['×¦×¢×¦×•×¢', 'toy', '×œ×§', '×× ×™×§×•×¨', '×—×œ×¤×™×']},
                '××ª× ×” ×œ×‘×¢×œ×™': {categories: ['×©×¢×•×Ÿ', '×˜×›× ×•×œ×•×’×™×”', '×¨×•×‘×•×˜', '×’××“×’×˜'], excludeTypes: ['serviceProvider'], excludeWords: ['×¦×¢×¦×•×¢', 'toy', '×œ×§', '×× ×™×§×•×¨', '×—×œ×¤×™×']},
                '××ª× ×” ×œ×’×‘×¨': {categories: ['×©×¢×•×Ÿ', '×˜×›× ×•×œ×•×’×™×”', '×¨×•×‘×•×˜', '×’××“×’×˜'], excludeTypes: ['serviceProvider'], excludeWords: ['×¦×¢×¦×•×¢', 'toy', '×œ×§', '×× ×™×§×•×¨', '×—×œ×¤×™×']},
                '××ª× ×” ×œ×‘×—×•×¨': {categories: ['×©×¢×•×Ÿ', '×˜×›× ×•×œ×•×’×™×”', '×¨×•×‘×•×˜', '×’××“×’×˜'], excludeTypes: ['serviceProvider'], excludeWords: ['×¦×¢×¦×•×¢', 'toy', '×œ×§', '×× ×™×§×•×¨', '×—×œ×¤×™×']},
                '××ª× ×”': {categories: ['×©×¢×•×Ÿ', '×ª×›×©×™×˜', '×¦×¢×¦×•×¢', '×œ×§'], excludeTypes: ['serviceProvider']},
                
                // ×™×œ×“×™×
                '×™×œ×“': {categories: ['×¦×¢×¦×•×¢'], excludeTypes: ['serviceProvider']},
                '×™×œ×“×™×': {categories: ['×¦×¢×¦×•×¢'], excludeTypes: ['serviceProvider']},
                '×¦×¢×¦×•×¢': {categories: ['×¦×¢×¦×•×¢'], excludeTypes: []},
                
                // ××•×¦×¨×™× - ××™×œ×•×ª ××¤×ª×— ××“×•×™×§×•×ª ×¢× ×¡×™× ×•×Ÿ
                '×œ×§': {
                    categories: ['×œ×§', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '×§×•×¡××˜×™×§×”', '×¦×™×¤×•×¨× ×™×™×'],
                    excludeTypes: [],
                    excludeWords: ['×©×¢×•×Ÿ', 'watch', '×˜×›× ×•×œ×•×’×™×”', 'technology'], // ×œ× ×œ×”×‘×™× ×©×¢×•× ×™×
                    requireWords: ['×œ×§', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '×§×•×¡××˜×™×§×”', '×¦×™×¤×•×¨× ×™×™×'] // ×“×¨×•×© ××—×“ ××”×
                },
                '×©×¢×•×Ÿ': {
                    categories: ['×©×¢×•×Ÿ'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['×œ×§', '×× ×™×§×•×¨', '×§×•×¡××˜×™×§×”', '×¦×¢×¦×•×¢', 'toy'], // ×œ× ×œ×”×‘×™× ×œ×§ ××• ×¦×¢×¦×•×¢×™×
                    requireWords: ['×©×¢×•×Ÿ', 'watch']
                },
                '×¨×§ ×©×¢×•×Ÿ': {
                    categories: ['×©×¢×•×Ÿ'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['×œ×§', '×× ×™×§×•×¨', '×§×•×¡××˜×™×§×”', '×¦×¢×¦×•×¢', 'toy', '×—×œ×¤×™×', '×—×œ×£'], // ğŸ¯ STRICT: exclude toys, car parts, etc.
                    requireWords: ['×©×¢×•×Ÿ', 'watch'] // MUST have watch in title/products
                },
                '×©×¢×•×Ÿ ×‘×œ×‘×“': {
                    categories: ['×©×¢×•×Ÿ'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['×œ×§', '×× ×™×§×•×¨', '×§×•×¡××˜×™×§×”', '×¦×¢×¦×•×¢', 'toy', '×—×œ×¤×™×', '×—×œ×£'], // ğŸ¯ STRICT: exclude toys, car parts, etc.
                    requireWords: ['×©×¢×•×Ÿ', 'watch'] // MUST have watch in title/products
                },
                '×¨×§ ×©×¢×•× ×™×': {
                    categories: ['×©×¢×•×Ÿ'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['×œ×§', '×× ×™×§×•×¨', '×§×•×¡××˜×™×§×”', '×¦×¢×¦×•×¢', 'toy', '×—×œ×¤×™×', '×—×œ×£'], // ğŸ¯ STRICT: exclude toys, car parts, etc.
                    requireWords: ['×©×¢×•×Ÿ', 'watch'] // MUST have watch in title/products
                },
                '×©×¢×•× ×™×': {
                    categories: ['×©×¢×•×Ÿ'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['×œ×§', '×× ×™×§×•×¨', '×§×•×¡××˜×™×§×”'],
                    requireWords: ['×©×¢×•×Ÿ', 'watch']
                },
                '×˜×œ×¤×•×Ÿ': {
                    categories: ['×˜×›× ×•×œ×•×’×™×”'],
                    excludeTypes: [],
                    excludeWords: [],
                    requireWords: ['×˜×œ×¤×•×Ÿ', 'phone', '×˜×›× ×•×œ×•×’×™×”']
                },
                '×˜×›× ×•×œ×•×’×™×”': {
                    categories: ['×˜×›× ×•×œ×•×’×™×”'],
                    excludeTypes: [],
                    excludeWords: [],
                    requireWords: ['×˜×›× ×•×œ×•×’×™×”', 'technology']
                },
                
                // ×¨×›×‘ - ×”×§×©×¨ ×—×›×!
                '×”×œ×š ×œ×™ ×”×¨×›×‘': {categories: ['×—×œ×¤×™×', '××•×¡×š', '×¨×›×‘×ª', '×¨×›×‘', '×—×œ×§'], preferTypes: ['store']},
                '×”×œ×š ×œ×™ ×¨×›×‘': {categories: ['×—×œ×¤×™×', '××•×¡×š', '×¨×›×‘×ª', '×¨×›×‘', '×—×œ×§'], preferTypes: ['store']},
                '×ª×§×œ×” ×‘×¨×›×‘': {categories: ['×—×œ×¤×™×', '××•×¡×š', '×¨×›×‘', '×—×œ×§'], preferTypes: ['store']},
                '×‘×¢×™×” ×‘×¨×›×‘': {categories: ['×—×œ×¤×™×', '××•×¡×š', '×¨×›×‘', '×—×œ×§'], preferTypes: ['store']},
                '×§×œ×§×•×œ ×¨×›×‘': {categories: ['×—×œ×¤×™×', '××•×¡×š', '×¨×›×‘', '×—×œ×§'], preferTypes: ['store']},
                '×¦×¨×™×š ×—×œ×¤×™×': {categories: ['×—×œ×¤×™×', '×¨×›×‘', '×—×œ×§'], preferTypes: ['store']},
                '×—×œ×¤×™×': {categories: ['×—×œ×¤×™×', '×¨×›×‘', '×—×œ×§'], preferTypes: ['store']},
                '××•×¡×š': {categories: ['××•×¡×š', '×—×œ×¤×™×', '×¨×›×‘'], preferTypes: ['store', 'serviceProvider']},
                '×¨×›×‘×ª': {categories: ['×—×œ×¤×™×', '×¨×›×‘×ª', '×¨×›×‘', '×—×œ×§'], preferTypes: ['store']},
                '×—×œ×§×™ ×¨×›×‘': {categories: ['×—×œ×¤×™×', '×¨×›×‘', '×—×œ×§'], preferTypes: ['store']},
                '×¨×›×‘': {categories: ['×—×œ×¤×™×', '×¨×›×‘', '×—×œ×§', '××•×¡×š'], preferTypes: ['store']},
                
                // ×©×™×¨×•×ª×™×
                '××™× ×¡×˜×œ×˜×•×¨': {categories: ['××™× ×¡×˜×œ×˜×•×¨', '×©×™×¨×•×ª'], preferTypes: ['serviceProvider']},
                '× ×’×¨': {categories: ['× ×’×¨', '× ×’×¨×•×ª', '×©×™×¨×•×ª'], preferTypes: ['serviceProvider']},
                '× ×’×¨×•×ª': {categories: ['× ×’×¨', '× ×’×¨×•×ª', '×©×™×¨×•×ª'], preferTypes: ['serviceProvider']},
                'plumber': {categories: ['××™× ×¡×˜×œ×˜×•×¨', '×©×™×¨×•×ª'], preferTypes: ['serviceProvider']},
                'electrician': {categories: ['×—×©××œ××™', '×©×™×¨×•×ª'], preferTypes: ['serviceProvider']},
                '×—×©××œ××™': {categories: ['×—×©××œ××™', '×©×™×¨×•×ª'], preferTypes: ['serviceProvider']},
                '××¡×¤×¨×”': {categories: ['××¡×¤×¨×”', '×©×™×¨×•×ª'], preferTypes: ['serviceProvider']},
                '×§×•×¡××˜×™×§××™×ª': {categories: ['×œ×§', '×§×•×¡××˜×™×§××™×ª', '×©×™×¨×•×ª'], preferTypes: ['serviceProvider']},
                '××××Ÿ': {categories: ['××××Ÿ', '×××× ×ª', '×©×™×¨×•×ª'], preferTypes: ['serviceProvider']},
                '×××× ×ª': {categories: ['××××Ÿ', '×××× ×ª', '×©×™×¨×•×ª'], preferTypes: ['serviceProvider']},
                '×¦×œ×': {categories: ['×¦×œ×', '×¦×™×œ×•×', '×©×™×¨×•×ª'], preferTypes: ['serviceProvider']},
                '×¡×¤×¨': {categories: ['×¡×¤×¨', '×¡×¤×¨×™×'], preferTypes: ['store']},
                '×§×•×¨×¡': {categories: ['×§×•×¨×¡'], preferTypes: ['course']}
            };
            
            // Initialize searchTermWithoutCity
            let searchTermWithoutCity = searchTerm;
            
            // Check if query is about services/stores in a city - expanded patterns
            // Pattern 1: "××™×–×” ×©×™×¨×•×ª×™× ×‘× ×ª× ×™×”", "××” ×—× ×•×™×•×ª ×‘× ×ª× ×™×”"
            const isCityServiceQueryPattern1 = /(?:××™×–×”|××”|×™×©)\s*(?:×©×™×¨×•×ª×™×|×¢×¡×§×™×|×—× ×•×™×•×ª|××•×¦×¨×™×|× ×•×ª× ×™\s+×©×¨×•×ª|×‘×¢×œ×™\s+××§×¦×•×¢)\s*(?:×‘|×‘×ª×•×š|×‘×©×“×”)\s*([×-×ª]+)/.test(searchTerm);
            
            // Pattern 2: "×—× ×•×™×•×ª ×‘× ×ª× ×™×”", "× ×•×ª× ×™ ×©×¨×•×ª ×‘× ×ª× ×™×”", "×‘×¢×œ×™ ××§×¦×•×¢ ×‘× ×ª× ×™×”"
            const isCityServiceQueryPattern2 = /^(?:×—× ×•×™×•×ª|× ×•×ª× ×™\s+×©×¨×•×ª|×‘×¢×œ×™\s+××§×¦×•×¢|×©×™×¨×•×ª×™×|×¢×¡×§×™×)\s+×‘([×-×ª]+)$/.test(searchTerm);
            
            // Pattern 3: "×—× ×•×™×•×ª ×‘× ×ª× ×™×”", "× ×•×ª× ×™ ×©×¨×•×ª ×‘× ×ª× ×™×”" (with any text before)
            const isCityServiceQueryPattern3 = /(?:×—× ×•×™×•×ª|× ×•×ª× ×™\s+×©×¨×•×ª|×‘×¢×œ×™\s+××§×¦×•×¢|×©×™×¨×•×ª×™×|×¢×¡×§×™×)\s+×‘([×-×ª]+)/.test(searchTerm);
            
            // ğŸ¯ IMPROVED Pattern 4: "X ×‘Y" (any word + city) - more flexible!
            // This will match: "×œ×§ ×‘× ×ª× ×™×”", "×©×¢×•×Ÿ ×‘×—×™×¤×”", "× ×’×¨ ×‘×ª×œ ××‘×™×‘", etc.
            const generalCityPattern = /^([×-×ªa-zA-Z\s]+)\s+×‘([×-×ª]+)$/;
            const isCityServiceQueryPattern4 = generalCityPattern.test(searchTerm);
            
            const isCityServiceQuery = isCityServiceQueryPattern1 || isCityServiceQueryPattern2 || isCityServiceQueryPattern3 || isCityServiceQueryPattern4;
            
            console.log(`ğŸ” City service query detection for "${searchTerm}": isCityServiceQuery=${isCityServiceQuery} (P1=${isCityServiceQueryPattern1}, P2=${isCityServiceQueryPattern2}, P3=${isCityServiceQueryPattern3}, P4=${isCityServiceQueryPattern4})`);
            
            // ğŸ¯ IMPROVED: Extract service/product for ANY "X ×‘..." patterns (Pattern 4)
            // This now works for ANY search term + city combination
            if (isCityServiceQueryPattern4 && !requiredCity) {
                const productCityMatch = searchTerm.match(generalCityPattern);
                if (productCityMatch && productCityMatch[1] && productCityMatch[2]) {
                    const searchWord = productCityMatch[1].trim();
                    const potentialCity = productCityMatch[2].trim();
                    
                    console.log(`ğŸ” Pattern 4 (flexible) - searching for "${searchWord}" in city "${potentialCity}"`);
                    
                    // Check if it's a known city
                    let foundCity = false;
                    for (const city of cities) {
                        if (city.toLowerCase() === potentialCity.toLowerCase() || 
                            city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                            potentialCity.toLowerCase().includes(city.toLowerCase())) {
                            requiredCity = city;
                            searchTermWithoutCity = searchWord;
                            console.log(`âœ… Pattern 4 match - Product/Service: "${searchTermWithoutCity}", City: ${requiredCity}`);
                            foundCity = true;
                            break;
                        }
                    }
                    
                    // If no exact match found, use it anyway if it looks like a city
                    if (!foundCity && potentialCity.length >= 2 && potentialCity.length <= 15 && /^[×-×ª\s]+$/.test(potentialCity)) {
                        requiredCity = potentialCity;
                        searchTermWithoutCity = searchWord;
                        console.log(`âœ… Pattern 4 match (new city) - Product/Service: "${searchTermWithoutCity}", City: ${requiredCity}`);
                    }
                }
            }
            
            // Extract service/product from search term if city was found (and not already extracted by Pattern 4)
            if (requiredCity && searchTermWithoutCity === searchTerm) {
                // Remove city and "×‘" from search term
                searchTermWithoutCity = searchTerm
                    .replace(new RegExp(requiredCity.toLowerCase(), 'g'), '')
                    .replace(/\s*×‘\s*/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                console.log(`ğŸ” Search term without city: "${searchTermWithoutCity}" (original: "${searchTerm}", requiredCity: "${requiredCity}")`);
            } else if (requiredCity) {
                console.log(`ğŸ” Required city: "${requiredCity}", search term without city: "${searchTermWithoutCity}"`);
            }
            
            // Find matching keyword
            let searchVariations = [searchTermWithoutCity, searchTerm];
            
            // ğŸ¯ NEW: Add singular form to search variations (e.g., "× ×’×¨×™×" -> also search for "× ×’×¨")
            const singularForms = [];
            for (const variation of searchVariations) {
                if (variation && typeof variation === 'string') {
                    let singular = variation.toLowerCase().trim();
                    
                    // Remove "×”" from beginning
                    if (singular.startsWith('×”') && singular.length > 2) {
                        singular = singular.substring(1);
                    }
                    
                    // Remove plural suffixes
                    if (singular.endsWith('×™×') && singular.length > 3) {
                        singularForms.push(singular.substring(0, singular.length - 2));
                        console.log(`ğŸ“ Added singular form: "${variation}" -> "${singular.substring(0, singular.length - 2)}"`);
                    } else if (singular.endsWith('×•×ª') && singular.length > 3) {
                        singularForms.push(singular.substring(0, singular.length - 2));
                        console.log(`ğŸ“ Added singular form: "${variation}" -> "${singular.substring(0, singular.length - 2)}"`);
                    }
                }
            }
            
            // Add singular forms to search variations
            searchVariations = [...searchVariations, ...singularForms];
            console.log(`ğŸ” Search variations (with singular forms): [${searchVariations.join(', ')}]`);
            
            // ğŸ¯ COMPREHENSIVE: Synonym expansion covering ALL business types, products & services
            const synonymMap = {
                // Coaching & Fitness
                '××××Ÿ': ['×××× ×ª', '××™××•×Ÿ', '×§×•××¦\'×™× ×’', 'coaching', '××××Ÿ ××™×©×™', '××××Ÿ ×›×•×©×¨', '××™××•×Ÿ ××™×©×™', '×›×•×©×¨'],
                '×××× ×ª': ['××××Ÿ', '××™××•×Ÿ', '×§×•××¦\'×™× ×’', 'coaching', '××××Ÿ ××™×©×™', '××™××•×Ÿ ××™×©×™', '×›×•×©×¨'],
                '××™××•×Ÿ': ['××××Ÿ', '×××× ×ª', '×§×•××¦\'×™× ×’', 'coaching', '××™××•×Ÿ ××™×©×™', '×›×•×©×¨'],
                '×§×•××¦\'×™× ×’': ['××××Ÿ', '×××× ×ª', '××™××•×Ÿ', 'coaching', '×›×•×©×¨'],
                'coaching': ['××××Ÿ', '×××× ×ª', '××™××•×Ÿ', '×§×•××¦\'×™× ×’', '×›×•×©×¨'],
                '×›×•×©×¨': ['××××Ÿ', '×××× ×ª', '××™××•×Ÿ', '×›×•×©×¨ ××™×©×™', '××××Ÿ ×›×•×©×¨', '×—×“×¨ ×›×•×©×¨', '×¡×¤×•×¨×˜'],
                
                // Carpentry & Woodwork
                '× ×’×¨': ['× ×’×¨×•×ª', '× ×’×¨×™×”', '×¢×‘×•×“×•×ª ×¢×¥', '× ×’×¨×™×™×”', '× ×’×¨ ××˜×‘×—×™×', '××¨×•× ×•×ª'],
                '× ×’×¨×•×ª': ['× ×’×¨', '× ×’×¨×™×”', '×¢×‘×•×“×•×ª ×¢×¥', '××¨×•× ×•×ª', '××˜×‘×—×™×'],
                
                // Watches & Jewelry
                '×©×¢×•×Ÿ': ['×©×¢×•× ×™×', '×©×¢×•× ×™ ×™×“', '×©×¢×•×Ÿ ×™×“', '×©×¢×•× ×™ ×§×™×¨'],
                '×©×¢×•× ×™×': ['×©×¢×•×Ÿ', '×©×¢×•× ×™ ×™×“', '×ª×›×©×™×˜×™×'],
                '×ª×›×©×™×˜': ['×ª×›×©×™×˜×™×', '×ª×›×©×™×˜× ×•×ª', '×ª×›×©×™×˜×Ÿ', '×–×”×‘', '×›×¡×£', '×ª×›×©×™×˜ ×–×”×‘'],
                
                // Toys & Games
                '×¦×¢×¦×•×¢': ['×¦×¢×¦×•×¢×™×', '××©×—×§', '××©×—×§×™×', '×¦×¢×¦×•×¢×™ ×™×œ×“×™×'],
                '×¦×¢×¦×•×¢×™×': ['×¦×¢×¦×•×¢', '××©×—×§', '××©×—×§×™×', '××©×—×§×™ ×™×œ×“×™×'],
                
                // Hairdressing & Barbershops
                '×¡×¤×¨': ['×¡×¤×¨×™×', '×¡×¤×¨×™×”', '×¡×¤×¨×™×™×”'],
                '××¡×¤×¨×”': ['×¡×¤×¨', '×ª×¡×¤×•×¨×ª', '×ª×¡×¤×•×¨×•×ª', '××¡×¤×¨', '×¡×¤×¨ ×’×‘×¨×™×', '×¡×¤×¨×•×ª'],
                '×ª×¡×¤×•×¨×ª': ['××¡×¤×¨×”', '×¡×¤×¨', '××¡×¤×¨', '×¢×™×¦×•×‘ ×©×™×¢×¨'],
                
                // Beauty & Nails
                '×œ×§': ['×¦×™×¤×•×¨× ×™×™×', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '×œ×§ ×’\'×œ', '×¢×™×¦×•×‘ ×¦×™×¤×•×¨× ×™×™×'],
                '×× ×™×§×•×¨': ['×œ×§', '×¦×™×¤×•×¨× ×™×™×', '×¤×“×™×§×•×¨', '×œ×§ ×’\'×œ'],
                '×¤×“×™×§×•×¨': ['×œ×§', '×¦×™×¤×•×¨× ×™×™×', '×× ×™×§×•×¨', '×œ×§ ×’\'×œ'],
                '×™×•×¤×™': ['×§×•×¡××˜×™×§×”', '×˜×™×¤×•×—', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '××™×¤×•×¨', '×¢×™×¦×•×‘ ×’×‘×•×ª'],
                '××¢×¦×‘': ['××¢×¦×‘×ª', '×¢×™×¦×•×‘', '××¢×¦×‘ ×©×™×¢×¨', '××¢×¦×‘ ×¤× ×™×', '××¢×¦×‘ ×’×¨×¤×™'],
                
                // Restaurants & Food
                '××¡×¢×“×”': ['××¡×¢×“×•×ª', '××•×›×œ', '××›×™×œ×”', '×‘×™×ª ×§×¤×”', '××–×•×Ÿ', '××•×›×œ ××”×™×¨'],
                '××¡×¢×“×•×ª': ['××¡×¢×“×”', '××•×›×œ', '××›×™×œ×”', '×‘×ª×™ ×§×¤×”'],
                '×§×¤×”': ['×‘×™×ª ×§×¤×”', '×§×¤×” ×‘×•×§×¨', '×§×¤×™×˜×¨×™×”'],
                '××•×›×œ': ['××¡×¢×“×”', '××–×•×Ÿ', '××›×™×œ×”', '××–×•×Ÿ ××”×™×¨'],
                '×¤×™×¦×”': ['×¤×™×¦×¨×™×™×”', '××™×˜×œ×§×™', '××¡×¢×“×”'],
                '×”××‘×•×¨×’×¨': ['×”××‘×•×¨×’×¨×™×', '×‘×•×¨×’×¨', '××–×•×Ÿ ××”×™×¨'],
                '×¡×•×©×™': ['×™×¤× ×™', '××¡×™×™×ª×™', '×¡×•×©×™ ×‘×¨'],
                
                // Plumbing & Electrician
                '××™× ×¡×˜×œ×˜×•×¨': ['××™× ×¡×˜×œ×¦×™×”', '×©×¨×‘×¨×‘', '××™× ×¡×˜×œ×˜×•×¨ ×‘×©×‘×ª', '×©×¨×‘×¨×‘×•×ª'],
                '×©×¨×‘×¨×‘': ['××™× ×¡×˜×œ×˜×•×¨', '××™× ×¡×˜×œ×¦×™×”', '×©×¨×‘×¨×‘×•×ª'],
                '×—×©××œ××™': ['×—×©××œ', '×—×©××œ××•×ª', '×ª×™×§×•×Ÿ ×—×©××œ'],
                
                // Car & Auto
                '×¨×›×‘': ['××›×•× ×™×ª', '×¨×›×‘×™×', '××•×˜×•', '××›×•× ×™×•×ª'],
                '×—×œ×¤×™×': ['×—×œ×§×™ ×—×™×œ×•×£', '×—×œ×¤×™ ×¨×›×‘', '××‘×™×–×¨×™× ×œ×¨×›×‘'],
                '××•×¡×š': ['×ª×™×§×•×Ÿ ×¨×›×‘', '××›×•× ××™', '××•×¡×›×™×'],
                '××›×•× ××™': ['××•×¡×š', '×ª×™×§×•×Ÿ ×¨×›×‘', '××›×•× ××•×ª'],
                
                // Technology & Robotics
                '×¨×•×‘×•×˜': ['×¨×•×‘×•×˜×™×§×”', '×¨×•×‘×•×˜×™×', '××•×˜×•××¦×™×”'],
                '×¨×•×‘×•×˜×™×§×”': ['×¨×•×‘×•×˜', '×¨×•×‘×•×˜×™×', '××•×˜×•××¦×™×”'],
                '×˜×›× ×•×œ×•×’×™×”': ['×”×™×™-×˜×§', '×˜×›× ×•×œ×•×’×™', '×—×“×©× ×•×ª'],
                '××—×©×‘': ['××—×©×‘×™×', '×œ×¤×˜×•×¤', '××—×©×‘ × ×™×™×“', '×§×•××¤×™×•×˜×¨'],
                
                // Courses & Education
                '×§×•×¨×¡': ['×§×•×¨×¡×™×', '×”×©×ª×œ××•×ª', '×œ×™××•×“×™×', '×”×›×©×¨×”'],
                '×§×•×¨×¡×™×': ['×§×•×¨×¡', '×”×©×ª×œ××•×ª', '×œ×™××•×“×™×', '×”×›×©×¨×”'],
                '×œ×™××•×“×™×': ['×§×•×¨×¡', '×§×•×¨×¡×™×', '×”×©×ª×œ××•×ª', '×”×›×©×¨×”'],
                
                // Events & Entertainment
                '××™×¨×•×¢': ['××™×¨×•×¢×™×', '××™×¨×•×¢ ×—×‘×¨×”', '××™×¨×•×¢ ×¤×¨×˜×™'],
                '××™×¨×•×¢×™×': ['××™×¨×•×¢', '×—×ª×•× ×”', '×‘×¨ ××¦×•×•×”', '××™×¨×•×¢ ×—×‘×¨×”'],
                '×¦×œ×': ['×¦×™×œ×•×', '×¦×œ××ª', '×¦×™×œ×•××™×', '×¦×œ× ××™×¨×•×¢×™×'],
                '×¦×™×œ×•×': ['×¦×œ×', '×¦×œ××ª', '×¦×™×œ×•××™×', '×¦×™×œ×•× ××™×¨×•×¢×™×'],
                '×“×™ ×’\'×™×™': ['dj', '×“×™.×’\'×™×™', '×ª×§×œ×™×˜×Ÿ', '××•×–×™×§×”'],
                
                // Health & Wellness
                '×“×™××˜×”': ['×ª×–×•× ×”', '×“×™××˜×Ÿ', '×“×™××˜× ×™×ª', '×”×¨×–×™×”'],
                '×ª×–×•× ×”': ['×“×™××˜×”', '×“×™××˜×Ÿ', '×“×™××˜× ×™×ª', '×ª×–×•× ××™'],
                '×™×•×’×”': ['×™×•×’×” ××™×©×™×ª', '×©×™×¢×•×¨×™ ×™×•×’×”', '××•×¨×ª ×™×•×’×”'],
                '×¢×™×¡×•×™': ['××¢×¡×”', '××¢×¡×•×ª', '×¢×™×¡×•×™ ×¨×¤×•××™', '×¢×™×¡×•×™ ×©×•×•×“×™'],
                '×¤×™×–×™×•×ª×¨×¤×™×”': ['×¤×™×–×™×•×ª×¨×¤×™×¡×˜', '×¤×™×–×™×•', '×©×™×§×•×'],
                
                // Home Services
                '× ×™×§×™×•×Ÿ': ['× ×™×§×™×•× ×•×ª', '×× ×§×”', '×—×‘×¨×ª × ×™×§×™×•×Ÿ', '×©×™×¨×•×ª×™ × ×™×§×™×•×Ÿ'],
                '×’×™× ×•×Ÿ': ['×’× ×Ÿ', '×’×™× ×”', '×©×™×¨×•×ª×™ ×’×™× ×•×Ÿ', '×¢×™×¦×•×‘ ×’×™× ×•×ª'],
                '×¦×‘×¢': ['×¦×‘×¢×™×', '×¦×‘×¢×™', '×¦×‘×¢×™ ×‘× ×™×™×Ÿ', '×¦×‘××™'],
                '×©×™×¤×•×¦×™×': ['×©×™×¤×•×¥', '×‘× ×™×™×”', '×‘× ×™×™×Ÿ', '×§×‘×œ×Ÿ'],
                '×§×‘×œ×Ÿ': ['×§×‘×œ× ×™×', '×©×™×¤×•×¦×™×', '×‘× ×™×™×”'],
                
                // Fashion & Clothing
                '××•×¤× ×”': ['×‘×’×“×™×', '×‘×™×’×•×“', '×œ×‘×•×©', '××•×¤× ×ª × ×©×™×'],
                '×‘×’×“×™×': ['×‘×™×’×•×“', '××•×¤× ×”', '×œ×‘×•×©', '×‘×’×“×™ × ×©×™×'],
                '× ×¢×œ×™×™×': ['× ×¢×œ×™×', '× ×¢×œ', '× ×¢×œ×™ ×¡×¤×•×¨×˜', '× ×¢×œ×™ × ×©×™×'],
                
                // Pets
                '×›×œ×‘': ['×›×œ×‘×™×', '×‘×¢×œ×™ ×—×™×™×', '×—×™×•×ª ××—××“', '××–×•×Ÿ ×œ×›×œ×‘×™×'],
                '×—×ª×•×œ': ['×—×ª×•×œ×™×', '×‘×¢×œ×™ ×—×™×™×', '×—×™×•×ª ××—××“', '××–×•×Ÿ ×œ×—×ª×•×œ×™×'],
                '×•×˜×¨×™× ×¨': ['×•×˜×¨×™× ×¨×™×ª', '×•×˜×¨×™× ×¨×™×”', '×¨×•×¤× ×•×˜×¨×™× ×¨', '××¨×¤××”'],
                
                // Gifts & Party
                '××ª× ×”': ['××ª× ×•×ª', '××ª× ×•×ª ×œ×’×‘×¨', '××ª× ×•×ª ×œ××™×©×”', '××ª× ×ª ×™×•× ×”×•×œ×“×ª'],
                '××ª× ×•×ª': ['××ª× ×”', '×©×™', '×©×™ ×œ×’×‘×¨', '×©×™ ×œ××™×©×”'],
                
                // Books & Print
                '×¡×¤×¨': ['×¡×¤×¨×™×', '×¡×¤×¨×™×”', '×—× ×•×ª ×¡×¤×¨×™×'],
                '×”×“×¤×¡×”': ['××“×¤×¡×ª', '×“×¤×•×¡', '×”×“×¤×¡×•×ª', '×“×™×’×™×˜×œ'],
                
                // Flowers
                '×¤×¨×—×™×': ['×¤×¨×—', '×–×¨×™ ×¤×¨×—×™×', '×–×¨ ×¤×¨×—×™×', '×¤×¨×—×™'],
                
                // Insurance & Legal
                '×‘×™×˜×•×—': ['×‘×™×˜×•×—×™×', '×¡×•×›×Ÿ ×‘×™×˜×•×—', '×—×‘×¨×ª ×‘×™×˜×•×—'],
                '×¢×•×¨×š ×“×™×Ÿ': ['×¢×•"×“', '××©×¨×“ ×¢×•×¨×›×™ ×“×™×Ÿ', '×™×™×¢×•×¥ ××©×¤×˜×™'],
                '×¨×•××” ×—×©×‘×•×Ÿ': ['×¨×•"×—', '×—×©×‘×•× ××•×ª', '×”× ×”×œ×ª ×—×©×‘×•× ×•×ª'],
                
                // Real Estate
                '× ×“×œ×Ÿ': ['×“×™×¨×•×ª', '×“×™×¨×”', '× ×›×¡×™×', '××ª×•×•×š'],
                '××ª×•×•×š': ['××ª×•×•×›×™×', '× ×“×œ×Ÿ', '×“×™×¨×•×ª', '× ×›×¡×™×']
            };
            
            const synonymExpansion = [];
            for (const variation of searchVariations) {
                if (variation && typeof variation === 'string') {
                    const varLower = variation.toLowerCase().trim();
                    // Check if this variation has synonyms
                    for (const [key, synonyms] of Object.entries(synonymMap)) {
                        if (varLower === key || varLower.includes(key)) {
                            synonymExpansion.push(...synonyms);
                            console.log(`ğŸ“š Added synonyms for "${varLower}": [${synonyms.join(', ')}]`);
                            break;
                        }
                    }
                }
            }
            
            // Add synonyms to search variations (avoid duplicates)
            searchVariations = [...new Set([...searchVariations, ...synonymExpansion])];
            console.log(`ğŸ” Search variations (with synonyms): [${searchVariations.join(', ')}]`);
            
            let excludeTypes = [];
            let preferTypes = null;
            // Initialize excludeWords and requireWords at function level (they might be used later)
            let excludeWords = [];
            let requireWords = [];
            
            // FIRST: Check if query is about products in a specific store (e.g., "××•×¦×¨×™× ×‘×—× ×•×ª ×¨××“")
            // OR about store info (e.g., "××” ×”×˜×œ×¤×•×Ÿ ×©×œ ×”×—× ×•×ª RED", "×‘××™×–×” ×¢×™×¨ ×”×—× ×•×ª ×¨××“")
            const storeProductPattern = /(?:×”××•×¦×¨×™×|××•×¦×¨×™×|××” ×™×©|××” ×™×© ×œ|××” ××•×›×¨×™×|××™×–×” ××•×¦×¨×™×)\s*(?:×‘|×‘×—× ×•×ª|×©×œ)\s*([×-×ªa-zA-Z]+)/i;
            const storeInfoPattern = /(?:××”|××™×–×”)\s*(?:×”×˜×œ×¤×•×Ÿ|×”×›×ª×•×‘×ª|×”×¢×™×¨|×”××™×™×œ)\s*(?:×©×œ|×‘)\s*(?:×”×—× ×•×ª|×”×¢×¡×§|×”×“×£)?\s*([×-×ªa-zA-Z]+)/i;
            const storeCityPattern = /(?:×‘××™×–×”|××™×¤×”)\s+(?:×¢×™×¨|××™×§×•×)\s+(?:×”×—× ×•×ª|×”×¢×¡×§|×”×“×£)\s*([×-×ªa-zA-Z]+)/i;
            
            const storeProductMatch = searchTerm.match(storeProductPattern);
            const storeInfoMatch = searchTerm.match(storeInfoPattern) || searchTerm.match(storeCityPattern);
            const storeMatch = storeProductMatch || storeInfoMatch;
            
            if (storeMatch && storeMatch[1]) {
                const storeName = storeMatch[1].trim();
                console.log('ğŸª Store query detected for:', storeName);
                
                // Add the store name as primary search term (both Hebrew and English versions)
                searchVariations = [storeName.toLowerCase(), searchTerm];
                
                // If store name is Hebrew, also try English equivalent (e.g., "×¨××“" -> "red")
                // If store name is English, also try Hebrew (less common)
                if (storeName.match(/[×-×ª]/)) {
                    // Hebrew store name - add common English equivalents
                    const hebrewToEnglish = {
                        '×¨××“': 'red',
                        '×™× ×™×‘': 'yaniv'
                    };
                    if (hebrewToEnglish[storeName.toLowerCase()]) {
                        searchVariations.push(hebrewToEnglish[storeName.toLowerCase()]);
                    }
                } else {
                    // English store name - also try common Hebrew equivalents
                    const englishToHebrew = {
                        'red': '×¨××“',
                        'yaniv': '×™× ×™×‘'
                    };
                    if (englishToHebrew[storeName.toLowerCase()]) {
                        searchVariations.push(englishToHebrew[storeName.toLowerCase()]);
                    }
                    searchVariations.push(storeName.toLowerCase());
                }
                
                // Don't exclude any types, prefer stores
                preferTypes = ['store'];
                console.log('ğŸ” Store search variations:', searchVariations);
            } else {
                // Regular search flow
                
                // Check if query is about services/stores in a city (already defined above)
                if (isCityServiceQuery) {
                    // Try multiple patterns to extract city
                    let city = null;
                    
                    // Pattern 1: "×—× ×•×™×•×ª ×‘× ×ª× ×™×”", "× ×•×ª× ×™ ×©×¨×•×ª ×‘× ×ª× ×™×”"
                    const pattern1 = /(?:×—× ×•×™×•×ª|× ×•×ª× ×™\s+×©×¨×•×ª|×‘×¢×œ×™\s+××§×¦×•×¢|×©×™×¨×•×ª×™×|×¢×¡×§×™×)\s+×‘([×-×ª]+)/;
                    const match1 = searchTerm.match(pattern1);
                    if (match1 && match1[1]) {
                        city = match1[1].trim();
                    }
                    
                    // Pattern 2: "(××™×–×”|××”|×™×©) (×©×™×¨×•×ª×™×|×¢×¡×§×™×|×—× ×•×™×•×ª) ×‘..."
                    if (!city) {
                        const pattern2 = /(?:×‘|×‘×ª×•×š|×‘×©×“×”)\s*([×-×ª]+)/;
                        const match2 = searchTerm.match(pattern2);
                        if (match2 && match2[1]) {
                            city = match2[1].trim();
                        }
                    }
                    
                    if (city) {
                        // Check what type of query it is
                        const isStoresQuery = /×—× ×•×™×•×ª/.test(searchTerm);
                        const isServicesQuery = /(?:× ×•×ª× ×™\s+×©×¨×•×ª|×‘×¢×œ×™\s+××§×¦×•×¢|×©×™×¨×•×ª×™×)/.test(searchTerm);
                        
                        console.log(`ğŸ™ï¸ City query detected: "${city}", stores: ${isStoresQuery}, services: ${isServicesQuery}`);
                        
                        // Set search variations and preferred types based on query
                        if (isStoresQuery) {
                            searchVariations = [city, '×—× ×•×ª', '×—× ×•×™×•×ª', '××•×¦×¨'];
                            preferTypes = ['store'];
                            console.log('ğŸª Filtering for stores only');
                        } else if (isServicesQuery) {
                            searchVariations = [city, '×©×™×¨×•×ª', '× ×•×ª×Ÿ ×©×™×¨×•×ª', '×‘×¢×œ ××§×¦×•×¢'];
                            preferTypes = ['serviceProvider'];
                            console.log('ğŸ”§ Filtering for services only');
                        } else {
                            // General query - show all
                            searchVariations = [city, '×©×™×¨×•×ª', '×¢×¡×§', '×—× ×•×ª', '××•×¦×¨'];
                            preferTypes = ['store', 'serviceProvider', 'event', 'course'];
                            console.log('ğŸŒ Showing all types');
                        }
                    }
                }
                
                // If no city query, check for regular keywords
                // ğŸ¯ Check for "×ª××œ×™×¦×™" / "×”××œ×¦" queries first (recommendation queries)
                if (!isCityServiceQuery) {
                    // Check for recommendation queries ("×ª××œ×™×¦×™", "×ª××œ×™×¥", "×”××œ×¦")
                    if (searchTerm.includes('×ª××œ×™×¦×™') || searchTerm.includes('×ª××œ×™×¥') || searchTerm.includes('×”××œ×¦')) {
                        // Check if it's about gifts/products for someone specific
                        if (searchTerm.includes('××ª× ×”') || searchTerm.includes('××•×¦×¨')) {
                            // Extract target person (e.g., "×œ××™×©×”", "×œ×‘×—×•×¨×”", "×œ×’×‘×¨", "×œ×™×œ×“")
                            if (searchTerm.includes('×œ××™×©×”') || searchTerm.includes('×œ×‘×—×•×¨×”') || searchTerm.includes('×œ××©×”')) {
                                // Gift for woman - prefer watches, nail polish, jewelry
                                searchVariations = ['×©×¢×•×Ÿ', '×œ×§', '×ª×›×©×™×˜', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '×§×•×¡××˜×™×§×”'];
                                excludeTypes = ['serviceProvider'];
                                excludeWords = ['×¦×¢×¦×•×¢', 'toy', '×—×œ×¤×™×', '×—×œ×£']; // Exclude toys, car parts
                            } else if (searchTerm.includes('×œ×’×‘×¨') || searchTerm.includes('×œ×‘×—×•×¨') || 
                                       searchTerm.includes('×œ×‘×¢×œ') || searchTerm.includes('×œ×‘×¢×œ×™')) {
                                // Gift for man/husband - prefer watches, technology, gadgets (NOT toys!)
                                searchVariations = ['×©×¢×•×Ÿ', '×˜×›× ×•×œ×•×’×™×”', '×¨×•×‘×•×˜', '×’××“×’×˜'];
                                excludeTypes = ['serviceProvider'];
                                excludeWords = ['×¦×¢×¦×•×¢', 'toy', '×œ×§', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '×—×œ×¤×™×', '×—×œ×£']; // ğŸ¯ STRICT: Exclude toys, nail polish, car parts
                            } else if (searchTerm.includes('×œ×™×œ×“') || searchTerm.includes('×œ×™×œ×“×™×')) {
                                // Gift for child - prefer toys
                                searchVariations = ['×¦×¢×¦×•×¢', '××©×—×§', '×‘×•×‘×”', '××›×•× ×™×ª'];
                                excludeTypes = ['serviceProvider'];
                                excludeWords = ['×©×¢×•×Ÿ', '×œ×§', '×—×œ×¤×™×']; // Exclude watches, nail polish, car parts
                            } else {
                                // General gift - prefer watches, jewelry, toys (but exclude services)
                                searchVariations = ['×©×¢×•×Ÿ', '×ª×›×©×™×˜', '×¦×¢×¦×•×¢', '×œ×§'];
                                excludeTypes = ['serviceProvider'];
                            }
                        } else if (searchTerm.includes('××¨×§×˜') || searchTerm.includes('××¨×§×˜×¤×œ×™×™×¡')) {
                            // "×ª××œ×™×¦×™ ××”××•×¦×¨×™× ×‘××¨×§×˜" - show all products
                            searchVariations = ['×©×¢×•×Ÿ', '×ª×›×©×™×˜', '×¦×¢×¦×•×¢', '×œ×§', '××•×¦×¨'];
                            excludeTypes = ['serviceProvider'];
                        } else {
                            // General "×ª××œ×™×¦×™" - show gifts (watches, jewelry, toys)
                            searchVariations = ['×©×¢×•×Ÿ', '×ª×›×©×™×˜', '×¦×¢×¦×•×¢', '×œ×§'];
                            excludeTypes = ['serviceProvider'];
                        }
                        console.log(`ğŸ” Recommendation query detected, searchVariations: ${searchVariations.join(', ')}`);
                    } else {
                        // Check for strict keywords first ("×¨×§ ×©×¢×•×Ÿ", etc.)
                        let foundStrictKeyword = false;
                        for (const [keyword, config] of Object.entries(smartKeywords)) {
                            // For strict keywords like "×¨×§ ×©×¢×•×Ÿ", check if query includes it
                            if (searchTerm.includes(keyword) && (keyword.includes('×¨×§') || keyword.includes('×‘×œ×‘×“'))) {
                                if (typeof config === 'object' && config.categories) {
                                    searchVariations = [...searchVariations, ...config.categories];
                                    if (config.excludeTypes) excludeTypes = [...excludeTypes, ...config.excludeTypes];
                                    if (config.preferTypes) preferTypes = config.preferTypes;
                                    // Store excludeWords and requireWords for later filtering
                                    if (config.excludeWords) excludeWords = [...excludeWords, ...config.excludeWords];
                                    if (config.requireWords) requireWords = [...requireWords, ...config.requireWords];
                                }
                                console.log(`ğŸ” STRICT keyword matched: "${keyword}", excludeWords: ${excludeWords.length}, requireWords: ${requireWords.length}`);
                                foundStrictKeyword = true;
                                break;
                            }
                        }
                        
                        // If no strict keyword found, check regular keywords
                        if (!foundStrictKeyword) {
                            for (const [keyword, config] of Object.entries(smartKeywords)) {
                                // Skip strict keywords if we already checked them
                                if (keyword.includes('×¨×§') || keyword.includes('×‘×œ×‘×“')) continue;
                                
                                if (searchTerm.includes(keyword)) {
                                    if (typeof config === 'object' && config.categories) {
                                        searchVariations = [...searchVariations, ...config.categories];
                                        if (config.excludeTypes) excludeTypes = [...excludeTypes, ...config.excludeTypes];
                                        if (config.preferTypes) preferTypes = config.preferTypes;
                                        // Store excludeWords and requireWords for later filtering
                                        if (config.excludeWords) excludeWords = [...excludeWords, ...config.excludeWords];
                                        if (config.requireWords) requireWords = [...requireWords, ...config.requireWords];
                                    } else if (Array.isArray(config)) {
                                        searchVariations = [...searchVariations, ...config];
                                    }
                                    console.log(`ğŸ” Keyword matched: "${keyword}", excludeWords: ${excludeWords.length}, requireWords: ${requireWords.length}`);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            console.log('ğŸ” Search variations:', searchVariations);
            console.log('ğŸš« Exclude types:', excludeTypes);
            console.log('â­ Prefer types:', preferTypes);
            
            // ALWAYS get fresh pages from server (ALL users in marketplace)
            const response = await fetch('/api/pages/all/marketplace');
            if (!response.ok) {
                console.error('âŒ Failed to fetch marketplace pages:', response.status);
                return [];
            }
            const data = await response.json();
            const allPages = data.pages || [];
            
            console.log(`ğŸ” Got ${allPages.length} fresh pages from server`);
            
            if (allPages.length === 0) {
                console.warn('âš ï¸ WARNING: No pages found in marketplace!');
                // Try fallback endpoint
                try {
                    const fallbackResponse = await fetch('/api/pages/all');
                    if (fallbackResponse.ok) {
                        const fallbackData = await fallbackResponse.json();
                        const fallbackPages = fallbackData.pages || fallbackData || [];
                        console.log(`ğŸ”„ Fallback: Got ${fallbackPages.length} pages from /api/pages/all`);
                        return fallbackPages.length > 0 ? fallbackPages : [];
                    }
                } catch (e) {
                    console.error('Fallback also failed:', e);
                }
                return [];
            }
            
            for (const page of allPages) {
                try {
                    let matchScore = 0;
                    
                    // EXCLUDE pages if needed
                    if (excludeTypes.includes(page.pageType)) {
                        continue;
                    }
                    
                    // Extract business name from query (e.g., "××” ×”×˜×œ×¤×•×Ÿ ×©×œ ×“×•×“ ×—×œ×¤×™×" -> "×“×•×“ ×—×œ×¤×™×")
                    let businessNameFromQuery = null;
                
                // Check for specific question patterns first
                const questionPatterns = [
                    /(?:××”|××™×¤×”|×”×™×›×Ÿ|××™×–×”)\s+(?:×”)?×˜×œ×¤×•×Ÿ\s+(?:×©×œ|×‘|×‘×ª×•×š)\s+([×-×ª\s]+)/,
                    /(?:××”|××™×¤×”|×”×™×›×Ÿ)\s+(?:×”×›×ª×•×‘×ª|×”××™×™×œ|×”×¤×¨×˜×™×)\s+(?:×©×œ|×‘|×‘×ª×•×š)\s+([×-×ª\s]+)/,
                    /(?:×©×œ|×‘|×‘×ª×•×š)\s+([×-×ª]{3,})/  // "×©×œ ×“×•×“ ×—×œ×¤×™×" or "×‘ ×™× ×™×‘"
                ];
                
                for (const pattern of questionPatterns) {
                    const match = searchTerm.match(pattern);
                    if (match && match[1]) {
                        businessNameFromQuery = match[1].trim();
                        // Clean up common words
                        businessNameFromQuery = businessNameFromQuery.replace(/\b(××”|××™×¤×”|×”×™×›×Ÿ|××™×–×”|×˜×œ×¤×•×Ÿ|×›×ª×•×‘×ª|××™×™×œ|×¤×¨×˜×™×|×©×œ|××ª|×¢×œ|×‘|×‘×ª×•×š)\b/g, '').trim();
                        if (businessNameFromQuery.length >= 2 && businessNameFromQuery.length <= 50) {
                            console.log('ğŸ¢ Extracted business name from query:', businessNameFromQuery);
                            break;
                        }
                    }
                }
                
                // If no pattern matched, try to find store/business name from query
                // Special case: "×”××•×¦×¨×™× ×‘×—× ×•×ª ×¨××“" -> extract "×¨××“" or "red"
                if (!businessNameFromQuery) {
                    // ğŸ¯ IMPROVED: Use searchTermWithoutCity to avoid extracting city as business name
                    const termToSearch = searchTermWithoutCity || searchTerm;
                    // Try to extract store name from product queries
                    const storeNameMatch = termToSearch.match(/(?:×‘|×‘×—× ×•×ª|×©×œ)\s*([×-×ªa-zA-Z]+)/i);
                    if (storeNameMatch && storeNameMatch[1]) {
                        const extractedName = storeNameMatch[1].trim();
                        // ğŸ¯ IMPROVED: Don't use city as business name
                        if (!requiredCity || extractedName.toLowerCase() !== requiredCity.toLowerCase()) {
                            businessNameFromQuery = extractedName;
                            console.log('ğŸ¢ Extracted store name from product query:', businessNameFromQuery);
                        }
                    }
                }
                
                // If still no match, try to find Hebrew/English word sequences
                if (!businessNameFromQuery) {
                    // ğŸ¯ IMPROVED: Use searchTermWithoutCity to avoid including city
                    const termToSearch = searchTermWithoutCity || searchTerm;
                    const words = termToSearch.match(/[×-×ªa-zA-Z]+(?:\s+[×-×ªa-zA-Z]+){0,2}/g);
                    if (words) {
                        // Take the longest sequence that's not a common word or city
                        const commonWords = ['××”', '××™×¤×”', '×”×™×›×Ÿ', '××™×–×”', '×˜×œ×¤×•×Ÿ', '×›×ª×•×‘×ª', '××™×™×œ', '×¤×¨×˜×™×', '×©×œ', '××ª', '×¢×œ', '×‘', '×‘×ª×•×š', '×”×œ×š', '×œ×™', '×”×¨×›×‘', '×”××•×¦×¨×™×', '××•×¦×¨×™×', '×‘×—× ×•×ª', '×—× ×•×ª', '×™×©', '××” ×™×©'];
                        businessNameFromQuery = words
                            .filter(w => {
                                const wLower = w.trim().toLowerCase();
                                // ğŸ¯ IMPROVED: Filter out common words AND the required city
                                return !commonWords.includes(wLower) && (!requiredCity || wLower !== requiredCity.toLowerCase());
                            })
                            .sort((a, b) => b.length - a.length)[0];
                        if (businessNameFromQuery && businessNameFromQuery.length >= 2) {
                            businessNameFromQuery = businessNameFromQuery.trim();
                            console.log('ğŸ¢ Extracted business name (fallback):', businessNameFromQuery);
                        }
                    }
                }
                
                // Check if page title or description matches (flexible matching)
                const titleLower = page.title.toLowerCase();
                const descLower = (page.description || '').toLowerCase();
                // ğŸ¯ IMPROVED: Use searchTermWithoutCity when searching with city
                const searchTermLower = (searchTermWithoutCity || searchTerm).toLowerCase();
                
                // Exact title match
                if (titleLower.includes(searchTermLower)) {
                    matchScore += 10;
                }
                
                // Partial word match (e.g., "×¨××“" matches "red" or vice versa)
                const titleWords = titleLower.split(/\s+/);
                const searchWords = searchTermLower.split(/\s+/);
                const wordMatch = searchWords.some(word => 
                    titleWords.some(titleWord => titleWord.includes(word) || word.includes(titleWord))
                );
                if (wordMatch && !titleLower.includes(searchTermLower)) {
                    matchScore += 7; // Partial match bonus
                }
                
                // Description match
                if (descLower.includes(searchTermLower)) {
                    matchScore += 5;
                }
                
                // Special handling for city-based queries - match even if title/desc don't match
                if (isCityServiceQuery) {
                    // For city queries, start with a base score for all pages (we'll check city later)
                    matchScore += 5; // Base score for city-based queries (increased from 3)
                    console.log(`ğŸ™ï¸ City query detected - giving base score to "${page.title}"`);
                }
                
                // Also check if any part of search term matches title/description (broader matching)
                const searchTermWords = searchTerm.split(/\s+/).filter(w => w.length > 2);
                searchTermWords.forEach(word => {
                    if (page.title.toLowerCase().includes(word.toLowerCase())) {
                        matchScore += 3;
                    }
                    if (page.description && page.description.toLowerCase().includes(word.toLowerCase())) {
                        matchScore += 2;
                    }
                });
                
                // EXACT business name match gets highest priority
                // Also check for partial matches (e.g., "red" matches "RED" or vice versa)
                if (businessNameFromQuery) {
                    const businessLower = businessNameFromQuery.toLowerCase();
                    let titleLower = page.title.toLowerCase();
                    
                    // Hebrew-English name mapping (bidirectional)
                    const nameMappings = {
                        '×¨××“': 'red',
                        'red': '×¨××“',
                        '×™× ×™×‘': 'yaniv',
                        'yaniv': '×™× ×™×‘'
                    };
                    
                    // Try to find matching name (direct or via mapping)
                    let businessMatch = null;
                    let titleMatch = null;
                    
                    if (nameMappings[businessLower]) {
                        businessMatch = nameMappings[businessLower];
                    }
                    if (nameMappings[titleLower]) {
                        titleMatch = nameMappings[titleLower];
                    }
                    
                    // Check direct match
                    if (titleLower.includes(businessLower) || businessLower.includes(titleLower) || 
                        titleLower === businessLower) {
                        matchScore += 50; // VERY HIGH score for exact business name (highest priority!)
                        console.log('âœ… Exact business name match:', businessNameFromQuery, 'â†’', page.title);
                    } 
                    // Check via mapping (e.g., "×¨××“" -> "red" matches "red" page)
                    else if (businessMatch && (titleLower.includes(businessMatch) || titleLower === businessMatch)) {
                        matchScore += 50; // VERY HIGH score for mapped match
                        console.log('âœ… Mapped business name match:', businessNameFromQuery, 'â†’', businessMatch, 'â†’', page.title);
                    }
                    else if (titleMatch && (businessLower.includes(titleMatch) || businessLower === titleMatch)) {
                        matchScore += 50; // VERY HIGH score for reverse mapped match
                        console.log('âœ… Reverse mapped business name match:', businessNameFromQuery, 'â†’', titleMatch, 'â†’', page.title);
                    }
                    else {
                        // Check for word-level match (e.g., "×¨××“" in Hebrew vs "red" in English)
                        const businessWords = businessLower.split(/\s+/);
                        const titleWords = titleLower.split(/\s+/);
                        const hasWordMatch = businessWords.some(bw => 
                            titleWords.some(tw => tw.includes(bw) || bw.includes(tw))
                        ) || (businessMatch && titleWords.some(tw => tw.includes(businessMatch) || businessMatch.includes(tw)));
                        
                        if (hasWordMatch) {
                            matchScore += 40; // High score for word-level match
                            console.log('âœ… Word-level business name match:', businessNameFromQuery, 'â†’', page.title);
                        } else {
                            matchScore -= 30; // Heavy penalty for non-matching pages when specific business was requested
                            console.log('âŒ Business name mismatch:', businessNameFromQuery, 'â‰ ', page.title);
                        }
                    }
                }
                
                // Check if any search variation matches
                for (const variation of searchVariations) {
                    if (page.title.toLowerCase().includes(variation)) {
                        matchScore += 8;
                    }
                    if (page.description && page.description.toLowerCase().includes(variation)) {
                        matchScore += 4;
                    }
                }
                
                // BONUS for preferred types
                if (preferTypes && preferTypes.includes(page.pageType)) {
                    matchScore += 5;
                }
                
                // For city-based queries, accept ALL pages (we'll filter by city later)
                // For regular queries, need at least some match - BUT also check products!
                const minScoreForCityQuery = isCityServiceQuery ? 1 : 0; // Lower threshold to allow product-based matches
                
                // Use metadata first (much faster!), fallback to live extraction for old pages
                let liveProducts = page.products || [];
                let contactInfo = {
                    phone: page.phone,
                    phones: page.phones || [],
                    email: page.email,
                    city: page.city,
                    address: page.address
                };
                
                // If metadata is missing, extract from HTML (for old pages)
                const needsExtraction = !page.city || !page.phone || (page.products && page.products.length === 0);
                if (needsExtraction) {
                try {
                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        console.log(`ğŸ” Extracting metadata for old page: ${page.title}`);
                    const response = await fetch(pageUrl);
                    if (response.ok) {
                        const html = await response.text();
                            
                            // Extract live data (only if metadata is missing)
                            if (!contactInfo.city || !contactInfo.phone) {
                                const extractedContactInfo = extractLiveContactInfo(html);
                                contactInfo = {
                                    ...contactInfo,
                                    phone: contactInfo.phone || extractedContactInfo.phone,
                                    phones: contactInfo.phones.length > 0 ? contactInfo.phones : extractedContactInfo.phones || [],
                                    email: contactInfo.email || extractedContactInfo.email,
                                    city: contactInfo.city || extractedContactInfo.city,
                                    address: contactInfo.address || extractedContactInfo.address
                                };
                            }
                            
                            // Extract products (only if metadata is missing or empty)
                            if (!liveProducts || liveProducts.length === 0) {
                                liveProducts = extractLiveProducts(html);
                            }
                        }
                    } catch (error) {
                        console.error('Error extracting metadata for old page:', error);
                    }
                }
                
                // FILTER: Check excludeWords and requireWords for focused search
                // Build combined text from page title, description, and products
                const pageText = [
                    page.title,
                    page.description || '',
                    ...(liveProducts || []).map(p => p.name || '').filter(Boolean)
                ].join(' ').toLowerCase();
                
                // Exclude pages that contain excludeWords (e.g., "×œ×§" should exclude pages with "×©×¢×•×Ÿ")
                if (excludeWords && excludeWords.length > 0) {
                    const hasExcludedWord = excludeWords.some(word => 
                        pageText.includes(word.toLowerCase())
                    );
                    if (hasExcludedWord) {
                        console.log(`ğŸš« Excluding "${page.title}" - contains excluded word`);
                        matchScore = -1000; // Very negative score to exclude
                    }
                }
                
                // Require pages that contain at least one requireWords (e.g., "×œ×§" should require "×œ×§" or "×× ×™×§×•×¨")
                if (requireWords && requireWords.length > 0 && matchScore >= 0) {
                    const hasRequiredWord = requireWords.some(word => 
                        pageText.includes(word.toLowerCase())
                    );
                    if (!hasRequiredWord) {
                        console.log(`âŒ Excluding "${page.title}" - missing required word (need one of: ${requireWords.join(', ')})`);
                        matchScore = -1000; // Very negative score to exclude
                    } else {
                        matchScore += 20; // Bonus for having required word
                        console.log(`âœ… "${page.title}" has required word - bonus score`);
                    }
                }
                
                // Check if products match search variations (VERY IMPORTANT - can override low title/desc scores!)
                if (liveProducts && liveProducts.length > 0) {
                    let productMatches = 0;
                    for (const variation of searchVariations) {
                        for (const product of liveProducts) {
                            if (product.name && product.name.toLowerCase().includes(variation)) {
                                productMatches += 5; // Increased from 3 - products are VERY important!
                                console.log(`ğŸ›ï¸ Product match: "${product.name}" matches "${variation}"`);
                            }
                        }
                    }
                    if (productMatches > 0) {
                        matchScore += productMatches; // Bonus for relevant products
                        console.log(`âœ… Page "${page.title}" has ${productMatches/5} matching products, total score: ${matchScore}`);
                        
                        // If products match but title/desc don't, give minimum score to include it
                        if (matchScore === productMatches) {
                            matchScore += 10; // Base score for having matching products
                            console.log(`ğŸ“ˆ Giving base score for product matches: ${matchScore}`);
                        }
                    }
                }
                    
                    // ğŸ¯ FIX: Check location if specified - CRITICAL: Must match exactly or exclude
                    let cityMatches = false; // Initialize cityMatches variable
                    
                    console.log(`ğŸ” Page "${page.title}" has city: "${contactInfo.city || 'unknown'}", required: "${requiredCity || 'none'}", matchScore so far: ${matchScore}`);
                    
                    if (requiredCity) {
                        const pageCityLower = (contactInfo.city || '').toLowerCase().trim();
                        const requiredCityLower = requiredCity.toLowerCase().trim();
                        
                        // Check for exact match or partial match (e.g., "× ×ª× ×™×”" matches "× ×ª× ×™×”", "×—×“×¨×”" matches "×—×“×¨×”")
                        cityMatches = pageCityLower === requiredCityLower || 
                                          pageCityLower.includes(requiredCityLower) || 
                                          requiredCityLower.includes(pageCityLower);
                        
                        if (cityMatches && pageCityLower) {
                            matchScore += 50; // BIG bonus for matching location
                            console.log(`âœ… Location match: ${contactInfo.city} matches ${requiredCity}`);
                        } else {
                            // ğŸ¯ IMPROVED: Don't completely exclude - mark as "wrong city" but keep in results
                            // This allows fallback to show "not found in X, but found in Y"
                            matchScore -= 10; // REDUCED penalty (was -30) - allow fallback results
                            page.wrongCity = true; // Mark as wrong city for later filtering
                            page.actualCity = contactInfo.city || '×œ× ×™×“×•×¢';
                            console.log(`âš ï¸ Wrong city - "${contactInfo.city || 'unknown'}" â‰  "${requiredCity}" - PENALIZING (score: ${matchScore})`);
                        }
                    } else if (isCityServiceQuery) {
                        // Even if city wasn't extracted before, try to match from contact info
                        const cityFromQuery = searchTerm.match(/(?:×‘|×‘×ª×•×š|×‘×©×“×”)\s*([×-×ª]+)/);
                        if (cityFromQuery && cityFromQuery[1]) {
                            const requestedCity = cityFromQuery[1].trim().toLowerCase();
                            const pageCityLower = (contactInfo.city || '').toLowerCase().trim();
                            
                            cityMatches = pageCityLower && (pageCityLower === requestedCity || 
                                pageCityLower.includes(requestedCity) || 
                                requestedCity.includes(pageCityLower));
                            
                            if (cityMatches) {
                                matchScore += 50; // Big bonus
                                console.log(`ğŸ“ City match found: ${contactInfo.city} matches ${cityFromQuery[1]}`);
                            } else {
                                // ğŸ¯ IMPROVED: Don't completely exclude - penalty instead
                                matchScore -= 10; // REDUCED penalty (was -30) - allow fallback results
                                page.wrongCity = true;
                                page.actualCity = contactInfo.city || '×œ× ×™×“×•×¢';
                                console.log(`âš ï¸ City doesn't match - "${contactInfo.city || 'unknown'}" â‰  "${cityFromQuery[1]}" - PENALIZING`);
                            }
                        } else if (cityFromQuery && cityFromQuery[1] && !contactInfo.city) {
                            // ğŸ¯ IMPROVED: If city was requested but page has no city info, penalty but don't exclude
                            cityMatches = false;
                            matchScore -= 10; // REDUCED penalty (was -20) - allow fallback results
                            page.wrongCity = true;
                            page.actualCity = '×œ× ×™×“×•×¢';
                            console.log(`âš ï¸ City query but no city info in page - PENALIZING (not excluding)`);
                        }
                    }
                    
                // Add live data to page
                            page.liveProducts = liveProducts;
                page.liveContactInfo = contactInfo;
                page.matchScore = matchScore;
                
                // ğŸ¯ FIX: For specific service+city queries (e.g., "×œ×§ ×‘× ×ª× ×™×”"), MUST match BOTH service AND city
                // Don't add pages that don't match the service/product if a specific service was requested
                let serviceMatchesQuery = true; // Default: if no specific service, accept all
                
                if (searchTermWithoutCity && searchTermWithoutCity.length > 0 && searchTermWithoutCity !== searchTerm) {
                    // There's a specific service/product in the query (e.g., "×œ×§" from "×œ×§ ×‘× ×ª× ×™×”")
                    let serviceLower = searchTermWithoutCity.toLowerCase().trim();
                    
                    // ğŸ¯ IMPROVED: Remove definite article "×”" from beginning (e.g., "×”× ×’×¨" -> "× ×’×¨")
                    if (serviceLower.startsWith('×”') && serviceLower.length > 2) {
                        serviceLower = serviceLower.substring(1);
                        console.log(`ğŸ”§ Removed definite article: "${searchTermWithoutCity}" -> "${serviceLower}"`);
                    }
                    
                    // ğŸ¯ NEW: Remove plural suffix "×™×" or "×•×ª" (e.g., "× ×’×¨×™×" -> "× ×’×¨", "××¡×¢×“×•×ª" -> "××¡×¢×“")
                    if (serviceLower.endsWith('×™×') && serviceLower.length > 3) {
                        serviceLower = serviceLower.substring(0, serviceLower.length - 2);
                        console.log(`ğŸ”§ Removed plural suffix: "${searchTermWithoutCity}" -> "${serviceLower}"`);
                    } else if (serviceLower.endsWith('×•×ª') && serviceLower.length > 3) {
                        serviceLower = serviceLower.substring(0, serviceLower.length - 2);
                        console.log(`ğŸ”§ Removed plural suffix: "${searchTermWithoutCity}" -> "${serviceLower}"`);
                    }
                    
                    // Check if page title, description, or products contain the service
                    console.log(`ğŸ” Checking service match for "${serviceLower}" against page "${page.title}"`);
                    console.log(`   titleLower: "${titleLower}"`);
                    console.log(`   descLower: "${descLower}"`);
                    console.log(`   serviceLower.includes in title: ${titleLower.includes(serviceLower)}`);
                    
                    const titleHasService = titleLower.includes(serviceLower) || 
                                           serviceLower.split(/\s+/)
                                               .filter(word => word && word.length > 1 && /[\u0590-\u05FF]/.test(word)) // Only Hebrew words with 2+ chars
                                               .some(word => {
                                                   // Also remove "×”" from individual words
                                                   const cleanWord = word.startsWith('×”') && word.length > 2 ? word.substring(1) : word;
                                                   const hasWord = titleLower.includes(cleanWord);
                                                   console.log(`   checking word "${cleanWord}" in title: ${hasWord}`);
                                                   return hasWord;
                                               });
                    const descHasService = descLower.includes(serviceLower) || 
                                          serviceLower.split(/\s+/)
                                              .filter(word => word && word.length > 1 && /[\u0590-\u05FF]/.test(word)) // Only Hebrew words with 2+ chars
                                              .some(word => {
                                                  const cleanWord = word.startsWith('×”') && word.length > 2 ? word.substring(1) : word;
                                                  return descLower.includes(cleanWord);
                                              });
                    
                    // Check if products match the service
                    const productsMatchService = liveProducts && liveProducts.length > 0 && 
                        liveProducts.some(product => 
                            product.name && product.name.toLowerCase().includes(serviceLower)
                        );
                    
                    // Service must match title, description, or products
                    serviceMatchesQuery = titleHasService || descHasService || productsMatchService;
                    
                    console.log(`ğŸ” Service match check for "${serviceLower}": title=${titleHasService}, desc=${descHasService}, products=${productsMatchService}, RESULT=${serviceMatchesQuery}`);
                    
                    if (!serviceMatchesQuery) {
                        console.log(`âŒ Service doesn't match: page "${page.title}" doesn't contain "${serviceLower}" - EXCLUDING`);
                        continue; // Skip this page - it doesn't match the requested service
                    }
                }
                
                // ğŸ¯ IMPROVED: Pages with wrong city get penalty, but aren't excluded
                // This allows fallback message "not found in X, but found in Y"
                // The penalty was already applied above
                
                // Only add to results if score is high enough OR if it has matching products
                const hasMatchingProducts = liveProducts && liveProducts.length > 0 && 
                    searchVariations.some(variation => 
                        liveProducts.some(product => 
                            product.name && product.name.toLowerCase().includes(variation)
                        )
                    );
                
                // ğŸ¯ IMPROVED: Allow fallback to wrong cities (with marked wrongCity flag)
                // If service matches, add the page even if city doesn't match (for fallback)
                // But prefer pages with matching city (already handled by matchScore bonus/penalty)
                const shouldInclude = serviceMatchesQuery && (matchScore >= minScoreForCityQuery || hasMatchingProducts);
                
                if (shouldInclude) {
                    results.push(page);
                    console.log(`âœ… Added "${page.title}" with score ${matchScore} (service: ${serviceMatchesQuery}, city: ${cityMatches}, wrongCity: ${page.wrongCity || false}, score: ${matchScore})`);
                } else {
                    console.log(`âš ï¸ Skipped "${page.title}" - service: ${serviceMatchesQuery}, city: ${cityMatches}, score: ${matchScore} too low`);
                }
                } catch (error) {
                    console.error(`âŒ Error processing page "${page?.title || 'unknown'}" - skipping:`, error);
                    continue; // Skip to next page
                }
            }
            
            // Sort by match score
            results.sort((a, b) => (b.matchScore || 0) - (a.matchScore || 0));
            
            // ğŸ¯ NEW: Handle city-specific queries - if user searched for "X ×‘Y" and no results in Y
            // Show results from other cities with appropriate message
            if (requiredCity && results.length > 0) {
                const resultsInRequestedCity = results.filter(page => !page.wrongCity);
                const resultsInOtherCities = results.filter(page => page.wrongCity);
                
                console.log(`ğŸ™ï¸ City filter: ${resultsInRequestedCity.length} in ${requiredCity}, ${resultsInOtherCities.length} in other cities`);
                
                // ğŸ” DEBUG: Show all results before filtering
                console.log('ğŸ“‹ All results BEFORE city filter:');
                results.forEach((page, i) => {
                    console.log(`  ${i+1}. ${page.title} - city: ${page.actualCity || 'unknown'}, wrongCity: ${page.wrongCity}, score: ${page.matchScore}`);
                });
                
                // ğŸ¯ NEW LOGIC: Always show top result, even if from wrong city
                const topScore = results[0].matchScore;
                const topResult = results[0];
                
                if (resultsInRequestedCity.length === 0 && resultsInOtherCities.length > 0) {
                    // Found results, but not in the requested city
                    // Add a flag so the UI can show appropriate message
                    results.forEach(page => {
                        page.notInRequestedCity = true;
                        page.requestedCity = requiredCity;
                    });
                    console.log(`âš ï¸ No results in ${requiredCity}, but found ${resultsInOtherCities.length} in other cities`);
                    console.log('ğŸ“‹ Returning results from OTHER cities');
                } else if (resultsInRequestedCity.length > 0) {
                    // Found results in requested city
                    const bestInRequestedCity = resultsInRequestedCity[0];
                    
                    // ğŸ¯ If top result is from another city but MUCH better (score difference > 30), include it
                    if (topResult.wrongCity && topScore > bestInRequestedCity.matchScore + 30) {
                        console.log(`â­ Top result "${topResult.title}" (score: ${topScore}) is from ${topResult.actualCity}, but much better than best in ${requiredCity} (score: ${bestInRequestedCity.matchScore})`);
                        console.log('ğŸ“‹ Including top result from other city at the beginning');
                        // Keep top result + results from requested city
                        results = [topResult, ...resultsInRequestedCity];
                        topResult.notInRequestedCity = true;
                        topResult.requestedCity = requiredCity;
                    } else {
                        // Filter to only requested city
                        results = resultsInRequestedCity;
                        console.log(`âœ… Found ${resultsInRequestedCity.length} results in ${requiredCity}`);
                        console.log('ğŸ“‹ Results AFTER city filter (only in requested city):');
                        results.forEach((page, i) => {
                            console.log(`  ${i+1}. ${page.title} - city: ${page.actualCity || 'unknown'}, score: ${page.matchScore}`);
                        });
                    }
                }
            }
            
            // If there's a specific business name in query, filter to only exact matches or very high scores
            const lowerQuery = searchTerm.toLowerCase();
            const businessNamePattern = /(?:×©×œ|××ª|×¢×œ|×‘|×‘×ª×•×š|××”|××™×¤×”|×”×™×›×Ÿ)\s+([×-×ª]{2,})/;
            const businessMatch = searchTerm.match(businessNamePattern);
            
            if (businessMatch && businessMatch[1]) {
                const requestedBusiness = businessMatch[1].trim().toLowerCase();
                // Remove common words
                const cleanBusinessName = requestedBusiness.replace(/\b(×©×œ|××ª|×¢×œ|×‘|×‘×ª×•×š|××”|××™×¤×”|×”×™×›×Ÿ|×˜×œ×¤×•×Ÿ|×›×ª×•×‘×ª|××™×™×œ|×¤×¨×˜×™×)\b/g, '').trim();
                
                if (cleanBusinessName.length >= 2) {
                    // Filter: keep only pages that match the business name OR have very high score
                    const filteredResults = results.filter(page => {
                        const titleMatch = page.title.toLowerCase().includes(cleanBusinessName);
                        const highScore = (page.matchScore || 0) >= 40;
                        return titleMatch || highScore;
                    });
                    
                    if (filteredResults.length > 0) {
                        console.log(`ğŸ¯ Filtered results from ${results.length} to ${filteredResults.length} for exact business: "${cleanBusinessName}"`);
                        return filteredResults;
                    }
                }
            }
            
            console.log(`ğŸ” Found ${results.length} LIVE pages for "${searchTerm}"`);
            return results;
            } catch (error) {
                console.error('âŒâŒâŒ CRITICAL ERROR in searchLivePages:', error);
                console.error('âŒ Error stack:', error.stack);
                console.error('âŒ Error message:', error.message);
                console.error('âŒ Query was:', query);
                return []; // Return empty array on error
            }
        }
        
        // Extract live description from HTML
        function extractLiveDescription(html) {
            console.log('ğŸ“ Extracting description from HTML');
            
            // Try to extract from meta description tag
            const metaDescMatch = html.match(/<meta[^>]*name=["']description["'][^>]*content=["']([^"']{10,300})["']/i);
            if (metaDescMatch && metaDescMatch[1]) {
                const desc = metaDescMatch[1].trim();
                console.log('ğŸ“ Found meta description:', desc);
                return desc;
            }
            
            // Try to extract from og:description
            const ogDescMatch = html.match(/<meta[^>]*property=["']og:description["'][^>]*content=["']([^"']{10,300})["']/i);
            if (ogDescMatch && ogDescMatch[1]) {
                const desc = ogDescMatch[1].trim();
                console.log('ğŸ“ Found og:description:', desc);
                return desc;
            }
            
            // Try to extract from first paragraph after h1
            const h1Match = html.match(/<h1[^>]*>.*?<\/h1>\s*<p[^>]*>([^<]{20,300})<\/p>/is);
            if (h1Match && h1Match[1]) {
                const desc = h1Match[1].trim().replace(/<[^>]+>/g, '');
                console.log('ğŸ“ Found description from first paragraph:', desc);
                return desc;
            }
            
            // Try to extract from any paragraph with class containing "desc" or "about"
            const descParagraphMatch = html.match(/<p[^>]*class=["'][^"']*(?:desc|about|intro)[^"']*["'][^>]*>([^<]{20,300})<\/p>/i);
            if (descParagraphMatch && descParagraphMatch[1]) {
                const desc = descParagraphMatch[1].trim().replace(/<[^>]+>/g, '');
                console.log('ğŸ“ Found description from paragraph class:', desc);
                return desc;
            }
            
            // Try to extract from ANY paragraph after header/hero section
            const anyParagraphMatch = html.match(/<(?:header|section|div)[^>]*>[\s\S]*?<p[^>]*>([^<]{30,300})<\/p>/i);
            if (anyParagraphMatch && anyParagraphMatch[1]) {
                const desc = anyParagraphMatch[1].trim().replace(/<[^>]+>/g, '');
                // Make sure it's not navigation or footer text
                if (!desc.match(/×–×›×•×™×•×ª|××•×“×•×ª|×¦×•×¨ ×§×©×¨|×ª×¤×¨×™×˜|×¢×œ×™× ×•|home|about|contact/i)) {
                    console.log('ğŸ“ Found description from any paragraph:', desc);
                    return desc;
                }
            }
            
            // Try to extract from h2 or h3 that looks like a description
            const h2Match = html.match(/<h2[^>]*>([^<]{20,300})<\/h2>/i);
            if (h2Match && h2Match[1]) {
                const desc = h2Match[1].trim();
                // Make sure it's descriptive text, not a title
                if (desc.length > 30 && !desc.match(/^[\u0590-\u05FF\s]{2,15}$/)) {
                    console.log('ğŸ“ Found description from h2:', desc);
                    return desc;
                }
            }
            
            console.log('âš ï¸ No description found in HTML');
            return '';
        }
        
        // Extract live contact info from HTML
        function extractLiveContactInfo(html) {
            const contactInfo = {};
            
            console.log('ğŸ“ Extracting contact info from HTML');
            
            // Extract phone numbers - SIMPLE approach like email extraction
            // Search entire HTML for Israeli phone number patterns (just like email does)
            const phonePatterns = [
                // International format (+972)
                /\+972[\s\-\)]?\s*5[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /\+972[\s\-\)]?\s*7[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /\+972[\s\-\)]?\s*5[0-9][\s\-]?\d{7}/g,
                // Standard Israeli format (05X/07X) - various separators
                /0?5[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /0?7[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /0?5[0-9][\s\-]?\d{7}/g,
                /0?7[0-9][\s\-]?\d{7}/g,
                // Dotted formats: 0X2.XXX.XXXX or similar
                /0[57]\d(?:[\.\s\-]?\d){8}/g
            ];
            
            let foundPhones = [];
            let contactAreaPhones = []; // Phones found in contact/footer areas (higher priority)
            const phoneScores = new Map(); // normalizedPhone -> score
            
            // First: Search in contact/footer areas specifically (higher priority)
            const contactAreaPattern = /<(?:section|div|footer)[^>]*(?:class|id)="[^"]*(?:contact|footer|info|details)[^"]*"[^>]*>([\s\S]{500,3000})<\/[^>]+>/gi;
            const contactAreas = [...html.matchAll(contactAreaPattern)];
            
            contactAreas.forEach(areaMatch => {
                const areaHtml = areaMatch[1];
                // Boost any phone found in contact area
                phonePatterns.forEach(pattern => {
                    const matches = areaHtml.match(pattern);
                    if (matches) {
                        matches.forEach(match => {
                            let phone = match.replace(/[\s\-\(\)\.]/g, '');
                            if (phone.startsWith('+972')) {
                                phone = phone.replace('+972', '0');
                            }
                            if (phone.length === 9 && (phone.startsWith('5') || phone.startsWith('7'))) {
                                phone = '0' + phone;
                            }
                            if (phone.length === 10 && phone.startsWith('0') && (phone[1] === '5' || phone[1] === '7')) {
                                const isValidPhone = phone.match(/^0[57][0-9]{8}$/);
                                if (isValidPhone && !phone.match(/^0+$/) && phone !== '0500000000' && phone !== '0700000000') {
                                    const formatted = `${phone.substring(0, 3)}-${phone.substring(3, 6)}-${phone.substring(6)}`;
                                    if (!contactAreaPhones.includes(formatted)) {
                                        contactAreaPhones.push(formatted);
                                        console.log('ğŸ“ Found phone (contact area):', formatted);
                                    }
                                    // score boost for contact area
                                    phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 5);
                                }
                            }
                        });
                    }
                });
                // Boost phones in tel: links inside contact area
                const telLinks = [...areaHtml.matchAll(/href\s*=\s*"tel:([^"'>\s]+)/gi)];
                telLinks.forEach(t => {
                    let raw = t[1] || '';
                    raw = decodeURIComponent(raw);
                    let phone = raw.replace(/[^0-9\+]/g, '').replace(/^\+972/, '0');
                    if (phone.length === 9 && (phone.startsWith('5') || phone.startsWith('7'))) phone = '0' + phone;
                    if (/^0[57]\d{8}$/.test(phone)) {
                        const formatted = `${phone.substring(0, 3)}-${phone.substring(3, 6)}-${phone.substring(6)}`;
                        phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 6); // higher weight for explicit tel link
                        if (!contactAreaPhones.includes(formatted)) contactAreaPhones.push(formatted);
                    }
                });
            });
            
            // Then: Search entire HTML for phone numbers (like email - simple and direct!)
            phonePatterns.forEach(pattern => {
                const matches = html.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        let phone = match.replace(/[\s\-\(\)\.]/g, '');
                        if (phone.startsWith('+972')) {
                            phone = phone.replace('+972', '0');
                        }
                        if (phone.length === 9 && (phone.startsWith('5') || phone.startsWith('7'))) {
                            phone = '0' + phone;
                        }
                        if (phone.length === 10 && phone.startsWith('0') && (phone[1] === '5' || phone[1] === '7')) {
                            const isValidPhone = phone.match(/^0[57][0-9]{8}$/);
                            if (isValidPhone && !phone.match(/^0+$/) && phone !== '0500000000' && phone !== '0700000000') {
                                const formatted = `${phone.substring(0, 3)}-${phone.substring(3, 6)}-${phone.substring(6)}`;
                                if (!foundPhones.includes(formatted)) {
                                    foundPhones.push(formatted);
                                    console.log('ğŸ“ Found phone:', formatted, 'from pattern:', pattern);
                                }
                                // base score for any appearance
                                phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 1);
                            }
                        }
                    });
                }
            });

            // Boost phones that are near the word "×˜×œ×¤×•×Ÿ" or "Phone"
            const proximityMatches = [...html.matchAll(/×˜×œ×¤×•×Ÿ[:\s\-]*([^<\n]{0,60})/gi)];
            proximityMatches.forEach(pm => {
                const seg = (pm[1] || '').toString();
                const hits = seg.match(/0[57]\d[\d\s\-\.]{7,}/g) || [];
                hits.forEach(h => {
                    let normalized = h.replace(/[^0-9]/g, '');
                    if (normalized.length === 9 && (normalized.startsWith('5') || normalized.startsWith('7'))) normalized = '0' + normalized;
                    if (/^0[57]\d{8}$/.test(normalized)) {
                        const formatted = `${normalized.substring(0, 3)}-${normalized.substring(3, 6)}-${normalized.substring(6)}`;
                        phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 3);
                    }
                });
            });
            
            // Prefer phones from contact areas, but fallback to any phone found
            const allPhones = [...contactAreaPhones, ...foundPhones.filter(p => !contactAreaPhones.includes(p))];
            
            if (allPhones.length > 0) {
                // Filter out phones that look like placeholders
                const validPhones = allPhones.filter(phone => {
                    const digits = phone.replace(/-/g, '');
                    const firstDigit = digits[0];
                    const isAllSame = digits.split('').every(d => d === firstDigit);
                    const isPlaceholder = phone.includes('000-000') || phone.includes('111-111') || phone.includes('123-456');
                    return !isAllSame && !isPlaceholder;
                });
                
                if (validPhones.length > 0) {
                    // Rank by score (desc), then by contact-area preference ordering
                    const ranked = [...new Set(validPhones)]
                        .map(p => ({ phone: p, score: phoneScores.get(p) || 0, inContact: contactAreaPhones.includes(p) }))
                        .sort((a, b) => (b.score - a.score) || (b.inContact - a.inContact));
                    contactInfo.phones = ranked.map(r => r.phone);
                    contactInfo.phone = contactInfo.phones[0]; // Primary best-scored
                    console.log('âœ… Using phone(s):', validPhones, '(found', allPhones.length, 'total,', contactAreaPhones.length, 'from contact areas)');
                } else if (allPhones.length > 0) {
                    contactInfo.phones = allPhones;
                    contactInfo.phone = allPhones[0];
                    console.log('âš ï¸ Using phone (fallback):', contactInfo.phone);
                }
            }
            
            // Extract email - SIMPLE approach (search entire HTML)
            const emailMatch = html.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
            if (emailMatch) {
                contactInfo.email = emailMatch[1];
                console.log('ğŸ“§ Found email:', contactInfo.email);
            }
            
            // Extract address and city (look for common address patterns) - expanded list
            const cities = [
                '×ª×œ ××‘×™×‘', '×™×¨×•×©×œ×™×', '×—×™×¤×”', '×‘××¨ ×©×‘×¢', '× ×ª× ×™×”', '××©×“×•×“', '×¨××ª ×’×Ÿ', '×¤×ª×— ×ª×§×•×•×”', 
                '×‘× ×™ ×‘×¨×§', '×—×•×œ×•×Ÿ', '×¨×—×•×‘×•×ª', '×›×¤×¨ ×¡×‘×', '××™×œ×ª', '×¨×¢× × ×”', '×”×¨×¦×œ×™×”', '×—×“×¨×”', 
                '×§×¨×™×™×ª ×‘×™××œ×™×§', '×§×¨×™×™×ª ××•×¦×§×™×Ÿ', '×¨××©×•×Ÿ ×œ×¦×™×•×Ÿ', '× ×”×¨×™×”', '×”×•×“ ×”×©×¨×•×Ÿ', '×’×‘×¢×ª×™×™×', 
                '×§×¨×™×™×ª ××ª×', '×§×¨×™×™×ª ×©××•× ×”', '×‘×™×ª ×©××Ÿ', '×¢×¤×•×œ×”'
            ];
            
            // Try exact match first
            for (const city of cities) {
                const cityRegex = new RegExp(city, 'g');
                if (html.match(cityRegex)) {
                    contactInfo.city = city;
                    console.log('ğŸ™ï¸ Found city (exact):', contactInfo.city);
                    break;
                }
            }
            
                // ğŸ¯ IMPROVED: Extract city from page metadata FIRST (title/description)
                // This allows business owners to specify city in their business description without Contact section
                if (!contactInfo.city && (page.title || page.description)) {
                    const titleAndDesc = `${page.title || ''} ${page.description || ''}`.toLowerCase();
                    const knownCities = [
                        '×ª×œ ××‘×™×‘', '×™×¨×•×©×œ×™×', '×—×™×¤×”', '×‘××¨ ×©×‘×¢', '× ×ª× ×™×”', '××©×“×•×“', '×¨××ª ×’×Ÿ', '×¤×ª×— ×ª×§×•×•×”', 
                        '×‘× ×™ ×‘×¨×§', '×—×•×œ×•×Ÿ', '×¨×—×•×‘×•×ª', '×›×¤×¨ ×¡×‘×', '××™×œ×ª', '×¨×¢× × ×”', '×”×¨×¦×œ×™×”', '×—×“×¨×”', 
                        '×§×¨×™×™×ª ×‘×™××œ×™×§', '×§×¨×™×™×ª ××•×¦×§×™×Ÿ', '×¨××©×•×Ÿ ×œ×¦×™×•×Ÿ', '× ×”×¨×™×”', '×”×•×“ ×”×©×¨×•×Ÿ', '×’×‘×¢×ª×™×™×', 
                        '×§×¨×™×™×ª ××ª×', '×§×¨×™×™×ª ×©××•× ×”', '×‘×™×ª ×©××Ÿ', '×¢×¤×•×œ×”', '××¢×œ×•×ª', '× ×¦×¨×ª', '×¢×›×•', '×˜×‘×¨×™×”',
                        '×¦×¤×ª', '×§×¨×™×ª ×’×ª', '×“×™××•× ×”', '××•×¤×§×™×', '× ×ª×™×‘×•×ª', '×§×¨×™×ª ××œ××›×™', '×§×¨×™×ª ×©××•× ×”',
                        '×§×¨×™×ª ××¨×‘×¢', '×‘×™×ª ×©××©', '××•×“×™×¢×™×Ÿ', '×œ×•×“', '×¨××œ×”', '×™×‘× ×”', '×’×“×¨×”', '×§×¨×™×ª ×¢×§×¨×•×Ÿ'
                    ];
                    
                    // Check title and description for city names
                    for (const city of knownCities) {
                        if (titleAndDesc.includes(city.toLowerCase())) {
                            contactInfo.city = city;
                            console.log('ğŸ™ï¸ Found city in title/description:', contactInfo.city);
                            break;
                        }
                    }
                }
                
                // ğŸ¯ FIX: Improve city extraction - use known cities list for accuracy
                if (!contactInfo.city) {
                    // List of common Israeli cities for accurate matching
                    const knownCities = [
                        '×ª×œ ××‘×™×‘', '×™×¨×•×©×œ×™×', '×—×™×¤×”', '×‘××¨ ×©×‘×¢', '× ×ª× ×™×”', '××©×“×•×“', '×¨××ª ×’×Ÿ', '×¤×ª×— ×ª×§×•×•×”', 
                        '×‘× ×™ ×‘×¨×§', '×—×•×œ×•×Ÿ', '×¨×—×•×‘×•×ª', '×›×¤×¨ ×¡×‘×', '××™×œ×ª', '×¨×¢× × ×”', '×”×¨×¦×œ×™×”', '×—×“×¨×”', 
                        '×§×¨×™×™×ª ×‘×™××œ×™×§', '×§×¨×™×™×ª ××•×¦×§×™×Ÿ', '×¨××©×•×Ÿ ×œ×¦×™×•×Ÿ', '× ×”×¨×™×”', '×”×•×“ ×”×©×¨×•×Ÿ', '×’×‘×¢×ª×™×™×', 
                        '×§×¨×™×™×ª ××ª×', '×§×¨×™×™×ª ×©××•× ×”', '×‘×™×ª ×©××Ÿ', '×¢×¤×•×œ×”', '××¢×œ×•×ª', '× ×¦×¨×ª', '×¢×›×•', '×˜×‘×¨×™×”',
                        '×¦×¤×ª', '×§×¨×™×ª ×’×ª', '×“×™××•× ×”', '××•×¤×§×™×', '× ×ª×™×‘×•×ª', '×§×¨×™×ª ××œ××›×™', '×§×¨×™×ª ×©××•× ×”',
                        '×§×¨×™×ª ××¨×‘×¢', '×‘×™×ª ×©××©', '××•×“×™×¢×™×Ÿ', '×œ×•×“', '×¨××œ×”', '×™×‘× ×”', '×’×“×¨×”', '×§×¨×™×ª ×¢×§×¨×•×Ÿ'
                    ];
                
                // Search for cities in contact info areas first (more reliable)
                const contactAreaPattern = /<(?:section|div|footer)[^>]*(?:class|id)="[^"]*(?:contact|footer|info|details)[^"]*"[^>]*>([\s\S]{500,3000})<\/[^>]+>/gi;
                const contactAreas = [...html.matchAll(contactAreaPattern)];
                
                // Check in contact areas first
                for (const areaMatch of contactAreas) {
                    const areaHtml = areaMatch[1].toLowerCase();
                    for (const city of knownCities) {
                        if (areaHtml.includes(city.toLowerCase())) {
                            contactInfo.city = city;
                            console.log('ğŸ™ï¸ Found city in contact area:', contactInfo.city);
                            break;
                        }
                    }
                    if (contactInfo.city) break;
                }
                
                // If not found in contact area, search entire HTML for known cities
                if (!contactInfo.city) {
                    const htmlLower = html.toLowerCase();
                    const citiesFound = [];
                    for (const city of knownCities) {
                        if (htmlLower.includes(city.toLowerCase())) {
                            citiesFound.push(city);
                            if (!contactInfo.city) {
                                contactInfo.city = city;
                                console.log('ğŸ™ï¸ Found city in HTML:', contactInfo.city);
                            }
                        }
                    }
                    if (citiesFound.length > 1) {
                        console.log('âš ï¸ Multiple cities found in HTML:', citiesFound.join(', '), '- using first:', contactInfo.city);
                    }
                }
                
                // Last resort: try pattern matching (but be more strict)
                if (!contactInfo.city) {
                    const cityPattern = /(?:×‘|×‘×ª×•×š|×‘×™×Ÿ|×¢×œ|×œ×™×“|×§×¨×•×‘\s+×œ)\s*([×-×ª]{2,15})/gi;
                    const matches = [...html.matchAll(cityPattern)];
                    if (matches.length > 0) {
                        for (const match of matches) {
                            const potentialCity = match[1].trim();
                            // Check if it matches a known city
                            for (const city of knownCities) {
                                if (city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                                    potentialCity.toLowerCase().includes(city.toLowerCase())) {
                                    contactInfo.city = city;
                                    console.log('ğŸ™ï¸ Found city by pattern:', contactInfo.city);
                                    break;
                                }
                            }
                            if (contactInfo.city) break;
                        }
                    }
                }
            }
            
            // Extract address - FIRST try navigation button links (Google Maps / Waze)
            // Users add address to navigation buttons, this is the most accurate source
            const navigationButtonPatterns = [
                // Google Maps: href="https://www.google.com/maps?q=..." or href="https://maps.google.com/?q=..."
                /href\s*=\s*["']https?:\/\/(?:www\.)?(?:maps\.)?google\.com\/maps[^"']*q=([^"'\&]+)/gi,
                /href\s*=\s*["']https?:\/\/(?:www\.)?(?:maps\.)?google\.com\/maps[^"']*daddr=([^"'\&]+)/gi,
                // Waze: href="https://waze.com/ul?q=..." or href="https://www.waze.com/ul?q=..."
                /href\s*=\s*["']https?:\/\/(?:www\.)?waze\.com\/ul[^"']*q=([^"'\&]+)/gi,
                /href\s*=\s*["']https?:\/\/(?:www\.)?waze\.com\/ul[^"']*ll=([^"'\&]+)/gi,
                // General navigation link with address in text
                /<a[^>]*href\s*=\s*["'](?:https?:\/\/(?:maps|waze))[^"']*["'][^>]*>([^<]{10,100})<\/a>/gi
            ];
            
            for (const pattern of navigationButtonPatterns) {
                const matches = [...html.matchAll(pattern)];
                if (matches && matches.length > 0) {
                    for (const match of matches) {
                        if (match[1]) {
                            // Decode URL-encoded address
                            let address = decodeURIComponent(match[1].trim());
                            // Clean up address
                            address = address.replace(/\+/g, ' ').replace(/%20/g, ' ').replace(/\s+/g, ' ').trim();
                            // Check if it looks like a real address (contains Hebrew/English, not just coordinates)
                            if (address.length > 5 && (address.match(/[×-×ª]/) || address.match(/[a-zA-Z]/))) {
                                // Prioritize addresses with street names
                                if (address.match(/×¨×—×•×‘|street|st\./i) || address.match(/\d+/)) {
                                    contactInfo.address = address;
                                    console.log('ğŸ“ Found address from navigation button:', contactInfo.address);
                                    break;
                                } else if (!contactInfo.address) {
                                    // Use this as fallback if no street address found yet
                                    contactInfo.address = address;
                                    console.log('ğŸ“ Found address from navigation button (fallback):', contactInfo.address);
                                }
                            }
                        }
                    }
                    if (contactInfo.address) break;
                }
            }
            
            // If no address from navigation button, try text patterns
            if (!contactInfo.address) {
                const addressPatterns = [
                    /([×-×ª\s]+,\s*×¨×—×•×‘\s+[×-×ª\s\d]+)/g,
                    /([×-×ª\s]+,\s*[×-×ª\s\d]+\s+\d+)/g,
                    /(×¨×—×•×‘\s+[×-×ª\s\d]+,\s*[×-×ª\s]+)/g,
                    /×›×ª×•×‘×ª[:\s]*([^<\n]{5,80})/gi
                ];
                
                for (const pattern of addressPatterns) {
                    const matches = html.match(pattern);
                    if (matches && matches[0]) {
                        let address = matches[0].replace(/×›×ª×•×‘×ª[:\s]*/gi, '').trim();
                        if (address.length > 5) {
                            contactInfo.address = address;
                            console.log('ğŸ“ Found address from text pattern:', contactInfo.address);
                            break;
                        }
                    }
                }
            }
            
            return contactInfo;
        }
        
        // Extract live products from HTML - ONLY REAL PRODUCTS, NO INVENTIONS
        function extractLiveProducts(html) {
            const products = [];
            
            console.log('ğŸ” Marketplace extractLiveProducts called, HTML length:', html.length);
            
            // â›” STRICT EXCLUSIONS - ×“×‘×¨×™× ×©×”× ×‘×•×•×“××•×ª ×œ× ××•×¦×¨×™×!
            // Get page title and h1 to exclude them from products (they're not products!)
            const pageTitleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
            const pageH1Match = html.match(/<h1[^>]*>([^<]{3,80})<\/h1>/i);
            const pageTitle = pageTitleMatch ? pageTitleMatch[1].trim() : '';
            const pageH1 = pageH1Match ? pageH1Match[1].trim() : '';
            
            const excludePatterns = [
                '× ×’×™×©×•×ª', '××•×“×•×ª', '×¦×•×¨ ×§×©×¨', '×“×£ ×”×‘×™×ª', '×¢×œ×™× ×•', '×ª×§× ×•×Ÿ', '××“×™× ×™×•×ª', 
                '×¤×¨×˜×™×•×ª', '×ª× ××™×', '×©×™×¨×•×ª', '××©×œ×•×—×™×', '×”×—×–×¨×•×ª', '××™×š ×œ×”×–××™×Ÿ',
                '×’×œ×¨×™', '×”××•×¦×¨×™×', '×ª×™××•×¨', '×”××™×•×—×“×™×', '×”×›×œ ×¢×œ', '×›×œ ×”×–×›×•×™×•×ª',
                '×–×›×•×™×•×ª ×™×•×¦×¨×™×', '×‘×¨×•×›×™× ×”×‘××™×', '×œ×§×•×—×•×ª', '×©××œ×•×ª', '×ª×©×•×‘×•×ª',
                '××•×¦×¨×™× ×©×œ× ×•', '×”××•×¦×¨×™× ×©×œ× ×•', '×ª×¤×¨×™×˜', '×›×•×ª×¨×ª', '×›×•×ª×¨×ª ×¨××©×™×ª',
                '×œ××”', '×œ××” ×œ×‘×—×•×¨', '×œ××” ×œ×‘×—×•×¨ ×‘', '×œ××” ×œ×‘×—×•×¨ ×‘×¨×•×‘×•×˜×™×', // ğŸ¯ FIX: Exclude question-style text
                '××™×š', '××™×š ×œ', '×›×™×¦×“', '××“×•×¢', '××” ×”×™×ª×¨×•× ×•×ª', '××” ×”×™×ª×¨×•×Ÿ',
                // ğŸ¯ NEW: Exclude accessibility/design options that are NOT real products
                '× ×™×’×•×“×™×•×ª', '×’×•×¤×Ÿ', '×§×¨×™×', '×”×“×’×©', '×§×™×©×•×¨×™×', '×¨×™×•×•×—', '×©×•×¨×•×ª', 
                '××•×’×‘×¨', '×¡××Ÿ', '×’×“×•×œ', '×¢×¦×•×¨', '×× ×™××¦×™×•×ª', '×ª×¦×•×’×”', '×’×“×œ×”',
                '×’×“×œ×ª', '×§×˜× ×”', '×§×˜× ×ª', '×’×•×¤×Ÿ ×’×“×•×œ', '×’×•×¤×Ÿ ×§×˜×Ÿ', '× ×™×’×•×“×™×•×ª ×’×‘×•×”×”',
                '× ×™×’×•×“×™×•×ª × ××•×›×”', '×’×•×¤×Ÿ ×§×¨×™×', '×’×•×¤×Ÿ ×’×“×•×œ', '×’×•×¤×Ÿ ×§×˜×Ÿ',
                pageTitle, pageH1 // Exclude page title and main h1
            ].filter(Boolean); // Remove empty strings
            
            // â›” EXCLUDE common non-product words from product names
            const excludeFromName = [
                'â‚ª', '×©×§×œ', '×©"×—', '××—×™×¨', '××—×™×¨×™×', '××—×™×¨×•×Ÿ', '××©×›×•×¨×ª',
                '×˜×œ×¤×•×Ÿ', '××™×™×œ', '××™××™×™×œ', '×›×ª×•×‘×ª', '×¢×™×¨', '×™×©×¨××œ', '×™×©×¨××œ',
                '×©× ×”', '×—×•×“×©', '×™×•×', '×©×¢×”', '×“×§×”', '×©× ×™×™×”',
                '××•×× ×•×ª', '×–××Ÿ', '×—×™×™×', '×—×™×™×', '×—×•×•×™×”', '×—×•×•×™×•×ª',
                '×˜×•×”×¨', '×™×•×¤×™', '××™×›×•×ª', '×”×©×¨××”', '×—×œ×•×', '×××ª', '× ×©××”',
                '×™×¢×™×œ×•×ª', '×—×¡×¨×ª', '×ª×§×“×™×', '×ª×§×“×™××™×', // ğŸ¯ FIX: Exclude descriptive text like "×™×¢×™×œ×•×ª ×—×¡×¨×ª ×ª×§×“×™×"
                '×‘×™×¦×•×¢×™×', '×‘×™×¦×•×¢', '×ª×›×•× ×”', '×ª×›×•× ×•×ª', '×™×ª×¨×•×Ÿ', '×™×ª×¨×•× ×•×ª',
                '××§×¦×•×¢×™×•×ª', '××”×™×¨×•×ª', '×××™× ×•×ª', '×¡×˜×™×’× ×¡', '×¡×˜×’× ×¡', '×¡×˜×’× ×œ'
            ];
            
            // â›” EXCLUDE phrases that are clearly NOT products (taglines, mottos, inspirational text, questions, descriptions)
            const excludePhrases = [
                /×–××Ÿ\s+(×–×•|×–×”)\s+××•×× ×•×ª/,
                /.*××•×× ×•×ª.*/,
                /.*×—×•×•×™×”.*/,
                /.*×¡×˜×’× ×¡.*/,
                /.*××•×©×œ×.*/,
                /^×˜×•×”×¨$/,
                /^×™×•×¤×™$/,
                /^××™×›×•×ª$/,
                /^×”×©×¨××”$/,
                /^×—×œ×•×$/,
                /^×××ª$/,
                /^× ×©××”$/,
                /^×œ××”.*/, // ğŸ¯ FIX: Exclude questions like "×œ××” ×œ×‘×—×•×¨ ×‘..."
                /.*×œ××”.*×‘×—×•×¨.*/, // ğŸ¯ FIX: Exclude "×œ××” ×œ×‘×—×•×¨ ×‘..." patterns
                /.*×œ××”.*×¨×•×‘×•×˜.*/, // ğŸ¯ FIX: Exclude "×œ××” ×œ×‘×—×•×¨ ×‘×¨×•×‘×•×˜×™×..."
                /.*\?$/, // ğŸ¯ FIX: Exclude text ending with question mark (likely a title/question, not product)
                /×™×¢×™×œ×•×ª\s+(×—×¡×¨×ª|×—×¡×¨).*/, // ğŸ¯ FIX: Exclude "×™×¢×™×œ×•×ª ×—×¡×¨×ª ×ª×§×“×™×"
                /×™×¢×™×œ×•×ª.*×ª×§×“×™×/, // ğŸ¯ FIX: Exclude "×™×¢×™×œ×•×ª ×—×¡×¨×ª ×ª×§×“×™×"
                /.*×™×¢×™×œ×•×ª.*/, // ğŸ¯ FIX: Exclude descriptive text like "×™×¢×™×œ×•×ª"
                /.*×‘×™×¦×•×¢×™×.*/, // ğŸ¯ FIX: Exclude "×‘×™×¦×•×¢×™×" (performance, not a product)
                /.*×ª×›×•× ×”.*/, // ğŸ¯ FIX: Exclude "×ª×›×•× ×”" (feature, not a product)
                /.*×™×ª×¨×•×Ÿ.*/, // ğŸ¯ FIX: Exclude "×™×ª×¨×•×Ÿ" (advantage, not a product)
                /.*××§×¦×•×¢×™×•×ª.*/, // ğŸ¯ FIX: Exclude "××§×¦×•×¢×™×•×ª" (professionalism, not a product)
                /.*××”×™×¨×•×ª.*/, // ğŸ¯ FIX: Exclude "××”×™×¨×•×ª" (speed, not a product)
                /.*×××™× ×•×ª.*/, // ğŸ¯ FIX: Exclude "×××™× ×•×ª" (reliability, not a product)
                // ğŸ¯ NEW: Exclude accessibility/design options that are NOT real products
                /^× ×™×’×•×“×™×•×ª\s+(×’×‘×•×”×”|× ××•×›×”|××•×’×‘×¨×ª)$/i,
                /^×’×•×¤×Ÿ\s+(×§×¨×™×|×’×“×•×œ|×§×˜×Ÿ|××•×’×‘×¨)$/i,
                /^×”×“×’×©\s+×§×™×©×•×¨×™×$/i,
                /^×¨×™×•×•×—\s+×©×•×¨×•×ª\s+××•×’×‘×¨$/i,
                /^×¡××Ÿ\s+×’×“×•×œ$/i,
                /^×¢×¦×•×¨\s+×× ×™××¦×™×•×ª$/i,
                /^×ª×¦×•×’×”\s+(×’×“×œ×”|×§×˜× ×”)$/i,
                /^× ×™×’×•×“×™×•×ª\s+×’×‘×•×”×”$/i,
                /^×’×•×¤×Ÿ\s+×§×¨×™×$/i,
            ];
            
            // ğŸ¯ Look for products - try multiple strategies for different page structures
            // Strategy 1: Look for product-card elements (common in RED and other stores)
            const productCardPattern = /<div[^>]*class="[^"]*product-card[^"]*"[^>]*>([\s\S]{50,2000})<\/div>/gi;
            const productCardMatches = [...html.matchAll(productCardPattern)];
            
            if (productCardMatches.length > 0) {
                console.log('âœ… Found product-card elements:', productCardMatches.length);
                
                productCardMatches.forEach(cardMatch => {
                    const cardHtml = cardMatch[1];
                    
                    // Look for product name - try multiple strategies
                    let nameMatch = null;
                    
                    // Priority 1: h3.product-name or h4.product-name
                    nameMatch = cardHtml.match(/<h[1-6][^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/h[1-6]>/i);
                    
                    // Priority 2: any h3 or h4 (common in stores)
                        if (!nameMatch) {
                        const hMatches = cardHtml.match(/<h[34][^>]*>([^<]{3,100})<\/h[34]>/gi);
                        if (hMatches && hMatches.length > 0) {
                            // Take the first one that looks like a product name
                            for (const hMatch of hMatches) {
                                const text = hMatch.replace(/<[^>]*>/g, '').trim();
                                if (text.length >= 3 && text.length <= 100 && text.match(/[×-×ª]/)) {
                                    nameMatch = [null, text];
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Priority 3: any element with class product-name (span, div, p, etc.)
                    if (!nameMatch) {
                        nameMatch = cardHtml.match(/<[^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/[^>]+>/i);
                    }
                    
                    // Priority 4: Look for text that's clearly a product name (standalone text in card)
                    if (!nameMatch) {
                        // Remove HTML tags and find meaningful text blocks
                        const textOnly = cardHtml.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                        const words = textOnly.split(/\s+/);
                        if (words.length >= 2 && words.length <= 10) {
                            // Check if it looks like product name (not price, not button text)
                            const potentialName = words.slice(0, 5).join(' ');
                            if (potentialName.match(/[×-×ª]/) && !potentialName.includes('â‚ª') && 
                                !potentialName.includes('×”×•×¡×£') && !potentialName.includes('×¢×’×œ×”') &&
                                potentialName.length >= 3 && potentialName.length <= 50) {
                                nameMatch = [null, potentialName];
                            }
                        }
                    }
                    
                    // Look for price - try multiple strategies
                    let priceMatch = null;
                    
                    // Priority 1: element with class product-price
                    priceMatch = cardHtml.match(/<[^>]*class="[^"]*product-price[^"]*"[^>]*>.*?â‚ª\s*(\d+(?:[.,]\d+)?)/i);
                    
                    // Priority 2: any â‚ª symbol with number in the card (most common)
                        if (!priceMatch) {
                        priceMatch = cardHtml.match(/â‚ª\s*(\d+(?:[.,]\d+)?)|(\d+(?:[.,]\d+)?)\s*â‚ª/);
                    }
                    
                    // Priority 3: Look for number patterns that look like prices (4 digits or more, possibly with comma)
                    if (!priceMatch) {
                        priceMatch = cardHtml.match(/(\d{1,3}(?:,\d{3})+(?:\.\d+)?)/); // e.g., 1,500 or 1,500.00
                        }
                        
                        if (nameMatch && priceMatch) {
                        const name = nameMatch[1].replace(/<[^>]*>/g, '').trim(); // Remove any HTML tags
                        let priceText = priceMatch[1] || priceMatch[2];
                        
                        // Additional validation: ensure price is actually in the same card context
                        const nameIndex = cardHtml.indexOf(nameMatch[0] || nameMatch.input);
                        const priceIndex = cardHtml.indexOf(priceMatch[0]);
                        
                        // Name and price must be reasonably close in the card (within 800 chars)
                        const distance = Math.abs((nameIndex || 0) - (priceIndex || 0));
                        if (distance > 800 && nameIndex !== -1 && priceIndex !== -1) {
                            console.log(`   âš ï¸ Skipping - name and price too far apart in card (${distance} chars)`);
                            return; // Skip this card - name and price not related
                        }
                        
                        // Clean price: remove commas and spaces, handle formats like 1,500
                        priceText = priceText.replace(/[,\s]/g, '');
                        const price = parseFloat(priceText);
                        
                        // STRICT validation
                            const isExcluded = excludePatterns.some(pattern => 
                                name.toLowerCase().includes(pattern.toLowerCase())
                            );
                            
                        const hasExcludedWords = excludeFromName.some(ex => name.includes(ex));
                        
                        // Check if name matches excluded phrases (taglines, mottos)
                        const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                        
                        // ğŸ¯ FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        // Only accept prices >= 10 (real product prices like â‚ª10, â‚ª60, â‚ª75)
                        const isValidPrice = price >= 10 && price < 100000 && !isNaN(price);
                        // Exclude single words that are likely taglines/mottos (too short to be a real product name)
                        const isSingleWord = name.trim().split(/\s+/).length === 1;
                        const isShortTagline = isSingleWord && name.length <= 8 && !name.match(/[0-9]/);
                        const isValidName = name.length >= 3 && name.length <= 100 && 
                                           name.match(/[×-×ª]/) && 
                                           !name.match(/^[0-9\s-]+$/) &&
                                           !name.includes('â‚ª') &&
                                           !name.includes('!') && // Exclude taglines that end with !
                                           !matchesExcludedPhrase &&
                                           !isShortTagline; // Exclude single short words that are likely taglines
                        
                        if (!isExcluded && !hasExcludedWords && !matchesExcludedPhrase && isValidName && isValidPrice) {
                            // Check for duplicates
                            const isDuplicate = products.some(p => p.name.toLowerCase() === name.toLowerCase());
                            if (!isDuplicate) {
                                products.push({ name, price });
                                console.log(`   âœ… VALID product-card: "${name}" - â‚ª${price}`);
                            }
                        } else {
                            console.log(`   âŒ EXCLUDED product-card: "${name}" - â‚ª${price} (isExcluded: ${isExcluded}, hasExcluded: ${hasExcludedWords}, validName: ${isValidName}, validPrice: ${isValidPrice})`);
                        }
                    } else {
                        if (!nameMatch) console.log(`   âš ï¸ No name found in product-card`);
                        if (!priceMatch) console.log(`   âš ï¸ No price found in product-card`);
                    }
                });
            }
            
            // Strategy 2: Look for ANY div with product-like classes or patterns
            // ğŸ¯ FIX: More comprehensive search for product containers
            const productContainerPatterns = [
                /<div[^>]*(?:class|id)="[^"]*(?:product-grid|product-gallery|store-items|gallery|products|main-content|container|grid|flex|items)[^"]*"[^>]*>([\s\S]*?)<\/div>/gi,
                /<section[^>]*(?:class|id)="[^"]*(?:products|store|gallery|main)[^"]*"[^>]*>([\s\S]*?)<\/section>/gi,
                /<main[^>]*>([\s\S]*?)<\/main>/gi
            ];
            
            let allContentSections = [];
            productContainerPatterns.forEach(pattern => {
                const matches = [...html.matchAll(pattern)];
                matches.forEach(match => {
                    if (match[1] && match[1].length > 100) { // Only add meaningful sections
                        allContentSections.push(match[1]);
                    }
                });
            });
            
            // If no specific sections found, use entire body/main content
            if (allContentSections.length === 0) {
                const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
                if (bodyMatch) {
                    allContentSections.push(bodyMatch[1]);
                }
            }
            
            console.log(`âœ… Found ${allContentSections.length} content sections to search`);
            
            allContentSections.forEach((sectionHtml, sectionIndex) => {
                console.log(`ğŸ” Searching section ${sectionIndex + 1} (${sectionHtml.length} chars)`);
                
                // Strategy 2a: Look for product items with price patterns
                // ğŸ¯ FIX: Look for patterns like: <h2>Product Name</h2>...<p class="product-price">â‚ªXX</p>
                const productPatternWithPrice = /(?:<h[2-6][^>]*>([^<]{3,80})<\/h[2-6]>|<[^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,80})<\/[^>]+>)[\s\S]{0,500}?â‚ª\s*(\d+(?:[.,]\d+)?)/gi;
                const productMatches = [...sectionHtml.matchAll(productPatternWithPrice)];
                
                productMatches.forEach(productMatch => {
                    const name = (productMatch[1] || productMatch[2] || '').trim();
                    const priceText = (productMatch[3] || '').replace(/[,\s]/g, '');
                    const price = parseFloat(priceText);
                    
                    if (name && name.length >= 3 && name.length <= 80 && 
                        !name.includes('â‚ª') && !name.includes('×”×•×¡×£') && !name.includes('×¢×’×œ×”') &&
                        price > 0 && price < 100000 && !isNaN(price) &&
                        name.match(/[×-×ª]/)) {
                        // Check exclusions
                        const isExcluded = excludePatterns.some(pattern => 
                            name.toLowerCase().includes(pattern.toLowerCase())
                        );
                        const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                        const isDuplicate = products.some(p => p.name.toLowerCase() === name.toLowerCase());
                        
                        if (!isExcluded && !matchesExcludedPhrase && !isDuplicate) {
                            products.push({ name, price });
                            console.log(`   âœ… Found product (pattern with price): "${name}" - â‚ª${price}`);
                        }
                    }
                });
            });
            
            // Strategy 2b: Original gallery search (keep for backward compatibility)
            const galleryPattern = /<div[^>]*(?:class|id)="[^"]*(?:product-grid|product-gallery|store-items|gallery|products|main-content|container)[^"]*"[^>]*>([\s\S]*?)<\/div>/gi;
            const galleryMatches = [...html.matchAll(galleryPattern)];
            
            if (galleryMatches.length > 0) {
                console.log('âœ… Found product gallery/content sections:', galleryMatches.length);
                
                galleryMatches.forEach(galleryMatch => {
                    const gallery = galleryMatch[0];
                    
                    // Look for product items inside gallery - try multiple patterns
                    const itemPatterns = [
                        /<div[^>]*class="[^"]*(?:product-item|product-card|gallery-item|store-item)[^"]*"[^>]*>([\s\S]{50,2000})<\/div>/gi,
                        /<div[^>]*id="[^"]*product[^"]*"[^>]*>([\s\S]{50,2000})<\/div>/gi,
                        /<article[^>]*>([\s\S]{50,2000})<\/article>/gi, // Some stores use article tags
                        /<section[^>]*class="[^"]*product[^"]*"[^>]*>([\s\S]{50,2000})<\/section>/gi
                    ];
                    
                    itemPatterns.forEach(pattern => {
                        const itemMatches = [...gallery.matchAll(pattern)];
                        
                        itemMatches.forEach(itemMatch => {
                            const itemHtml = itemMatch[1];
                            
                            // Extract product name - comprehensive search
                            let nameMatch = itemHtml.match(/<h[1-6][^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/h[1-6]>/i);
                    if (!nameMatch) {
                                const hMatches = itemHtml.match(/<h[34][^>]*>([^<]{3,100})<\/h[34]>/gi);
                                if (hMatches && hMatches.length > 0) {
                                    for (const hMatch of hMatches) {
                                        const text = hMatch.replace(/<[^>]*>/g, '').trim();
                                        if (text.length >= 3 && text.length <= 100 && text.match(/[×-×ª]/) &&
                                            !text.includes('â‚ª') && !text.includes('×”×•×¡×£')) {
                                            nameMatch = [null, text];
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!nameMatch) {
                                nameMatch = itemHtml.match(/<[^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/[^>]+>/i);
                            }
                            
                            // Extract price - comprehensive search
                            let priceMatch = itemHtml.match(/<[^>]*class="[^"]*product-price[^"]*"[^>]*>.*?â‚ª\s*(\d+(?:[.,]\d+)?)/i);
                    if (!priceMatch) {
                                priceMatch = itemHtml.match(/â‚ª\s*(\d+(?:[.,]\d+)?)|(\d+(?:[.,]\d+)?)\s*â‚ª/);
                            }
                            if (!priceMatch) {
                                priceMatch = itemHtml.match(/(\d{1,3}(?:,\d{3})+(?:\.\d+)?)/); // Formats like 1,500
                    }
                    
                    if (nameMatch && priceMatch) {
                                const name = nameMatch[1].replace(/<[^>]*>/g, '').trim();
                                let priceText = priceMatch[1] || priceMatch[2];
                                // Clean price: remove commas, spaces
                                priceText = priceText.replace(/[,\s]/g, '');
                                const price = parseFloat(priceText);
                        
                        const isExcluded = excludePatterns.some(pattern => 
                            name.toLowerCase().includes(pattern.toLowerCase())
                        );
                                const hasExcludedWords = excludeFromName.some(ex => name.includes(ex));
                                const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                                // ğŸ¯ FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        // Only accept prices >= 10 (real product prices like â‚ª10, â‚ª60, â‚ª75)
                        const isValidPrice = price >= 10 && price < 100000 && !isNaN(price);
                                const isSingleWord = name.trim().split(/\s+/).length === 1;
                                const isShortTagline = isSingleWord && name.length <= 8 && !name.match(/[0-9]/);
                                const isValidName = name.length >= 3 && name.length <= 100 && 
                                                   name.match(/[×-×ª]/) && 
                                                   !name.match(/^[0-9\s-]+$/) &&
                                                   !name.includes('!') &&
                                                   !matchesExcludedPhrase &&
                                                   !isShortTagline;
                                
                                if (!isExcluded && !hasExcludedWords && !matchesExcludedPhrase && isValidName && isValidPrice) {
                                    // Check if not duplicate
                                    const isDuplicate = products.some(p => p.name.toLowerCase() === name.toLowerCase());
                                    if (!isDuplicate) {
                            products.push({ name, price });
                                        console.log(`   âœ… VALID gallery product: "${name}" - â‚ª${price}`);
                                    }
                                }
                            }
                        });
                    });
                });
            }
            
            // Strategy 3: Direct search for product patterns (ALWAYS try, even if we found some)
            // This helps find products that might be in different structures
            console.log(`âš ï¸ Found ${products.length} products so far, trying additional patterns...`);
            
            // Strategy 3: Look for patterns where h2-h6 appears near a price (within same structural block)
            // ğŸ¯ FIX: More comprehensive search for product blocks
            // Look for ANY block that contains both a product name AND a price
            const blockPatterns = [
                /<(?:div|section|article|li)[^>]*>([\s\S]{30,3000})<\/(?:div|section|article|li)>/gi,
                /<article[^>]*>([\s\S]{30,3000})<\/article>/gi,
                /<li[^>]*>([\s\S]{30,3000})<\/li>/gi
            ];
            
            let allBlocks = [];
            blockPatterns.forEach(pattern => {
                const matches = [...html.matchAll(pattern)];
                matches.forEach(match => {
                    if (match[1] && match[1].length >= 30 && match[1].length <= 3000) {
                        // Only add if it contains Hebrew and potential price
                        // ğŸ¯ FIX: Must catch single digit prices like â‚ª10 (change \d{2,} to \d{1,})
                        if (match[1].match(/[×-×ª]/) && match[1].match(/â‚ª|\d{1,}/)) {
                            allBlocks.push(match[1]);
                        }
                    }
                });
            });
            
            console.log(`ğŸ” Scanning ${allBlocks.length} blocks for additional products...`);
            
            allBlocks.forEach((blockHtml, blockIndex) => {
                // Skip if block is too generic (navigation, header, footer)
                if (blockHtml.includes('nav') || blockHtml.includes('header') || 
                    blockHtml.includes('footer') || blockHtml.includes('×ª×¤×¨×™×˜') ||
                    blockHtml.includes('menu') || blockHtml.includes('navigation')) {
                    return;
                }
                
                // ğŸ¯ FIX: Look for product names in multiple patterns
                // Priority 1: h2-h6 with Hebrew text (potential product name)
                // âš ï¸ EXCLUDE h1 - it's usually the page title, not a product!
                let nameMatches = blockHtml.match(/<h[2-6][^>]*>([^<]{3,80})<\/h[2-6]>/gi) || [];
                
                // Priority 2: strong, b, span, p with product-like text
                if (nameMatches.length === 0) {
                    const strongMatches = blockHtml.match(/<(?:strong|b)[^>]*>([^<]{4,60})<\/(?:strong|b)>/gi);
                    if (strongMatches) {
                        strongMatches.forEach(match => {
                            const text = match.replace(/<[^>]*>/g, '').trim();
                            if (text.match(/[×-×ª]{4,}/) && !text.includes('â‚ª') && !text.includes('×”×•×¡×£') && text.length >= 4 && text.length <= 60) {
                                nameMatches.push(`<h3>${text}</h3>`); // Treat as name
                            }
                        });
                    }
                }
                
                // Priority 3: Look for text in divs/spans that could be product names
                if (nameMatches.length === 0) {
                    const textMatches = blockHtml.match(/<(?:p|span|div)[^>]*class="[^"]*[^"]*"[^>]*>([^<]{4,60})<\/(?:p|span|div)>/gi);
                    if (textMatches) {
                        textMatches.forEach(textMatch => {
                            const text = textMatch.replace(/<[^>]*>/g, '').trim();
                            // Check if it looks like a product name (Hebrew, not price, not button)
                            if (text.match(/[×-×ª]{4,}/) && !text.includes('â‚ª') && !text.includes('×”×•×¡×£') && 
                                !text.includes('×¢×’×œ×”') && !text.match(/^\d+$/) && // Not just numbers
                                text.length >= 4 && text.length <= 60 &&
                                !excludePatterns.some(pattern => text.toLowerCase().includes(pattern.toLowerCase()))) {
                                nameMatches.push(`<h3>${text}</h3>`); // Treat as name
                            }
                        });
                    }
                }
                if (nameMatches.length === 0) {
                    // Also try p, span, strong with product-like text
                    const textMatches = blockHtml.match(/<(?:p|span|strong|b)[^>]*>([^<]{4,60})<\/(?:p|span|strong|b)>/gi);
                    if (textMatches) {
                        // Check if any look like product names
                        textMatches.forEach(textMatch => {
                            const text = textMatch.replace(/<[^>]*>/g, '').trim();
                            if (text.match(/[×-×ª]{4,}/) && !text.includes('â‚ª') && !text.includes('×”×•×¡×£')) {
                                nameMatches.push(`<h3>${text}</h3>`); // Treat as name
                            }
                        });
                    }
                }
                
                if (!nameMatches || nameMatches.length === 0) return;
                
                nameMatches.forEach(nameMatch => {
                    const nameText = nameMatch.replace(/<[^>]*>/g, '').trim();
                    
                    // Check if this is the page title or h1 (not a product!)
                    const isPageTitle = pageTitle && nameText.toLowerCase() === pageTitle.toLowerCase();
                    const isPageH1 = pageH1 && nameText.toLowerCase() === pageH1.toLowerCase();
                    
                    // Check excluded phrases
                    const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(nameText));
                    
                    // Check if name looks valid (Hebrew, not excluded, not page title, not tagline)
                    const isSingleWord = nameText.trim().split(/\s+/).length === 1;
                    const isShortTagline = isSingleWord && nameText.length <= 8 && !nameText.match(/[0-9]/);
                    const isValidName = !isPageTitle && !isPageH1 && !matchesExcludedPhrase && !isShortTagline &&
                                       nameText.length >= 3 && nameText.length <= 80 && 
                                       nameText.match(/[×-×ª]/) && 
                                       !nameText.match(/^[0-9\s-]+$/) &&
                                       !nameText.includes('!') &&
                                       !excludePatterns.some(pattern => 
                                           nameText.toLowerCase().includes(pattern.toLowerCase())
                                       ) &&
                                       !excludeFromName.some(ex => nameText.includes(ex));
                    
                    if (!isValidName) return;
                    
                    // ğŸ¯ FIX: Look for price in the SAME block (must be nearby) - improved pattern
                    // Must catch low prices like â‚ª10, â‚ª60, â‚ª75, â‚ª85, â‚ª90!
                    const pricePatterns = [
                        /â‚ª\s*(\d{1,4}(?:,\d{3})*)/,  // â‚ª1,500 or â‚ª1500 or â‚ª10
                        /(\d{1,4}(?:,\d{3})*)\s*â‚ª/,  // 1,500â‚ª or 10â‚ª
                        /â‚ª\s*(\d{1,6})/,                  // â‚ª720 or â‚ª10 (must catch single digits!)
                        /(\d{1,6})/,                   // 720, 1500, 10 (standalone number - must catch single digits!)
                    ];
                    
                    let priceMatch = null;
                    for (const pattern of pricePatterns) {
                        priceMatch = blockHtml.match(pattern);
                        if (priceMatch && priceMatch[1]) {
                            const testPrice = parseFloat(priceMatch[1].replace(/[,\s]/g, ''));
                            // ğŸ¯ FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                            // (e.g., "×™×¢×™×œ×•×ª ×—×¡×¨×ª ×ª×§×“×™× - â‚ª2" - the 2 is probably part of text, not a product price)
                            // Only accept prices >= 10 (real product prices like â‚ª10, â‚ª60, â‚ª75)
                            if (testPrice >= 10 && testPrice < 50000) { // Reasonable price range (includes small prices like 10!)
                                break;
                            }
                            priceMatch = null;
                        }
                    }
                    
                    if (priceMatch) {
                        let priceText = priceMatch[1];
                        priceText = priceText.replace(/[,\s]/g, '');
                        const price = parseFloat(priceText);
                        
                        // Additional validation: price must be reasonable and in the same block as name
                        const nameIndex = blockHtml.indexOf(nameMatch);
                        const priceIndex = blockHtml.indexOf(priceMatch[0]);
                        const distance = Math.abs(nameIndex - priceIndex);
                        
                        // ğŸ¯ FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        // (e.g., "×™×¢×™×œ×•×ª ×—×¡×¨×ª ×ª×§×“×™× - â‚ª2" - the price 2 is probably not a product price)
                        // Only accept prices >= 10 (real product prices like â‚ª10, â‚ª60, â‚ª75)
                        const isValidPriceValue = price >= 10 && price < 50000;
                        
                        // ğŸ¯ FIX: Allow low prices like 10, 60, 75, 85, 90 (not just >50!)
                        // Price must be within 800 chars of name (increased from 500 to catch more products)
                        // But exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        if (isValidPriceValue && !isNaN(price) && distance < 800) {
                            // Check if not duplicate and not already found
                            const isDuplicate = products.some(p => p.name.toLowerCase() === nameText.toLowerCase());
                            if (!isDuplicate) {
                                products.push({ name: nameText, price });
                                console.log(`   âœ… VALID additional product: "${nameText}" - â‚ª${price} (distance: ${distance})`);
                            }
                        }
                    }
                });
            });
            
            // Remove duplicates
            const uniqueProducts = [];
            const seenNames = new Set();
            products.forEach(p => {
                if (!seenNames.has(p.name.toLowerCase())) {
                    seenNames.add(p.name.toLowerCase());
                    uniqueProducts.push(p);
                }
            });
            
            console.log(`âœ… Marketplace extractLiveProducts found ${uniqueProducts.length} REAL products:`, uniqueProducts);
            return uniqueProducts;
        }
        
        // Shared smart search function (Same as Stav bot) - ENHANCED WITH AUTO-RELOAD
        async function handleSharedSmartSearch(message, allPages) {
            const lowerMessage = message.toLowerCase();
            
            // Handle greetings and personal questions - NO FIXED MESSAGES
            if (lowerMessage.includes('×©×œ×•×') || lowerMessage.includes('×”×™×™') || lowerMessage.includes('×”×™') || 
                lowerMessage.includes('×©××™') || lowerMessage.includes('×§×•×¨××™× ×œ×™') || lowerMessage.includes('×× ×™') ||
                lowerMessage.includes('××” ×©×œ×•××š') || lowerMessage.includes('××™×š ××ª×”') || lowerMessage.includes('××™×š ××ª')) {
                return null; // Send to N8N instead of fixed message
            }
            
            // Handle knowledge questions - send to N8N
            if (lowerMessage.includes('××” ×’×•×“×œ') || lowerMessage.includes('××” ×–×”') || lowerMessage.includes('××™×š') || 
                lowerMessage.includes('××ª×™') || lowerMessage.includes('××™×¤×”') || lowerMessage.includes('×œ××”') ||
                lowerMessage.includes('×›××”') || lowerMessage.includes('××™') || lowerMessage.includes('××™×–×”')) {
                return null; // Send to N8N for general knowledge questions
            }
            
            // Only search for pages if user is specifically looking for something
            if (!lowerMessage.includes('××ª× ×”') && !lowerMessage.includes('×œ×§') && !lowerMessage.includes('×©×¢×•×Ÿ') && !lowerMessage.includes('×¦×¢×¦×•×¢') && !lowerMessage.includes('×§×•×¨×¡') && !lowerMessage.includes('×—× ×•×ª') && !lowerMessage.includes('×©×™×¨×•×ª') && !lowerMessage.includes('××™×¨×•×¢') && !lowerMessage.includes('××—×™×¨') && !lowerMessage.includes('×›××”') && !lowerMessage.includes('×¢×•×œ×”') && !lowerMessage.includes('â‚ª') && !lowerMessage.includes('×©×§×œ') && !lowerMessage.includes('×”×›×™ ×–×•×œ') && !lowerMessage.includes('×”×›×™ ×™×§×¨') && !lowerMessage.includes('×”×©×•×•××”') && !lowerMessage.includes('× ×’×™×“') && !lowerMessage.includes('×•×œ×§') && !lowerMessage.includes('×•×©×¢×•×Ÿ') && !lowerMessage.includes('×•×¦×¢×¦×•×¢') && !lowerMessage.includes('×¦×¢×¦×•×¢×™×') && !lowerMessage.includes('×©×¢×•× ×™×')) {
                // For other general questions, send to N8N
                return null;
            }
            
            // Search for pages with live content - ALWAYS get fresh data
            const liveResults = await searchLivePages(message);
            if (liveResults.length > 0) {
                let response = `××¦××ª×™ ${liveResults.length} ×“×¤×™× ×¨×œ×•×•× ×˜×™×™×:\n\n`;
                liveResults.forEach(page => {
                    response += `ğŸª **${page.title}**\n`;
                    if (page.description) {
                        response += `${page.description}\n`;
                    }
                    
                    // Show live product data if available
                    if (page.liveProducts && page.liveProducts.length > 0) {
                        response += `ğŸ’° ××•×¦×¨×™× ×—×™×™×:\n`;
                        page.liveProducts.forEach(product => {
                            response += `â€¢ ${product.name} - â‚ª${product.price}\n`;
                        });
                    }
                    
                    response += `ğŸ”— [×¦×¤×” ×‘×“×£](/users/${page.userId}/${page.pageId}_html)\n\n`;
                });
                return { message: response, action: { type: 'none' } };
            }
            
            return null;
        }
        
        // Replace the original sendAIMessage with enhanced version
        window.sendAIMessage = sendAIMessageEnhanced;
        
        // Allow Enter key in chat input
        document.getElementById('aiChatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendAIMessage();
            }
        });
        
        // Go to full app function
        function goToFullApp() {
            window.location.href = '/';
        }

        // === STAV CHAT FUNCTIONS ===
        function toggleStavChat() {
            const chatWindow = document.getElementById('stavChatWindow');
            chatWindow.classList.toggle('active');
            if (chatWindow.classList.contains('active')) {
                document.getElementById('stavChatInput').focus();
            }
        }

        // Process Stav message with REAL data search
        async function processStavMessage(userMessage, allPages) {
            try {
                console.log('ğŸ” Processing Stav message with REAL data:', userMessage);
                
                const lowerMessage = userMessage.toLowerCase().trim();
                
                // ğŸ¯ Check if user is asking to see website/link/page
                const userWantsLink = /×ª×¨××”.*××ª×¨|×ª×¨××”.*×“×£|×ª×¨××™.*××ª×¨|×ª×¨××™.*×“×£|×”×¨××”.*××ª×¨|×œ×¨××•×ª.*××ª×¨|××¤×©×¨.*××ª×¨|×§×™×©×•×¨|×¤×ª×—.*××ª×¨|×œ×™× ×§|link|××ª×¨.*×©×œ|×œ×“×£.*×©×œ|×¤×ª×™×—×ª.*××ª×¨|×ª×¨××•.*××ª×¨|×”×¦×’.*××ª×¨/i.test(userMessage);
                
                // ğŸ¯ NEW: Check if user is responding "yes" to previous "want to see website?" question
                // (e.g., "×›×Ÿ", "×ª×¨××”", "×‘×˜×—", "××©××—", "×”×¨××”", "××©××— ×œ×¤×¨×˜×™× ×¢×œ X", "×¨×•×¦×” ×œ×¤×ª×•×—")
                let userSaysYes = /^(×›×Ÿ|×‘×˜×—|××©××—|yes|ok|××•×§×™×™)$/i.test(userMessage.trim()) || 
                                  /××©××— ×œ×¤×¨×˜×™×|×¨×•×¦×” ×¤×¨×˜×™×|×ª×Ÿ ×¤×¨×˜×™×|×¤×¨×˜×™× × ×•×¡×¤×™×|×¨×•×¦×” ×œ×¤×ª×•×—|×× ×™ ×¨×•×¦×” ×œ×¤×ª×•×—/i.test(userMessage);
                
                // ğŸ¯ SPECIAL: If user says "××©××— ×œ×¤×¨×˜×™× ×¢×œ X" where X is in current context, treat as "yes"
                if (!userSaysYes && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    const pageNamesInContext = window.stavCurrentPages.map(p => p.title?.toLowerCase()).filter(Boolean);
                    const hasPageNameInMessage = pageNamesInContext.some(pageName => 
                        userMessage.toLowerCase().includes(pageName) && 
                        /×¤×¨×˜×™×|××™×“×¢|×˜×œ×¤×•×Ÿ|×›×ª×•×‘×ª/i.test(userMessage)
                    );
                    if (hasPageNameInMessage) {
                        console.log('âœ… User asking for details about page in context - treating as YES');
                        userSaysYes = true;
                    }
                }
                
                const userSaysYesToPreview = window.stavCurrentPages && window.stavCurrentPages.length > 0 && 
                    /^(×›×Ÿ|×ª×¨××”|×ª×¨××™|×‘×˜×—|××©××—|×”×¨××”|×”×¨××™|×‘×•×|×¤×ª×—|yes|ok|××•×§×™×™)$/i.test(userMessage.trim());
                
                console.log(`ğŸ” [LINK CHECK] userMessage: "${userMessage}"`);
                console.log(`ğŸ” [LINK CHECK] userSaysYes: ${userSaysYes}`);
                console.log(`ğŸ” [LINK CHECK] userWantsLink: ${userWantsLink}`);
                console.log(`ğŸ” [LINK CHECK] userSaysYesToPreview: ${userSaysYesToPreview}`);
                console.log(`ğŸ” [LINK CHECK] window.stavCurrentPages: ${window.stavCurrentPages?.length || 0} pages`);
                
                // ğŸ¯ NEW: If user chose a specific option by number or word (e.g., "1", "2", "×¨××©×•×Ÿ", "×©× ×™")
                if (window.stavCurrentPages && window.stavCurrentPages.length > 1) {
                    let selectedIndex = -1;
                    
                    // Check for number (1, 2, 3...)
                    const numberMatch = userMessage.trim().match(/^(\d+)$/);
                    if (numberMatch) {
                        selectedIndex = parseInt(numberMatch[1], 10) - 1; // Convert to 0-based index
                    }
                    
                    // Check for Hebrew ordinal words
                    const hebrewOrdinals = {
                        '×¨××©×•×Ÿ': 0, '×¨××©×•× ×”': 0, '××—×“': 0,
                        '×©× ×™': 1, '×©× ×™×”': 1, '×©×ª×™×™×': 1,
                        '×©×œ×™×©×™': 2, '×©×œ×™×©×™×ª': 2, '×©×œ×•×©': 2,
                        '×¨×‘×™×¢×™': 3, '×¨×‘×™×¢×™×ª': 3, '××¨×‘×¢': 3,
                        '×—××™×©×™': 4, '×—××™×©×™×ª': 4, '×—××©': 4,
                        '×©×™×©×™': 5, '×©×™×©×™×ª': 5, '×©×©': 5,
                        '×©×‘×™×¢×™': 6, '×©×‘×™×¢×™×ª': 6, '×©×‘×¢': 6,
                        '×©××™× ×™': 7, '×©××™× ×™×ª': 7, '×©××•× ×”': 7,
                        '×ª×©×™×¢×™': 8, '×ª×©×™×¢×™×ª': 8, '×ª×©×¢': 8,
                        '×¢×©×™×¨×™': 9, '×¢×©×™×¨×™×ª': 9, '×¢×©×¨': 9
                    };
                    
                    for (const [word, index] of Object.entries(hebrewOrdinals)) {
                        if (userMessage.trim() === word || userMessage.includes(word)) {
                            selectedIndex = index;
                            break;
                        }
                    }
                    
                    // If valid selection, show that specific page
                    if (selectedIndex >= 0 && selectedIndex < window.stavCurrentPages.length) {
                        console.log(`âœ… User selected option ${selectedIndex + 1} - showing page`);
                        const selectedPage = window.stavCurrentPages[selectedIndex];
                        
                        // Build message with LIVE description - will be fetched when displaying
                        // For now, just pass the page and let the display function fetch the description
                        return {
                            type: 'pages',
                            pages: [selectedPage], // Only the selected page
                            message: `×‘×‘×§×©×”, ×”× ×” ×”×“×£ ×©×œ ${selectedPage.title}`, // Description will be added during display
                            includeLinks: true,
                            needsPreview: true // Show iframe preview
                        };
                    }
                }
                
                // ğŸ¯ NEW: If user says "×›×Ÿ" (yes) and we have pages in context, show PAGE (not just contact info)
                if (userSaysYes && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    console.log('âœ… User said YES - showing PAGE for pages in context');
                    
                    // Show the page with iframe + link
                    return { 
                        type: 'pages', 
                        pages: window.stavCurrentPages,
                        message: window.stavCurrentPages.length === 1 
                            ? `×”× ×” ×“×£ ${window.stavCurrentPages[0].title}:` 
                            : `×”× ×” ${window.stavCurrentPages.length} ×”×“×¤×™×:`,
                        includeLinks: true, // Show links
                        needsPreview: true // Show iframe preview in chat
                    };
                }
                
                // If user wants link OR says yes to preview, check if we have pages in context
                if ((userWantsLink || userSaysYesToPreview) && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    console.log('ğŸ”— âœ… User EXPLICITLY wants link/preview - showing pages with PREVIEW + LINKS');
                    
                    // ğŸ¯ IMPROVED: Show both preview AND links when user explicitly asks
                    return { 
                        type: 'pages', 
                        pages: window.stavCurrentPages,
                        message: window.stavCurrentPages.length === 1 
                            ? `×”× ×” ×“×£ ${window.stavCurrentPages[0].title}:` 
                            : `×”× ×” ${window.stavCurrentPages.length} ×”×“×¤×™×:`,
                        includeLinks: true, // Show links
                        needsPreview: true // Show iframe preview in chat
                    };
                } else {
                    console.log('â„¹ï¸ User did NOT request to see page - NO preview will be shown');
                }
                
                // ğŸ¯ IMPROVED: Detect common product categories even in questions like "×©×¢×•× ×™× ×™×©?" or "×•×©×¢×•×Ÿ?"
                const productCategories = [
                    // Coaching & Fitness
                    '××××Ÿ', '×××× ×ª', '××™××•×Ÿ', '×§×•××¦\'×™× ×’', 'coaching', '×›×•×©×¨', '×—×“×¨ ×›×•×©×¨', '×¡×¤×•×¨×˜',
                    // Carpentry & Woodwork
                    '× ×’×¨', '× ×’×¨×•×ª', '× ×’×¨×™×”', '×¢×‘×•×“×•×ª ×¢×¥', '××¨×•× ×•×ª', '××˜×‘×—×™×',
                    // Watches & Jewelry
                    '×©×¢×•×Ÿ', '×©×¢×•× ×™×', '×ª×›×©×™×˜', '×ª×›×©×™×˜×™×', '×–×”×‘', '×›×¡×£',
                    // Toys & Games
                    '×¦×¢×¦×•×¢', '×¦×¢×¦×•×¢×™×', '××©×—×§', '××©×—×§×™×',
                    // Hairdressing & Beauty
                    '××¡×¤×¨×”', '×¡×¤×¨', '×ª×¡×¤×•×¨×ª', '×œ×§', '×× ×™×§×•×¨', '×¤×“×™×§×•×¨', '×¦×™×¤×•×¨× ×™×™×', '×™×•×¤×™', '××¢×¦×‘', '××™×¤×•×¨',
                    // Restaurants & Food
                    '××¡×¢×“×”', '××¡×¢×“×•×ª', '××•×›×œ', '×§×¤×”', '×‘×™×ª ×§×¤×”', '×¤×™×¦×”', '×”××‘×•×¨×’×¨', '×¡×•×©×™', '××–×•×Ÿ',
                    // Plumbing & Electrician
                    '××™× ×¡×˜×œ×˜×•×¨', '×©×¨×‘×¨×‘', '×—×©××œ××™', '×—×©××œ',
                    // Car & Auto
                    '×¨×›×‘', '×—×œ×¤×™×', '××•×¡×š', '××›×•× ××™', '××›×•× ×™×ª',
                    // Technology & Robotics
                    '×¨×•×‘×•×˜', '×¨×•×‘×•×˜×™×§×”', '×˜×›× ×•×œ×•×’×™×”', '××—×©×‘', '××—×©×‘×™×',
                    // Courses & Education
                    '×§×•×¨×¡', '×§×•×¨×¡×™×', '×œ×™××•×“×™×', '×”×©×ª×œ××•×ª', '×”×›×©×¨×”',
                    // Events & Entertainment
                    '××™×¨×•×¢', '××™×¨×•×¢×™×', '×¦×œ×', '×¦×™×œ×•×', '×“×™ ×’\'×™×™', 'dj', '×—×ª×•× ×”',
                    // Health & Wellness
                    '×“×™××˜×”', '×ª×–×•× ×”', '×™×•×’×”', '×¢×™×¡×•×™', '×¤×™×–×™×•×ª×¨×¤×™×”', '××¢×¡×”',
                    // Home Services
                    '× ×™×§×™×•×Ÿ', '×’×™× ×•×Ÿ', '×’× ×Ÿ', '×¦×‘×¢', '×©×™×¤×•×¦×™×', '×§×‘×œ×Ÿ', '×‘× ×™×™×”',
                    // Fashion & Clothing
                    '××•×¤× ×”', '×‘×’×“×™×', '×‘×™×’×•×“', '× ×¢×œ×™×™×', '× ×¢×œ×™×',
                    // Pets
                    '×›×œ×‘', '×›×œ×‘×™×', '×—×ª×•×œ', '×—×ª×•×œ×™×', '×•×˜×¨×™× ×¨', '×—×™×•×ª ××—××“',
                    // Gifts & Party
                    '××ª× ×”', '××ª× ×•×ª', '×©×™',
                    // Books & Print
                    '×¡×¤×¨', '×¡×¤×¨×™×', '×”×“×¤×¡×”', '×“×¤×•×¡',
                    // Flowers
                    '×¤×¨×—×™×', '×¤×¨×—', '×–×¨ ×¤×¨×—×™×',
                    // Insurance & Legal
                    '×‘×™×˜×•×—', '×‘×™×˜×•×—×™×', '×¢×•×¨×š ×“×™×Ÿ', '×¨×•××” ×—×©×‘×•×Ÿ',
                    // Real Estate
                    '× ×“×œ×Ÿ', '×“×™×¨×”', '×“×™×¨×•×ª', '××ª×•×•×š',
                    // General
                    '×—× ×•×ª', '×—× ×•×™×•×ª', '×©×™×¨×•×ª', '×©×™×¨×•×ª×™×', '×¢×¡×§', '×¢×¡×§×™×'
                ];
                const mentionsProduct = productCategories.some(cat => lowerMessage.includes(cat));
                
                // If user mentions a product category, treat as marketplace query (even with "×™×©?" or "×•" prefix)
                if (mentionsProduct) {
                    console.log('ğŸ¯ Product category mentioned - treating as marketplace query:', lowerMessage);
                    // Continue to marketplace search below (don't return null to N8N)
                }
                
                // Handle greetings and small talk - return null to send to N8N
                const greetings = ['×©×œ×•×', '×”×™×™', '×”×™', '×”×™×™×™', '×”×™×•', '×‘×•×§×¨', '×¢×¨×‘', '×¦×”×¨×™×™×', '×˜×•×‘', '×œ×”×ª×¨××•×ª', '×‘×™×™', '×‘×”×¦×œ×—×”'];
                const isGreeting = greetings.some(greeting => lowerMessage === greeting || lowerMessage.includes(greeting));
                
                // Handle questions about bot itself or general chat
                const botQuestions = ['××” ×©×œ×•××š', '××™×š ××ª', '××™ ××ª', '××” ××ª', '××” ××ª×”', '××™ ××ª×”'];
                const isBotQuestion = botQuestions.some(q => lowerMessage.includes(q));
                
                // Handle self-introduction (e.g., "×× ×™ ×™× ×™×‘", "×× ×™ ×¦×™×¤×™", "×©××™ ×“×•×“", "×§×•×¨××™× ×œ×™ ×©×™×¨×”")
                const selfIntroPatterns = [
                    /^×× ×™\s+[×-×ª]+/,
                    /^×©××™\s+[×-×ª]+/,
                    /^×§×•×¨××™×\s+×œ×™\s+[×-×ª]+/,
                    /^×”×©×\s+×©×œ×™\s+[×-×ª]+/,
                    /^×× ×™\s+×”[×-×ª]+/
                ];
                const isSelfIntro = selfIntroPatterns.some(pattern => pattern.test(userMessage.trim()));
                
                // Handle general knowledge questions (like "××” ×’×•×“×œ ×”×•×“×•", "××™×š ×œ...", etc.)
                const generalKnowledgePatterns = [
                    /^××”\s+(×’×•×“×œ|×©×˜×—|××•×›×œ×•×¡×™×”|××•×¨×š|×¨×•×—×‘|×’×•×‘×”|×¢×•××§|××©×§×œ|×˜××¤×¨×˜×•×¨×”|××”×™×¨×•×ª|××¨×—×§)/,
                    /^(××™×š\s+×œ|×›×™×¦×“\s+×œ|××“×¨×™×š|×ª×”×œ×™×š|×©×œ×‘×™×)/,
                    /^(××”\s+×–×”|××”\s+×¤×™×¨×•×©|××”\s+××©××¢×•×ª)/,
                    /^(××ª×™\s+×”×•×§×|××ª×™\s+× ×•×¡×“|××ª×™\s+× ×‘× ×”|×ª××¨×™×š|×©× ×”)/,
                    /^(×œ××”|××“×•×¢|×××™×–×”\s+×¡×™×‘×”)/
                ];
                const isGeneralKnowledge = generalKnowledgePatterns.some(pattern => pattern.test(userMessage.trim()));
                
                // Handle general questions that don't need page previews (price info, statistics, etc.)
                const generalInfoPatterns = [
                    /(?:×™×•×“×¢×ª|××”|××™×–×”|×›××”)\s*(?:××—×™×¨|××—×™×¨×™×)/,
                    /××”\s+(×”××•×¦×¨|×”××•×¦×¨×™×)\s*(?:×”×›×™|×”)?\s*(?:×–×•×œ|×™×§×¨|×˜×•×‘)/,
                    /(?:×›××”|××”)\s*(?:× ×•×ª× ×™|××¡×¤×§×™|×‘×¢×œ×™)\s*(?:×©×¨×•×ª|×©×™×¨×•×ª|××§×¦×•×¢)/,
                    /(?:×›××”|××”)\s*(?:×“×¤×™×|×¢×¡×§×™×|×—× ×•×™×•×ª)\s*(?:×™×©|×§×™×™××™×)/,
                    /×‘××™×–×”\s+×¢×™×¨|××”\s+×”×˜×œ×¤×•×Ÿ\s+×©×œ/i
                ];
                const isGeneralInfo = generalInfoPatterns.some(pattern => pattern.test(userMessage.trim()));
                
                // ğŸ§  Check for context-aware follow-up questions (e.g., "××™×–×” ××•×¦×¨×™× ×™×© ×©×", "××” ××—×™×¨×™ ×”×©×¢×˜× ×™×")
                // These refer to previously mentioned pages/stores
                const contextFollowUpPatterns = [
                    /(?:××™×–×”|××”)\s*(?:××•×¦×¨×™×|×¤×¨×™×˜×™×)\s*(?:×™×©|×§×™×™××™×|×–××™× ×™×)\s*(?:×©×|×‘×—× ×•×ª|×‘|×‘×ª×•×›×”)/i,
                    /(?:×©×|×‘×—× ×•×ª|×‘|×‘×ª×•×›×”)\s*(?:×™×©|×§×™×™××™×|×–××™× ×™×)/i
                ];
                const isContextFollowUp = contextFollowUpPatterns.some(pattern => pattern.test(userMessage));
                
                // Check if query is about prices of products mentioned before (e.g., "××” ××—×™×¨×™ ×”×©×¢×˜× ×™×")
                const isPriceQuery = /××”\s+(?:××—×™×¨|××—×™×¨×™×|××—×™×¨×™)/i.test(userMessage);
                const hasProductReference = /(?:×©×¢×˜× ×™×|×©×¢×•× ×™×|×©×¢×•×Ÿ|××•×¦×¨×™×|×¤×¨×™×˜×™×)/i.test(userMessage);
                const isPriceFollowUp = isPriceQuery && (hasProductReference || isContextFollowUp);
                
                // Get last mentioned page from conversation context (if available)
                let lastMentionedPage = null;
                if (typeof window !== 'undefined' && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    lastMentionedPage = window.stavCurrentPages[0]; // Get the first/last page shown
                    console.log('ğŸ§  Context follow-up detected - last mentioned page:', lastMentionedPage?.title);
                }
                
                // If this is a context follow-up or price query about products mentioned before
                if ((isContextFollowUp || isPriceFollowUp) && lastMentionedPage) {
                    console.log('ğŸ§  Handling context follow-up - searching page:', lastMentionedPage.title);
                    const liveResults = await searchLivePages(lastMentionedPage.title);
                    if (liveResults && liveResults.length > 0) {
                        return { 
                            type: 'pages', 
                            pages: liveResults,
                            message: `××¦××ª×™ ××ª ×”××™×“×¢ ×¢×œ ${liveResults[0].title}`,
                            needsPreview: false // Don't show preview for follow-up questions
                        };
                    }
                }
                
                // If it's a price query about watches but no context, search for watches
                if (isPriceQuery && /×©×¢×˜× ×™×|×©×¢×•× ×™×/i.test(userMessage) && !lastMentionedPage) {
                    console.log('ğŸ’° Price query about watches detected - searching for watches');
                    const liveResults = await searchLivePages('×©×¢×•×Ÿ');
                    if (liveResults && liveResults.length > 0) {
                        return { 
                            type: 'pages', 
                            pages: liveResults,
                            message: `××¦××ª×™ ${liveResults.length} ×“×¤×™× ×¢× ×©×¢×•× ×™×`,
                            needsPreview: false
                        };
                    }
                }
                
                // âš ï¸ IMPORTANT: Don't send product/store queries to N8N - they invent data!
                // Check if query is about products in a specific store or general product query
                // But be more specific - only count as marketplace query if it's clearly about marketplace
                const storeProductPattern = /(?:×”××•×¦×¨×™×|××•×¦×¨×™×|××” ×™×©|××” ×™×© ×œ|××” ××•×›×¨×™×|××™×–×” ××•×¦×¨×™×)\s*(?:×‘|×‘×—× ×•×ª|×‘×—× ×•×ª|×©×œ)\s*([×-×ªa-zA-Z]+)/i;
                const storeProductMatch = userMessage.match(storeProductPattern);
                
                // Only consider it a product query if it's clearly about marketplace items
                // Exclude general questions like "××” ×–×” ××•×¦×¨?" which should go to N8N
                // Check for general question patterns first
                const isGeneralQuestion = /^××”\s+(×–×”|×¤×™×¨×•×©|××©××¢×•×ª)/.test(userMessage.trim()) || 
                                         /^××™×š\s+×œ/.test(userMessage.trim()) ||
                                         /^×œ××”|^××“×•×¢/.test(userMessage.trim());
                
                // ğŸ¯ IMPROVED: Check if the query matches any page in the marketplace
                // This allows single-word queries like "× ×’×¨", "×œ×§", "×¦×¢×¦×•×¢×™×" to be recognized as marketplace queries
                let matchesPageInMarketplace = false;
                const cleanQuery = lowerMessage.trim();
                
                console.log('ğŸ” [MARKETPLACE CHECK] cleanQuery:', cleanQuery, 'length:', cleanQuery.length, 'isGeneralQuestion:', isGeneralQuestion);
                console.log('ğŸ” [MARKETPLACE CHECK] allPages count:', allPages?.length || 0);
                
                // If query is a single word or short phrase (not a question), check if it matches pages
                if (!isGeneralQuestion && cleanQuery.length > 1 && cleanQuery.length < 30) {
                    // Check if query matches any page title, description, or product name
                    for (const page of (allPages || [])) {
                        const pageTitle = (page.title || '').toLowerCase();
                        const pageDesc = (page.description || '').toLowerCase();
                        const pageProducts = (page.products || []).map(p => (p.name || '').toLowerCase()).join(' ');
                        
                        // ğŸ¯ IMPROVED: Check word-by-word matching
                        // Extract words from query (removing "×‘" prefix for city queries like "× ×’×¨ ×‘× ×ª× ×™×”")
                        const queryWords = cleanQuery.split(/\s+/)
                            .map(w => w.replace(/^×‘/, '').replace(/^×©×œ/, '').replace(/^×”/, '')) // Remove leading ×‘, ×©×œ, or ×”
                            .filter(w => w.length > 1); // Keep words with at least 2 chars
                        
                        // Check if any query word matches title/description/products
                        const hasMatch = queryWords.some(word => 
                            pageTitle.includes(word) || 
                            pageDesc.includes(word) || 
                            pageProducts.includes(word)
                        ) || pageTitle.includes(cleanQuery) || 
                           pageDesc.includes(cleanQuery) || 
                           pageProducts.includes(cleanQuery) ||
                           cleanQuery.includes(pageTitle.split(' ')[0]); // Check if query matches first word of title
                        
                        if (hasMatch) {
                            matchesPageInMarketplace = true;
                            console.log(`âœ… [MARKETPLACE CHECK] Query "${cleanQuery}" matches page "${page.title}" - treating as marketplace query`);
                            console.log(`âœ… [MARKETPLACE CHECK] queryWords:`, queryWords);
                            break;
                        }
                    }
                    
                    if (!matchesPageInMarketplace) {
                        console.log(`âŒ [MARKETPLACE CHECK] Query "${cleanQuery}" does NOT match any pages`);
                    }
                }
                
                // ğŸ¯ FIX: Make search more focused - exclude vague queries like "××” ×©" or single letters
                const isVagueQuery = cleanQuery.length <= 2 || 
                                     cleanQuery === '××” ×©' || 
                                     cleanQuery === '××”' ||
                                     cleanQuery === '×©' ||
                                     /^[×-×ª]\s*$/.test(cleanQuery); // Single Hebrew letter
                
                const isProductQuery = !isGeneralQuestion && !isVagueQuery && (
                    matchesPageInMarketplace || // NEW: If query matches a page, it's a marketplace query
                    // ğŸ¯ FIX: Also catch "××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ" / "××” ×”××•×¦×¨ ×”×›×™ ×™×§×¨" / "××” ×”××ª× ×” ×”×›×™ ×–×•×œ×”" variations
                    lowerMessage.includes('××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ') || lowerMessage.includes('××” ×”××•×¦×¨ ×”×›×™ ×™×§×¨') ||
                    lowerMessage.includes('××” ×”××ª× ×” ×”×›×™ ×–×•×œ×”') || lowerMessage.includes('××” ×”××ª× ×” ×”×›×™ ×™×§×¨×”') ||
                    lowerMessage.includes('×”××•×¦×¨ ×”×›×™ ×–×•×œ') || lowerMessage.includes('×”××•×¦×¨ ×”×›×™ ×™×§×¨') ||
                    lowerMessage.includes('×”××ª× ×” ×”×›×™ ×–×•×œ×”') || lowerMessage.includes('×”××ª× ×” ×”×›×™ ×™×§×¨×”') ||
                    (lowerMessage.includes('××•×¦×¨') && (lowerMessage.includes('×™×©') || lowerMessage.includes('××•×›×¨') || lowerMessage.includes('×—× ×•×ª') || lowerMessage.includes('×“×£'))) ||
                    (lowerMessage.includes('××ª× ×”') && (lowerMessage.includes('×™×©') || lowerMessage.includes('××•×›×¨') || lowerMessage.includes('×—× ×•×ª') || lowerMessage.includes('×“×£') || lowerMessage.includes('×–×•×œ×”') || lowerMessage.includes('×–×•×œ'))) ||
                    (lowerMessage.includes('×©×¢×•×Ÿ') && (lowerMessage.includes('×™×©') || lowerMessage.includes('××—×™×¨') || lowerMessage.includes('×—× ×•×ª'))) ||
                    (lowerMessage.includes('×¦×¢×¦×•×¢') && (lowerMessage.includes('×™×©') || lowerMessage.includes('××—×™×¨') || lowerMessage.includes('×—× ×•×ª'))) ||
                    (lowerMessage.includes('×œ×§') && (lowerMessage.includes('×™×©') || lowerMessage.includes('××—×™×¨') || lowerMessage.includes('×©×™×¨×•×ª'))) ||
                    // ğŸ¯ FIX: Add service providers - ××™× ×¡×˜×œ×˜×•×¨, × ×’×¨, etc. (with or without city)
                    lowerMessage.includes('××™× ×¡×˜×œ×˜×•×¨') || lowerMessage.includes('××™× ×˜×œ×˜×•×¨') || // Handle typo "××™× ×˜×œ×˜×•×¨"
                    lowerMessage.includes('× ×’×¨') || lowerMessage.includes('× ×’×¨×•×ª') ||
                    lowerMessage.includes('×—×©××œ××™') || lowerMessage.includes('××××Ÿ') || lowerMessage.includes('×××× ×ª') ||
                    lowerMessage.includes('×§×•×¡××˜×™×§××™×ª') || lowerMessage.includes('××¡×¤×¨×”') ||
                    lowerMessage.includes('×¦×œ×') || lowerMessage.includes('×¦×™×œ×•×') ||
                    lowerMessage.includes('× ×™×§×™×•×Ÿ') || lowerMessage.includes('×‘×™×‘×™×¡×™×˜×¨') ||
                    lowerMessage.includes('×—× ×•×ª') ||
                    lowerMessage.includes('××¨×§×˜×¤×œ×™×™×¡') ||
                    lowerMessage.includes('× ×•×ª×Ÿ ×©×™×¨×•×ª') ||
                    lowerMessage.includes('×‘×¢×œ ××§×¦×•×¢') ||
                    // NEW: Common marketplace terms - single words that likely refer to services/products (but not too vague)
                    (cleanQuery.length >= 3 && /^(× ×’×¨|× ×’×¨×•×ª|××™× ×¡×˜×œ×˜×•×¨|××™× ×˜×œ×˜×•×¨|×œ×§|×× ×™×§×•×¨|×¤×“×™×§×•×¨|×¦×¢×¦×•×¢|×¦×¢×¦×•×¢×™×|×©×¢×•×Ÿ|×©×¢×•× ×™×|×§×•×¨×¡|×§×•×¨×¡×™×|×—× ×•×ª|×¢×¡×§|×©×™×¨×•×ª|××•×¦×¨|××ª× ×”|×—×©××œ××™|××××Ÿ|×××× ×ª|×§×•×¡××˜×™×§××™×ª|××¡×¤×¨×”|×¦×œ×|× ×™×§×™×•×Ÿ|×‘×™×‘×™×¡×™×˜×¨|×œ×’×•)$/.test(cleanQuery))
                );
                
                console.log('ğŸ¯ [DECISION] isProductQuery:', isProductQuery, '| matchesPageInMarketplace:', matchesPageInMarketplace, '| includes × ×’×¨:', lowerMessage.includes('× ×’×¨'));
                
                // Check if query is about specific store/business info (phone, city, etc.)
                const businessInfoPatterns = [
                    /(?:××”|××™×–×”)\s*(?:×”×˜×œ×¤×•×Ÿ|×”×›×ª×•×‘×ª|×”×¢×™×¨|×”××™×™×œ)\s*(?:×©×œ|×‘)\s*([×-×ªa-zA-Z]+)/i,
                    /(?:×‘××™×–×”|××™×¤×”)\s+(?:×¢×™×¨|××™×§×•×)\s+(?:×”×—× ×•×ª|×”×¢×¡×§|×”×“×£)\s*([×-×ªa-zA-Z]+)/i
                ];
                let requestedBusiness = null;
                for (const pattern of businessInfoPatterns) {
                    const match = userMessage.match(pattern);
                    if (match && match[1]) {
                        requestedBusiness = match[1].trim();
                        console.log('ğŸª Business info query detected for:', requestedBusiness);
                        break;
                    }
                }
                
                // ğŸ¯ FIX: Handle "××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ" / "××” ×”××•×¦×¨ ×”×›×™ ×™×§×¨" locally - don't send to N8N!
                // BUT: "×¨×©×™××ª ××—×™×¨×™×" / "×¨×©×™××ª ××•×¦×¨×™×" / "×ª×¨××™ ××•×¦×¨×™×" SHOULD show price list!
                const isPriceListQuery = lowerMessage.includes('×¨×©×™××ª ××—×™×¨×™×') || lowerMessage.includes('×¨×©×™××ª ××•×¦×¨×™×') ||
                                         lowerMessage.includes('×ª×¨××™ ××•×¦×¨×™×') || lowerMessage.includes('×ª×¨××™ ××—×™×¨×™×') ||
                                         lowerMessage.includes('××•×¦×¨×™× ×•××—×™×¨×™×') || lowerMessage.includes('××•×¦×¨×™× ××—×™×¨×™×') ||
                                         (lowerMessage.includes('×ª×¨××™') && (lowerMessage.includes('××•×¦×¨') || lowerMessage.includes('××—×™×¨'))) ||
                                         lowerMessage.includes('×”×¨××™ ××•×¦×¨×™×') || lowerMessage.includes('×”×¨××™ ××—×™×¨×™×') ||
                                         lowerMessage.includes('×¨×©×™××” ×©×œ ××•×¦×¨×™×') || lowerMessage.includes('×¨×©×™××” ×©×œ ××—×™×¨×™×') ||
                                         lowerMessage.includes('×ª× ×™ ×¨×©×™××ª') || lowerMessage.includes('×ª× ×™ ×œ×™ ×¨×©×™××ª') ||
                                         lowerMessage.includes('×ª× ×™ ××ª ×¨×©×™××ª') || lowerMessage.includes('×›×œ ×”××•×¦×¨×™×') ||
                                         /(?:×”)?(?:××—×™×¨×™×|×™×©\s+××—×™×¨×™×)\s+×©×œ\s+([×-×ª\s]{2,20})/.test(userMessage); // "××—×™×¨×™× ×©×œ ×¦×¢×¦×•×¢×™×" OR "×”××—×™×¨×™× ×©×œ ×¦×¢×¦×•×¢×™×"
                
                // ğŸ¯ NEW: Extract category from "××—×™×¨×™× ×©×œ X" or "×”××—×™×¨×™× ×©×œ X" query
                let priceListCategory = null;
                if (isPriceListQuery) {
                    const categoryMatch = userMessage.match(/(?:×”)?(?:××—×™×¨×™×|×™×©\s+××—×™×¨×™×)\s+×©×œ\s+([×-×ª\s]{2,20})/i);
                    if (categoryMatch && categoryMatch[1]) {
                        priceListCategory = categoryMatch[1].trim();
                        console.log(`ğŸ“‹ Price list query for category: "${priceListCategory}"`);
                    }
                    
                    // ğŸ¯ SPECIAL: If user asks for product list and we have pages in context, show products from those pages
                    const asksForProductListOfCurrentContext = /×ª× ×™.*×¨×©×™××ª|×ª× ×™.*××ª.*×¨×©×™××ª|×¨×©×™××ª.*××•×¦×¨×™×.*×‘|××•×¦×¨×™×.*×‘×—× ×•×ª|×‘×—× ×•×ª.*×”×–××ª|×‘××ª×¨.*×”×–×”/i.test(userMessage);
                    if (asksForProductListOfCurrentContext && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                        console.log('ğŸ“‹ User asking for product list from current context pages');
                        const textResponse = await generateTextResponseWithRealData(window.stavCurrentPages, userMessage, false);
                        return {
                            type: 'text',
                            message: textResponse
                        };
                    }
                }
                
                // ğŸ¯ NEW: Handle "×©×¢×•× ×™× ×¢×“ 2000×©" / "××•×¦×¨×™× ×¢×“ X ×©×§×œ" queries - filter by max price
                const maxPricePattern = /(?:×¢×“|×¢×“\s+)?(\d+)\s*(?:×©|×©×§×œ|×©"×—|â‚ª)/i;
                const maxPriceMatch = userMessage.match(maxPricePattern);
                const maxPrice = maxPriceMatch ? parseFloat(maxPriceMatch[1]) : null;
                
                // ğŸ¯ NEW: Handle "××” ×”××—×™×¨ ×©×œ X" or "××—×™×¨ ×©×œ X" queries locally - find specific product and return price
                // BUT: Skip if it's "××—×™×¨×™× ×©×œ X" (plural) - that's a price list query!
                const isGeneralPriceListQuery = /××—×™×¨×™×\s+×©×œ|×™×©\s+××—×™×¨×™×/.test(userMessage);
                const specificProductPricePattern = /(?:××”|××™×–×”)?\s*(?:×”××—×™×¨|××—×™×¨|×”××—×™×¨ ×©×œ)\s*(?:×©×œ|×‘)?\s*([×-×ª\s]{3,30})/i;
                const specificProductPriceMatch = !isGeneralPriceListQuery ? userMessage.match(specificProductPricePattern) : null;
                
                // ğŸ¯ NEW: Also handle "××—×™×¨ ×©×œ X ×”×›×™ ×–×•×œ" queries
                const cheapestProductPricePattern = /(?:××”|××™×–×”)?\s*(?:×”××—×™×¨|××—×™×¨)\s*(?:×©×œ|×‘)?\s*([×-×ª\s]{3,30})\s*(?:×”×›×™\s*×–×•×œ|×”×›×™\s*×–×•×œ×”)/i;
                const cheapestProductPriceMatch = userMessage.match(cheapestProductPricePattern);
                
                // Handle "××—×™×¨ ×©×œ X ×”×›×™ ×–×•×œ" - find cheapest product matching the category
                if (cheapestProductPriceMatch && cheapestProductPriceMatch[1]) {
                    const categoryName = cheapestProductPriceMatch[1].trim();
                    console.log(`ğŸ’° Cheapest product in category query detected: "${categoryName}"`);
                    
                    // Search all store pages for products in this category
                    const storePages = (allPages || []).filter(page => page.pageType === 'store');
                    let allProducts = [];
                    
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            const liveProducts = extractLiveProducts(html);
                            
                            // Check if page title or products match the category
                            const pageTitleLower = (page.title || '').toLowerCase();
                            const categoryNameLower = categoryName.toLowerCase();
                            
                            if (pageTitleLower.includes(categoryNameLower) || categoryNameLower.includes(pageTitleLower)) {
                                liveProducts.forEach(product => {
                                    const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                    if (price >= 10 && price < 100000) {
                                        allProducts.push({
                                            ...product,
                                            pageTitle: page.title,
                                            pageUrl: pageUrl,
                                            userId: page.userId,
                                            pageId: page.pageId
                                        });
                                    }
                                });
                            } else {
                                // Check if products match the category
                                for (const product of liveProducts) {
                                    const productNameLower = (product.name || '').toLowerCase();
                                    if (productNameLower.includes(categoryNameLower) || categoryNameLower.includes(productNameLower.split(' ')[0])) {
                                        const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                        if (price >= 10 && price < 100000) {
                                            allProducts.push({
                                                ...product,
                                                pageTitle: page.title,
                                                pageUrl: pageUrl,
                                                userId: page.userId,
                                                pageId: page.pageId
                                            });
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('Error searching for product:', error);
                        }
                    }
                    
                    if (allProducts.length > 0) {
                        // Sort by price and get cheapest
                        allProducts.sort((a, b) => {
                            const priceA = parseFloat(String(a.price || 0).replace(/[,\s]/g, ''));
                            const priceB = parseFloat(String(b.price || 0).replace(/[,\s]/g, ''));
                            return priceA - priceB;
                        });
                        
                        const cheapest = allProducts[0];
                        const price = parseFloat(String(cheapest.price || 0).replace(/[,\s]/g, ''));
                        
                        return {
                            type: 'message',
                            message: `ğŸ’° **${cheapest.name}** ×‘-${cheapest.pageTitle} ×¢×•×œ×” **â‚ª${price.toLocaleString()}**\n\n×–×” ×”×¦×¢×¦×•×¢ ×”×›×™ ×–×•×œ ×‘×§×˜×’×•×¨×™×” "${categoryName}"\n\nğŸ”— [×¦×¤×” ×‘×“×£](${cheapest.pageUrl})`
                        };
                    } else {
                        return {
                            type: 'message',
                            message: `××¦×˜×¢×¨, ×œ× ××¦××ª×™ ×¦×¢×¦×•×¢×™× ×‘×§×˜×’×•×¨×™×” "${categoryName}" ×‘××¢×¨×›×ª.`
                        };
                    }
                }
                
                if (specificProductPriceMatch && specificProductPriceMatch[1]) {
                    const productName = specificProductPriceMatch[1].trim();
                    console.log(`ğŸ’° Specific product price query detected: "${productName}"`);
                    
                    // Search all store pages for this specific product
                    const storePages = (allPages || []).filter(page => page.pageType === 'store');
                    let foundProduct = null;
                    let foundPage = null;
                    
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            const liveProducts = extractLiveProducts(html);
                            
                            // Find product that matches the query - improved matching for partial names
                            const productNameLower = productName.toLowerCase().trim();
                            // Remove common words that might interfere
                            const cleanProductName = productNameLower.replace(/\s+(×©×œ|×‘|××‘×œ|××|××•|×¢×)\s+/g, ' ').trim();
                            
                            for (const product of liveProducts) {
                                const productNameLower2 = (product.name || '').toLowerCase().trim();
                                
                                // Check exact match
                                if (productNameLower2 === productNameLower || productNameLower2 === cleanProductName) {
                                    const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                    if (price >= 10 && price < 100000) {
                                        foundProduct = product;
                                        foundPage = page;
                                        break;
                                    }
                                }
                                
                                // Check if query contains all key words from product name (flexible matching)
                                const productWords = productNameLower2.split(/\s+/).filter(w => w.length >= 2);
                                const queryWords = cleanProductName.split(/\s+/).filter(w => w.length >= 2);
                                
                                // If query contains 2+ words and most of them match product
                                if (queryWords.length >= 2) {
                                    const matchingWords = queryWords.filter(qw => 
                                        productWords.some(pw => pw.includes(qw) || qw.includes(pw))
                                    );
                                    // If at least 50% of query words match, or if all key words match
                                    if (matchingWords.length >= Math.min(2, queryWords.length) || 
                                        (queryWords.length >= 3 && matchingWords.length >= Math.ceil(queryWords.length * 0.5))) {
                                        const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                        if (price >= 10 && price < 100000) {
                                            foundProduct = product;
                                            foundPage = page;
                                            break;
                                        }
                                    }
                                }
                                
                                // Check if product name includes query or vice versa (partial match)
                                // Also handle typos/variations like "××¨×•×¥" vs "××™×¨×•×¥"
                                const normalizedProductName = productNameLower2.replace(/××™×¨×•×¥|××¨×•×¥/g, '××™×¨×•×¥').replace(/××™×¨×•×¥/g, '××™×¨×•×¥');
                                const normalizedQuery = productNameLower.replace(/××™×¨×•×¥|××¨×•×¥/g, '××™×¨×•×¥').replace(/××™×¨×•×¥/g, '××™×¨×•×¥');
                                
                                if (normalizedProductName.includes(normalizedQuery) || normalizedQuery.includes(normalizedProductName) ||
                                    productNameLower2.includes(productNameLower) || productNameLower.includes(productNameLower2)) {
                                    const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                    if (price >= 10 && price < 100000) {
                                        foundProduct = product;
                                        foundPage = page;
                                        break;
                                    }
                                }
                            }
                            if (foundProduct) break;
                        } catch (error) {
                            console.error('Error searching for product:', error);
                        }
                    }
                    
                    if (foundProduct && foundPage) {
                        const price = parseFloat(String(foundProduct.price || 0).replace(/[,\s]/g, ''));
                        const pageUrl = `/users/${foundPage.userId}/${foundPage.pageId}_html`;
                        return {
                            type: 'message',
                            message: `ğŸ’° **${foundProduct.name}** ×‘-${foundPage.title} ×¢×•×œ×” **â‚ª${price.toLocaleString()}**\n\nğŸ”— [×¦×¤×” ×‘×“×£](${pageUrl})`
                        };
                    } else {
                        return {
                            type: 'message',
                            message: `××¦×˜×¢×¨, ×œ× ××¦××ª×™ ××ª ×”××•×¦×¨ "${productName}" ×‘××¢×¨×›×ª. × ×¡×” ×œ×—×¤×© ×‘××•×¤×Ÿ ××—×¨.`
                        };
                    }
                }
                
                // ğŸ¯ FIX: Handle "××” ×”×¦×¢×¦×•×¢ ×”×›×™ ×–×•×œ" / "×©×¢×•×Ÿ ×”×›×™ ×–×•×œ" / "××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ" / "××” ×”××ª× ×” ×”×›×™ ×–×•×œ×”" - return DIRECT answer!
                // Also handle simple queries like "×©×¢×•×Ÿ ×”×›×™ ×–×•×œ" or "×¦×¢×¦×•×¢ ×”×›×™ ×–×•×œ" or "××ª× ×”" (without "××”")
                if ((lowerMessage.includes('××” ×”×¦×¢×¦×•×¢ ×”×›×™ ×–×•×œ') || lowerMessage.includes('××” ×”×¦×¢×¦×•×¢ ×”×›×™ ×™×§×¨') ||
                    lowerMessage.includes('××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ') || lowerMessage.includes('××” ×”××•×¦×¨ ×”×›×™ ×™×§×¨') ||
                    lowerMessage.includes('××” ×”××ª× ×” ×”×›×™ ×–×•×œ×”') || lowerMessage.includes('××” ×”××ª× ×” ×”×›×™ ×™×§×¨×”') ||
                    lowerMessage.includes('×”×¦×¢×¦×•×¢ ×”×›×™ ×–×•×œ') || lowerMessage.includes('×”×¦×¢×¦×•×¢ ×”×›×™ ×™×§×¨') ||
                    lowerMessage.includes('×”××•×¦×¨ ×”×›×™ ×–×•×œ') || lowerMessage.includes('×”××•×¦×¨ ×”×›×™ ×™×§×¨') ||
                    lowerMessage.includes('×”××ª× ×” ×”×›×™ ×–×•×œ×”') || lowerMessage.includes('×”××ª× ×” ×”×›×™ ×™×§×¨×”') ||
                    lowerMessage.includes('×©×¢×•×Ÿ ×”×›×™ ×–×•×œ') || lowerMessage.includes('×©×¢×•×Ÿ ×”×›×™ ×™×§×¨') ||
                    lowerMessage.includes('×œ×§ ×”×›×™ ×–×•×œ') || lowerMessage.includes('×œ×§ ×”×›×™ ×™×§×¨') ||
                    (lowerMessage.includes('×”×›×™ ×–×•×œ') && (lowerMessage.includes('××•×¦×¨') || lowerMessage.includes('××ª× ×”') || lowerMessage.includes('×¦×¢×¦×•×¢') || lowerMessage.includes('×©×¢×•×Ÿ') || lowerMessage.includes('×œ×§'))) ||
                    (lowerMessage.includes('×”×›×™ ×™×§×¨') && (lowerMessage.includes('××•×¦×¨') || lowerMessage.includes('××ª× ×”') || lowerMessage.includes('×¦×¢×¦×•×¢') || lowerMessage.includes('×©×¢×•×Ÿ') || lowerMessage.includes('×œ×§')))) &&
                    !isPriceListQuery) { // Don't handle locally if it's a "list prices" query
                    console.log('ğŸ’° Price comparison query detected - handling locally, NOT sending to N8N!');
                    
                    // Search all store pages for products
                    const storePages = (allPages || []).filter(page => page.pageType === 'store');
                    let allProducts = [];
                    
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            const liveProducts = extractLiveProducts(html);
                            
                            liveProducts.forEach(product => {
                                allProducts.push({
                                    ...product,
                                    pageTitle: page.title,
                                    pageUrl: pageUrl,
                                    userId: page.userId,
                                    pageId: page.pageId
                                });
                            });
                        } catch (error) {
                            console.error('Error extracting products from', pageUrl, ':', error);
                        }
                    }
                    
                    if (allProducts.length > 0) {
                        // ğŸ¯ FIX: Filter out invalid products (questions, taglines, etc.)
                        // Define exclude patterns (same as in extractLiveProducts)
                        const excludePatterns = [
                            '× ×’×™×©×•×ª', '××•×“×•×ª', '×¦×•×¨ ×§×©×¨', '×“×£ ×”×‘×™×ª', '×¢×œ×™× ×•', '×ª×§× ×•×Ÿ', '××“×™× ×™×•×ª', 
                            '×¤×¨×˜×™×•×ª', '×ª× ××™×', '×©×™×¨×•×ª', '××©×œ×•×—×™×', '×”×—×–×¨×•×ª', '××™×š ×œ×”×–××™×Ÿ',
                            '×’×œ×¨×™', '×”××•×¦×¨×™×', '×ª×™××•×¨', '×”××™×•×—×“×™×', '×”×›×œ ×¢×œ', '×›×œ ×”×–×›×•×™×•×ª',
                            '×–×›×•×™×•×ª ×™×•×¦×¨×™×', '×‘×¨×•×›×™× ×”×‘××™×', '×œ×§×•×—×•×ª', '×©××œ×•×ª', '×ª×©×•×‘×•×ª',
                            '××•×¦×¨×™× ×©×œ× ×•', '×”××•×¦×¨×™× ×©×œ× ×•', '×ª×¤×¨×™×˜', '×›×•×ª×¨×ª', '×›×•×ª×¨×ª ×¨××©×™×ª',
                            '×œ××”', '×œ××” ×œ×‘×—×•×¨', '×œ××” ×œ×‘×—×•×¨ ×‘', '×œ××” ×œ×‘×—×•×¨ ×‘×¨×•×‘×•×˜×™×',
                            '××™×š', '××™×š ×œ', '×›×™×¦×“', '××“×•×¢', '××” ×”×™×ª×¨×•× ×•×ª', '××” ×”×™×ª×¨×•×Ÿ',
                            // ğŸ¯ NEW: Exclude accessibility/design options that are NOT real products
                            '× ×™×’×•×“×™×•×ª', '×’×•×¤×Ÿ', '×§×¨×™×', '×”×“×’×©', '×§×™×©×•×¨×™×', '×¨×™×•×•×—', '×©×•×¨×•×ª', 
                            '××•×’×‘×¨', '×¡××Ÿ', '×’×“×•×œ', '×¢×¦×•×¨', '×× ×™××¦×™×•×ª', '×ª×¦×•×’×”', '×’×“×œ×”',
                            '×’×“×œ×ª', '×§×˜× ×”', '×§×˜× ×ª', '×’×•×¤×Ÿ ×’×“×•×œ', '×’×•×¤×Ÿ ×§×˜×Ÿ', '× ×™×’×•×“×™×•×ª ×’×‘×•×”×”',
                            '× ×™×’×•×“×™×•×ª × ××•×›×”', '×’×•×¤×Ÿ ×§×¨×™×', '×’×•×¤×Ÿ ×’×“×•×œ', '×’×•×¤×Ÿ ×§×˜×Ÿ'
                        ].filter(Boolean);
                        
                        const excludePhrases = [
                            /×–××Ÿ\s+(×–×•|×–×”)\s+××•×× ×•×ª/,
                            /.*××•×× ×•×ª.*/,
                            /.*×—×•×•×™×”.*/,
                            /.*×¡×˜×’× ×¡.*/,
                            /.*××•×©×œ×.*/,
                            /^×˜×•×”×¨$/,
                            /^×™×•×¤×™$/,
                            /^××™×›×•×ª$/,
                            /^×”×©×¨××”$/,
                            /^×—×œ×•×$/,
                            /^×××ª$/,
                            /^× ×©××”$/,
                            /^×œ××”.*/,
                            /.*×œ××”.*×‘×—×•×¨.*/,
                            /.*×œ××”.*×¨×•×‘×•×˜.*/,
                            /.*\?$/,
                        ];
                        
                        const validProducts = allProducts.filter(product => {
                            const name = product.name || '';
                            // Exclude questions, taglines, etc.
                            const isQuestion = name.includes('?') || name.includes('×œ××”') || 
                                               name.includes('××™×š') || name.match(/^×œ××”\s+.*/) ||
                                               name.includes('×œ××” ×œ×‘×—×•×¨') || name.includes('×œ××” ×œ×‘×—×•×¨ ×‘');
                            const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                            const isExcluded = excludePatterns.some(pattern => 
                                name.toLowerCase().includes(pattern.toLowerCase())
                            );
                            
                            // Must have valid price (>= 10, not 2, 3, 5, 7 which are likely not product prices)
                            const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                            // ğŸ¯ FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                            // Only accept prices >= 10 (real product prices like â‚ª10, â‚ª60, â‚ª75)
                            const hasValidPrice = price >= 10 && price < 100000 && !isNaN(price);
                            
                            // Must have valid name (not question, not excluded, reasonable length)
                            const hasValidName = name.length >= 3 && name.length <= 100 && 
                                               !isQuestion && !matchesExcludedPhrase && !isExcluded &&
                                               name.match(/[×-×ª]/); // Must contain Hebrew
                            
                            return hasValidName && hasValidPrice;
                        });
                        
                        console.log(`âœ… Filtered products: ${validProducts.length} valid out of ${allProducts.length} total`);
                        console.log(`ğŸ” Valid products:`, validProducts.map(p => `${p.name} - â‚ª${p.price}`));
                        
                        if (validProducts.length === 0) {
                            return { type: 'message', message: '××¦×˜×¢×¨, ×œ× ××¦××ª×™ ××™×“×¢ ×¢×œ ××•×¦×¨×™× ×–××™× ×™× ×›×¨×’×¢ ×‘××¨×§×˜×¤×œ×™×™×¡.' };
                        }
                        
                        // ğŸ¯ FIX: Filter products by category if query specifies category (e.g., "××” ×”×¦×¢×¦×•×¢ ×”×›×™ ×–×•×œ", "×©×¢×•×Ÿ ×”×›×™ ×–×•×œ")
                        let filteredProducts = validProducts;
                        
                        // Filter by toy category
                        if (lowerMessage.includes('×¦×¢×¦×•×¢')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                return pageTitle.includes('×¦×¢×¦×•×¢') || productName.includes('×¦×¢×¦×•×¢') || 
                                       productName.includes('××›×•× ×™×ª') || productName.includes('×‘×•×‘×”') ||
                                       productName.includes('×§×•×‘×™×™×”') || productName.includes('××©×—×§') ||
                                       productName.includes('×¨×›×‘×ª') || productName.includes('×“×™× ×•×–××•×¨');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        // Filter by watch category - handle "×¨×§ ×©×¢×•×Ÿ" / "×©×¢×•×Ÿ ×‘×œ×‘×“" queries
                        else if (lowerMessage.includes('×©×¢×•×Ÿ') || lowerMessage.includes('×¨×§ ×©×¢×•×Ÿ') || lowerMessage.includes('×©×¢×•×Ÿ ×‘×œ×‘×“')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                
                                // For "×¨×§ ×©×¢×•×Ÿ" - be very strict, only watches!
                                if (lowerMessage.includes('×¨×§ ×©×¢×•×Ÿ') || lowerMessage.includes('×©×¢×•×Ÿ ×‘×œ×‘×“') || lowerMessage.includes('×¨×§ ×©×¢×•× ×™×')) {
                                    // Only accept pages with "×©×¢×•×Ÿ" in title OR products with "×©×¢×•×Ÿ" in name
                                    // Exclude everything else (toys, etc.)
                                    return (pageTitle.includes('×©×¢×•×Ÿ') && !pageTitle.includes('×¦×¢×¦×•×¢')) || 
                                           (productName.includes('×©×¢×•×Ÿ') && !productName.includes('×¦×¢×¦×•×¢'));
                                }
                                
                                // Regular "×©×¢×•×Ÿ" query - accept watches
                                return pageTitle.includes('×©×¢×•×Ÿ') || productName.includes('×©×¢×•×Ÿ');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        // Filter by nail polish category
                        else if (lowerMessage.includes('×œ×§')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                return pageTitle.includes('×œ×§') || productName.includes('×œ×§') ||
                                       productName.includes('×× ×™×§×•×¨') || productName.includes('×¤×“×™×§×•×¨');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        // Filter by gift/present category - exclude services (like barber shop, numbera)
                        else if (lowerMessage.includes('××ª× ×”')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                
                                // Exclude services (××¡×¤×¨×”, ×©×™×¨×•×ª×™×)
                                if (pageTitle.includes('××¡×¤×¨×”') || pageTitle.includes('×©×™×¨×•×ª') || 
                                    productName.includes('××¡×¤×¨×”') || productName.includes('×©×™×¨×•×ª')) {
                                    return false;
                                }
                                
                                // Include gift-worthy products: toys, watches, jewelry, etc.
                                return pageTitle.includes('×¦×¢×¦×•×¢') || pageTitle.includes('×©×¢×•×Ÿ') || 
                                       pageTitle.includes('×ª×›×©×™×˜') || pageTitle.includes('××ª× ×”') ||
                                       productName.includes('×¦×¢×¦×•×¢') || productName.includes('×©×¢×•×Ÿ') ||
                                       productName.includes('×ª×›×©×™×˜') || productName.includes('××›×•× ×™×ª') ||
                                       productName.includes('×‘×•×‘×”') || productName.includes('×§×•×‘×™×™×”') ||
                                       productName.includes('×¨×›×‘×ª') || productName.includes('×“×™× ×•×–××•×¨');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        
                        // ğŸ¯ NEW: Filter by max price if query specifies "×¢×“ X ×©×§×œ" (e.g., "×©×¢×•× ×™× ×¢×“ 2000×©")
                        if (maxPrice !== null && maxPrice > 0) {
                            console.log(`ğŸ” Filtering products by max price: â‚ª${maxPrice}`);
                            const beforeCount = filteredProducts.length;
                            filteredProducts = filteredProducts.filter(product => {
                                const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                return price <= maxPrice;
                            });
                            console.log(`âœ… Filtered ${filteredProducts.length} products (from ${beforeCount}) under â‚ª${maxPrice}`);
                            
                            // If query includes category word, keep filtering by category
                            if (lowerMessage.includes('×©×¢×•×Ÿ')) {
                                filteredProducts = filteredProducts.filter(product => {
                                    const pageTitle = (product.pageTitle || '').toLowerCase();
                                    const productName = (product.name || '').toLowerCase();
                                    return pageTitle.includes('×©×¢×•×Ÿ') || productName.includes('×©×¢×•×Ÿ');
                                });
                            }
                        }
                        
                        // Sort by price
                        filteredProducts.sort((a, b) => {
                            const priceA = parseFloat(String(a.price).replace(/[,\s]/g, ''));
                            const priceB = parseFloat(String(b.price).replace(/[,\s]/g, ''));
                            return priceA - priceB;
                        });
                        
                        if (filteredProducts.length === 0) {
                            return { type: 'message', message: '××¦×˜×¢×¨, ×œ× ××¦××ª×™ ××™×“×¢ ×¢×œ ××•×¦×¨×™× ×–××™× ×™× ×›×¨×’×¢ ×‘××¨×§×˜×¤×œ×™×™×¡.' };
                        }
                        
                        const cheapest = filteredProducts[0];
                        const mostExpensive = filteredProducts[filteredProducts.length - 1];
                        const cleanPageTitle = cheapest.pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                        const fullPageUrl = `${window.location.origin}${cheapest.pageUrl}`;
                        
                        let response = '';
                        
                        // ğŸ¯ NEW: Handle "×¢×“ X ×©×§×œ" queries (e.g., "×©×¢×•× ×™× ×¢×“ 2000×©")
                        if (maxPrice !== null && maxPrice > 0) {
                            if (filteredProducts.length === 0) {
                                return { 
                                    type: 'message', 
                                    message: `××¦×˜×¢×¨, ×œ× ××¦××ª×™ ${lowerMessage.includes('×©×¢×•×Ÿ') ? '×©×¢×•× ×™×' : '××•×¦×¨×™×'} ×¢×“ â‚ª${maxPrice.toLocaleString()} ×‘××¨×§×˜×¤×œ×™×™×¡.`
                                };
                            }
                            
                            // Show all products under max price, sorted by price
                            response = `ğŸ’° **××¦××ª×™ ${filteredProducts.length} ${lowerMessage.includes('×©×¢×•×Ÿ') ? '×©×¢×•× ×™×' : '××•×¦×¨×™×'} ×¢×“ â‚ª${maxPrice.toLocaleString()}:**\n\n`;
                            filteredProducts.slice(0, 10).forEach((product, idx) => {
                                const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                const productPageTitle = product.pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                                const productPageUrl = `${window.location.origin}${product.pageUrl}`;
                                response += `${idx + 1}. **${product.name}** ×‘-${productPageTitle} - â‚ª${price.toLocaleString()}\n`;
                                response += `   ğŸ”— [×¦×¤×” ×‘×“×£](${productPageUrl})\n\n`;
                            });
                            if (filteredProducts.length > 10) {
                                response += `...×•×¢×•×“ ${filteredProducts.length - 10} ${lowerMessage.includes('×©×¢×•×Ÿ') ? '×©×¢×•× ×™×' : '××•×¦×¨×™×'} × ×•×¡×¤×™×`;
                            }
                        }
                        else if (lowerMessage.includes('×”×›×™ ×–×•×œ') || lowerMessage.includes('×–×•×œ')) {
                            let categoryText = '';
                            if (lowerMessage.includes('×¦×¢×¦×•×¢')) categoryText = ' ×‘×§×˜×’×•×¨×™×™×ª ×¦×¢×¦×•×¢×™×';
                            else if (lowerMessage.includes('×©×¢×•×Ÿ')) categoryText = ' ×‘×§×˜×’×•×¨×™×™×ª ×©×¢×•× ×™×';
                            else if (lowerMessage.includes('×œ×§')) categoryText = ' ×‘×§×˜×’×•×¨×™×™×ª ×œ×§ ×’\'×œ';
                            else if (lowerMessage.includes('××ª× ×”')) categoryText = ' ×‘×§×˜×’×•×¨×™×™×ª ××ª× ×•×ª';
                            
                            // ğŸ¯ Save page to context for "×›×Ÿ" follow-up
                            const pageTitleForSearch = cheapest.pageTitle || cleanPageTitle;
                            const pageFromList = allPages.find(p => 
                                p.title === pageTitleForSearch || 
                                p.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === cleanPageTitle
                            );
                            if (pageFromList) {
                                window.stavCurrentPages = [pageFromList];
                                console.log('ğŸ’¾ Saved page to context for follow-up:', cleanPageTitle);
                            }
                            
                            response = `${cheapest.name} ×‘-${cleanPageTitle} ×¢×•×œ×” â‚ª${parseFloat(String(cheapest.price).replace(/[,\s]/g, '')).toLocaleString()}\n`;
                            response += `×–×” ×”××•×¦×¨ ×”×›×™ ×–×•×œ${categoryText} ×‘××¨×§×˜×¤×œ×™×™×¡.\n`;
                            response += `×¨×•×¦×” ×œ×¤×ª×•×— ××ª ×”×“×£?`;
                        } else if (lowerMessage.includes('×”×›×™ ×™×§×¨') || lowerMessage.includes('×™×§×¨')) {
                            const mostExpensiveFullUrl = `${window.location.origin}${mostExpensive.pageUrl}`;
                            const mostExpensiveCleanTitle = mostExpensive.pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                            
                            // ğŸ¯ Save page to context for "×›×Ÿ" follow-up
                            const pageFromList = allPages.find(p => 
                                p.title === mostExpensive.pageTitle || 
                                p.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === mostExpensiveCleanTitle
                            );
                            if (pageFromList) {
                                window.stavCurrentPages = [pageFromList];
                                console.log('ğŸ’¾ Saved page to context for follow-up:', mostExpensiveCleanTitle);
                            }
                            
                            response = `${mostExpensive.name} ×‘-${mostExpensiveCleanTitle} ×¢×•×œ×” â‚ª${parseFloat(String(mostExpensive.price).replace(/[,\s]/g, '')).toLocaleString()}\n`;
                            response += `×–×” ×”××•×¦×¨ ×”×›×™ ×™×§×¨ ×‘××¨×§×˜×¤×œ×™×™×¡.\n`;
                            response += `×¨×•×¦×” ×œ×¤×ª×•×— ××ª ×”×“×£?`;
                        } else {
                            response = `ğŸ¤– **××¦××ª×™ ${filteredProducts.length} ××•×¦×¨×™×!**\n\n`;
                            response += `ğŸ¥‡ **×”×›×™ ×–×•×œ:** ${cheapest.name} - â‚ª${parseFloat(String(cheapest.price).replace(/[,\s]/g, '')).toLocaleString()}\n`;
                            response += `ğŸ’ **×”×›×™ ×™×§×¨:** ${mostExpensive.name} - â‚ª${parseFloat(String(mostExpensive.price).replace(/[,\s]/g, '')).toLocaleString()}\n\n`;
                        }
                        
                        console.log(`âœ… Returning response with ${filteredProducts.length} products (all fetched LIVE from pages)`);
                        return { type: 'message', message: response };
                    } else {
                        return { type: 'message', message: '××¦×˜×¢×¨, ×œ× ××¦××ª×™ ××™×“×¢ ×¢×œ ××•×¦×¨×™× ×–××™× ×™× ×›×¨×’×¢ ×‘××¨×§×˜×¤×œ×™×™×¡.' };
                    }
                }
                
                // Determine if this is a marketplace query (products, stores, services)
                // BUT exclude general knowledge questions, greetings, bot questions, etc.
                // ğŸ¯ IMPROVED: If query matches a page, it's definitely a marketplace query
                const isMarketplaceQuery = (matchesPageInMarketplace || storeProductMatch || isProductQuery || requestedBusiness) && 
                                          !isGeneralKnowledge && 
                                          !isBotQuestion && 
                                          !isGreeting && 
                                          !isSelfIntro;
                
                // ğŸ¯ IMPORTANT: Check if user mentions a product category FIRST (even if it looks like a general question)
                // E.g., "×©×¢×•× ×™× ×™×©?" should be treated as marketplace query, not general question
                if (mentionsProduct) {
                    console.log('ğŸ¯ Product mentioned - skipping N8N, treating as marketplace query');
                    // Continue to marketplace search below (don't send to N8N)
                } else if (isGeneralKnowledge || isBotQuestion || isGreeting || isSelfIntro) {
                    // If it's a general question (knowledge, bot question, greeting, etc.) - send to N8N
                    console.log('ğŸ’¬ General question detected (knowledge/bot/greeting), sending to N8N');
                    return null; // Return null to send to N8N webhook
                } else if (!isMarketplaceQuery) {
                    // NOT a marketplace query - send directly to N8N for intelligent response
                    console.log('ğŸ’¬ Not a marketplace query, sending to N8N for intelligent response');
                    return null; // Return null to send to N8N webhook
                }
                
                // This IS a marketplace query - search in pages
                console.log('ğŸ” Query about products/store/business info - will search in pages');
                console.log('ğŸ¯ User message:', userMessage);
                
                // ğŸ¯ IMPROVED: If this is "××—×™×¨×™× ×©×œ X", search for X (the category) not the whole query
                // BUT: Keep the original userMessage for later use in generateTextResponseWithRealData
                let searchQuery = userMessage;
                const originalUserMessage = userMessage; // Save original for price list detection
                if (priceListCategory) {
                    searchQuery = priceListCategory;
                    console.log(`ğŸ“‹ Price list query - searching for category: "${priceListCategory}" instead of "${userMessage}"`);
                }
                
                // First, try to search in REAL pages
                console.log('ğŸ” Starting search with', allPages?.length || 0, 'total pages available');
                console.log('ğŸ¯ Calling searchLivePages with query:', searchQuery);
                const liveResults = await searchLivePages(searchQuery);
                
                console.log('ğŸ” Search completed, found:', liveResults?.length || 0, 'results');
                if (liveResults && liveResults.length > 0) {
                    console.log('âœ… Found pages:', liveResults.map(p => p.title).join(', '));
                } else {
                    console.log('âŒ No pages found for query:', userMessage);
                }
                
                if (liveResults && liveResults.length > 0) {
                    console.log('âœ… Found', liveResults.length, 'real pages');
                    
                    // ğŸš« REMOVED: Old auto-preview logic
                    // Preview should ONLY be shown when user explicitly requests it (handled at top of function)
                    // NOT when they just search for a service/product
                    const needsPreview = false; // âŒ NEVER auto-show preview - user must explicitly ask
                    
                    console.log('â„¹ï¸ Search results will NOT show preview automatically (needsPreview = false)');
                    
                    // ğŸ¯ Check if this is a "price list" or "show products" query - if so, return text directly
                    const lowerUserMessage = userMessage.toLowerCase();
                    const isPriceListOrShowQuery = priceListCategory || // "××—×™×¨×™× ×©×œ X"
                                                   lowerUserMessage.includes('×ª×¨××™ ××•×¦×¨×™×') || 
                                                   lowerUserMessage.includes('×ª×¨××™ ××—×™×¨×™×') ||
                                                   lowerUserMessage.includes('××•×¦×¨×™× ×•××—×™×¨×™×') ||
                                                   lowerUserMessage.includes('×¨×©×™××ª ××—×™×¨×™×') ||
                                                   lowerUserMessage.includes('×¨×©×™××ª ××•×¦×¨×™×') ||
                                                   lowerUserMessage.includes('×ª× ×™ ×¨×©×™××ª') ||
                                                   lowerUserMessage.includes('×ª× ×™ ×œ×™ ×¨×©×™××ª') ||
                                                   lowerUserMessage.includes('×ª× ×™ ××ª ×¨×©×™××ª') ||
                                                   lowerUserMessage.includes('×›×œ ×”××•×¦×¨×™×') ||
                                                   (lowerUserMessage.includes('×ª×¨××™') && 
                                                    (lowerUserMessage.includes('××•×¦×¨') || lowerUserMessage.includes('××—×™×¨'))) ||
                                                   (lowerUserMessage.includes('×ª××œ×™×¦×™') && lowerUserMessage.includes('××ª× ×”'));
                    
                    // If this is a "show products/prices" query, generate text response directly
                    if (isPriceListOrShowQuery) {
                        console.log('ğŸ“ Price list/show products query - generating text response directly');
                        
                        // ğŸ¯ IMPORTANT: Save pages to context so "×›×Ÿ" will work correctly!
                        window.stavCurrentPages = liveResults;
                        console.log('ğŸ’¾ Saved', liveResults.length, 'pages to context for follow-up questions');
                        
                        // ğŸ¯ Check if user wants link in this query
                        const includeLinks = /×ª×¨××”.*××ª×¨|×ª×¨××”.*×“×£|×§×™×©×•×¨|×¤×ª×—.*××ª×¨|×œ×™× ×§|link/i.test(userMessage);
                        // ğŸ¯ IMPORTANT: Use originalUserMessage (not searchQuery) so "××—×™×¨×™× ×©×œ X" is detected correctly
                        const textResponse = await generateTextResponseWithRealData(liveResults, originalUserMessage, includeLinks);
                        
                        // Return pages type with text, so context is preserved
                        return {
                            type: 'pages',
                            pages: liveResults,
                            message: textResponse,
                            showAsText: true, // Flag to show as text (not buttons)
                            needsPreview: false
                        };
                    }
                    
                    // Return the pages themselves (not text) so we can display them properly
                    return { 
                        type: 'pages', 
                        pages: liveResults,
                        message: `××¦××ª×™ ${liveResults.length} ×“×¤×™× ×¨×œ×•×•× ×˜×™×™×`,
                        needsPreview: needsPreview // Flag to indicate if preview should be shown
                    };
                }
                
                // If query was about products/store but no results found, show available pages
                console.log('âš ï¸ No products found for marketplace query - showing encouragement');
                
                if (allPages && allPages.length > 0) {
                    let message = `×œ× ××¦××ª×™ ××ª ××” ×©×—×™×¤×©×ª. ğŸ˜”\n\n××•×œ×™ ×ª× ×¡×” ×œ×—×¤×© ×‘××•×¤×Ÿ ××—×¨ ××• ×©×™×¨×•×ª ××—×¨? ×× ×™ ×›××Ÿ ×œ×¢×–×•×¨! ğŸ˜Š`;
                    
                    return { 
                        type: 'message',
                        message: message
                    };
                }
                
                return { 
                    type: 'message',
                    message: '×œ× ××¦××ª×™ ××ª ××” ×©×—×™×¤×©×ª. ğŸ˜”\n\n××•×œ×™ ×ª× ×¡×” ×œ×—×¤×© ×‘××•×¤×Ÿ ××—×¨ ××• ×©×™×¨×•×ª ××—×¨? ×× ×™ ×›××Ÿ ×œ×¢×–×•×¨! ğŸ˜Š'
                };
            } catch (error) {
                console.error('âŒâŒâŒ Error in processStavMessage:', error);
                console.error('âŒ Error stack:', error.stack);
                console.error('âŒ Error message:', error.message);
                return { 
                    type: 'message',
                    message: '××¦×˜×¢×¨, ××™×¨×¢×” ×©×’×™××”. × ×¡×” ×©×•×‘.'
                };
            }
        }

        // ğŸ¤ Speech Recognition & Text-to-Speech
        let recognition = null;
        let isListening = false;
        let isSpeaking = false;
        let lastInputWasVoice = false; // Track if user used voice input
        let speechSynthesis = window.speechSynthesis;

        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.log('âš ï¸ Speech recognition not supported');
                return null;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'he-IL';
            recognition.continuous = false;
            recognition.interimResults = false;

            recognition.onstart = function() {
                console.log('ğŸ¤ Listening...');
                isListening = true;
                const micButton = document.getElementById('micButton');
                if (micButton) {
                    micButton.style.background = '#ef4444';
                    micButton.textContent = 'ğŸ”´';
                }
            };

            recognition.onresult = function(event) {
                let transcript = event.results[0][0].transcript;
                console.log('ğŸ“ Heard (RAW):', transcript);
                
                // ğŸ¯ CLEAN: Remove punctuation marks from voice input
                transcript = transcript.replace(/[.,!?;:ØŒØ›]/g, '').trim();
                console.log('ğŸ“ Heard (CLEAN):', transcript);
                
                lastInputWasVoice = true; // Mark that user used voice
                const input = document.getElementById('stavChatInput');
                if (input) {
                    input.value = transcript;
                    sendStavMessage();
                }
            };

            recognition.onerror = function(event) {
                console.error('âŒ Speech recognition error:', event.error);
                isListening = false;
                const micButton = document.getElementById('micButton');
                if (micButton) {
                    micButton.style.background = '#667eea';
                    micButton.textContent = 'ğŸ¤';
                }
            };

            recognition.onend = function() {
                console.log('ğŸ¤ Stopped listening');
                isListening = false;
                const micButton = document.getElementById('micButton');
                if (micButton) {
                    micButton.style.background = '#667eea';
                    micButton.textContent = 'ğŸ¤';
                }
            };

            return recognition;
        }

        function toggleSpeechRecognition() {
            // If currently speaking, stop the speech
            if (isSpeaking) {
                stopSpeaking();
                return;
            }

            if (!recognition) {
                recognition = initSpeechRecognition();
                if (!recognition) {
                    alert('×”×“×¤×“×¤×Ÿ ×©×œ×š ×œ× ×ª×•××š ×‘×–×™×”×•×™ ×§×•×œ×™');
                    return;
                }
            }

            if (isListening) {
                recognition.stop();
            } else {
                recognition.start();
            }
        }

        function stopSpeaking() {
            speechSynthesis.cancel();
            isSpeaking = false;
            
            // ğŸ¤– Stop Google TTS audio
            if (window.currentAudio) {
                window.currentAudio.pause();
                window.currentAudio = null;
                console.log('ğŸ¤– Google TTS audio stopped');
            }
            
            const micButton = document.getElementById('micButton');
            if (micButton) {
                micButton.style.background = '#667eea';
                micButton.textContent = 'ğŸ¤';
            }
            console.log('ğŸ”‡ Speech stopped');
        }

        async function speakText(text) {
            // Remove emojis, asterisks, HTML, parentheses, and clean text for speech
            const cleanText = text
                .replace(/<[^>]*>/g, '') // Remove HTML tags
                .replace(/&[^;]+;/g, '') // Remove HTML entities
                .replace(/[ğŸ˜ŠğŸ’¡ğŸ“ğŸ“ğŸ“§ğŸ ğŸ’°âœ…âŒğŸ”—ğŸ“„ğŸªğŸ‰ğŸ“ğŸ”§ğŸ‘ï¸ğŸ¯ğŸ”ğŸ“šğŸ“ğŸ”ŠğŸ¤ğŸ”´]/g, '')
                .replace(/\*\*/g, '')
                .replace(/\*/g, '')
                .replace(/\([^)]*\)/g, '') // Remove parentheses
                .replace(/\.{2,}/g, '') // Remove multiple dots
                .replace(/\n\n+/g, '. ')
                .replace(/\n/g, '. ')
                .replace(/â€¢/g, '')
                .replace(/\|/g, '')
                .replace(/\s+/g, ' ')
                .trim();

            if (!cleanText) return;

            // Cancel any ongoing speech and audio
            speechSynthesis.cancel();
            if (window.currentAudio) {
                window.currentAudio.pause();
                window.currentAudio = null;
            }

            const micButton = document.getElementById('micButton');
            if (micButton) {
                micButton.style.background = '#10b981';
                micButton.textContent = 'ğŸ”Š';
            }

            try {
                // ğŸ¤– Google Cloud Text-to-Speech API
                const API_KEY = 'AIzaSyBexR71l9bdJ28OKx8P7QhyQDQpqTPa56o';
                
                console.log('ğŸ¤– Calling Google TTS API...');
                
                // ğŸ¯ Add timeout to prevent hanging (10 seconds max)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${API_KEY}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        input: { text: cleanText },
                        voice: {
                            languageCode: 'he-IL',
                            name: 'he-IL-Wavenet-A', // Female robotic voice (Wavenet = highest quality available for Hebrew)
                            ssmlGender: 'FEMALE'
                        },
                        audioConfig: {
                            audioEncoding: 'MP3',
                            pitch: -5.0,        // Lower pitch for robotic effect
                            speakingRate: 1.35, // Fast (as requested - kept the same)
                            volumeGainDb: 0.0,  // Normal volume
                            effectsProfileId: ['small-bluetooth-speaker-class-device'] // Robotic effect
                        }
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);

                const data = await response.json();
                
                if (data.error) {
                    console.error('âŒ Google TTS error:', data.error);
                    throw new Error(data.error.message);
                }
                
                if (data.audioContent) {
                    console.log('âœ… Received audio from Google TTS');
                    
                    // Convert base64 to audio and play
                    const audio = new Audio('data:audio/mp3;base64,' + data.audioContent);
                    window.currentAudio = audio;
                    
                    audio.onplay = () => {
                        isSpeaking = true;
                        console.log('ğŸ”Š Speaking (Google TTS):', cleanText.substring(0, 50) + '...');
                    };
                    
                    audio.onended = () => {
                        isSpeaking = false;
                        if (micButton) {
                            micButton.style.background = '#667eea';
                            micButton.textContent = 'ğŸ¤';
                        }
                        console.log('âœ… Speech finished');
                    };
                    
                    audio.onerror = (e) => {
                        console.error('âŒ Audio playback error:', e);
                        isSpeaking = false;
                        if (micButton) {
                            micButton.style.background = '#667eea';
                            micButton.textContent = 'ğŸ¤';
                        }
                    };
                    
                    await audio.play();
                } else {
                    throw new Error('No audio content received');
                }
            } catch (error) {
                console.error('âŒ Google TTS error:', error);
                console.error('âŒ Error details:', error.message);
                console.error('âŒ Error name:', error.name);
                
                // ğŸ¯ Check error type
                if (error.name === 'AbortError') {
                    console.warn('âš ï¸ Google TTS request timed out (>10s)');
                } else if (error.message && (error.message.includes('quota') || error.message.includes('429'))) {
                    console.warn('âš ï¸ Google TTS quota exceeded or rate limit hit');
                } else if (error.message && error.message.includes('API key')) {
                    console.warn('âš ï¸ Google TTS API key issue');
                } else if (error.message && error.message.includes('network')) {
                    console.warn('âš ï¸ Network error - no internet connection?');
                }
                
                // Fallback to browser TTS if Google fails
                console.log('âš ï¸ Falling back to browser TTS');
                
                try {
                    const utterance = new SpeechSynthesisUtterance(cleanText);
                    utterance.lang = 'he-IL';
                    utterance.rate = 1.35; // Match the Google TTS rate
                    utterance.pitch = 0.6;
                    
                    utterance.onstart = () => {
                        isSpeaking = true;
                        console.log('ğŸ”Š Browser TTS started (fallback)');
                    };
                    
                    utterance.onend = () => {
                        isSpeaking = false;
                        if (micButton) {
                            micButton.style.background = '#667eea';
                            micButton.textContent = 'ğŸ¤';
                        }
                        console.log('âœ… Browser TTS finished (fallback)');
                    };
                    
                    utterance.onerror = (e) => {
                        console.error('âŒ Browser TTS error:', e);
                        isSpeaking = false;
                        if (micButton) {
                            micButton.style.background = '#667eea';
                            micButton.textContent = 'ğŸ¤';
                        }
                    };
                    
                    speechSynthesis.speak(utterance);
                } catch (fallbackError) {
                    console.error('âŒ Browser TTS fallback also failed:', fallbackError);
                    // Reset mic button
                    isSpeaking = false;
                    if (micButton) {
                        micButton.style.background = '#667eea';
                        micButton.textContent = 'ğŸ¤';
                    }
                }
            }
        }

        async function sendStavMessage() {
            const input = document.getElementById('stavChatInput');
            const userMessage = input.value.trim();
            
            if (!userMessage) return;
            
            // ğŸ¯ FIX: Store user message in window for later use (for price list detection)
            window.lastUserMessage = userMessage;
            console.log('ğŸ’¾ Stored user message:', userMessage);
            
            // Check if this was a typed message (not voice)
            const wasVoice = lastInputWasVoice;
            console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            console.log('ğŸ“¨ INPUT METHOD:', wasVoice ? 'ğŸ¤ VOICE' : 'âŒ¨ï¸ TEXT');
            console.log('ğŸ“ MESSAGE:', userMessage);
            console.log('ğŸ” MESSAGE LENGTH:', userMessage.length);
            console.log('ğŸ”¤ MESSAGE CHARS:', Array.from(userMessage).map(c => c.charCodeAt(0)));
            console.log(wasVoice ? 'ğŸ”Š Response will be SPOKEN + TEXT' : 'ğŸ“ Response will be TEXT ONLY');
            console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            
            // Display user message
            addStavMessage(userMessage, true);
            input.value = '';
            
            // Reset voice flag after sending (for next message)
            // Don't reset here - wait for response to be added
            // lastInputWasVoice = false;
            
            // Show typing indicator with animation
            const typingMessageDiv = document.createElement('div');
            typingMessageDiv.className = 'stav-message bot stav-typing-indicator';
            typingMessageDiv.id = 'stav-typing-indicator';
            typingMessageDiv.innerHTML = `
                <div class="stav-loader">
                    <div class="inner one"></div>
                    <div class="inner two"></div>
                    <div class="inner three"></div>
                </div>
                <span>×¡×ª×™×• ××§×œ×™×“×”...</span>
            `;
            const messagesDiv = document.getElementById('stavChatMessages');
            messagesDiv.appendChild(typingMessageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            try {
                // Get all pages for Stav
                const response = await fetch('/api/pages/all');
                if (!response.ok) {
                    console.error('âŒ Failed to fetch pages:', response.status, response.statusText);
                    addStavMessage('××¦×˜×¢×¨, ×‘×¢×™×” ×‘×˜×¢×™× ×ª ×”×“×¤×™× ××”×©×¨×ª. × ×¡×” ×©×•×‘ ×××•×—×¨ ×™×•×ª×¨.', false);
                    return;
                }
                const data = await response.json();
                const allPages = data.pages || data || [];
                
                console.log('ğŸ“Š All pages for Stav:', allPages.length, 'pages');
                if (allPages.length === 0) {
                    console.warn('âš ï¸ No pages returned from API!');
                }
                
                // Process the message and get response
                const botResponse = await processStavMessage(userMessage, allPages);
                
                // ğŸ¯ FIX: Handle text responses (like "××” ×”××•×¦×¨ ×”×›×™ ×–×•×œ") FIRST - don't send to N8N!
                if (botResponse && (botResponse.type === 'text' || botResponse.type === 'message') && botResponse.message) {
                    console.log('âœ… Found text response, displaying directly:', botResponse.message);
                
                // Remove typing indicator
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) {
                        typingIndicator.remove();
                    }
                    
                    // Display the message
                    addStavMessage(botResponse.message, false);
                    return; // Don't send to N8N
                }
                
                // If we have pages to display, show them as TEXT ONLY (no buttons!)
                // ğŸ¯ User wants ONLY text conversation - NO buttons/preview!
                if (botResponse && botResponse.type === 'pages' && botResponse.pages && botResponse.pages.length > 0) {
                    console.log('âœ… Found pages, displaying as TEXT ONLY (no buttons):', botResponse.pages.length);
                    
                    // ğŸ¯ Save pages in context for later use (if user asks for link)
                    window.stavCurrentPages = botResponse.pages;
                    
                    // Remove typing indicator
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) typingIndicator.remove();
                    
                    // ğŸ¯ NEW: If user explicitly requested to see the page, show preview WITHOUT repeating text!
                    console.log('ğŸ“Š [PREVIEW DEBUG] needsPreview:', botResponse.needsPreview);
                    console.log('ğŸ“Š [PREVIEW DEBUG] includeLinks:', botResponse.includeLinks);
                    console.log('ğŸ“Š [PREVIEW DEBUG] pages count:', botResponse.pages?.length);
                    
                    if (botResponse.needsPreview === true) {
                        console.log('ğŸ–¼ï¸âœ… SHOWING IFRAME ONLY (no text!) because needsPreview=true');
                        // Show short polite message with LIVE description before iframe
                        const bestPage = botResponse.pages[0];
                        if (bestPage) {
                            let shortMessage = `×‘×‘×§×©×”, ×”× ×” ×”×“×£ ×©×œ ${bestPage.title}`;
                            
                            // Fetch the page to extract LIVE description
                            const pageUrl = `/users/${bestPage.userId}/${bestPage.pageId}_html`;
                            try {
                                const pageResponse = await fetch(pageUrl);
                                if (pageResponse.ok) {
                                    const html = await pageResponse.text();
                                    const liveDesc = extractLiveDescription(html);
                                    
                                    if (liveDesc && liveDesc.length > 0) {
                                        // Use full description - don't cut it!
                                        shortMessage += ` - ${liveDesc}`;
                                    }
                                }
                            } catch (error) {
                                console.error('âŒ Error fetching live description:', error);
                            }
                            
                            addStavMessage(shortMessage, false);
                            console.log('âœ… Added short intro message with LIVE description:', shortMessage);
                        }
                        // Show iframe after short delay
                        setTimeout(async () => {
                            if (bestPage) {
                                await displayPagePreview(bestPage, 'stavChatMessages');
                                console.log('âœ… Displayed page preview for:', bestPage.title);
                            }
                        }, 100); // Show immediately
                    } else {
                        console.log('ğŸ“ Showing text response (no preview) because needsPreview=false');
                        // ğŸ¯ CRITICAL: Show ONLY text response - NO buttons!
                        // Generate text response with real data and display it directly
                        const messageToPass = userMessage || botResponse.message || `××¦××ª×™ ${botResponse.pages.length} ×“×¤×™× ×¨×œ×•×•× ×˜×™×™×`;
                        const includeLinks = botResponse.includeLinks || false;
                        const textResponse = await generateTextResponseWithRealData(botResponse.pages, messageToPass, includeLinks);
                        if (textResponse && textResponse.trim().length > 0) {
                            addStavMessage(textResponse, false);
                            console.log('âœ… Added text response with real data (NO buttons)');
                        }
                    }
                    
                    // ğŸ¯ IMPROVED: DON'T send to N8N when we have successful local results!
                    // This prevents timeout/errors and makes the bot faster
                    console.log('âœ… Local search successful - NOT sending to N8N (prevents timeout)');
                    stavFirstReplySent = true;
                    return; // Exit - don't send to N8N!
                } else if (botResponse && botResponse.type === 'message') {
                    // Just a text message, display it directly
                    // Remove typing indicator before displaying message
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) typingIndicator.remove();
                    
                    addStavMessage(botResponse.message, false);
                    stavFirstReplySent = true;
                    return; // Don't send to N8N for simple messages
                } else if (botResponse === null) {
                    // botResponse is null - this means send to N8N (general questions, etc.)
                    console.log('ğŸ’¬ botResponse is null - sending to N8N for intelligent response');
                    // Keep typing indicator until N8N responds
                } else {
                    // Unknown response type - remove typing indicator and send to N8N
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) typingIndicator.remove();
                    console.log('âš ï¸ Unknown botResponse type, sending to N8N');
                }
                
                // Send to N8N for conversational response (for general questions or context)
                console.log('ğŸ’¬ Sending to N8N webhook for conversational response');
                try {
                    const webhookUrl = '/api/n8n-webhook'; // Use proxy route instead of direct N8N
                    
                    // CRITICAL: Reload pages if allPages is empty or not loaded yet
                    if (!allPages || allPages.length === 0) {
                        console.log('âš ï¸ allPages is empty! Reloading pages...');
                        await loadPages();
                        console.log(`âœ… Reloaded pages: ${allPages.length} pages available`);
                    }
                    
                    // Check if this is a question about service providers - include ALL serviceProvider pages
                    const isServiceProviderQuestion = /(?:×›××”|××”|×™×©|××—×¤×©|×¦×¨×™×š|××™×–×”|××™)\s*(?:× ×•×ª× ×™|××¡×¤×§×™|×‘×¢×œ×™|×‘×¢×œ)?\s*(?:×©×¨×•×ª|×©×™×¨×•×ª|××§×¦×•×¢)/.test(userMessage.toLowerCase()) || 
                                                      /×‘×¢×œ×™\s*××§×¦×•×¢|×‘×¢×œ\s*××§×¦×•×¢/.test(userMessage.toLowerCase());
                    
                    // ğŸ¯ NEW: Check if query looks like a marketplace search (single words like "× ×’×¨", "×œ×§", "×¦×¢×¦×•×¢×™×")
                    // Even if processStavMessage didn't catch it, we should find matching pages and send them
                    let matchingPagesForBody = [];
                    const userMessageLower = userMessage.toLowerCase().trim();
                    const isShortQuery = userMessageLower.length > 1 && userMessageLower.length < 30 && 
                                        !userMessageLower.includes('?') && 
                                        !userMessageLower.match(/^(××”|××™×š|×œ××”|××“×•×¢|××ª×™|××™×¤×”)/);
                    
                    // If it's a short query (likely marketplace search), try to find matching pages
                    if (isShortQuery && allPages && allPages.length > 0) {
                        console.log(`ğŸ” Short query detected - checking for matching pages: "${userMessageLower}"`);
                        
                        for (const page of allPages) {
                            const pageTitle = (page.title || '').toLowerCase();
                            const pageDesc = (page.description || '').toLowerCase();
                            const pageProducts = (page.products || []).map(p => (p.name || '').toLowerCase()).join(' ');
                            const pageCity = (page.city || '').toLowerCase();
                            
                            // Check if query matches page (title, description, products, or city)
                            if (pageTitle.includes(userMessageLower) || 
                                pageDesc.includes(userMessageLower) || 
                                pageProducts.includes(userMessageLower) ||
                                userMessageLower.includes(pageTitle.split(' ')[0]) ||
                                pageTitle.split(' ').some(word => word.length > 2 && userMessageLower.includes(word)) ||
                                // Also check if query is in city (e.g., "× ×ª× ×™×”")
                                (pageCity && pageCity.includes(userMessageLower))) {
                                
                                // ğŸ¯ FIX: Extract products from live page if not in metadata
                                let products = page.products || [];
                                
                                // ğŸ¯ FIX: ALWAYS extract products from live page to get latest prices
                                // User said "×× ×× ×™ ××©× ×” ×‘×“×¤×™× ××—×™×¨×™× ×”×‘×•×˜ ×××•×¨ ×œ×–×”×•×ª ××ª ×–×”" - so we need LIVE data!
                                const alwaysExtractProducts = true; // Always get live data for latest prices!
                                if (alwaysExtractProducts || !products || products.length === 0) {
                                    try {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        const response = await fetch(pageUrl);
                                        if (response.ok) {
                                            const html = await response.text();
                                            const liveProducts = extractLiveProducts(html);
                                            // Always use live products if found (to get latest prices)
                                            if (liveProducts && liveProducts.length > 0) {
                                                products = liveProducts;
                                                console.log(`ğŸ›’ Extracted ${products.length} LIVE products from page for "${page.title}":`, products.map(p => `${p.name} - â‚ª${p.price}`));
                                            } else if (!page.products || page.products.length === 0) {
                                                // Fallback to metadata if live extraction failed
                                                products = page.products || [];
                                            }
                                        }
                                    } catch (error) {
                                        console.error(`Error extracting products for "${page.title}":`, error);
                                        // Fallback to metadata if extraction fails
                                        if (!products || products.length === 0) {
                                            products = page.products || [];
                                        }
                                    }
                                }
                                
                                // Add page to matching pages for body
                                const phone = page.phone || null;
                                const phones = page.phones || [];
                                const email = page.email || null;
                                const city = page.city || null;
                                const address = page.address || null;
                                
                                matchingPagesForBody.push({
                                    title: page.title,
                                    type: page.pageType || 'unknown',
                                    userId: page.userId,
                                    pageId: page.pageId,
                                    description: page.description || '',
                                    url: `/users/${page.userId}/${page.pageId}_html`,
                                    phone: phone,
                                    phones: phones,
                                    email: email,
                                    city: city,
                                    address: address,
                                    products: products.map(prod => ({ name: prod.name, price: prod.price }))
                                });
                                
                                console.log(`âœ… Found matching page for body: ${page.title} (${products.length} products)`);
                            }
                        }
                        
                        if (matchingPagesForBody.length > 0) {
                            console.log(`ğŸ“‹ Found ${matchingPagesForBody.length} matching pages for body`);
                        }
                    }
                    
                    // Prepare pages to send - ALWAYS send ALL pages to N8N so it knows what exists
                    // CRITICAL: Include REAL contact info (phone, city, address) so N8N can use REAL data
                    let pagesToSend = [];
                    if (botResponse && botResponse.type === 'pages' && botResponse.pages && botResponse.pages.length > 0) {
                        // Send the actual found pages WITH REAL CONTACT INFO
                        pagesToSend = botResponse.pages.slice(0, 20).map(p => {
                            // Use metadata FIRST, fallback to liveContactInfo
                            const phone = p.phone || (p.liveContactInfo && p.liveContactInfo.phone) || null;
                            const phones = p.phones || (p.liveContactInfo && p.liveContactInfo.phones) || [];
                            const email = p.email || (p.liveContactInfo && p.liveContactInfo.email) || null;
                            const city = p.city || (p.liveContactInfo && p.liveContactInfo.city) || null;
                            const address = p.address || (p.liveContactInfo && p.liveContactInfo.address) || null;
                            const products = p.products || p.liveProducts || [];
                            
                            return {
                                title: p.title,
                                type: p.pageType || 'unknown',
                                userId: p.userId,
                                pageId: p.pageId,
                                description: p.description || '',
                                url: `/users/${p.userId}/${p.pageId}_html`,
                                // Include REAL contact info (from metadata or live data)
                                phone: phone,
                                phones: phones,
                                email: email,
                                city: city,
                                address: address,
                                products: products.map(prod => ({ name: prod.name, price: prod.price }))
                            };
                        });
                        console.log(`ğŸ“¤ Sending ${pagesToSend.length} found pages to N8N WITH REAL CONTACT INFO`);
                    } else {
                        // No specific results OR general question - send ALL pages to N8N so it knows what exists
                        // CRITICAL: Always send all pages, not just 20, so N8N has full context
                        if (allPages && allPages.length > 0) {
                            pagesToSend = allPages.map(p => {
                                const phone = p.phone || null;
                                const phones = p.phones || [];
                                const email = p.email || null;
                                const city = p.city || null;
                                const address = p.address || null;
                                const products = p.products || [];
                                
                                return {
                                    title: p.title,
                                    type: p.pageType || 'unknown',
                                    userId: p.userId,
                                    pageId: p.pageId,
                                    description: p.description || '',
                                    url: `/users/${p.userId}/${p.pageId}_html`,
                                    // Include REAL contact info from metadata
                                    phone: phone,
                                    phones: phones,
                                    email: email,
                                    city: city,
                                    address: address,
                                    products: products.map(prod => ({ name: prod.name, price: prod.price }))
                                };
                            });
                            console.log(`ğŸ“¤ Sending ALL ${pagesToSend.length} pages to N8N WITH REAL CONTACT INFO`);
                        } else {
                            console.error('âŒ ERROR: allPages is still empty! Cannot send pages to N8N.');
                        }
                    }
                    
                    // If service provider question, filter to service providers WITH REAL CONTACT INFO
                        if (isServiceProviderQuestion && allPages) {
                            const serviceProviderPages = allPages.filter(p => p.pageType === 'serviceProvider');
                            console.log(`ğŸ”§ Found ${serviceProviderPages.length} service provider pages to send to N8N`);
                        pagesToSend = serviceProviderPages.slice(0, 20).map(p => {
                            const phone = p.phone || null;
                            const phones = p.phones || [];
                            const email = p.email || null;
                            const city = p.city || null;
                            const address = p.address || null;
                            const products = p.products || [];
                            
                            return {
                                title: p.title,
                                type: p.pageType || 'serviceProvider',
                                userId: p.userId,
                                pageId: p.pageId,
                                description: p.description || '',
                                url: `/users/${p.userId}/${p.pageId}_html`,
                                // Include REAL contact info from metadata
                                phone: phone,
                                phones: phones,
                                email: email,
                                city: city,
                                address: address,
                                products: products.map(prod => ({ name: prod.name, price: prod.price }))
                            };
                        });
                        console.log(`ğŸ“¤ Sending ${pagesToSend.length} service provider pages WITH REAL CONTACT INFO`);
                        }
                        
                        // ğŸ¯ IMPROVED: If we found matching pages for body, include them even if pagesToSend is empty
                        // This ensures N8N always gets relevant pages for marketplace queries like "× ×’×¨", "×œ×§", "×¦×¢×¦×•×¢×™×"
                        if (matchingPagesForBody.length > 0 && pagesToSend.length === 0) {
                            console.log(`ğŸ“‹ Using ${matchingPagesForBody.length} matching pages for body instead of empty pagesToSend`);
                            pagesToSend = matchingPagesForBody;
                        }
                        
                        console.log('ğŸ“¤ Sending to N8N:', {
                            message: userMessage,
                            context: 'stav-marketplace',
                            hasPages: (allPages?.length || 0) > 0,
                            pagesCount: allPages?.length || 0,
                        foundPagesCount: botResponse && botResponse.type === 'pages' ? (botResponse.pages?.length || 0) : 0,
                        pagesToSend: pagesToSend.length,
                        matchingPagesForBody: matchingPagesForBody.length,
                        isServiceProviderQuestion: isServiceProviderQuestion,
                        pagesToSendSample: pagesToSend.slice(0, 3).map(p => ({ title: p.title, type: p.type, city: p.city }))
                        });
                        
                        const webhookResponse = await fetch(webhookUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                message: userMessage,
                                context: 'stav-marketplace',
                                availablePages: allPages?.length || 0,
                                pages: pagesToSend.length > 0 ? pagesToSend : (matchingPagesForBody.length > 0 ? matchingPagesForBody : []), // ğŸ¯ Use matching pages if pagesToSend is empty
                            foundPages: botResponse && botResponse.type === 'pages' ? botResponse.pages : [],
                            hasSearchResults: !!(botResponse && botResponse.type === 'pages' && botResponse.pages && botResponse.pages.length > 0) || matchingPagesForBody.length > 0,
                                serviceProviders: isServiceProviderQuestion ? (pagesToSend.length > 0 ? pagesToSend : matchingPagesForBody) : [],
                                matchingPages: matchingPagesForBody // ğŸ¯ NEW: Include matching pages in body
                            })
                        });
                        
                        console.log('ğŸ“¥ N8N response status:', webhookResponse.status);
                        
                        if (webhookResponse.ok) {
                            const webhookData = await webhookResponse.json();
                            console.log('ğŸ“¥ N8N response data:', webhookData);
                            // Try multiple response formats
                            let responseMessage = webhookData.message || 
                                                   webhookData.response || 
                                                   webhookData.text || 
                                                   webhookData.output?.message ||
                                                   webhookData.output?.response ||
                                                   (typeof webhookData.output === 'string' ? webhookData.output : null) ||
                                                   (webhookData.data?.message) ||
                                                   '××¦×˜×¢×¨, ×œ× ×”×¦×œ×—×ª×™ ×œ×¢× ×•×ª ×¢×œ ×–×”. × ×¡×” ×œ×—×¤×© ××©×”×• ×‘××¨×§×˜×¤×œ×™×™×¡!';
                            
                            // Clean and translate to pure Hebrew - AGGRESSIVE cleaning
                            if (typeof responseMessage === 'string') {
                                // Split into sentences (by periods, exclamation marks, question marks, or line breaks)
                                const sentences = responseMessage.split(/[.!?\n]\s*/);
                                
                                // Filter: keep only sentences that contain Hebrew characters
                                const hebrewSentences = sentences.filter(sentence => {
                                    const trimmed = sentence.trim();
                                    if (!trimmed) return false; // Skip empty
                                    // Keep if contains Hebrew OR is just punctuation/emojis/numbers
                                    return /[×-×ª]/.test(trimmed) || /^[\s\*\-\d\s\.\,\:\(\)ğŸ˜ŠğŸ’œâœ¨ğŸ¯ğŸªğŸ’°â­ğŸ†ğŸ‘ï¸ğŸ”—ğŸ“ğŸ“§ğŸ“ğŸ™ï¸ğŸš€\-\s]+$/.test(trimmed);
                                });
                                
                                // Reconstruct message from Hebrew sentences only
                                responseMessage = hebrewSentences
                                    .map(s => s.trim())
                                    .filter(s => s.length > 0)
                                    .join('. ')
                                    .replace(/\.\s*\./g, '.') // Remove double periods
                                    .trim();
                                
                                // Additional cleanup - remove common English patterns anywhere in text
                                responseMessage = responseMessage
                                    .replace(/silently[^×-×ª]*/gi, '')
                                    .replace(/The\s+user[^×-×ª]*/gi, '')
                                    .replace(/for\s+the\s+[^×-×ª\.]*/gi, '')
                                    .replace(/after\s+I['ve]*\s+[^×-×ª\.]*/gi, '')
                                    .replace(/I['ve]*\s+tried[^×-×ª\.]*/gi, '')
                                    .replace(/[A-Z][a-z]+\s+[^×-×ª\.]{10,}/g, '') // Remove long English sentences
                                    .replace(/["'][^"']*["']/g, ''); // Remove quoted English text
                                
                                // Replace English/Arabic greetings with Hebrew
                                responseMessage = responseMessage
                                    .replace(/\b×”×™×™\b/g, '×©×œ×•×')
                                    .replace(/\bhi\b/gi, '×©×œ×•×')
                                    .replace(/\bhello\b/gi, '×©×œ×•×')
                                    .replace(/\bhey\b/gi, '×©×œ×•×');
                                
                                // Final cleanup - remove any remaining English-only words/phrases
                                const words = responseMessage.split(/\s+/);
                                const hebrewWords = words.filter(word => {
                                    // Keep if contains Hebrew OR is punctuation/number/emoji
                                    return /[×-×ª]/.test(word) || /^[\*\-\d\.\,\:\(\)ğŸ˜ŠğŸ’œâœ¨ğŸ¯ğŸªğŸ’°â­ğŸ†ğŸ‘ï¸ğŸ”—ğŸ“ğŸ“§ğŸ“ğŸ™ï¸\-\s]*$/.test(word);
                                });
                                responseMessage = hebrewWords.join(' ').trim();
                                
                                // Clean up multiple spaces and fix punctuation
                                responseMessage = responseMessage
                                    .replace(/\s+/g, ' ')
                                    .replace(/\s*([\.\,\:\!])\s*/g, '$1 ')
                                    .trim();
                                
                                // If result is empty or mostly English, don't use fallback - N8N should handle it
                                // Only use minimal fallback if completely empty
                                if (!responseMessage || responseMessage.length === 0) {
                                    // Try one more time to get response - maybe it's in a different format
                                    responseMessage = webhookData?.text || webhookData?.toString() || null;
                                }
                            }
                            
                            // Remove typing indicator right before displaying N8N response
                            const typingIndicator = document.getElementById('stav-typing-indicator');
                            if (typingIndicator) typingIndicator.remove();
                            
                            // âš ï¸ IMPORTANT: Filter out invented contact info from N8N response
                            // N8N sometimes invents phone numbers, addresses, etc.
                            // We should only display REAL data from pages, not invented data
                            const hasInventedContactInfo = /(?:×˜×œ×¤×•×Ÿ|×˜×œ×¤×•× ×™×|ğŸ“|phone).*?(?:\d{3}[-.\s]?\d{3}[-.\s]?\d{4}|\d{10})/.test(responseMessage) ||
                                                         /(?:×›×ª×•×‘×ª|address|ğŸ ).*?(?:×¨×—×•×‘|street|×‘×™×ª)/i.test(responseMessage) ||
                                                         /(?:××™××™×™×œ|email|ğŸ“§).*?@/.test(responseMessage);
                            
                            // ğŸ¯ FIX: Check if N8N response has missing prices - improved pattern matching
                            // Match patterns like: "××•×¦×¨ - *" or "××•×¦×¨ -" or "××•×¦×¨ - *" or "* ××•×¦×¨ - *"
                            const hasMissingPrices = /[×-×ª]+\s*-\s*\*\s*$/.test(responseMessage) ||  // "××•×¦×¨ - *"
                                                     /[×-×ª]+\s*-\s*\*/.test(responseMessage) ||      // "××•×¦×¨ - *"
                                                     /[×-×ª]+\s*-\s*$/.test(responseMessage) ||         // "××•×¦×¨ -" (end of line)
                                                     /\*\s*[×-×ª]+\s*-\s*\*/.test(responseMessage) ||  // "* ××•×¦×¨ - *"
                                                     /\*\s*[×-×ª]+\s*-\s*$/.test(responseMessage);       // "* ××•×¦×¨ -"
                            
                            // If N8N returned pages to display, ALWAYS use displayPageOptions with REAL data
                            // Don't display N8N's text if it contains invented contact info OR missing prices
                            if (webhookData && webhookData.pages && Array.isArray(webhookData.pages) && webhookData.pages.length > 0) {
                                console.log('ğŸ“„ N8N returned pages - using displayPageOptions with REAL data');
                                console.log('ğŸ” Checking for missing prices:', hasMissingPrices);
                                
                                // ğŸ¯ IMPORTANT: Save pages to context so "×›×Ÿ" will work!
                                window.stavCurrentPages = webhookData.pages;
                                console.log('ğŸ’¾ Saved', webhookData.pages.length, 'pages from N8N to context');
                                
                                // Display pages with REAL data from metadata/HTML (not invented)
                                // If N8N has missing prices, don't show its text - displayPageOptions will show correct prices
                                // ğŸ¯ FIX: Pass userMessage to detect if user wants full price list
                                const messageToPass = hasMissingPrices ? null : (window.lastUserMessage || userMessage || responseMessage);
                                console.log('ğŸ“¤ Passing message to displayPageOptions:', messageToPass, 'hasMissingPrices:', hasMissingPrices);
                                await displayPageOptions(webhookData.pages, messageToPass);
                                
                                // ğŸ¯ REMOVED: Don't let N8N automatically show preview
                                // Preview should ONLY be shown when user explicitly requests it
                                // by saying "×ª×¨××” ×œ×™ ××ª ×”××ª×¨" or similar
                                console.log('â„¹ï¸ N8N sent pages, but NOT showing preview automatically (user must request)');
                                stavFirstReplySent = true;
                            } else if (responseMessage && responseMessage.length > 0 && !hasInventedContactInfo) {
                                // ğŸ¯ FIX: Check if user asked for price list - if so, ALWAYS show pages with prices!
                                const userAskedForPriceList = window.lastUserMessage && (
                                    window.lastUserMessage.toLowerCase().includes('×¨×©×™××ª ××—×™×¨×™×') ||
                                    window.lastUserMessage.toLowerCase().includes('×¨×©×™××ª ××•×¦×¨×™×') ||
                                    window.lastUserMessage.toLowerCase().includes('×ª×¨××™ ××•×¦×¨×™×') ||
                                    window.lastUserMessage.toLowerCase().includes('×ª×¨××™ ××—×™×¨×™×') ||
                                    window.lastUserMessage.toLowerCase().includes('××•×¦×¨×™× ×•××—×™×¨×™×') ||
                                    (window.lastUserMessage.toLowerCase().includes('×ª×¨××™') && 
                                     (window.lastUserMessage.toLowerCase().includes('××•×¦×¨') || window.lastUserMessage.toLowerCase().includes('××—×™×¨'))) ||
                                    window.lastUserMessage.toLowerCase().includes('××—×™×¨×™× ×©×œ') ||
                                    window.lastUserMessage.toLowerCase().includes('×›×œ ×”××—×™×¨×™×') ||
                                    window.lastUserMessage.toLowerCase().includes('×›×œ ×”××•×¦×¨×™×')
                                );
                                
                                // ğŸ¯ FIX: Check if N8N response has missing prices - improved pattern matching
                                const hasMissingPricesInText = /[×-×ª]+\s*-\s*\*\s*$/.test(responseMessage) ||  // "××•×¦×¨ - *"
                                                                /[×-×ª]+\s*-\s*\*/.test(responseMessage) ||      // "××•×¦×¨ - *"
                                                                /[×-×ª]+\s*-\s*$/.test(responseMessage) ||         // "××•×¦×¨ -" (end of line)
                                                                /\*\s*[×-×ª]+\s*-\s*\*/.test(responseMessage) ||  // "* ××•×¦×¨ - *"
                                                                /\*\s*[×-×ª]+\s*-\s*$/.test(responseMessage) ||   // "* ××•×¦×¨ -"
                                                                /××™×Ÿ.*××—×™×¨/i.test(responseMessage) ||              // "××™×Ÿ ××—×™×¨×™×"
                                                                /×œ×.*××—×™×¨/i.test(responseMessage);                // "×œ× ××—×™×¨×™×"
                                
                                // ğŸ¯ FIX: If user asked for price list OR N8N says no prices, show pages with prices anyway!
                                if (userAskedForPriceList || hasMissingPricesInText) {
                                    console.log('ğŸ” User asked for price list or N8N says no prices - showing pages with REAL prices');
                                    console.log('ğŸ” userAskedForPriceList:', userAskedForPriceList, 'hasMissingPricesInText:', hasMissingPricesInText);
                                    console.warn('âš ï¸ N8N response has missing prices - will extract and display from LIVE data');
                                    console.log('ğŸ” Response message:', responseMessage);
                                    console.log('ğŸ” All pages:', (allPages || []).map(p => p.title));
                                    
                                    // Try to find pages mentioned in the response and display them with REAL prices
                                    const pageTitlesMentioned = (allPages || []).filter(p => {
                                        const titleInMessage = responseMessage.includes(p.title);
                                        console.log(`ğŸ” Checking "${p.title}": ${titleInMessage}`);
                                        return titleInMessage;
                                    });
                                    
                                    console.log(`ğŸ“‹ Found ${pageTitlesMentioned.length} pages mentioned in response`);
                                    
                                    if (pageTitlesMentioned.length > 0) {
                                        console.log('âœ… Displaying pages with REAL prices - TEXT ONLY (no buttons):', pageTitlesMentioned.map(p => p.title));
                                        
                                        // ğŸ¯ IMPORTANT: Save pages to context so "×›×Ÿ" will work!
                                        window.stavCurrentPages = pageTitlesMentioned;
                                        console.log('ğŸ’¾ Saved', pageTitlesMentioned.length, 'pages to context from N8N text response');
                                        
                                        // ğŸ¯ Show ONLY text - NO buttons!
                                        const input = document.getElementById('stavChatInput');
                                        const currentUserMessage = input ? input.value.trim() : (window.lastUserMessage || null);
                                        // ğŸ¯ Check if user wants link
                                        const includeLinks = currentUserMessage && /×ª×¨××”.*××ª×¨|×ª×¨××”.*×“×£|×§×™×©×•×¨|×¤×ª×—.*××ª×¨|×œ×™× ×§|link/i.test(currentUserMessage);
                                        const textResponse = await generateTextResponseWithRealData(pageTitlesMentioned, currentUserMessage || '×¨×©×™××ª ××—×™×¨×™×', includeLinks);
                                        if (textResponse && textResponse.trim().length > 0) {
                                            addStavMessage(textResponse, false);
                                        }
                                    } else {
                                        // Can't find pages - try to search by keywords from user's query
                                        // Extract keywords from user's message (e.g., "×¦×¢×¦×•×¢×™×", "×—×œ×¤×™×", etc.)
                                        const userMessageWords = (window.lastUserMessage || '').toLowerCase().split(/\s+/);
                                        const commonKeywords = ['×¦×¢×¦×•×¢', '×¦×¢×¦×•×¢×™×', '×—×œ×¤×™×', '×©×¢×•×Ÿ', '×©×¢×•× ×™×', '×œ×§', '×× ×™×§×•×¨', '× ×’×¨', '× ×’×¨×•×ª', '××™× ×¡×˜×œ×˜×•×¨'];
                                        const searchKeywords = [];
                                        
                                        // Add keywords from user's message
                                        userMessageWords.forEach(word => {
                                            if (commonKeywords.some(kw => word.includes(kw) || kw.includes(word))) {
                                                searchKeywords.push(word);
                                            }
                                        });
                                        
                                        // Add default keywords if none found
                                        if (searchKeywords.length === 0) {
                                            searchKeywords.push(...['×¦×¢×¦×•×¢', '×—×œ×¤×™×', '×©×¢×•×Ÿ']);
                                        }
                                        
                                        console.log('ğŸ” Searching pages by keywords:', searchKeywords);
                                        
                                        const pagesByKeywords = (allPages || []).filter(p => 
                                            searchKeywords.some(keyword => 
                                                p.title.toLowerCase().includes(keyword.toLowerCase()) ||
                                                (p.description && p.description.toLowerCase().includes(keyword.toLowerCase()))
                                            )
                                        );
                                        
                                        if (pagesByKeywords.length > 0) {
                                            console.log('âœ… Found pages by keywords:', pagesByKeywords.map(p => p.title));
                                            // ğŸ¯ FIX: Get userMessage from window context
                                            const currentUserMessage = window.lastUserMessage || '×¨×©×™××ª ××—×™×¨×™×';
                                            await displayPageOptions(pagesByKeywords, currentUserMessage);
                                        } else {
                                            // Still can't find - search for all store pages
                                            const allStorePages = (allPages || []).filter(p => p.pageType === 'store');
                                            if (allStorePages.length > 0) {
                                                console.log('âœ… Found store pages:', allStorePages.map(p => p.title));
                                                // ğŸ¯ FIX: Get userMessage from window context
                                                const currentUserMessage = window.lastUserMessage || '×¨×©×™××ª ××—×™×¨×™×';
                                                await displayPageOptions(allStorePages, currentUserMessage);
                                            } else {
                                                // Still can't find - show a helpful message
                                                console.warn('âš ï¸ Could not find pages mentioned in response');
                                                addStavMessage('×× ×™ ×¢×•×‘×“×ª ×¢×œ ×œ×”×‘×™× ×œ×š ××ª ×›×œ ×”××—×™×¨×™×... ğŸ˜Š', false);
                                            }
                                        }
                                    }
                                } else if (!userAskedForPriceList) {
                                    // Only display N8N response if it doesn't contain invented contact info OR missing prices
                                    // AND user didn't ask for price list
                                    addStavMessage(responseMessage, false);
                                } else {
                                    // User asked for price list but we couldn't find pages - show N8N response anyway
                                    console.warn('âš ï¸ User asked for price list but could not find pages');
                                    addStavMessage(responseMessage, false);
                                }
                                stavFirstReplySent = true;
                            } else if (responseMessage && responseMessage.length > 0 && hasInventedContactInfo) {
                                // N8N response contains invented contact info - filter it out
                                console.warn('âš ï¸ N8N response contains invented contact info - filtering out');
                                // Remove phone numbers, addresses, emails from response
                                let filteredMessage = responseMessage
                                    .replace(/(?:×˜×œ×¤×•×Ÿ|×˜×œ×¤×•× ×™×|ğŸ“|phone).*?(?:\d{3}[-.\s]?\d{3}[-.\s]?\d{4}|\d{10})/gi, '')
                                    .replace(/(?:×›×ª×•×‘×ª|address|ğŸ ).*?(?:×¨×—×•×‘|street|×‘×™×ª)[^\.]*/gi, '')
                                    .replace(/(?:××™××™×™×œ|email|ğŸ“§)[^\.]*/gi, '')
                                    .replace(/\*\*×›×ª×•×‘×ª[^:]*:[^\.]*/gi, '')
                                    .replace(/\*\*×˜×œ×¤×•×Ÿ[^:]*:[^\.]*/gi, '')
                                    .replace(/\*\*××™××™×™×œ[^:]*:[^\.]*/gi, '')
                                    .replace(/\s+/g, ' ')
                                    .trim();
                                
                                if (filteredMessage && filteredMessage.length > 10) {
                                    addStavMessage(filteredMessage, false);
                                    stavFirstReplySent = true;
                                } else {
                                    // Response was mostly invented contact info - don't display it
                                    console.warn('âš ï¸ N8N response was mostly invented contact info - skipping display');
                                    stavFirstReplySent = true;
                                }
                            }
                        } else {
                            // webhookResponse is not ok - handle error
                            const errorText = await webhookResponse.text().catch(() => '');
                            console.error('âŒ N8N webhook error:', webhookResponse.status, errorText);
                            // Remove typing indicator on error
                            const typingIndicator = document.getElementById('stav-typing-indicator');
                            if (typingIndicator) typingIndicator.remove();
                            // Only minimal error message - no fallback
                            addStavMessage('××•×¤×¡, ×™×© ×‘×¢×™×” ×¢× ×”×©×¨×ª. × ×¡×”/×™ ×©×•×‘ ×‘×¢×•×“ ×¨×’×¢ ğŸ˜Š', false);
                            stavFirstReplySent = true;
                        }
                    } catch (webhookError) {
                        console.error('âŒ Webhook error:', webhookError);
                        console.error('Error details:', webhookError.message, webhookError.stack);
                        // Remove typing indicator on error
                        const typingIndicator = document.getElementById('stav-typing-indicator');
                        if (typingIndicator) typingIndicator.remove();
                        // Only minimal error message - no fallback
                        addStavMessage('××•×¤×¡, ×™×© ×‘×¢×™×” ×¢× ×”×—×™×‘×•×¨. × ×¡×”/×™ ×©×•×‘ ×‘×¢×•×“ ×¨×’×¢ ğŸ˜Š', false);
                        stavFirstReplySent = true;
                }
                    
                    // No more built-in responses - everything goes through N8N
                
            } catch (error) {
                console.error('âŒ Error processing Stav message:', error);
                console.error('âŒ Error type:', error.name);
                console.error('âŒ Error message:', error.message);
                console.error('âŒ Error stack:', error.stack);
                
                // Remove typing indicator (safely)
                const typingIndicator = document.getElementById('stav-typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                } else {
                    // Fallback: remove by text content
                const messagesDiv = document.getElementById('stavChatMessages');
                const lastMessage = messagesDiv.lastElementChild;
                    if (lastMessage && (lastMessage.textContent.includes('××§×œ×™×“×”') || lastMessage.id === 'stav-typing-indicator')) {
                    lastMessage.remove();
                    }
                }
                
                // ğŸ¯ More specific error messages
                let errorMessage = '××•×¤×¡, ××©×”×• ×”×©×ª×‘×©. × ×¡×” ×©×•×‘.';
                
                if (error.name === 'TypeError' || error.message.includes('fetch')) {
                    errorMessage = '×‘×¢×™×” ×‘×—×™×‘×•×¨ ×œ×©×¨×ª. ×‘×“×•×§ ××ª ×”××™× ×˜×¨× ×˜ ×•× ×¡×” ×©×•×‘.';
                } else if (error.message.includes('API') || error.message.includes('TTS')) {
                    errorMessage = '×‘×¢×™×” ×¢× ×©×™×¨×•×ª ×”×“×™×‘×•×¨. ×”×”×•×“×¢×” ×ª×•×¦×’ ×‘×˜×§×¡×˜ ×‘×œ×‘×“.';
                } else if (error.message.includes('timeout')) {
                    errorMessage = '×”×©×¨×ª ×œ× ×”×’×™×‘. × ×¡×” ×©×•×‘ ×‘×¢×•×“ ×¨×’×¢.';
                }
                
                addStavMessage(errorMessage, false);
            }
        }

        function addStavMessage(message, isUser = false) {
            const messagesDiv = document.getElementById('stavChatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `stav-message ${isUser ? 'user' : 'bot'}`;
            
            // Remove emojis, asterisks, excessive punctuation, parentheses, dots, and HTML
            const cleanMessage = message
                .replace(/<[^>]*>/g, '') // Remove ALL HTML tags
                .replace(/&[^;]+;/g, '') // Remove HTML entities
                .replace(/[ğŸ˜ŠğŸ’¡ğŸ“ğŸ“ğŸ“§ğŸ ğŸ’°âœ…âŒğŸ”—ğŸ“„ğŸªğŸ‰ğŸ“ğŸ”§ğŸ‘ï¸ğŸ¯ğŸ”ğŸ“šğŸ“ğŸ”ŠğŸ¤ğŸ”´]/g, '')
                .replace(/\*\*/g, '')
                .replace(/\*/g, '')
                .replace(/\([^)]*\)/g, '') // Remove parentheses and content
                .replace(/\.{2,}/g, '') // Remove multiple dots
                .replace(/!+/g, '.') // Replace multiple ! with single .
                .replace(/\s+/g, ' ') // Replace multiple spaces with single
                .trim();
            
            messageDiv.textContent = cleanMessage;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // If this is a bot message AND user used voice input, speak it
            if (!isUser && cleanMessage && lastInputWasVoice) {
                setTimeout(() => {
                    speakText(cleanMessage);
                    // Reset voice flag after speaking starts (ready for next input)
                    lastInputWasVoice = false;
                }, 300);
            } else if (!isUser) {
                // Bot message but user didn't use voice - reset flag
                lastInputWasVoice = false;
            }
        }
        
        // Generate dialogue before showing results - asks clarifying questions
        function generateDialogueBeforeShowing(pages, userQuery) {
            if (!pages || pages.length === 0) return null;
            
            const query = userQuery.toLowerCase();
            const hasMultipleOptions = pages.length > 1;
            
            // If query is vague and has multiple results, ask clarifying question
            if (hasMultipleOptions && (
                query.includes('××ª× ×”') || 
                query.includes('××©×”×•') || 
                query.includes('××•×¦×¨') || 
                query.length < 10
            )) {
                const firstPage = pages[0];
                return `××¦××ª×™ ×œ×š ${pages.length} ××¤×©×¨×•×™×•×ª ××¢×•×œ×•×ª! ğŸ¯\n\n×œ××©×œ: **${firstPage.title}** ${firstPage.description ? `- ${firstPage.description.substring(0, 60)}...` : ''}\n\n××” ×‘×“×™×•×§ ××ª/×” ××—×¤×©/×ª? (××•×¦×¨ ×¡×¤×¦×™×¤×™, ××—×™×¨, ××™×§×•×, ×•×›×•') ğŸ˜Š`;
            }
            
            // If query is about specific business, verify it's the right one
            const businessPattern = /(?:××”|××™×¤×”|××™×–×”|×©×œ|××ª)\s+([×-×ª]{2,})/;
            const businessMatch = userQuery.match(businessPattern);
            if (businessMatch && pages.length > 1) {
                const businessName = businessMatch[1].trim();
                const exactMatch = pages.find(p => p.title.toLowerCase().includes(businessName.toLowerCase()));
                if (exactMatch) {
                    return null; // Already have exact match, show it directly
                }
            }
            
            return null; // No dialogue needed
        }
        
        // Generate smart recommendations with selling points
        function generateSmartRecommendation(pages, userQuery) {
            if (!pages || pages.length === 0) return null;
            
            const topPage = pages[0];
            const query = userQuery.toLowerCase();
            
            let recommendation = '';
            
            // Detect user intent
            const isCarProblem = query.includes('×¨×›×‘') || query.includes('×”×œ×š') || query.includes('×§×œ×§×•×œ') || query.includes('×ª×§×œ×”');
            const isGift = query.includes('××ª× ×”') || query.includes('××ª× ×•×ª');
            const isService = query.includes('×©×™×¨×•×ª') || query.includes('×¦×¨×™×š');
            const isPriceSearch = query.includes('×›××”') || query.includes('××—×™×¨') || query.includes('â‚ª');
            
            // Build smart recommendation based on intent
            if (isCarProblem) {
                recommendation = `ğŸ”§ **×”××œ×¦×” ×©×œ×™:** ${topPage.title} × ×¨××” ×”×›×™ ××ª××™× ×œ×‘×¢×™×” ×©×œ×š! `;
                if (topPage.liveProducts && topPage.liveProducts.length > 0) {
                    const carProducts = topPage.liveProducts.filter(p => 
                        p.name.toLowerCase().includes('×—×œ×£') || 
                        p.name.toLowerCase().includes('×¤× ×¡') || 
                        p.name.toLowerCase().includes('××¦×‘×¨') ||
                        p.name.toLowerCase().includes('×‘×œ×') ||
                        p.name.toLowerCase().includes('×¦××™×’')
                    );
                    if (carProducts.length > 0) {
                        recommendation += `×™×© ×œ×”× ${carProducts.length} ××•×¦×¨×™× ×¨×œ×•×•× ×˜×™×™× ×œ×‘×¢×™×” ×©×œ×š, ×›×•×œ×œ: ${carProducts.slice(0, 2).map(p => p.name).join(', ')}. `;
                    }
                }
                if (topPage.liveContactInfo && topPage.liveContactInfo.phone) {
                    recommendation += `ğŸ“ **×˜×œ×¤×•×Ÿ:** ${topPage.liveContactInfo.phone} - ××ª×” ×™×›×•×œ ×œ×”×ª×§×©×¨ ×¢×›×©×™×•!`;
                }
            } else if (isGift) {
                recommendation = `ğŸ **×”××œ×¦×” ××•×©×œ××ª:** ${topPage.title} ××¦×™×¢×™× ××ª× ×•×ª ××¢×•×œ×•×ª! `;
                if (topPage.liveProducts && topPage.liveProducts.length > 0) {
                    const cheapest = topPage.liveProducts.reduce((min, p) => p.price < min.price ? p : min, topPage.liveProducts[0]);
                    const expensive = topPage.liveProducts.reduce((max, p) => p.price > max.price ? p : max, topPage.liveProducts[0]);
                    recommendation += `×™×© ×œ×”× ${topPage.liveProducts.length} ××•×¦×¨×™×, ××ª×—×™×œ ×-â‚ª${cheapest.price} ×•×¢×“ â‚ª${expensive.price}. `;
                }
                if (pages.length > 1) {
                    recommendation += `ğŸ’¡ **×˜×™×¤:** ×™×© ×¢×•×“ ${pages.length - 1} ×¢×¡×§×™× ×©××¤×©×¨ ×œ×”×©×•×•×ª - ×ª×¨××” ××ª ×›×œ ×”××•×¤×¦×™×•×ª ×œ××˜×”!`;
                }
            } else if (isPriceSearch) {
                recommendation = `ğŸ’° **×”××—×™×¨×™× ×”×˜×•×‘×™× ×‘×™×•×ª×¨:** `;
                const prices = pages.slice(0, 3).flatMap(p => 
                    (p.liveProducts || []).map(prod => ({ page: p.title, product: prod.name, price: prod.price }))
                ).sort((a, b) => a.price - b.price).slice(0, 3);
                
                if (prices.length > 0) {
                    prices.forEach((item, idx) => {
                        recommendation += `${idx + 1}. ${item.product} ×‘-${item.page} - â‚ª${item.price} | `;
                    });
                    recommendation = recommendation.slice(0, -3) + '.';
                }
            } else {
                // General recommendation - friendlier tone
                recommendation = `âœ¨ **××¦××ª×™ ×œ×š ××©×”×• ××¢×•×œ×”!** ${topPage.title} × ×¨××” ×”×›×™ ××ª××™× ×œ××” ×©××ª/×” ××—×¤×©/×ª! `;
                if (topPage.description) {
                    recommendation += `${topPage.description.substring(0, 80)}... `;
                }
                if (topPage.liveContactInfo && topPage.liveContactInfo.city) {
                    recommendation += `ğŸ“ ×××•×§× ×‘-${topPage.liveContactInfo.city}. `;
                }
                if (topPage.liveProducts && topPage.liveProducts.length > 0) {
                    recommendation += `×™×© ×œ×”× ${topPage.liveProducts.length} ××•×¦×¨×™× ×–××™× ×™× ×¢×›×©×™×•! ğŸ˜Š`;
                }
            }
            
            return recommendation || null;
        }
        
        // ğŸ¯ NEW: Generate text response with REAL data from pages
        async function generateTextResponseWithRealData(pages, userMessage, includeLinks = false, showFullDescription = false) {
            if (!pages || pages.length === 0) return '';
            
            let textResponse = '';
            const pageCount = Math.min(pages.length, 5); // Limit to top 5
            
            // ğŸ¯ Check if user is asking to see website/link
            const userWantsLink = includeLinks || (userMessage && (
                /×ª×¨××”.*××ª×¨|×ª×¨××”.*×“×£|×ª×¨××™.*××ª×¨|×ª×¨××™.*×“×£|×”×¨××”.*××ª×¨|×œ×¨××•×ª.*××ª×¨|××¤×©×¨.*××ª×¨|×§×™×©×•×¨|×¤×ª×—.*××ª×¨|×œ×™× ×§|link|××ª×¨.*×©×œ|×œ×“×£.*×©×œ|×¤×ª×™×—×ª.*××ª×¨|×ª×¨××•.*××ª×¨|×”×¦×’.*××ª×¨/i.test(userMessage)
            ));
            
            // ğŸ¯ NEW: Check if user explicitly asked for product list (show ALL products, not summary)
            const userAskedForProductList = userMessage && (
                /×ª× ×™?.*×¨×©×™××ª.*××•×¦×¨×™×|×ª× ×™?.*××ª.*×¨×©×™××ª.*××•×¦×¨×™×|×ª×¨××™.*××•×¦×¨×™×|×ª×¨××™.*××—×™×¨×™×|×¨×©×™××ª.*××—×™×¨×™×|××•×¦×¨×™×.*×•××—×™×¨×™×|×”×¨××™.*××•×¦×¨×™×|(?:×”)?××—×™×¨×™×\s+×©×œ|××”.*×”××•×¦×¨×™×|××™×–×”.*××•×¦×¨×™×|×›×œ.*×”××•×¦×¨×™×/i.test(userMessage)
            );
            
            // ğŸ¯ NEW: Check if results are from different city than requested
            const notInRequestedCity = pages[0]?.notInRequestedCity;
            const requestedCity = pages[0]?.requestedCity;
            const actualCity = pages[0]?.actualCity;
            
            // ğŸ¯ Check if user is asking for contact details specifically
            const userWantsContactInfo = userMessage && (
                /×˜×œ×¤×•×Ÿ|××¡×¤×¨|××™×š ×œ×¤× ×•×ª|××™×š ×œ×™×¦×•×¨ ×§×©×¨|×›×ª×•×‘×ª|××™×™×œ|××™×¤×”|×”×™×›×Ÿ|×¤×¨×˜×™ ×§×©×¨|×¤×¨×˜×™× × ×•×¡×¤×™×/i.test(userMessage)
            );
            
            // Helper function: Convert number to Hebrew words
            const numberToHebrewWords = (num) => {
                const hebrewNumbers = {
                    2: '×©×ª×™',
                    3: '×©×œ×•×©',
                    4: '××¨×‘×¢',
                    5: '×—××©',
                    6: '×©×©',
                    7: '×©×‘×¢',
                    8: '×©××•× ×”',
                    9: '×ª×©×¢',
                    10: '×¢×©×¨'
                };
                return hebrewNumbers[num] || num.toString(); // Fallback to number if > 10
            };
            
            // Friendly opening message - VERY SHORT and conversational
            if (notInRequestedCity && requestedCity) {
                // Results found, but not in requested city
                textResponse += `×œ× ××¦××ª×™ ×‘${requestedCity}, ××‘×œ ×™×©`;
                if (actualCity && actualCity !== '×œ× ×™×“×•×¢') {
                    textResponse += ` ×‘${actualCity}:\n\n`;
                } else {
                    textResponse += `:\n\n`;
                }
            } else if (pageCount === 1) {
                textResponse += `××¦××ª×™ ××ª ${pages[0].title}.\n\n`;
            } else {
                textResponse += `×™×© ${numberToHebrewWords(pageCount)} ××¤×©×¨×•×™×•×ª:\n\n`;
            }
            
            // For each page, extract REAL data and format as text
            for (let i = 0; i < pageCount; i++) {
                const page = pages[i];
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                
                try {
                    // Fetch live data
                    const pageResponse = await fetch(pageUrl);
                    if (!pageResponse.ok) continue;
                    
                    const html = await pageResponse.text();
                    const contactInfo = extractLiveContactInfo(html);
                    const products = extractLiveProducts(html);
                    
                    // Build text response - SUPER SHORT like talking to a friend
                    if (pageCount === 1) {
                        // Single result - name is already in "××¦××ª×™ ××ª X"
                        // Only show description if showFullDescription is true (e.g., after user says "yes")
                        if (showFullDescription) {
                            const liveDesc = extractLiveDescription(html);
                            if (liveDesc && liveDesc.length > 0) {
                                textResponse += `${liveDesc}\n`;
                            }
                        }
                    } else {
                        // Multiple results - numbered list of names only
                        textResponse += `${i + 1}. ${page.title}`;
                        
                        // Add SHORT description for multiple results
                        if (page.description && !page.description.includes('page') && page.description.trim().length > 0) {
                            let shortDesc = page.description.trim();
                            if (shortDesc.length > 60) {
                                const lastSpace = shortDesc.lastIndexOf(' ', 60);
                                shortDesc = lastSpace > 30 ? shortDesc.substring(0, lastSpace) : shortDesc.substring(0, 60);
                            }
                            textResponse += ` - ${shortDesc}`;
                        }
                    }
                    
                    textResponse += `\n`;
                    
                    // ğŸ¯ ONLY show contact info if user specifically asked for it
                    if (userWantsContactInfo) {
                        let contactLine = [];
                        if (contactInfo.phone) {
                            contactLine.push(contactInfo.phone);
                        }
                        if (contactInfo.city && !textResponse.includes(contactInfo.city)) {
                            contactLine.push(contactInfo.city);
                        }
                        if (contactLine.length > 0) {
                            textResponse += `   ${contactLine.join(', ')}\n`;
                        }
                    }
                    
                    // ğŸ¯ ONLY show products if user explicitly asked for them or for product list
                    if (userAskedForProductList && products && products.length > 0) {
                        // Sort products by price
                        const sortedProducts = [...products].sort((a, b) => {
                            const priceA = parseFloat(String(a.price || 0).replace(/[,\s]/g, ''));
                            const priceB = parseFloat(String(b.price || 0).replace(/[,\s]/g, ''));
                            return priceA - priceB;
                        });
                        
                        // Filter valid products
                        const validProducts = sortedProducts.filter(product => {
                            const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                            return price >= 10 && price < 100000;
                        });
                        
                        if (validProducts.length > 0) {
                            textResponse += `\n××•×¦×¨×™×:\n`;
                            validProducts.forEach((product) => {
                                const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                textResponse += `   â€¢ ${product.name} - â‚ª${price.toLocaleString()}\n`;
                            });
                        }
                    }
                    
                    // ğŸ¯ ONLY show link if user explicitly asked for it AND not showing preview
                    // (Don't show "click here" when iframe is already open!)
                    if (userWantsLink && includeLinks !== 'preview') {
                        textResponse += `ğŸ”— [×œ×—×¥ ×›××Ÿ ×œ×¦×¤×™×™×” ×‘××ª×¨](${pageUrl})\n`;
                    }
                    
                    textResponse += `\n`;
                } catch (error) {
                    console.error(`âŒ Error generating text response for "${page.title}":`, error);
                }
            }
            
            // ğŸ¯ Add SHORT friendly hint at the end - ONLY if NOT showing link/contact/products
            console.log('ğŸ” [HINT CHECK] userWantsLink:', userWantsLink, 'userWantsContactInfo:', userWantsContactInfo, 'userAskedForProductList:', userAskedForProductList, 'pageCount:', pageCount);
            if (!userWantsLink && !userWantsContactInfo && !userAskedForProductList && pageCount > 0) {
                if (pageCount > 1) {
                    textResponse += `\n\n××™×–×” ×ª×¨×¦×”?`;
                    console.log('âœ… Added hint: "××™×–×” ×ª×¨×¦×”?"');
                } else {
                    textResponse += `\n\n×¨×•×¦×” ×¤×¨×˜×™× × ×•×¡×¤×™×?`;
                    console.log('âœ… Added hint: "×¨×•×¦×” ×¤×¨×˜×™× × ×•×¡×¤×™×?"');
                }
            } else {
                console.log('âš ï¸ Skipped hint - one of conditions failed');
            }
            
            return textResponse.trim();
        }
        
        // Display page options list (without previews) - ALWAYS fetch fresh data, ORGANIZED BY CATEGORIES
        // message can be the user's query to detect if they want full price list
        // showTextResponseFirst: if true, show text response with real data before buttons
        async function displayPageOptions(pages, message, showTextResponseFirst = false) {
            const messagesDiv = document.getElementById('stavChatMessages');
            
            // ğŸ¯ FIX: If showTextResponseFirst is true, generate and show text response with real data FIRST
            if (showTextResponseFirst) {
                console.log('ğŸ“ Generating text response with real data first...');
                // ğŸ¯ Check if user wants link
                const includeLinks = message && /×ª×¨××”.*××ª×¨|×ª×¨××”.*×“×£|×§×™×©×•×¨|×¤×ª×—.*××ª×¨|×œ×™× ×§|link/i.test(message);
                const textResponse = await generateTextResponseWithRealData(pages, message, includeLinks);
                if (textResponse && textResponse.trim().length > 0) {
                    addStavMessage(textResponse, false);
                    console.log('âœ… Added text response with real data');
                }
            }
            
            // ğŸ¯ CRITICAL: ALWAYS fetch LIVE data from pages - NO cached metadata!
            // User requirement: "×©×•× × ×ª×•×Ÿ ×œ× ××•×‘× ×” ×”×›×œ ×¦×¨×™×š ×œ×”×™×•×ª ×“×™× ××™"
            // All data must be DYNAMIC from the actual live HTML pages
            console.log('ğŸ” ALWAYS fetching LIVE data (dynamic) for', pages.length, 'pages - NO cached metadata!');
            for (let i = 0; i < Math.min(pages.length, 5); i++) {
                const page = pages[i];
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                
                // ğŸ¯ ALWAYS fetch live HTML and extract data dynamically (NO metadata!)
                let contactInfo = { phone: null, phones: [], email: null, city: null, address: null };
                let products = [];
                
                try {
                    console.log(`ğŸ” Fetching LIVE data for "${page.title}" from ${pageUrl}`);
                    const pageResponse = await fetch(pageUrl);
                    if (pageResponse.ok) {
                        const html = await pageResponse.text();
                        // Extract LIVE contact info from HTML (dynamic, not cached)
                        contactInfo = extractLiveContactInfo(html);
                        // Extract LIVE products from HTML (dynamic, not cached)
                        products = extractLiveProducts(html);
                        console.log(`âœ… Extracted LIVE data for "${page.title}":`, {
                            phone: contactInfo.phone,
                            city: contactInfo.city,
                            productsCount: products.length
                        });
                    } else {
                        console.warn(`âš ï¸ Failed to fetch live data for "${page.title}"`);
                    }
                } catch (error) {
                    console.error(`âŒ Error fetching live data for "${page.title}":`, error);
                }
                
                // Store live data in page object for later use
                pages[i].liveContactInfo = contactInfo;
                pages[i].liveProducts = products;
            }
            
            // ğŸ¯ FIX: Sort pages by relevance score (if available) to show best recommendations first
            // Limit to top 5 pages for accurate recommendations (not all pages!)
            const sortedPages = [...pages].sort((a, b) => {
                // Sort by matchScore if available (from searchLivePages)
                const scoreA = a.matchScore || 0;
                const scoreB = b.matchScore || 0;
                if (scoreB !== scoreA) return scoreB - scoreA;
                
                // If same score, prefer pages with products
                const productsA = (a.liveProducts || []).length;
                const productsB = (b.liveProducts || []).length;
                if (productsB !== productsA) return productsB - productsA;
                
                // If same products count, prefer pages with contact info
                const contactA = (a.liveContactInfo?.phone ? 1 : 0) + (a.liveContactInfo?.city ? 1 : 0);
                const contactB = (b.liveContactInfo?.phone ? 1 : 0) + (b.liveContactInfo?.city ? 1 : 0);
                return contactB - contactA;
            });
            
            // Limit to top 5 pages for accurate recommendations
            const topPages = sortedPages.slice(0, 5);
            
            // Categorize top pages by type for better organization
            const categories = {
                stores: topPages.filter(p => p.pageType === 'store' || p.pageType === 'onlineStore'),
                services: topPages.filter(p => p.pageType === 'serviceProvider'),
                courses: topPages.filter(p => p.pageType === 'course'),
                events: topPages.filter(p => p.pageType === 'event'),
                other: topPages.filter(p => !['store', 'onlineStore', 'serviceProvider', 'course', 'event'].includes(p.pageType))
            };
            
            // Create options message with categories
            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'stav-message bot';
            optionsDiv.style.cssText = `
                background: #f3f4f6;
                border-radius: 12px;
                padding: 16px;
                margin: 12px 0;
            `;
            
            // ğŸ¯ FIX: Show accurate count - only top 5 recommendations
            const totalPages = topPages.length;
            const messageText = message || (totalPages > 0 ? `×”××œ×¦×•×ª ××“×•×™×§×•×ª - ××¦××ª×™ ${totalPages} ${totalPages === 1 ? '×“×£' : '×“×¤×™×'} ×”×›×™ ×¨×œ×•×•× ×˜×™×™×:` : '×œ× ××¦××ª×™ ×“×¤×™× ×¨×œ×•×•× ×˜×™×™×');
            let optionsHtml = `<div style="font-weight: 600; font-size: 16px; margin-bottom: 16px; color: #1f2937;">${messageText}</div>`;
            
            // Display by categories
            const categoryLabels = {
                stores: { emoji: 'ğŸª', label: '×—× ×•×™×•×ª', pages: categories.stores },
                services: { emoji: 'ğŸ”§', label: '×©×™×¨×•×ª×™×', pages: categories.services },
                courses: { emoji: 'ğŸ“', label: '×§×•×¨×¡×™×', pages: categories.courses },
                events: { emoji: 'ğŸ‰', label: '××™×¨×•×¢×™×', pages: categories.events },
                other: { emoji: 'ğŸ“„', label: '××—×¨', pages: categories.other }
            };
            
            // ğŸ¯ FIX: Show only top 5 recommendations, not all pages (for accuracy!)
            let pageIndex = 0;
            const maxPagesToShow = 5; // Show only top 5 recommendations for accuracy
            
            Object.entries(categoryLabels).forEach(([key, category]) => {
                if (category.pages.length > 0 && pageIndex < maxPagesToShow) {
                    optionsHtml += `<div style="margin-bottom: 16px;">`;
                    // Show count only if there are more pages in this category than we're showing
                    const showingCount = Math.min(category.pages.length, maxPagesToShow - pageIndex);
                    const countText = category.pages.length > showingCount ? ` (${showingCount} ××ª×•×š ${category.pages.length})` : ` (${category.pages.length})`;
                    optionsHtml += `<div style="font-weight: 600; font-size: 14px; color: #667eea; margin-bottom: 8px;">${category.emoji} ${category.label}${countText}</div>`;
                    
                    category.pages.forEach((page) => {
                        if (pageIndex >= maxPagesToShow) return;
                        
                        const index = pageIndex++;
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                // ALWAYS use fresh live data (just fetched above, not invented)
                const contact = page.liveContactInfo || {};
                const products = page.liveProducts || [];
                
                optionsHtml += `<div style="background: white; border-radius: 8px; padding: 12px; margin: 8px 0; border: 1px solid #e5e7eb;">`;
                optionsHtml += `<div style="font-weight: 600; font-size: 16px; color: #1f2937; margin-bottom: 8px;">${index + 1}. ${page.title}</div>`;
                
                // Only show description if it's from the actual page metadata (not invented)
                // Don't show fake descriptions
                if (page.description && page.description.length > 0 && !page.description.includes('page')) {
                    optionsHtml += `<div style="color: #6b7280; font-size: 14px; margin-bottom: 8px;">${page.description.substring(0, 100)}${page.description.length > 100 ? '...' : ''}</div>`;
                }
                
                // Show contact info ONLY if available from REAL metadata (not invented)
                // NEVER show invented contact info - only show if we have REAL data
                const hasRealContactInfo = (contact.phone && contact.phone.length > 0) || 
                                          (contact.city && contact.city.length > 0) || 
                                          (contact.email && contact.email.length > 0 && contact.email.includes('@')) ||
                                          (contact.address && contact.address.length > 0);
                
                if (hasRealContactInfo) {
                    optionsHtml += `<div style="font-size: 13px; color: #1e40af; margin-top: 8px; font-weight: 600;">`;
                    if (contact.phone && contact.phone.length > 0) {
                        optionsHtml += `ğŸ“ ${contact.phone}`;
                        // Add clickable tel link
                        optionsHtml += ` <a href="tel:${contact.phone.replace(/-/g, '')}" style="background: #10b981; color: white; padding: 4px 8px; border-radius: 4px; text-decoration: none; margin-right: 4px; font-size: 11px;">ğŸ“ ×”×ª×§×©×¨</a>`;
                    }
                    // Don't show additional phones - only show the main phone number
                    if (contact.city && contact.city.length > 0) {
                        optionsHtml += ` ğŸ“ ${contact.city}`;
                    }
                    if (contact.email && contact.email.length > 0 && contact.email.includes('@')) {
                        optionsHtml += ` ğŸ“§ ${contact.email}`;
                    }
                    if (contact.address && contact.address.length > 0) {
                        optionsHtml += ` ğŸ  ${contact.address}`;
                    }
                    optionsHtml += `</div>`;
                } else {
                    // No real contact info available - don't display anything (not even placeholder)
                    console.log(`âš ï¸ No real contact info for "${page.title}" - skipping display`);
                }
                
                // Show product count and highlights ONLY if available from live data (REAL products only)
                if (products && Array.isArray(products) && products.length > 0) {
                    // Validate products are real (have name and price)
                    const validProducts = products.filter(p => p && p.name && p.price && p.price > 0);
                    
                    if (validProducts.length > 0) {
                        // ğŸ¯ FIX: Check if user asked for full price list - if so, show ALL products with prices
                        const messageToCheck = message || window.lastUserMessage || '';
                        const isPriceListQuery = messageToCheck && (
                            messageToCheck.toLowerCase().includes('×¨×©×™××ª ××—×™×¨×™×') ||
                            messageToCheck.toLowerCase().includes('×ª×¨××™ ××•×¦×¨×™×') ||
                            messageToCheck.toLowerCase().includes('×ª×¨××™ ××—×™×¨×™×') ||
                            messageToCheck.toLowerCase().includes('××•×¦×¨×™× ×•××—×™×¨×™×') ||
                            (messageToCheck.toLowerCase().includes('×ª×¨××™') && 
                             (messageToCheck.toLowerCase().includes('××•×¦×¨') || messageToCheck.toLowerCase().includes('××—×™×¨'))) || 
                            messageToCheck.toLowerCase().includes('×¨×©×™××ª ××•×¦×¨×™×') ||
                            messageToCheck.toLowerCase().includes('××—×™×¨×™× ×©×œ') ||
                            messageToCheck.toLowerCase().includes('×›×œ ×”××—×™×¨×™×') ||
                            messageToCheck.toLowerCase().includes('×›×œ ×”××•×¦×¨×™×')
                        );
                        
                        console.log('ğŸ” Checking for price list query:', {
                            message: message,
                            lastUserMessage: window.lastUserMessage,
                            messageToCheck: messageToCheck,
                            isPriceListQuery: isPriceListQuery
                        });
                        
                        if (isPriceListQuery) {
                            // Show ALL products with prices (sorted by price)
                            const sortedByPrice = [...validProducts].sort((a, b) => {
                                const getNumericPrice = (price) => {
                                    if (typeof price === 'number') return price;
                                    const priceStr = String(price).replace(/[â‚ª,\s]/g, '');
                                    const numPrice = parseFloat(priceStr) || 0;
                                    return numPrice;
                                };
                                return getNumericPrice(a.price) - getNumericPrice(b.price);
                            });
                            
                            optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 8px; margin-bottom: 8px;">ğŸ’° ${validProducts.length} ××•×¦×¨×™× ×–××™× ×™×:</div>`;
                            optionsHtml += `<div style="margin-top: 4px; margin-bottom: 8px;">`;
                            sortedByPrice.forEach((product, idx) => {
                                optionsHtml += `<div style="font-size: 12px; color: #374151; margin-top: 4px; padding: 4px 0; border-bottom: 1px solid #e5e7eb;">
                                    <span style="font-weight: 600;">${idx + 1}.</span> ${product.name} - <span style="color: #059669; font-weight: 600;">â‚ª${product.price}</span>
                                </div>`;
                            });
                            optionsHtml += `</div>`;
                            
                            // Still show cheapest as highlight
                            const cheapestProduct = sortedByPrice[0];
                            if (cheapestProduct && cheapestProduct.name && cheapestProduct.price) {
                                optionsHtml += `<div style="font-size: 12px; color: #059669; margin-top: 4px; font-weight: 600; padding: 4px 8px; background: #ecfdf5; border-radius: 4px; display: inline-block;">â­ ×”×›×™ ×–×•×œ: ${cheapestProduct.name} - â‚ª${cheapestProduct.price}</div>`;
                            }
                        } else {
                            // Normal display - show only cheapest product
                            optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 4px;">ğŸ’° ${validProducts.length} ××•×¦×¨×™× ×–××™× ×™×</div>`;
                            
                            // Show cheapest product as selling point
                            // Sort by price (numeric) to find the ACTUAL cheapest
                            // ğŸ¯ FIX: Always show cheapest, even if only 1 product
                            const sortedByPrice = [...validProducts].sort((a, b) => {
                                // Extract numeric price value - handle multiple formats
                                const getNumericPrice = (price) => {
                                    if (typeof price === 'number') return price;
                                    const priceStr = String(price).replace(/[â‚ª,\s]/g, '');
                                    const numPrice = parseFloat(priceStr) || 0;
                                    return numPrice;
                                };
                                
                                const priceA = getNumericPrice(a.price);
                                const priceB = getNumericPrice(b.price);
                                return priceA - priceB;
                            });
                            
                            const cheapestProduct = sortedByPrice[0];
                            if (cheapestProduct && cheapestProduct.name && cheapestProduct.price) {
                                // ğŸ¯ FIX: Always show cheapest product, even if only one product
                                optionsHtml += `<div style="font-size: 12px; color: #059669; margin-top: 4px; font-weight: 600;">â­ ×”×›×™ ×–×•×œ: ${cheapestProduct.name} - â‚ª${cheapestProduct.price}</div>`;
                            }
                        }
                    } else {
                        // No valid products found (empty array or invalid data)
                        optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 4px; font-style: italic;">ğŸ’¡ ×œ×—×¥ ×¢×œ "×¦×¤×” ×‘×“×£" ×›×“×™ ×œ×¨××•×ª ×¤×¨×˜×™× × ×•×¡×¤×™×</div>`;
                    }
                } else {
                    // No products array or empty - DON'T invent products
                    optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 4px; font-style: italic;">ğŸ’¡ ×œ×—×¥ ×¢×œ "×¦×¤×” ×‘×“×£" ×›×“×™ ×œ×¨××•×ª ×¤×¨×˜×™× × ×•×¡×¤×™×</div>`;
                }
                        
                        // Add selling point badges
                        if (pageIndex === 1) {
                            optionsHtml += `<div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; margin-top: 8px; display: inline-block;">ğŸ† ××•××œ×¥ ×‘×™×•×ª×¨</div>`;
                        }
                        
                        // ğŸ¯ FIX: User wants ONLY text conversation - NO preview buttons!
                        // Only show "×¦×¤×” ×‘×“×£" link
                        const fullPageUrl = `${window.location.origin}${pageUrl}`;
                        optionsHtml += `<div style="margin-top: 12px;">
                            <a href="${fullPageUrl}" target="_blank" style="
                                display: inline-block;
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                color: white;
                                padding: 8px 16px;
                                border-radius: 6px;
                                text-decoration: none;
                                font-weight: 600;
                                font-size: 14px;
                                cursor: pointer;
                            ">ğŸ‘ï¸ ×¦×¤×” ×‘×“×£</a>
                        </div>`;
                        
                        optionsHtml += `</div>`;
                    });
                    
                    optionsHtml += `</div>`; // Close category section
                }
            });
            
            optionsDiv.innerHTML = optionsHtml;
            messagesDiv.appendChild(optionsDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // Store pages in window for preview function
            window.stavCurrentPages = pages;
        }
        
        // Open page preview when user clicks button
        function openPagePreview(index, userId, pageId) {
            const messagesDiv = document.getElementById('stavChatMessages');
            const pages = window.stavCurrentPages || [];
            
            if (pages[index]) {
                const page = pages[index];
                
                // Add confirmation message
                addStavMessage(`×¤×•×ª×— ××ª "${page.title}"...`, false);
                
                // Display the preview (async)
                setTimeout(async () => {
                    await displayPagePreview(page, 'stavChatMessages');
                }, 300);
            }
        }
        
        // Ask user if they want to see the website BEFORE showing it
        function askToShowWebsite(pages) {
            const messagesDiv = document.getElementById('stavChatMessages');
            
            const askDiv = document.createElement('div');
            askDiv.className = 'stav-message bot';
            askDiv.style.cssText = `
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border-radius: 12px;
                padding: 16px;
                margin: 12px 0;
            `;
            
            let askHtml = `<div style="font-weight: 600; font-size: 16px; margin-bottom: 12px;">ğŸ‘ï¸ ×”×× ×ª×¨×¦×” ×œ×¨××•×ª ××ª ×”×“×£?</div>`;
            askHtml += `<div style="font-size: 14px; opacity: 0.95; margin-bottom: 16px;">××¤×©×¨ ×œ×¨××•×ª ×¤×¨×˜×™× × ×•×¡×¤×™×, ××•×¦×¨×™× ×•×ª×¦×•×’×” ××§×“×™××” ×©×œ ×”×“×£</div>`;
            
            pages.slice(0, 3).forEach((page, index) => {
                askHtml += `<button onclick="confirmShowPage(${index})" style="
                    background: rgba(255,255,255,0.2);
                    color: white;
                    border: 2px solid white;
                    border-radius: 8px;
                    padding: 10px 16px;
                    margin: 4px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 14px;
                    transition: all 0.2s;
                    width: calc(33% - 8px);
                " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">${page.title}</button>`;
            });
            
            askHtml += `<div style="margin-top: 12px; font-size: 12px; opacity: 0.9;">ğŸ’¡ ××• ×œ×—×¥ ×¢×œ "×¦×¤×” ×‘×“×£" ×‘×ª××•× ×” ×œ××¢×œ×”</div>`;
            
            askDiv.innerHTML = askHtml;
            messagesDiv.appendChild(askDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // Store pages for confirmShowPage function
            window.stavCurrentPages = pages;
        }
        
        // Confirm and show page when user clicks - FIRST show text details, THEN ask about preview
        async function confirmShowPage(index) {
            const pages = window.stavCurrentPages || [];
            if (pages[index]) {
                const page = pages[index];
                
                // FIRST: Display text details (already extracted in displayPageOptions)
                // Remove the "ask to show" message
                const messagesDiv = document.getElementById('stavChatMessages');
                const askDivs = messagesDiv.querySelectorAll('.stav-message.bot');
                askDivs.forEach(div => {
                    if (div.innerHTML.includes('×”×× ×ª×¨×¦×” ×œ×¨××•×ª ××ª ×”×“×£')) {
                        div.remove();
                    }
                });
                
                // Show text details (fetch fresh if needed)
                await displayPagePreview(page, 'stavChatMessages');
                
                // THEN ask if they want to open the actual website
                const openDiv = document.createElement('div');
                openDiv.className = 'stav-message bot';
                openDiv.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border-radius: 12px;
                    padding: 16px;
                    margin: 12px 0;
                `;
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                openDiv.innerHTML = `
                    <div style="font-weight: 600; font-size: 16px; margin-bottom: 12px;">ğŸ‘ï¸ ×”×× ×ª×¨×¦×” ×œ×¤×ª×•×— ××ª ×”××ª×¨?</div>
                    <div style="font-size: 14px; opacity: 0.95; margin-bottom: 16px;">××¤×©×¨ ×œ×¤×ª×•×— ××ª ×”×“×£ ×”××œ× ×‘×“×¤×“×¤×Ÿ</div>
                    <button onclick="window.open('${pageUrl}', '_blank')" style="
                        background: rgba(255,255,255,0.2);
                        color: white;
                        border: 2px solid white;
                        border-radius: 8px;
                        padding: 10px 16px;
                        cursor: pointer;
                        font-weight: 600;
                        font-size: 14px;
                        transition: all 0.2s;
                        margin-right: 8px;
                    " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">×¤×ª×— ×‘××ª×¨</button>
                    <button onclick="this.parentElement.remove()" style="
                        background: rgba(255,255,255,0.1);
                        color: white;
                        border: 1px solid rgba(255,255,255,0.5);
                        border-radius: 8px;
                        padding: 10px 16px;
                        cursor: pointer;
                        font-size: 14px;
                    ">×œ× ×¢×›×©×™×•</button>
                `;
                messagesDiv.appendChild(openDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        }
        
        // Helper: Scroll iframe to main title or hero section
        function scrollIframeToMainTitle(iframe) {
            try {
                if (!iframe) return;
                const doc = iframe.contentDocument || iframe.contentWindow?.document;
                if (!doc) return;
                const selectors = [
                    '[data-main-title]',
                    '[role="heading"][aria-level="1"]',
                    'header h1',
                    'main h1',
                    'h1',
                    'main h2',
                    'h2',
                    'h3', // Added h3 as fallback
                    '[itemprop="name"]',
                    '[data-title], [data-page-title]',
                    "[id*='title' i]", "[class*='title' i]",
                    "[id*='header' i] h1, [class*='header' i] h1",
                    "[id*='hero' i]", "[class*='hero' i]", // More hero selectors
                    '#hero h1, .hero h1, #hero, .hero',
                    "[id*='main' i]", "[class*='main' i]", // More main selectors
                    '#main, main',
                    '.container h1', '.container h2', // Container selectors
                    '#content, .content', // Content area
                    'article h1', 'article h2', 'article' // Article selectors
                ];
                let target = null;
                for (const sel of selectors) {
                    const el = doc.querySelector(sel);
                    if (el) { target = el; break; }
                }
                // Heuristic: find first prominent heading-like element by font-size/weight near top
                if (!target) {
                    try {
                        const walkerRoot = doc.body || doc.documentElement;
                        const candidates = Array.from(walkerRoot.querySelectorAll('h1, h2, h3, h4, div, p, span, [class*="title" i], [class*="heading" i], [class*="hero" i]'));
                        const scored = candidates.map(el => {
                            const cs = iframe.contentWindow.getComputedStyle(el);
                            const fontSize = parseFloat(cs.fontSize) || 0;
                            const fontWeight = parseInt(cs.fontWeight, 10) || 400;
                            const rect = el.getBoundingClientRect();
                            const distance = Math.max(0, rect.top);
                            const textLength = (el.textContent || '').trim().length;
                            // Prefer large, bold, near top, with reasonable text length (10-100 chars)
                            const textScore = (textLength >= 10 && textLength <= 100) ? 15 : 0;
                            const score = fontSize * 3 + (fontWeight >= 600 ? 30 : 0) + textScore - distance * 0.02;
                            return { el, score, fontSize, distance };
                        }).filter(x => {
                            const rect = x.el.getBoundingClientRect();
                            return x.el && x.score > 0 && rect.top >= 0 && rect.top < 1400 && x.fontSize >= 16;
                        });
                        if (scored.length > 0) {
                            scored.sort((a,b) => b.score - a.score);
                            target = scored[0].el;
                            console.log('âœ… Found title via smart scoring:', target.tagName, 'fontSize:', scored[0].fontSize, 'score:', scored[0].score);
                        }
                    } catch (_) {}
                }
                // Try match og:title to a heading text
                if (!target) {
                    const og = doc.querySelector('meta[property="og:title"]')?.content || '';
                    const titleTag = doc.querySelector('title')?.textContent || '';
                    const expected = (og || titleTag || '').trim();
                    if (expected) {
                        const headings = Array.from(doc.querySelectorAll('h1, h2, [role="heading"]'));
                        target = headings.find(h => (h.textContent || '').trim().includes(expected)) || null;
                    }
                }
                // Compute sticky header offset if exists
                let offset = 10; // Very small offset to show more content
                try {
                    const sticky = doc.querySelector('header, .sticky, .fixed');
                    if (sticky) {
                        const rect = sticky.getBoundingClientRect();
                        if (rect && rect.height) offset = Math.min(40, Math.max(10, rect.height + 5));
                    }
                } catch (_) {}
                let y = 0;
                if (target) {
                    const rect = target.getBoundingClientRect();
                    y = rect.top + (iframe.contentWindow?.pageYOffset || 0) - offset;
                    console.log('âœ… Found title element:', target.tagName, ', scrolling to:', y);
                } else {
                    // If no title found, scroll to a fixed position that shows content
                    y = 400; // Scroll to 400px - should show main content
                    console.log('âš ï¸ No title found, scrolling to fallback position:', y);
                }
                // ğŸ¬ Smooth auto-scroll: scroll directly from top to the main title
                const targetY = Math.max(0, y);
                iframe.contentWindow?.scrollTo({ top: 0, behavior: 'instant' }); // Start from top
                iframe.style.opacity = '1';
                
                // ğŸ¬ Auto-scroll smoothly to the main title (faster, 2 seconds)
                setTimeout(() => {
                    let currentY = 0;
                    const duration = 2000; // 2 seconds (faster!)
                    const startTime = performance.now();
                    
                    function animateScroll(currentTime) {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Ease-in-out function for smooth acceleration/deceleration
                        const easeInOut = progress < 0.5
                            ? 2 * progress * progress
                            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                        
                        currentY = targetY * easeInOut;
                        iframe.contentWindow?.scrollTo({ top: currentY, behavior: 'auto' });
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateScroll);
                        }
                    }
                    
                    requestAnimationFrame(animateScroll);
                }, 300); // Start scrolling faster (300ms delay instead of 500ms)
            } catch (_) {
                if (iframe) iframe.style.opacity = '1';
            }
        }
        
        // Display page preview in Stav chat - ALWAYS fetch fresh data from page
        async function displayPagePreview(page, containerId) {
            console.log('ğŸ–¼ï¸ displayPagePreview() called for:', page?.title);
            
            const container = document.getElementById(containerId);
            if (!container) {
                console.error('âŒ Container not found:', containerId);
                return;
            }
            
            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
            
            // ALWAYS fetch fresh data from the actual page HTML
            console.log('ğŸ” Fetching fresh page data for preview:', pageUrl);
            try {
                const pageResponse = await fetch(pageUrl);
                if (pageResponse.ok) {
                    const html = await pageResponse.text();
                    
                    // Extract live data from HTML
                    const liveContactInfo = extractLiveContactInfo(html);
                    const liveProducts = extractLiveProducts(html);
                    
                    // Update page with live data
                    page.liveContactInfo = liveContactInfo;
                    page.liveProducts = liveProducts;
                    
                    console.log('âœ… Loaded live data:', {
                        contact: liveContactInfo,
                        productsCount: liveProducts.length
                    });
                } else {
                    console.error('âŒ Failed to fetch page:', pageResponse.status);
                }
            } catch (error) {
                console.error('âŒ Error fetching page data:', error);
            }
            
            // ğŸ¯ Just show the iframe preview - NO text repetition!
            
            // AUTOMATICALLY show iframe preview at the end - Stav opens it herself
            // LARGER preview - shows more of the website
            const previewDiv = document.createElement('div');
            previewDiv.className = 'stav-message bot';
            previewDiv.style.cssText = `
                margin: 16px 0;
                border: 2px solid #e5e7eb;
                border-radius: 12px;
                overflow: hidden;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                opacity: 0;
                transform: translateY(20px);
                transition: all 0.5s ease;
                height: 800px;
                max-height: 80vh;
            `;
            
            previewDiv.innerHTML = `
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                    <span>ğŸ‘ï¸</span>
                    <span>×ª×¦×•×’×” ××§×“×™××” - ${page.title || '×”×“×£'}</span>
                </div>
                <div style="position: relative; height: calc(100% - 48px); overflow: hidden; background: #f9fafb; display: block;">
                    <iframe id="stav-preview-iframe" src="${pageUrl}" style="width: 100%; height: 100%; border: none; opacity: 0; transition: opacity 0.8s ease; display: block; margin: 0;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
                </div>
            `;
            
            container.appendChild(previewDiv);
            container.scrollTop = container.scrollHeight;
            
            // Animate iframe in after a delay
            setTimeout(() => {
                previewDiv.style.opacity = '1';
                previewDiv.style.transform = 'translateY(0)';
            }, 500);

            // After iframe mounts, adjust height to content and scroll to main heading/center
            setTimeout(() => {
                const iframe = previewDiv.querySelector('#stav-preview-iframe');
                if (!iframe) {
                    console.error('âŒ Iframe not found!');
                    return;
                }
                
                console.log('ğŸ¬ Iframe element found, waiting for load...');
                
                // Handle iframe load
                iframe.addEventListener('load', () => {
                    console.log('âœ… Iframe loaded successfully!');
                    // Fade in the iframe
                    iframe.style.opacity = '1';
                    
                    try {
                        const doc = iframe.contentDocument || iframe.contentWindow?.document;
                        if (doc) {
                            console.log('âœ… Can access iframe document - injecting styles');
                            // Inject compact preview styles to reduce visual length
                            const style = doc.createElement('style');
                            style.textContent = `
                                html, body { overscroll-behavior: none; }
                                body { padding-top: min(24px, 4vh); }
                                #hero, .hero { margin-bottom: 12px !important; }
                                section { margin-block: 12px !important; }
                                img, video { max-height: 48vh; object-fit: cover; }
                                header.sticky, header.fixed { position: sticky; top: 0; }
                            `;
                            doc.head && doc.head.appendChild(style);
                            console.log('âœ… Styles injected into iframe');
                        } else {
                            console.warn('âš ï¸ Cannot access iframe document (possible CORS issue)');
                        }
                    } catch (error) {
                        console.warn('âš ï¸ Cannot inject styles into iframe:', error.message);
                    }
                    // Always attempt to scroll to main title using robust helper
                    scrollIframeToMainTitle(iframe);
                    // Retry scroll after components/styles settle
                    setTimeout(() => scrollIframeToMainTitle(iframe), 250);
                    setTimeout(() => scrollIframeToMainTitle(iframe), 900);
                }, { once: true });
                
                // Handle iframe errors
                iframe.addEventListener('error', (e) => {
                    console.error('âŒ Iframe failed to load:', e);
                    // Show error message in iframe
                    iframe.style.display = 'none';
                    const errorMsg = document.createElement('div');
                    errorMsg.style.cssText = 'padding: 40px; text-align: center; color: #dc2626; background: #fef2f2; border-radius: 8px; margin: 20px;';
                    errorMsg.innerHTML = `
                        <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
                        <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">×©×’×™××” ×‘×˜×¢×™× ×ª ×”×“×£</div>
                        <div style="font-size: 14px; color: #991b1b;">×œ× ×”×¦×œ×—× ×• ×œ×˜×¢×•×Ÿ ××ª ×ª×¦×•×’×ª ×”×“×£. × ×¡×” ×œ×œ×—×•×¥ ×¢×œ ×”×§×™×©×•×¨ ×œ××¢×œ×”.</div>
                    `;
                    iframe.parentElement.appendChild(errorMsg);
                });
            }, 50);
        }

        // Handle Enter key in Stav input
        // Check Stav status and hide if inactive
        async function checkStavStatus() {
            try {
                const response = await fetch('/api/stav/status');
                const data = await response.json();
                
                // Hide Stav if not active or not enabled
                if (!data.active || !data.enabled) {
                    // Hide Stav button
                    const stavButton = document.querySelector('button[onclick="toggleStavChat()"]');
                    if (stavButton) {
                        stavButton.style.display = 'none';
                    }
                    
                    // Hide Stav chat window
                    const stavWindow = document.getElementById('stavChatWindow');
                    if (stavWindow) {
                        stavWindow.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Error checking Stav status:', error);
                // If error, show Stav by default (fail open)
            }
        }
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Check Stav status first
            await checkStavStatus();
            
            const stavInput = document.getElementById('stavChatInput');
            if (stavInput) {
                stavInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendStavMessage();
                    }
                });
            }
            // Open Stav in fullscreen when toggled
            const win = document.getElementById('stavChatWindow');
            if (win) {
                const origToggle = window.toggleStavChat;
                window.toggleStavChat = function() {
                    if (typeof origToggle === 'function') origToggle();
                    win.classList.add('fullscreen');
                }
            }
        });
      </script>
  </body>
</html>