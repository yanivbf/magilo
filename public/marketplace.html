<!DOCTYPE html>
<html lang="he" dir="rtl">
    <!-- Updated: 2025-11-15 11:45:00 - CITY FILTERING FIXED -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AutoPage Marketplace</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .hero-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .page-card {
            transition: all 0.3s ease;
        }
        .page-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .ai-bot-bubble {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer !important;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            z-index: 1000;
            transition: all 0.3s ease;
            pointer-events: auto !important;
        }
        
        .ai-bot-bubble:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
        }
        
        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }
            100% {
                background-position: 200% 0;
            }
        }
        
        .ai-chat-window {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 350px;
            height: 500px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        
        .ai-chat-window.active {
            display: flex;
        }
        
        .ai-chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .ai-chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: #f8f9fa;
        }
        
        .page-preview{
            margin-top: 15px;
            margin-bottom: 15px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
            background: white;
            box-shadow: 0 8px 16px -4px rgba(0, 0, 0, 0.15);
            width: calc(100% + 32px);
            margin-left: -16px;
            height: 544px;
            text-align: right;
            direction: rtl;
            display: block;
            position: relative;
        }
        
        .preview-header {
            display: none !important; /* הסתרת הכותרת */
        }
        
        .preview-header h3 {
            display: none !important;
        }
        
        .preview-content {
            padding: 0;
            background: white;
            height: 500px;
            position: relative;
        }
        
        .preview-content iframe {
            border: none;
            border-radius: 0 0 12px 12px;
        }
        
        .ai-message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 10px;
            max-width: 80%;
        }
        
        .ai-message.user {
            background: #667eea;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .ai-message.bot {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
            margin-left: auto;
            margin-right: 0;
            text-align: right !important;
            direction: rtl !important;
            display: block !important;
            width: 100% !important;
            padding: 12px 16px !important;
            text-align: right !important;
            align-self: flex-end !important;
            max-width: none !important;
        }
        
        .typing-text {
            display: inline-block;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .ai-chat-input {
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }
        
        .ai-chat-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
        }
        
        .ai-chat-input button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        
        .typing-dots {
            animation: typing 1.5s infinite;
        }
        
        @keyframes typing {
            0%, 60%, 100% { opacity: 0; }
            30% { opacity: 1; }
        }

        /* Stav typing animation with spinning loader */
        .stav-typing-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            font-style: italic;
            color: #6b7280;
        }
        
        .stav-loader {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            perspective: 300px;
            position: relative;
            flex-shrink: 0;
        }
        
        .stav-loader .inner {
            position: absolute;
            box-sizing: border-box;
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }
        
        .stav-loader .inner.one {
            left: 0%;
            top: 0%;
            animation: stav-rotate-one 1.5s linear infinite;
            border-bottom: 3px solid #8b5cf6;
        }
        
        .stav-loader .inner.two {
            right: 0%;
            top: 0%;
            animation: stav-rotate-two 1.5s linear infinite;
            border-right: 3px solid #ec4899;
        }
        
        .stav-loader .inner.three {
            right: 0%;
            bottom: 0%;
            animation: stav-rotate-three 1.5s linear infinite;
            border-top: 3px solid #3b82f6;
        }
        
        @keyframes stav-rotate-one {
            0% { transform: rotateX(35deg) rotateY(-45deg) rotateZ(0deg); }
            100% { transform: rotateX(35deg) rotateY(-45deg) rotateZ(360deg); }
        }
        
        @keyframes stav-rotate-two {
            0% { transform: rotateX(50deg) rotateY(10deg) rotateZ(0deg); }
            100% { transform: rotateX(50deg) rotateY(10deg) rotateZ(360deg); }
        }
        
        @keyframes stav-rotate-three {
            0% { transform: rotateX(35deg) rotateY(55deg) rotateZ(0deg); }
            100% { transform: rotateX(35deg) rotateY(55deg) rotateZ(360deg); }
        }

        /* === STAV CHAT WINDOW === */
        .stav-chat-window {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .stav-chat-window.active {
            display: flex;
        }
        
        .stav-chat-container {
            width: 95%;
            max-width: 1400px;
            height: 90%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .stav-chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }
        
        .stav-avatar-img {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
            animation: avatarPulse 2s ease-in-out infinite;
        }
        
        @keyframes avatarPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
            }
        }
        
        .stav-chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8fafc;
        }
        
        .stav-message {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
        }
        
        .stav-message.user {
            background: #667eea;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .stav-message.bot {
            background: white;
            color: #333;
            margin-left: auto;
            margin-right: 0;
            text-align: right !important;
            direction: rtl !important;
            display: flex !important;
            align-items: flex-start !important;
            gap: 10px !important;
            width: 100% !important;
            border: 1px solid #e5e7eb;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 12px 16px !important;
            max-width: none !important;
        }
        
        .stav-message.bot .bot-avatar {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
            border: 2px solid #667eea;
            animation: avatarPulse 2s ease-in-out infinite;
        }
        
        .stav-message.bot .bot-text {
            flex: 1;
            text-align: right;
            direction: rtl;
        }
        
        .typing-text {
            display: inline-block;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .stav-chat-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 10px;
        }
        
        .stav-chat-input input {
            flex: 1;
            padding: 15px;
            border: 2px solid #e5e7eb;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }
        
        .stav-chat-input input:focus {
            border-color: #667eea;
        }
        
        .stav-chat-input button {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .stav-chat-input button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Fullscreen Page Preview Modal -->
    <div id="page-preview-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 9999; padding: 20px;">
        <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 0 10px;">
                <h2 id="modal-page-title" style="color: white; font-size: 24px; font-weight: bold; margin: 0;"></h2>
                <button onclick="closePagePreviewModal()" style="background: #667eea; color: white; border: none; width: 50px; height: 50px; border-radius: 50%; font-size: 28px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s;">
                    ✕
                </button>
            </div>
            <iframe id="modal-page-iframe" style="width: 100%; height: calc(100% - 80px); border: 0; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
            <div style="text-align: center; margin-top: 15px;">
                <a id="modal-page-link" href="#" target="_blank" style="color: #667eea; background: white; padding: 12px 24px; border-radius: 25px; text-decoration: none; font-weight: 600; font-size: 16px; display: inline-block; transition: all 0.3s;">
                    🔗 פתח בטאב חדש
                </a>
            </div>
        </div>
    </div>

    <!-- Hero Header with Purple Background -->
    <div class="hero-gradient text-white">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
            <div class="text-center">
                <h1 class="text-4xl md:text-6xl font-bold mb-4">AutoPage Marketplace</h1>
                <p class="text-xl md:text-2xl mb-8 opacity-90">מצא את הדף המושלם שלך</p>
                
                <!-- Search Bar -->
                <div class="max-w-2xl mx-auto mb-8">
                    <div class="relative">
                        <input type="text" id="search-input" placeholder="חפש דפים, עסקים, שירותים..." 
                               class="w-full px-6 py-4 text-gray-900 text-lg rounded-full focus:ring-4 focus:ring-white focus:ring-opacity-50 focus:outline-none">
                        <button onclick="searchPages()" class="absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- Create Page Button -->
                <div class="flex justify-center gap-4">
                    <button onclick="goToFullApp()" class="bg-white text-indigo-600 px-8 py-4 rounded-full font-bold text-lg hover:bg-gray-100 transition-all transform hover:scale-105 flex items-center gap-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                        </svg>
                        צור דף עכשיו
                    </button>
                    <button onclick="if(typeof toggleStavChat === 'function') toggleStavChat(); else console.error('toggleStavChat not defined');" class="bg-purple-600 text-white px-8 py-4 rounded-full font-bold text-lg hover:bg-purple-700 transition-all transform hover:scale-105 flex items-center gap-2">
                        🤖 סתיו
                    </button>
                </div>
                
                <!-- View Toggle Buttons -->
                <div class="flex justify-center gap-2 mt-4">
                    <button id="grid-view-btn" onclick="setView('grid')" class="p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path>
                        </svg>
                    </button>
                    <button id="table-view-btn" onclick="setView('table')" class="p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Filter Buttons -->
    <div class="bg-white border-b">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
            <div class="flex flex-wrap justify-center gap-3">
                <button onclick="filterByType('all')" class="px-6 py-3 bg-indigo-500 text-white rounded-full hover:bg-indigo-600 transition-all">הכל</button>
                <button onclick="filterByType('store')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">🏪 חנויות</button>
                <button onclick="filterByType('event')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">🎉 אירועים</button>
                <button onclick="filterByType('course')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">🎓 קורסים</button>
                <button onclick="filterByType('serviceProvider')" class="px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all">🔧 בעלי מקצוע</button>
            </div>
            <div class="text-center mt-4">
                <p id="pages-count" class="text-gray-600">טוען דפים...</p>
            </div>
        </div>
    </div>

    <!-- Loading State -->
    <div id="loading-state" class="text-center py-12">
        <div class="text-lg text-gray-600">טוען דפים...</div>
    </div>

    <!-- Pages Grid -->
    <div id="pages-grid" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- Pages will be loaded here -->
    </div>
    
    <!-- Pages Table -->
    <div id="pages-table" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 hidden">
        <div class="bg-white shadow overflow-hidden sm:rounded-md">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">תמונה</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">כותרת</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">סוג</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">תיאור</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">תאריך יצירה</th>
                        <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">פעולות</th>
                    </tr>
                </thead>
                <tbody id="table-body" class="bg-white divide-y divide-gray-200">
                    <!-- Table rows will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Stav Chat Window (Main Bot) -->
    <div class="stav-chat-window" id="stavChatWindow">
        <div class="stav-chat-container">
            <div class="stav-chat-header">
                <img src="/stav-avatar.png" alt="סתיו" class="stav-avatar-img" onerror="this.style.display='none'">
                <h2 style="flex: 1;">סתיו</h2>
                <button onclick="toggleStavChat()" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">×</button>
            </div>
        <div class="stav-chat-messages" id="stavChatMessages">
            <div class="stav-message bot">
                <div class="bot-text">שלום, מה שלומך?</div>
                <img src="/stav-avatar.png" alt="סתיו" class="bot-avatar" onerror="this.style.display='none'">
            </div>
        </div>
            <div class="stav-chat-input">
                <button id="micButton" onclick="toggleSpeechRecognition()" style="background: #667eea; color: white; border: none; padding: 15px; border-radius: 8px; margin-left: 10px; cursor: pointer; font-size: 20px;">🎤</button>
                <input type="text" id="stavChatInput" placeholder="כתוב הודעה או לחץ על המיקרופון...">
                <button onclick="sendStavMessage()">שלח</button>
            </div>
        </div>
    </div>

    <!-- Responsive overrides for Stav chat (marketplace) -->
    <style>
        .stav-chat-window { z-index: 9999; position: fixed; right: 24px; bottom: 24px; }
        .stav-chat-window.fullscreen { inset: 0 !important; right: 0 !important; left: 0 !important; top: 0 !important; bottom: 0 !important; width: 100vw !important; height: 100vh !important; margin: 0 !important; padding: 0 !important; }
        .stav-chat-container { display: flex !important; flex-direction: column !important; }
        .stav-chat-window.fullscreen .stav-chat-container { width: 100% !important; max-width: none !important; height: 100% !important; margin: 0 !important; border-radius: 0 !important; }
        .stav-chat-header { flex: 0 0 auto !important; }
        .stav-chat-messages { flex: 1 1 auto !important; overflow-y: auto !important; }
        .stav-chat-input { flex: 0 0 auto !important; }
        @media (max-width: 640px) {
            .stav-chat-window { left: 4vw; right: 4vw; bottom: calc(16px + env(safe-area-inset-bottom)); }
            .stav-chat-container { width: 100%; max-height: min(70vh, 560px); border-radius: 16px; overflow: hidden; }
            .stav-chat-messages { max-height: none !important; }
            .stav-chat-input { padding-bottom: max(8px, env(safe-area-inset-bottom)); }
        }
    </style>

    <!-- AI Search Bot (Old Marketplace Bot - Keep for legacy) -->
    <div class="ai-bot-bubble" id="aiBotBubble" title="עזרה חכמה" onclick="toggleAIChat()" style="cursor: pointer !important; pointer-events: auto !important; display: none;">
        🤖
    </div>

    <div class="ai-chat-window" id="aiChatWindow" style="display: none;">
        <div class="ai-chat-header">
            <span>🤖 העוזרת החכמה</span>
            <button id="closeAiChat" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">×</button>
        </div>
        <div class="ai-chat-messages" id="aiChatMessages">
        </div>
        <div class="ai-chat-input">
            <input type="text" id="aiChatInput" placeholder="כתוב הודעה...">
            <button onclick="sendAIMessage()">שלח</button>
        </div>
    </div>

    <script>
        console.log('%c🚀🚀🚀 MARKETPLACE LOADED - VERSION 2025-11-15 13:30 - FIXED TYPOS & SHORT WORDS! 🚀🚀🚀', 'background: #ff0000; color: #ffffff; font-size: 20px; font-weight: bold; padding: 10px;');
        console.log('%c✅ תיקנתי: אינסטלטור (כל הווריאציות) + לק (מילה קצרה)!', 'background: #00ff00; color: #000000; font-size: 16px; padding: 5px;');
        
        // --- N8N Webhook URL (single source of truth) ---
        const N8N_WEBHOOK_URL = 'https://n8n-service-how4.onrender.com/webhook/jhfuhgufkhlkuho8erhf757754jhldkbsjkbmreketpg';
        
        // --- Local fallback logic to avoid repeating the same greeting and answer simple queries ---
        let stavFirstReplySent = false;
        function stavLocalFallbackReply(message) {
            // MINIMAL fallback - only for basic greetings when N8N completely fails
            // All other queries should be handled by N8N
            try {
                const raw = (message || '').toString();
                const msg = raw.trim();

                // Only handle basic greetings - everything else should go to N8N
                if (/^(היי|הי|שלום)[!\s\u200f\u200e]*$/i.test(msg)) {
                    return stavFirstReplySent
                        ? 'היי! כאן בשבילך 😊'
                        : 'היי! 😊 איך אני יכולה לעזור?';
                }

                // Minimal fallback for everything else - just acknowledge
                // All queries should be handled by N8N, not here
                return 'אני כאן בשבילך! 😊 נסה/י שוב או כתוב/י מה את/ה מחפש/ת.';
            } catch (_) {
                return 'אני כאן בשבילך! 😊';
            }
        }
        const AI_WEBHOOK = N8N_WEBHOOK_URL; // Use the same N8N webhook
        
        // Simple toggle function
        function toggleAIChat() {
            console.log('🔧 toggleAIChat called');
            const chatWindow = document.getElementById('aiChatWindow');
            if (chatWindow) {
                chatWindow.classList.toggle('active');
                console.log('🔧 Chat window toggled, active:', chatWindow.classList.contains('active'));
                
                if (chatWindow.classList.contains('active')) {
                    const input = document.getElementById('aiChatInput');
                    if (input) {
                        input.focus();
                    }
                }
            } else {
                console.error('❌ Chat window not found');
            }
        }
        
        // Add event listener for AI bot bubble
        document.addEventListener('DOMContentLoaded', function() {
            const aiBotBubble = document.getElementById('aiBotBubble');
            if (aiBotBubble) {
                aiBotBubble.addEventListener('click', toggleAIChat);
                aiBotBubble.addEventListener('touchstart', toggleAIChat);
            }
            
            const closeAiChat = document.getElementById('closeAiChat');
            if (closeAiChat) {
                closeAiChat.addEventListener('click', toggleAIChat);
            }
        });
        
        // Also add click event directly to the bubble
        function addBotBubbleClick() {
            const aiBotBubble = document.getElementById('aiBotBubble');
            if (aiBotBubble) {
                aiBotBubble.onclick = toggleAIChat;
                aiBotBubble.addEventListener('click', toggleAIChat);
                aiBotBubble.addEventListener('touchstart', toggleAIChat);
            }
        }
        
        // Call the function after DOM is loaded
        setTimeout(addBotBubbleClick, 1000);
        
        // Also try to add click event after page loads
        window.addEventListener('load', function() {
            const aiBotBubble = document.getElementById('aiBotBubble');
            if (aiBotBubble) {
                aiBotBubble.onclick = toggleAIChat;
                aiBotBubble.addEventListener('click', toggleAIChat);
            }
        });
        
        function addAIMessage(message, isUser = false) {
            const messagesDiv = document.getElementById('aiChatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${isUser ? 'user' : 'bot'}`;
            
            if (isUser) {
                messageDiv.textContent = message;
            } else {
                // Convert markdown-style links to clickable links
                let processedMessage = message.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, text, url) => {
                    // Make sure URL is full URL (add origin if needed)
                    const fullUrl = url.startsWith('http') ? url : (url.startsWith('/') ? `${window.location.origin}${url}` : url);
                    return `<a href="${fullUrl}" target="_blank" onclick="event.preventDefault(); window.open('${fullUrl}', '_blank'); return false;" style="color: #667eea; text-decoration: underline; cursor: pointer;">${text}</a>`;
                });
                
                // 🎯 FIX: Also convert plain text links like "🔗 צפה בדף: /users/..." to clickable links
                // Match patterns like "🔗 צפה בדף: /users/..." or "צפה בדף: /users/..."
                processedMessage = processedMessage.replace(
                    /(🔗\s*)?צפה\s+בדף\s*:\s*(\/users\/[^\s\)<>]+)/g,
                    (match, emoji, url) => {
                        const fullUrl = url.startsWith('http') ? url : `${window.location.origin}${url}`;
                        return `<a href="${fullUrl}" target="_blank" onclick="event.preventDefault(); window.open('${fullUrl}', '_blank'); return false;" style="color: #667eea; text-decoration: underline; cursor: pointer;">👁️ צפה בדף</a>`;
                    }
                );
                
                // Also match standalone URLs like "/users/..." at the end of sentences (but not already in links)
                processedMessage = processedMessage.replace(
                    /(\/users\/[^\s\)<>]+)(?![^<]*<\/a>)/g,
                    (match, url) => {
                        // Make sure it's not already a link
                        if (!processedMessage.includes(`<a href="${url}"`)) {
                            const fullUrl = url.startsWith('http') ? url : `${window.location.origin}${url}`;
                            return `<a href="${fullUrl}" target="_blank" onclick="event.preventDefault(); window.open('${fullUrl}', '_blank'); return false;" style="color: #667eea; text-decoration: underline; cursor: pointer;">🔗 צפה בדף</a>`;
                        }
                        return match;
                    }
                );
                
                // Add animated typing effect for bot messages
                messageDiv.innerHTML = '<span class="typing-text"></span>';
                messagesDiv.appendChild(messageDiv);
                
                // Animate typing effect
                const typingSpan = messageDiv.querySelector('.typing-text');
                let i = 0;
                const typeMessage = () => {
                    if (i < processedMessage.length) {
                        // Get current position in HTML string
                        const htmlToAdd = processedMessage.substring(0, i + 1);
                        typingSpan.innerHTML = htmlToAdd;
                        
                        // 🎯 FIX: Re-attach click handlers to links after they're added
                        typingSpan.querySelectorAll('a').forEach(link => {
                            if (!link.dataset.handlerAttached) {
                                link.dataset.handlerAttached = 'true';
                                const href = link.getAttribute('href');
                                if (href) {
                                    link.addEventListener('click', (e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        window.open(href, '_blank');
                                        return false;
                                    });
                                }
                            }
                        });
                        
                        i++;
                        setTimeout(typeMessage, 50); // 50ms delay between characters
                    } else {
                        // After typing is complete, ensure all links have handlers
                        setTimeout(() => {
                            typingSpan.querySelectorAll('a').forEach(link => {
                                if (!link.dataset.handlerAttached) {
                                    link.dataset.handlerAttached = 'true';
                                    const href = link.getAttribute('href');
                                    if (href) {
                                        link.addEventListener('click', (e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            window.open(href, '_blank');
                                            return false;
                                        });
                                    }
                                }
                            });
                        }, 100);
                    }
                };
                typeMessage();
                
                // Fix image URLs to be absolute and add error handling
                processedMessage = processedMessage.replace(/src="([^"]+)"/g, (match, src) => {
                    let fullSrc = src;
                    if (src.startsWith('/')) {
                        fullSrc = `${window.location.origin}${src}`;
                    }
                    return `src="${fullSrc}" onerror="this.style.display='none'" onload="this.style.display='block'"`;
                });
                
                messageDiv.innerHTML = processedMessage;
            }
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function removeTypingIndicator() {
            const messagesDiv = document.getElementById('aiChatMessages');
            if (messagesDiv.lastChild && messagesDiv.lastChild.textContent.includes('מקלידה')) {
                messagesDiv.removeChild(messagesDiv.lastChild);
            }
        }
        
        // Global variables
        let allPages = [];
        let filteredPages = [];
        let currentType = 'all';
        let currentView = 'grid';
        
        // Load pages on page load
        document.addEventListener('DOMContentLoaded', async function() {
            await loadPages();
        });
        
        // Search functionality
        document.getElementById('search-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPages();
            }
        });
        
        async function loadPages() {
            try {
                const response = await fetch('/api/pages/all/marketplace');
                const data = await response.json();
                
                // Handle both array and object with pages property
                allPages = Array.isArray(data) ? data : (data.pages || []);
                filteredPages = [...allPages];
                
                console.log('Loaded pages:', allPages);
                console.log('Page types:', [...new Set(allPages.map(p => p.pageType))]);
                
                displayPages();
                updatePagesCount();
                
                // Hide loading state
                document.getElementById('loading-state').style.display = 'none';
            } catch (error) {
                console.error('Error loading pages:', error);
                document.getElementById('loading-state').innerHTML = `
                    <div class="text-red-500 text-lg">לא הצלחתי לטעון דפים. בדקי שהשרת רץ ועדכני את הדפדפן.</div>
                `;
            }
        }
        
        function filterByType(type) {
            currentType = type;
            
            // Update button styles
            document.querySelectorAll('button[onclick^="filterByType"]').forEach(btn => {
                btn.className = 'px-6 py-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 transition-all';
            });
            event.target.className = 'px-6 py-3 bg-indigo-500 text-white rounded-full hover:bg-indigo-600 transition-all';
            
            console.log('Filtering by type:', type);
            console.log('All pages:', allPages);
            console.log('Page types found:', [...new Set(allPages.map(p => p.pageType))]);
            
            if (type === 'all') {
                filteredPages = [...allPages];
            } else {
                filteredPages = allPages.filter(page => {
                    console.log(`Page: ${page.title}, pageType: ${page.pageType}, matches: ${page.pageType === type}`);
                    return page.pageType === type;
                });
            }
            
            console.log('Filtered pages:', filteredPages);
            displayPages();
            updatePagesCount();
        }
        
        async function searchPages() {
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            
            if (searchTerm === '') {
                filteredPages = [...allPages];
            } else {
                // Enhanced search that ALWAYS reads from live pages
                filteredPages = [];
                
                // Extract city and service/product from search term
                const cities = [
                    'תל אביב', 'ירושלים', 'חיפה', 'באר שבע', 'נתניה', 'אשדוד', 'רמת גן', 'פתח תקווה', 
                    'בני ברק', 'חולון', 'רחובות', 'כפר סבא', 'אילת', 'רעננה', 'הרצליה', 'חדרה', 
                    'קריית ביאליק', 'קריית מוצקין', 'ראשון לציון', 'נהריה', 'הוד השרון', 'גבעתיים', 
                    'קריית אתא', 'קריית שמונה', 'בית שאן', 'עפולה'
                ];
                
                // 🚫 Words that should NEVER be considered city names
                const notCityWords = [
                    'אלגנטי', 'אלגנטית', 'יפה', 'מיוחד', 'מיוחדת', 'זול', 'זולה', 'יקר', 'יקרה',
                    'קלאסי', 'קלאסית', 'מודרני', 'מודרנית', 'עתיק', 'עתיקה', 'חדש', 'חדשה', 'ישן', 'ישנה',
                    'זהב', 'כסף', 'שחור', 'לבן', 'אדום', 'כחול', 'ירוק', 'צהוב', 'ורוד', 'סגול', 'חום', 'אפור',
                    'עור', 'פלסטיק', 'מתכת', 'עץ', 'זכוכית', 'נייר', 'בד', 'משי', 'כותנה',
                    'גדול', 'קטן', 'ענק', 'זעיר', 'בינוני', 'ארוך', 'קצר', 'רחב', 'צר',
                    'שעון', 'שעונים', 'צעצוע', 'צעצועים', 'לק', 'מניקור', 'תכשיט', 'תכשיטים'
                ];
                
                let requiredCity = null;
                let serviceOrProduct = searchTerm;
                
                // Try multiple patterns to extract city
                // Pattern 1: "נגר בנתניה" or "מספרה בתל אביב" (service ב city)
                // 🎯 FIX: Changed ([א-ת]+) to ([א-ת\s]+) to support multi-word cities like "תל אביב"
                const patternWithBe = /([א-ת\s]+)\s+ב([א-ת\s]+)/;
                const matchWithBe = searchTerm.match(patternWithBe);
                if (matchWithBe && matchWithBe[2]) {
                    const potentialCity = matchWithBe[2].trim();
                    // Check if it's a known city
                    for (const city of cities) {
                        if (city.toLowerCase() === potentialCity.toLowerCase() || 
                            city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                            potentialCity.toLowerCase().includes(city.toLowerCase())) {
                            requiredCity = city;
                            // Extract service/product (what comes before "ב")
                            serviceOrProduct = matchWithBe[1].trim();
                            serviceOrProduct = serviceOrProduct.replace(/^(ב|בתוך|בשדה|של|את|על)\s+/g, '').trim();
                            console.log(`🏙️ Found city (ב pattern): "${city}", service/product: "${serviceOrProduct}"`);
                            break;
                        }
                    }
                    // If no match but it looks like a city (Hebrew word 2-15 chars), use it
                    // 🚫 BUT: Don't consider product attributes as cities!
                    if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15 && 
                        /^[א-ת\s]+$/.test(potentialCity) &&
                        !notCityWords.includes(potentialCity.toLowerCase())) {
                        requiredCity = potentialCity;
                        serviceOrProduct = matchWithBe[1].trim();
                        serviceOrProduct = serviceOrProduct.replace(/^(ב|בתוך|בשדה|של|את|על)\s+/g, '').trim();
                        console.log(`🏙️ Found city (new from ב pattern): "${potentialCity}", service/product: "${serviceOrProduct}"`);
                    } else if (potentialCity && notCityWords.includes(potentialCity.toLowerCase())) {
                        console.log(`🚫 searchPages: Rejected "${potentialCity}" as city (product attribute)`);
                    }
                }
                
                // Pattern 2: Exact city name in query
                if (!requiredCity) {
                    for (const city of cities) {
                        if (searchTerm.includes(city.toLowerCase())) {
                            requiredCity = city;
                            // Remove city from search term to get service/product
                            serviceOrProduct = searchTerm.replace(city.toLowerCase(), '').trim();
                            // Remove common prepositions
                            serviceOrProduct = serviceOrProduct.replace(/^(ב|בתוך|בשדה|של|את|על)\s+/g, '').trim();
                            console.log(`🏙️ Found city (exact): "${city}", service/product: "${serviceOrProduct}"`);
                            break;
                        }
                    }
                }
                
                // Pattern 3: "(ב|בתוך|בשדה) עיר" pattern
                if (!requiredCity) {
                    const cityPattern = /(?:ב|בתוך|בשדה)\s+([א-ת]{2,})/;
                    const cityMatch = searchTerm.match(cityPattern);
                    if (cityMatch && cityMatch[1]) {
                        const potentialCity = cityMatch[1].trim();
                        // Check if it's a known city (partial match)
                        for (const city of cities) {
                            if (city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                                potentialCity.toLowerCase().includes(city.toLowerCase())) {
                                requiredCity = city;
                                serviceOrProduct = searchTerm.replace(/(?:ב|בתוך|בשדה)\s*[א-ת]+/g, '').trim();
                                serviceOrProduct = serviceOrProduct.replace(/^(ב|בתוך|בשדה|של|את|על)\s+/g, '').trim();
                                console.log(`🏙️ Found city (pattern): "${city}", service/product: "${serviceOrProduct}"`);
                                break;
                            }
                        }
                        // If no match but it looks like a city, use it
                        // 🚫 BUT: Don't consider product attributes as cities!
                        if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15 &&
                            !notCityWords.includes(potentialCity.toLowerCase())) {
                            requiredCity = potentialCity;
                            serviceOrProduct = searchTerm.replace(/(?:ב|בתוך|בשדה)\s*[א-ת]+/g, '').trim();
                            serviceOrProduct = serviceOrProduct.replace(/^(ב|בתוך|בשדה|של|את|על)\s+/g, '').trim();
                            console.log(`🏙️ Found city (new): "${potentialCity}", service/product: "${serviceOrProduct}"`);
                        } else if (!requiredCity && potentialCity && notCityWords.includes(potentialCity.toLowerCase())) {
                            console.log(`🚫 searchPages Pattern 3: Rejected "${potentialCity}" as city (product attribute)`);
                        }
                    }
                }
                
                // If service/product is empty after removing city, use full search term
                if (!serviceOrProduct || serviceOrProduct.length < 2) {
                    serviceOrProduct = searchTerm;
                }
                
                // Check if this is a "חנויות ב..." or "נותני שרות ב..." query
                const isStoresInCityQuery = /^חנויות\s+ב([א-ת]+)$/.test(searchTerm);
                const isServicesInCityQuery = /^(?:נותני\s+שרות|בעלי\s+מקצוע|שירותים)\s+ב([א-ת]+)$/.test(searchTerm);
                
                if (isStoresInCityQuery || isServicesInCityQuery) {
                    // For "חנויות בנתניה" or "נותני שרות בנתניה" queries
                    const cityMatch = searchTerm.match(/ב([א-ת]+)$/);
                    if (cityMatch && cityMatch[1]) {
                        const queryCity = cityMatch[1].trim();
                        // Find the city in the cities list
                        for (const city of cities) {
                            if (city.toLowerCase() === queryCity.toLowerCase() || 
                                city.toLowerCase().includes(queryCity.toLowerCase()) || 
                                queryCity.toLowerCase().includes(city.toLowerCase())) {
                                requiredCity = city;
                                // Set service/product based on query type
                                if (isStoresInCityQuery) {
                                    serviceOrProduct = 'חנות'; // Filter for stores
                                } else if (isServicesInCityQuery) {
                                    serviceOrProduct = 'שירות'; // Filter for services
                                }
                                console.log(`🏙️ Special query detected: "${isStoresInCityQuery ? 'חנויות' : 'נותני שרות'}" in "${city}"`);
                                break;
                            }
                        }
                        // If city not found in list, use it as-is
                        if (!requiredCity && queryCity.length >= 2 && queryCity.length <= 15) {
                            requiredCity = queryCity;
                            if (isStoresInCityQuery) {
                                serviceOrProduct = 'חנות';
                            } else if (isServicesInCityQuery) {
                                serviceOrProduct = 'שירות';
                            }
                            console.log(`🏙️ Special query (new city): "${isStoresInCityQuery ? 'חנויות' : 'נותני שרות'}" in "${queryCity}"`);
                        }
                    }
                }
                
                for (const page of allPages) {
                    let matches = false;
                    
                    // For "חנויות ב..." queries, check if page is a store
                    if (isStoresInCityQuery && page.pageType !== 'store') {
                        continue; // Skip non-store pages
                    }
                    
                    // For "נותני שרות ב..." queries, check if page is a service provider
                    if (isServicesInCityQuery && page.pageType !== 'serviceProvider') {
                        continue; // Skip non-service pages
                    }
                    
                    // Check title and description for service/product
                    const titleMatch = page.title.toLowerCase().includes(serviceOrProduct);
                    const descriptionMatch = page.description && page.description.toLowerCase().includes(serviceOrProduct);
                    
                    // Check products from metadata (much faster!)
                    let productMatch = false;
                    if (page.products && Array.isArray(page.products) && page.products.length > 0) {
                        productMatch = page.products.some(product => 
                            product.name && product.name.toLowerCase().includes(serviceOrProduct)
                        );
                    }
                    
                    // For "חנויות ב..." queries, match any store in the city (service/product can be empty)
                    // For "נותני שרות ב..." queries, match any service provider in the city
                    const serviceMatches = isStoresInCityQuery || isServicesInCityQuery || titleMatch || descriptionMatch || productMatch;
                    
                    // If city is required, must check both service AND city
                    if (requiredCity) {
                        // Check city from metadata first (much faster!)
                        let cityMatches = false;
                        if (page.city) {
                            cityMatches = page.city.toLowerCase().includes(requiredCity.toLowerCase()) || 
                                         requiredCity.toLowerCase().includes(page.city.toLowerCase());
                        }
                        
                        // If no city in metadata, check HTML (for old pages)
                        if (!cityMatches) {
                            cityMatches = await checkPageHasCity(page, requiredCity);
                        }
                        
                        // Both service AND city must match
                        if (serviceMatches && cityMatches) {
                            matches = true;
                        } else if (serviceMatches && !cityMatches) {
                            // Service matches but city doesn't - try live content (might have different city)
                            const liveContentMatch = await checkLivePageContentWithCity(page, serviceOrProduct, requiredCity);
                            if (liveContentMatch) {
                                matches = true;
                            }
                        }
                    } else {
                        // No city requirement - check service/product only
                        if (serviceMatches) {
                            matches = true;
                        } else {
                            // Check live page content (for old pages without metadata)
                            const liveContentMatch = await checkLivePageContent(page, serviceOrProduct);
                            if (liveContentMatch) {
                                matches = true;
                            }
                        }
                    }
                    
                    if (matches) {
                        filteredPages.push(page);
                    }
                }
            }
            
            displayPages();
            updatePagesCount();
        }
        
        // Check if page has specific city (using metadata first, fallback to HTML)
        async function checkPageHasCity(page, requiredCity) {
            // First check metadata (much faster!)
            if (page.city) {
                return page.city.toLowerCase().includes(requiredCity.toLowerCase()) || 
                       requiredCity.toLowerCase().includes(page.city.toLowerCase());
            }
            
            // Fallback: check HTML (for old pages without metadata)
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (response.ok) {
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    const cityLower = requiredCity.toLowerCase();
                    
                    // Check if city appears in page content
                    return htmlLower.includes(cityLower);
                }
            } catch (error) {
                console.error('Error checking page city:', error);
            }
            return false;
        }
        
        // Enhanced version that also checks for city
        async function checkLivePageContentWithCity(page, searchTerm, requiredCity) {
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (response.ok) {
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    
                    // Check if search term appears in page content
                    const found = htmlLower.includes(searchTerm.toLowerCase());
                    
                    // If city is required, verify it exists in page
                    if (requiredCity && found) {
                        const cityFound = htmlLower.includes(requiredCity.toLowerCase());
                        return cityFound;
                    }
                    
                    // Also check for price patterns
                    if (searchTerm.includes('₪') || searchTerm.includes('שקל')) {
                        const priceMatch = htmlLower.match(/₪\d+/g);
                        if (priceMatch) {
                            console.log(`💰 Found prices in ${page.title}:`, priceMatch);
                            return true;
                        }
                    }
                    
                    return found;
                }
            } catch (error) {
                console.error('Error checking live page content:', error);
            }
            return false;
        }
        
        // New function to check live page content
        async function checkLivePageContent(page, searchTerm) {
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (response.ok) {
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    
                    // Check if search term appears in page content
                    const found = htmlLower.includes(searchTerm.toLowerCase());
                    console.log(`🔍 Live search for "${searchTerm}" in ${page.title}: ${found}`);
                    
                    // Also check for price patterns
                    if (searchTerm.includes('₪') || searchTerm.includes('שקל')) {
                        const priceMatch = htmlLower.match(/₪\d+/g);
                        if (priceMatch) {
                            console.log(`💰 Found prices in ${page.title}:`, priceMatch);
                            return true;
                        }
                    }
                    
                    return found;
                }
            } catch (error) {
                console.error('Error checking live page content:', error);
            }
            return false;
        }
        
        function displayPages() {
            if (currentView === 'grid') {
                displayGrid();
            } else {
                displayTable();
            }
        }
        
        function displayGrid() {
            const grid = document.getElementById('pages-grid');
            const table = document.getElementById('pages-table');
            
            grid.classList.remove('hidden');
            table.classList.add('hidden');
            
            grid.innerHTML = '';
            
            if (filteredPages.length === 0) {
                grid.innerHTML = '<div class="col-span-full text-center text-gray-500 py-8">לא נמצאו דפים</div>';
                return;
            }
            
            filteredPages.forEach(page => {
                const pageCard = createPageCard(page);
                grid.appendChild(pageCard);
            });
        }
        
        function displayTable() {
            const grid = document.getElementById('pages-grid');
            const table = document.getElementById('pages-table');
            const tbody = document.getElementById('table-body');
            
            grid.classList.add('hidden');
            table.classList.remove('hidden');
            
            tbody.innerHTML = '';
            
            if (filteredPages.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="px-6 py-4 text-center text-gray-500">לא נמצאו דפים</td></tr>';
                return;
            }
            
            filteredPages.forEach(page => {
                const row = createTableRow(page);
                tbody.appendChild(row);
            });
        }
        
        function setView(view) {
            currentView = view;
            
            // Update button styles
            document.getElementById('grid-view-btn').className = view === 'grid' ? 
                'p-3 rounded-full bg-white bg-opacity-30 text-white hover:bg-opacity-40 transition-all' :
                'p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all';
            document.getElementById('table-view-btn').className = view === 'table' ? 
                'p-3 rounded-full bg-white bg-opacity-30 text-white hover:bg-opacity-40 transition-all' :
                'p-3 rounded-full bg-white bg-opacity-20 text-white hover:bg-opacity-30 transition-all';
            
            displayPages();
        }
        
        function createPageCard(page) {
            const card = document.createElement('div');
            card.className = 'page-card bg-white rounded-lg shadow-md overflow-hidden';
            
            const typeIcons = {
                'store': '🏪',
                'event': '🎉',
                'course': '🎓',
                'serviceProvider': '🔧',
                'other': '📄'
            };
            
            const icon = typeIcons[page.pageType] || '📄';
            const typeName = getTypeName(page.pageType);
            
            // Fix image URL - convert relative paths to absolute
            let imageUrl = page.thumbnail || '';
            if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
                imageUrl = `/output/${page.userId}/${imageUrl}`;
            }
            
            
            // Use /users/ route like in the main interface
            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
            
            // Try to find a screenshot image - only for courses
            const screenshotUrl = page.pageType === 'course' ? page.thumbnail : null;
            
            card.innerHTML = `
                <!-- תצוגה מקדימה של האתר -->
                <div class="relative rounded-t-xl overflow-hidden bg-gradient-to-br from-gray-50 to-gray-100" style="height: 200px; flex-shrink: 0;">
                    ${screenshotUrl ? `
                        <!-- תצוגה מקדימה עם תמונה -->
                        <img 
                            src="${screenshotUrl}" 
                            alt="${page.title}"
                            class="w-full h-full object-cover"
                            onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                        />
                        <div class="absolute inset-0 bg-gradient-to-br from-indigo-500/10 to-purple-500/10 hidden items-center justify-center">
                            <div class="text-center">
                                <div class="w-16 h-16 bg-white/90 rounded-full flex items-center justify-center mx-auto mb-3 shadow-lg border-2 border-indigo-200">
                                    <span class="text-2xl font-bold text-indigo-600">${icon}</span>
                                </div>
                                <div class="text-sm font-medium text-gray-700 bg-white/90 px-3 py-1 rounded-full shadow-sm border border-gray-200">
                                    ${typeName}
                                </div>
                            </div>
                        </div>
                    ` : `
                        <!-- תצוגה מקדימה עם iframe -->
                        <div class="absolute inset-2 bg-white rounded-lg overflow-hidden shadow-lg border border-gray-300">
                            <iframe 
                                src="${window.location.origin}${pageUrl}" 
                                class="w-full h-full border-0"
                                style="pointer-events: none; transform: scale(0.6) translateX(65%); transform-origin: top left; width: 166.67%; height: 166.67%;"
                                title="תצוגה מקדימה של ${page.title}"
                                loading="lazy"
                                importance="low"
                                sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-downloads allow-modals allow-top-navigation allow-presentation">
                            </iframe>
                        </div>
                    `}
                </div>
                <div class="p-6">
                    <h3 class="text-xl font-semibold text-gray-900 mb-2">${page.title}</h3>
                    <p class="text-gray-600 mb-4">${page.description || 'ללא תיאור'}</p>
                    <div class="flex items-center justify-between">
                        <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-indigo-100 text-indigo-800">
                            ${icon} ${typeName}
                        </span>
                        <a href="/view/${page.userId}/${page.pageId}_html" target="_blank" 
                           class="text-indigo-600 hover:text-indigo-800 font-medium">
                            צפה בדף →
                        </a>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createTableRow(page) {
            const row = document.createElement('tr');
            row.className = 'hover:bg-gray-50';
            
            const typeIcons = {
                'store': '🏪',
                'event': '🎉',
                'course': '🎓',
                'serviceProvider': '🔧',
                'other': '📄'
            };
            
            const icon = typeIcons[page.pageType] || '📄';
            const typeName = getTypeName(page.pageType);
            
            // Fix image URL
            let imageUrl = page.thumbnail || '';
            if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
                imageUrl = `/output/${page.userId}/${imageUrl}`;
            }
            
            // Use /users/ route like in the main interface
            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
            
            const createdDate = new Date(page.created_at).toLocaleDateString('he-IL');
            
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap">
                    <div class="flex-shrink-0 h-16 w-16">
                        ${imageUrl ? `
                            <!-- תצוגה מקדימה עם תמונה -->
                            <div class="h-16 w-16 rounded-lg overflow-hidden border border-gray-300 bg-white shadow-sm">
                                <img 
                                    src="${imageUrl}" 
                                    alt="${page.title}"
                                    class="w-full h-full object-cover"
                                    onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                />
                                <div class="h-16 w-16 rounded-lg bg-gradient-to-br from-indigo-100 to-purple-100 flex items-center justify-center text-2xl hidden">${icon}</div>
                            </div>
                        ` : `
                            <!-- Placeholder עם אייקון - לא iframe כי זה לא עובד טוב בטבלה קטנה -->
                            <div class="h-16 w-16 rounded-lg bg-gradient-to-br from-indigo-100 via-purple-50 to-pink-100 border-2 border-indigo-200 shadow-sm flex flex-col items-center justify-center">
                                <div class="text-3xl mb-1">${icon}</div>
                                <div class="text-[10px] font-medium text-indigo-700 text-center px-1 truncate w-full">${typeName}</div>
                            </div>
                        `}
                    </div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <div class="text-sm font-medium text-gray-900">${page.title}</div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800">
                        ${icon} ${typeName}
                    </span>
                </td>
                <td class="px-6 py-4">
                    <div class="text-sm text-gray-500 max-w-xs truncate">${page.description || 'ללא תיאור'}</div>
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    ${createdDate}
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                    <a href="/view/${page.userId}/${page.pageId}_html" target="_blank" 
                       class="text-indigo-600 hover:text-indigo-900">
                        צפה בדף
                    </a>
                </td>
            `;
            
            return row;
        }
        
        function getTypeName(type) {
            const names = {
                'store': 'חנות',
                'event': 'אירוע',
                'course': 'קורס',
                'serviceProvider': 'בעל מקצוע',
                'other': 'אחר'
            };
            return names[type] || 'אחר';
        }
        
        function updatePagesCount() {
            const count = filteredPages.length;
            const total = allPages.length;
            document.getElementById('pages-count').textContent = 
                `מציג ${count} מתוך ${total} דפים`;
        }
        
        
        // Extract product info from description and HTML content
        async function extractProductInfo(description, keyword, pageUrl = null) {
            if (!description) return null;
            
            const desc = description.toLowerCase();
            const keywordLower = keyword.toLowerCase();
            
            // Look for price patterns - more comprehensive
            const pricePatterns = [
                /(\d+)\s*₪/g,
                /(\d+)\s*שקל/g,
                /(\d+)\s*ש"ח/g,
                /מחיר[:\s]*(\d+)/g,
                /(\d+)\s*-\s*(\d+)\s*₪/g,
                /מחיר[:\s]*(\d+)\s*-\s*(\d+)/g,
                /(\d+)\s*למאה/g,
                /(\d+)\s*למטה/g,
                /(\d+)\s*למעלה/g
            ];
            
            let price = null;
            for (const pattern of pricePatterns) {
                const match = pattern.exec(desc);
                if (match) {
                    if (match[2]) {
                        price = `${match[1]}-${match[2]}₪`;
                    } else {
                        price = `${match[1]}₪`;
                    }
                    break;
                }
            }
            
            // Look for location patterns
            const locationPatterns = [
                /מיקום[:\s]*([^,.\n]{2,50})/g,
                /כתובת[:\s]*([^,.\n]{2,50})/g,
                /נמצא[:\s]*([^,.\n]{2,50})/g,
                /ב[:\s]*([^,.\n]{2,50})/g
            ];
            
            let location = null;
            for (const pattern of locationPatterns) {
                const match = pattern.exec(desc);
                if (match && match[1] && match[1].length > 2) {
                    location = match[1].trim();
                    break;
                }
            }
            
            // Look for product name patterns - more specific
            let productName = null;
            if (keywordLower === 'שעון') {
                const watchPatterns = [
                    /שעון\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*שעון/g,
                    /שעון\s+([א-ת\s]{2,30})/g,
                    /([א-ת\s]{2,30})\s*שעון\s+([א-ת\s]{2,30})/g
                ];
                for (const pattern of watchPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            } else if (keywordLower === 'תכשיט') {
                const jewelryPatterns = [
                    /תכשיט\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*תכשיט/g,
                    /([^,.\n]{2,30})\s*זהב/g,
                    /([^,.\n]{2,30})\s*כסף/g
                ];
                for (const pattern of jewelryPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            } else if (keywordLower === 'צעצוע') {
                const toyPatterns = [
                    /צעצוע\s+([^,.\n]{2,30})/g,
                    /([^,.\n]{2,30})\s*צעצוע/g,
                    /([^,.\n]{2,30})\s*משחק/g
                ];
                for (const pattern of toyPatterns) {
                    const match = pattern.exec(desc);
                    if (match && match[1] && match[1].length > 2) {
                        productName = match[1].trim();
                        break;
                    }
                }
            }
            
            // If we have a page URL, try to fetch the HTML content to find more prices
            if (pageUrl && (!price || !productName)) {
                try {
                    console.log('🔍 Fetching HTML for:', pageUrl);
                    const response = await fetch(pageUrl);
                    const html = await response.text();
                    const htmlLower = html.toLowerCase();
                    
                    console.log('📄 HTML length:', html.length);
                    
                    // Look for prices in HTML content
                    if (!price) {
                        console.log('💰 Looking for prices in HTML...');
                        const htmlPricePatterns = [
                            /<p class="product-price[^"]*"[^>]*>₪(\d+(?:,\d+)?)<\/p>/g,
                            /class="product-price[^"]*"[^>]*>₪(\d+(?:,\d+)?)/g,
                            /₪\s*(\d+(?:,\d+)?)/g,
                            /(\d+(?:,\d+)?)\s*₪/g
                        ];
                        
                        for (const pattern of htmlPricePatterns) {
                            const matches = [...html.matchAll(pattern)];
                            console.log('🔍 Pattern matches:', pattern, matches.length);
                            if (matches.length > 0) {
                                // Get the first price found
                                const firstPrice = matches[0][1] || matches[0][0].match(/(\d+(?:,\d+)?)/)?.[1];
                                console.log('💰 Found price:', firstPrice);
                                if (firstPrice) {
                                    price = `₪${firstPrice}`;
                                    break;
                                }
                            }
                        }
                        
                        // If still no price, try a simpler approach
                        if (!price) {
                            console.log('🔍 Trying simple price search...');
                            const simplePriceMatch = html.match(/₪\s*(\d+(?:,\d+)?)/);
                            console.log('💰 Simple match result:', simplePriceMatch);
                            if (simplePriceMatch) {
                                price = `₪${simplePriceMatch[1]}`;
                            }
                        }
                        
                        console.log('💰 Final price found:', price);
                    }
                    
                    // Look for product names in HTML content
                    if (!productName && keywordLower === 'שעון') {
                        const watchPatterns = [
                            /שעון\s+([^<>{}\n]{2,30})/g,
                            /([^<>{}\n]{2,30})\s*שעון/g,
                            /<h[1-6][^>]*>.*?שעון\s+([^<]{2,30})/g,
                            /class="[^"]*product-name[^"]*"[^>]*>([^<]+)/g,
                            /<h3[^>]*>([^<]*שעון[^<]*)<\/h3>/g
                        ];
                        
                        for (const pattern of watchPatterns) {
                            const matches = [...html.matchAll(pattern)];
                            if (matches.length > 0) {
                                productName = matches[0][1].trim();
                                break;
                            }
                        }
                    }
                } catch (error) {
                    console.log('Could not fetch HTML content:', error);
                }
            }
            
            if (productName || price || location) {
                return {
                    name: productName || `${keyword} מיוחד`,
                    price: price || 'מחיר לפי בקשה',
                    location: location || 'מיקום לא צוין'
                };
            }
            
            return null;
        }

        // Smart search functionality - copied from Stav the Great
        let lastSearchContext = null; // Remember last search context
        let lastSearchResults = []; // Remember last search results
        
        async function handleSmartSearch(message, allPages) {
            const lowerMessage = message.toLowerCase();
            
            // Handle greetings and personal questions - NO FIXED MESSAGES
            if (lowerMessage.includes('שלום') || lowerMessage.includes('היי') || lowerMessage.includes('הי') || 
                lowerMessage.includes('שמי') || lowerMessage.includes('קוראים לי') || lowerMessage.includes('אני') ||
                lowerMessage.includes('מה שלומך') || lowerMessage.includes('איך אתה') || lowerMessage.includes('איך את')) {
                return null; // Send to N8N instead of fixed message
            }
            
            // Handle context switching (e.g., "ולגבר" after "מתנה לילד")
            if (lowerMessage.includes('ולגבר') || lowerMessage.includes('ולאישה') || lowerMessage.includes('ולילד') || 
                lowerMessage.includes('ולגברים') || lowerMessage.includes('ולנשים') || lowerMessage.includes('ולילדים')) {
                // Extract the gift type from context
                let giftType = 'מתנה';
                if (lowerMessage.includes('גבר') || lowerMessage.includes('גברים')) giftType = 'מתנה לגבר';
                else if (lowerMessage.includes('אישה') || lowerMessage.includes('נשים')) giftType = 'מתנה לאישה';
                else if (lowerMessage.includes('ילד') || lowerMessage.includes('ילדים')) giftType = 'מתנה לילד';
                
                // Process as gift search
                const giftResult = await handleSmartSearch(giftType, allPages);
                if (giftResult) return giftResult;
            }
            
            // Handle greetings and personal questions - NO FIXED MESSAGES
            if (lowerMessage.includes('שלום') || lowerMessage.includes('היי') || lowerMessage.includes('הי') || 
                lowerMessage.includes('מה שלומך') || lowerMessage.includes('איך אתה') || lowerMessage.includes('איך את') ||
                lowerMessage.includes('שמי') || lowerMessage.includes('קוראים לי') || lowerMessage.includes('אני יניב') || lowerMessage.includes('אני ימחת')) {
                return null; // Send to N8N instead of fixed message
            }
            
            // 🎯 FIX: FIRST check if this is a marketplace query - handle locally, don't send to N8N!
            const isMarketplacePriceQuery = lowerMessage.includes('מה המוצר') || lowerMessage.includes('מה מחיר') || 
                                            lowerMessage.includes('מה המוצר הכי זול') || lowerMessage.includes('מה המוצר הכי יקר') ||
                                            lowerMessage.includes('המוצר הכי זול במרקט') || lowerMessage.includes('המוצר הכי זול במרקטפלייס') ||
                                            (lowerMessage.includes('מה') && (lowerMessage.includes('במרקט') || lowerMessage.includes('רקטפלייס') || lowerMessage.includes('הכי זול') || lowerMessage.includes('הכי יקר')));
            
            // Handle knowledge questions - send to N8N (but NOT marketplace queries!)
            // 🎯 FIX: "מה גודל יפן", "מה זה X" are general knowledge, NOT marketplace!
            // BUT: "מה מחיר", "מה המוצר הכי זול" ARE marketplace!
            const isGeneralKnowledgeQuery = (lowerMessage.includes('מה גודל') ||  // "מה גודל כדור הארץ"
                                             lowerMessage.includes('מה זה') ||    // "מה זה X"
                                             lowerMessage === 'מה' ||             // Just "מה"
                                             (lowerMessage.startsWith('מה ') && // "מה X" where X is NOT marketplace-related
                                              !lowerMessage.includes('מחיר') && 
                                              !lowerMessage.includes('מוצר') && 
                                              !lowerMessage.includes('מתנה') && 
                                              !lowerMessage.includes('במרקט') &&
                                              !lowerMessage.includes('רקטפלייס') &&
                                              !lowerMessage.includes('חנות') &&
                                              !lowerMessage.includes('שירות') &&
                                              !lowerMessage.includes('לק') &&
                                              !lowerMessage.includes('שעון') &&
                                              !lowerMessage.includes('צעצוע'))) &&
                                             !isMarketplacePriceQuery;
            
            if (isGeneralKnowledgeQuery || 
                (!isMarketplacePriceQuery && (lowerMessage.includes('איך') || 
                 lowerMessage.includes('מתי') || 
                 (lowerMessage.includes('איפה') && !lowerMessage.includes('חנות') && !lowerMessage.includes('לק') && !lowerMessage.includes('שעון')) ||
                 lowerMessage.includes('למה') ||
                 (lowerMessage.includes('כמה') && !lowerMessage.includes('מחיר') && !lowerMessage.includes('מוצר') && !lowerMessage.includes('עולה')) ||
                 lowerMessage.includes('מי') || 
                 lowerMessage.includes('איזה')))) {
                console.log('📚 General knowledge query detected - sending to N8N');
                return null; // Send to N8N for general knowledge questions
            }
            
            // Only search for pages if user is specifically looking for something
            // 🎯 FIX: Also catch "מה המוצר הכי זול במרקט" variations - handle locally, don't send to N8N!
            // 🎯 NEW: Add "תמליצי", "מתנה ל", "מוצר ל" as marketplace queries
            const isMarketplaceQuery = isMarketplacePriceQuery || 
                lowerMessage.includes('מתנה') || lowerMessage.includes('לק') || lowerMessage.includes('שעון') || 
                lowerMessage.includes('צעצוע') || lowerMessage.includes('קורס') || lowerMessage.includes('חנות') || 
                lowerMessage.includes('שירות') || lowerMessage.includes('אירוע') || lowerMessage.includes('מחיר') || 
                lowerMessage.includes('כמה') || lowerMessage.includes('עולה') || lowerMessage.includes('₪') || 
                lowerMessage.includes('שקל') || lowerMessage.includes('הכי זול') || lowerMessage.includes('הכי יקר') || 
                lowerMessage.includes('השוואה') || lowerMessage.includes('נגיד') || lowerMessage.includes('ולק') || 
                lowerMessage.includes('ושעון') || lowerMessage.includes('וצעצוע') || lowerMessage.includes('צעצועים') || 
                lowerMessage.includes('שעונים') || lowerMessage.includes('במרקט') || lowerMessage.includes('רקטפלייס') ||
                // 🎯 NEW: Handle "תמליצי", "מתנה ל", "מוצר ל", "תראי מוצרים" queries
                lowerMessage.includes('תמליצי') || lowerMessage.includes('תמליץ') || lowerMessage.includes('המלצ') ||
                lowerMessage.includes('תראי מוצרים') || lowerMessage.includes('תראי מחירים') ||
                lowerMessage.includes('מוצרים ומחירים') ||
                (lowerMessage.includes('תראי') && (lowerMessage.includes('מוצר') || lowerMessage.includes('מחיר'))) ||
                (lowerMessage.includes('מתנה') && (lowerMessage.includes('ל') || lowerMessage.includes('לאישה') || 
                 lowerMessage.includes('לבחורה') || lowerMessage.includes('לאשה') ||
                 lowerMessage.includes('לגבר') || lowerMessage.includes('לבחור') || 
                 lowerMessage.includes('לבעל') || lowerMessage.includes('לבעלי') ||
                 lowerMessage.includes('לילד'))) ||
                (lowerMessage.includes('מוצר') && (lowerMessage.includes('ל') || lowerMessage.includes('לאישה') || 
                 lowerMessage.includes('לבחורה') || lowerMessage.includes('לאשה') ||
                 lowerMessage.includes('לגבר') || lowerMessage.includes('לבחור') ||
                 lowerMessage.includes('לבעל') || lowerMessage.includes('לבעלי') ||
                 lowerMessage.includes('לילד'))) ||
                (lowerMessage.includes('מרקט') || lowerMessage.includes('מרקטפלייס')) && 
                 (lowerMessage.includes('תמליצי') || lowerMessage.includes('תמליץ') || lowerMessage.includes('מוצר') || 
                  lowerMessage.includes('מתנה') || lowerMessage.includes('המלצ'));
            
            if (!isMarketplaceQuery) {
                // For other general questions, send to N8N
                return null; // Let N8N handle general questions
            }
            
            // Reset search context if user is searching for something new
            if (lowerMessage.includes('מחפש') || lowerMessage.includes('המלצ') || lowerMessage.includes('לא') || lowerMessage.includes('לא ') || lowerMessage.includes('נגיד') || lowerMessage.includes('ולק') || lowerMessage.includes('ושעון') || lowerMessage.includes('וצעצוע') || lowerMessage.includes('צעצועים') || lowerMessage.includes('צעצוע') || lowerMessage.includes('שעונים') || lowerMessage.includes('שעון')) {
                lastSearchContext = null;
                lastSearchResults = [];
                console.log('🔄 Reset search context for new search or rejection');
            }
            
            // Special handling for "cheapest" or "most expensive" across all pages
            // ✅ Added more variations like "מוצר זול", "מוצר הזול", "המוצר הזול"
            // 🎯 FIX: Also handle "מה המוצר הכי זול במרקט" and variations
            if (lowerMessage.includes('הכי זול') || lowerMessage.includes('הכי יקר') || lowerMessage.includes('השוואה') || 
                lowerMessage.includes('מוצר זול') || lowerMessage.includes('מוצר הזול') || lowerMessage.includes('המוצר הזול') ||
                lowerMessage.includes('מוצר יקר') || lowerMessage.includes('מוצר היקר') || lowerMessage.includes('המוצר היקר') ||
                lowerMessage.includes('מה הזול') || lowerMessage.includes('מה היקר') || lowerMessage.includes('זול ביותר') || lowerMessage.includes('יקר ביותר') ||
                lowerMessage.includes('מה המוצר הכי זול') || lowerMessage.includes('מה המוצר הכי יקר') ||
                lowerMessage.includes('המוצר הכי זול במרקט') || lowerMessage.includes('המוצר הכי זול במרקטפלייס') ||
                lowerMessage.includes('מחירים') || lowerMessage.includes('מחיר') || lowerMessage.includes('כמה עולה') || 
                lowerMessage.includes('השווא') || lowerMessage.includes('השוויה')) {
                console.log('🔍 Price comparison search triggered:', lowerMessage);
                
                // Determine what product they're looking for
                let searchKeyword = '';
                
                // 🧠 FIRST: Check conversation context (if user already said what they want)
                if (window.marketplaceConversationContext && window.marketplaceConversationContext.lastSearchCategory) {
                    const lastCategory = window.marketplaceConversationContext.lastSearchCategory.toLowerCase();
                    // If last search was for a specific category, use it!
                    if (lastCategory.includes('צעצוע')) searchKeyword = 'צעצוע';
                    else if (lastCategory.includes('שעון')) searchKeyword = 'שעון';
                    else if (lastCategory.includes('לק')) searchKeyword = 'לק';
                    else if (lastCategory.includes('תכשיט')) searchKeyword = 'תכשיט';
                    else if (lastCategory.includes('טכנולוגיה')) searchKeyword = 'טכנולוגיה';
                    
                    console.log('🧠 Using last search context:', searchKeyword);
                }
                
                // If no context, check the current message
                if (!searchKeyword) {
                    // ✅ Check for product keywords (including "ה" prefix like "הצעצוע", "התכשיט")
                    if (lowerMessage.includes('שעון') || lowerMessage.includes('שעונים') || lowerMessage.includes('השעון')) searchKeyword = 'שעון';
                    else if (lowerMessage.includes('צעצוע') || lowerMessage.includes('צעצועים') || lowerMessage.includes('הצעצוע')) searchKeyword = 'צעצוע';
                    else if (lowerMessage.includes('לק') || lowerMessage.includes('הלק')) searchKeyword = 'לק';
                    else if (lowerMessage.includes('תכשיט') || lowerMessage.includes('תכשיטים') || lowerMessage.includes('התכשיט')) searchKeyword = 'תכשיט';
                    else if (lowerMessage.includes('טכנולוגיה') || lowerMessage.includes('הטכנולוגיה')) searchKeyword = 'טכנולוגיה';
                    else if (lowerMessage.includes('נקיון') || lowerMessage.includes('נקה') || lowerMessage.includes('ניקוי')) searchKeyword = 'נקיון';
                    else if (lowerMessage.includes('נגר') || lowerMessage.includes('תיקון') || lowerMessage.includes('בעיות מים')) searchKeyword = 'שירותים';
                    else searchKeyword = 'מוצר';
                }
                
                console.log('🔍 Search keyword for comparison:', searchKeyword);
                console.log('📊 Original message:', userMessage);
                console.log('📊 Lowercase message:', lowerMessage);
                
                // 💾 SAVE the search category for future reference
                window.marketplaceConversationContext.lastSearchCategory = searchKeyword;
                console.log('💾 Saved search category:', searchKeyword);
                
                // 🔥 NEW APPROACH: Filter pages AFTER reading their live content!
                let relevantPages = [];
                
                if (searchKeyword === 'מוצר') {
                    // For general "מוצר" - include all store pages AND messageInBottle
                    relevantPages = allPages.filter(page => page.pageType === 'store' || page.pageType === 'messageInBottle');
                } else {
                    // 🔥 FOR SPECIFIC CATEGORIES - Read LIVE HTML and check!
                    const pluralKeyword = searchKeyword + 'ים';
                    
                    for (const page of allPages) {
                        // Include both store pages AND messageInBottle pages
                        if (page.pageType !== 'store' && page.pageType !== 'messageInBottle') continue;
                        
                        const titleLower = page.title.toLowerCase();
                        const descLower = (page.description || '').toLowerCase();
                        const requestLower = (page.request || '').toLowerCase();
                        
                        // Quick check: Title, description, or request match
                        if (titleLower.includes(searchKeyword) || titleLower.includes(pluralKeyword) ||
                            descLower.includes(searchKeyword) || descLower.includes(pluralKeyword) ||
                            requestLower.includes(searchKeyword) || requestLower.includes(pluralKeyword)) {
                            relevantPages.push(page);
                            console.log(`✅ Page "${page.title}" matched by title/description/request`);
                            continue;
                        }
                        
                        // 🔥 If not in title/desc, check LIVE products!
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            
                            // 🔥 Extract LIVE products and check if ANY product matches the keyword!
                            const liveProducts = extractLiveProducts(html);
                            const hasMatchingProduct = liveProducts.some(product => {
                                const productName = product.name.toLowerCase();
                                return productName.includes(searchKeyword) || productName.includes(pluralKeyword);
                            });
                            
                            if (hasMatchingProduct) {
                                relevantPages.push(page);
                                console.log(`✅ Page "${page.title}" matched by LIVE products`);
                            } else {
                                console.log(`❌ Page "${page.title}" has NO products matching "${searchKeyword}"`);
                            }
                        } catch (error) {
                            console.error('Error checking page:', page.title, error);
                        }
                    }
                }
                
                console.log(`🔍 Found ${relevantPages.length} pages matching "${searchKeyword}":`, relevantPages.map(p => p.title));
                
                if (relevantPages.length > 0) {
                    // Check if we have messageInBottle pages
                    const messageInBottlePages = relevantPages.filter(page => page.pageType === 'messageInBottle');
                    const storePages = relevantPages.filter(page => page.pageType === 'store');
                    
                    // Handle messageInBottle pages differently
                    if (messageInBottlePages.length > 0) {
                        let response = '';
                        
                        if (messageInBottlePages.length === 1) {
                            const page = messageInBottlePages[0];
                            response = `🍾 **מצאתי מסר בבקבוק רלוונטי!**\n\n`;
                            response += `**${page.name}** - ${page.request}\n`;
                            response += `📍 **אזור:** ${page.area}\n`;
                            if (page.phone) {
                                response += `📞 **טלפון:** ${page.phone}\n`;
                            }
                            if (page.price) {
                                response += `💰 **מחיר:** ₪${page.price} ${page.priceType || 'כללי'}\n`;
                            }
                            response += `\n🔗 [צפה בדף](/users/${page.userId}/${page.pageId}_html)\n\n`;
                            response += `💬 **השאר פרטים ואני אמסור אותם!**`;
                        } else {
                            response = `🍾 **מצאתי ${messageInBottlePages.length} מסרים בבקבוק רלוונטיים!**\n\n`;
                            
                            messageInBottlePages.forEach((page, index) => {
                                response += `**${index + 1}. ${page.name}** - ${page.request}\n`;
                                response += `📍 **אזור:** ${page.area}\n`;
                                if (page.phone) {
                                    response += `📞 **טלפון:** ${page.phone}\n`;
                                }
                                if (page.price) {
                                    response += `💰 **מחיר:** ₪${page.price} ${page.priceType || 'כללי'}\n`;
                                }
                                response += `🔗 [צפה בדף](/users/${page.userId}/${page.pageId}_html)\n\n`;
                            });
                            
                            response += `💬 **השאר פרטים ואני אמסור אותם למי שמתאים!**`;
                        }
                        
                        return response;
                    }
                    
                    // Handle store pages (existing logic)
                    let allProducts = [];
                    
                    // 🔥 READ LIVE PRODUCTS FROM EACH PAGE (not from old metadata)!
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        
                        try {
                            // 🔥 Fetch the LIVE HTML page
                            const response = await fetch(pageUrl);
                            if (!response.ok) {
                                console.warn('Failed to fetch page:', pageUrl);
                                continue;
                            }
                            
                            const html = await response.text();
                            
                            // 🔥 Extract LIVE products from HTML
                            const liveProducts = extractLiveProducts(html);
                            console.log(`🔥 Extracted ${liveProducts.length} LIVE products from ${page.title}:`, liveProducts);
                            
                            if (liveProducts.length > 0) {
                                // 🎯 FOR SPECIFIC CATEGORIES: Include ALL products from relevant pages!
                                // The page itself is already filtered by category, so we trust the products in it
                                if (searchKeyword !== 'מוצר') {
                                    console.log(`🎯 Including ALL ${liveProducts.length} products from "${page.title}" (category: ${searchKeyword})`);
                                    liveProducts.forEach(product => {
                                        allProducts.push({
                                            ...product,
                                            pageTitle: page.title,
                                            pageUrl: pageUrl,
                                            pageName: page.title
                                        });
                                    });
                                } else {
                                    // For general "מוצר", include all products
                                    liveProducts.forEach(product => {
                                        allProducts.push({
                                            ...product,
                                            pageTitle: page.title,
                                            pageUrl: pageUrl,
                                            pageName: page.title
                                        });
                                    });
                                }
                            }
                        } catch (error) {
                            console.error('Error extracting live products from', pageUrl, ':', error);
                        }
                    }
                    
                    // If we have both messageInBottle pages and store products, combine them
                    if (messageInBottlePages.length > 0 && allProducts.length > 0) {
                        let response = '';
                        
                        // Add messageInBottle pages
                        response += `🍾 **מצאתי ${messageInBottlePages.length} מסרים בבקבוק רלוונטיים!**\n\n`;
                        
                        messageInBottlePages.forEach((page, index) => {
                            response += `**${index + 1}. ${page.name}** - ${page.request}\n`;
                            response += `📍 **אזור:** ${page.area}\n`;
                            if (page.phone) {
                                response += `📞 **טלפון:** ${page.phone}\n`;
                            }
                            if (page.price) {
                                response += `💰 **מחיר:** ₪${page.price} ${page.priceType || 'כללי'}\n`;
                            }
                            response += `🔗 [צפה בדף](/users/${page.userId}/${page.pageId}_html)\n\n`;
                        });
                        
                        response += `\n🛍️ **וגם יש לי ${allProducts.length} מוצרים רלוונטיים:**\n\n`;
                        
                        // Add store products
                        allProducts.slice(0, 3).forEach((product, index) => {
                            response += `**${index + 1}. ${product.name}** - ₪${product.price}\n`;
                            response += `🏪 **חנות:** ${product.pageTitle}\n`;
                            response += `🔗 [צפה בדף](${product.pageUrl})\n\n`;
                        });
                        
                        if (allProducts.length > 3) {
                            response += `... ועוד ${allProducts.length - 3} מוצרים נוספים!\n\n`;
                        }
                        
                        response += `💬 **השאר פרטים ואני אמסור אותם למי שמתאים!**`;
                        
                        return response;
                    }
                    
                    // If we only have store products, continue with existing logic
                    if (allProducts.length > 0) {
                        // Sort by price
                        allProducts.sort((a, b) => {
                            const priceA = parseInt(a.price.replace(',', ''));
                            const priceB = parseInt(b.price.replace(',', ''));
                            return priceA - priceB;
                        });
                        
                        const cheapest = allProducts[0];
                        const mostExpensive = allProducts[allProducts.length - 1];
                        
                        // 🎯 FIX: Ensure we only use REAL products, not invented ones
                        if (!cheapest || !cheapest.name || !cheapest.price) {
                            console.error('❌ Invalid cheapest product:', cheapest);
                            return `מצטער, לא מצאתי מידע על מוצרים זמינים כרגע במרקטפלייס. נסה לחפש מוצר ספציפי או בדוק את הדפים הזמינים.`;
                        }
                        
                        // 🤖 CONVERSATIONAL RESPONSE - Talk like a friend!
                        let response = '';
                        
                        // 🎯 FIX: Also handle "מה המוצר הכי זול במרקט" variations
                        if (lowerMessage.includes('הכי זול') || lowerMessage.includes('מה המוצר הכי זול') || lowerMessage.includes('המוצר הכי זול במרקט')) {
                            // 🎯 FIX: Use REAL product name and price only
                            const productName = cheapest.name || 'מוצר';
                            const productPrice = cheapest.price || 'מחיר לפי בקשה';
                            const pageTitle = cheapest.pageTitle || cheapest.pageName || 'חנות';
                            
                            // 🎯 FIX: Get page URL for link - find the page from allPages
                            const cleanPageTitle = pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                            let pageUrl = '';
                            
                            // Try to find page from allPages using userId and pageId if available
                            if (cheapest.userId && cheapest.pageId) {
                                pageUrl = `/users/${cheapest.userId}/${cheapest.pageId}_html`;
                            } else if (cheapest.pageUrl) {
                                pageUrl = cheapest.pageUrl;
                            } else {
                                // Fallback: find page from allPages by title
                                for (const page of allPages) {
                                    if (page.title === pageTitle || page.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === cleanPageTitle) {
                                        pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        break;
                                    }
                                }
                            }
                            
                            response += `🤖 **יש לי "${productName}" במחיר ₪${productPrice}** - זה ${searchKeyword === 'מוצר' ? 'המוצר' : `ה${searchKeyword}`} הכי זול במרקט!\n\n`;
                            response += `📍 הוא נמצא ב**${cleanPageTitle}**\n`;
                            if (pageUrl) {
                                response += `🔗 **צפה בדף:** ${pageUrl}\n\n`;
                            }
                            response += `💡 **רוצה שאחפש לך עוד משהו?** או רוצה לראות את הדף?`;
                            
                            console.log('✅ Returning REAL cheapest product:', {
                                name: productName,
                                price: productPrice,
                                pageTitle: cleanPageTitle,
                                pageUrl: pageUrl
                            });
                        } else if (lowerMessage.includes('הכי יקר') || lowerMessage.includes('מה המוצר הכי יקר')) {
                            // 🎯 FIX: Use REAL product name and price only, with link
                            const productName = mostExpensive.name || 'מוצר';
                            const productPrice = mostExpensive.price || 'מחיר לפי בקשה';
                            const pageTitle = mostExpensive.pageTitle || mostExpensive.pageName || 'חנות';
                            const cleanPageTitle = pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                            
                            // 🎯 FIX: Get page URL for link
                            let pageUrl = '';
                            if (mostExpensive.userId && mostExpensive.pageId) {
                                pageUrl = `/users/${mostExpensive.userId}/${mostExpensive.pageId}_html`;
                            } else if (mostExpensive.pageUrl) {
                                pageUrl = mostExpensive.pageUrl;
                            } else {
                                // Fallback: find page from allPages by title
                                for (const page of allPages) {
                                    if (page.title === pageTitle || page.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === cleanPageTitle) {
                                        pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        break;
                                    }
                                }
                            }
                            
                            response += `🤖 **יש לי "${productName}" במחיר ₪${productPrice}** - זה ${searchKeyword === 'מוצר' ? 'המוצר' : `ה${searchKeyword}`} הכי יקר במרקט!\n\n`;
                            response += `📍 הוא נמצא ב**${cleanPageTitle}**\n`;
                            if (pageUrl) {
                                response += `🔗 **צפה בדף:** ${pageUrl}\n\n`;
                            }
                            response += `💡 **רוצה שאחפש לך עוד משהו?** או רוצה לראות את הדף?`;
                        } else {
                            response += `🤖 **מצאתי ${allProducts.length} מוצרים ב-${relevantPages.length} חנויות!**\n\n`;
                            response += `🥇 **הכי זול:** ${cheapest.name} - ₪${cheapest.price}\n`;
                            response += `💎 **הכי יקר:** ${mostExpensive.name} - ₪${mostExpensive.price}\n\n`;
                            response += `💡 **רוצה לראות את המוצרים? או שאחפש לך משהו אחר?**`;
                        }
                        
                        // 💾 SAVE the recommended page in context so we can open it if user says "yes"
                        const recommendedProduct = lowerMessage.includes('הכי זול') ? cheapest : (lowerMessage.includes('הכי יקר') ? mostExpensive : cheapest);
                        const firstRelevantPage = relevantPages[0];
                        
                        // 🎯 CLEAN the title - remove timestamp (e.g., "1761023899504")
                        const cleanTitle = firstRelevantPage.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                        
                        window.marketplaceConversationContext.recommendedPage = {
                            title: cleanTitle,
                            url: firstRelevantPage.url,
                            pageId: firstRelevantPage.pageId
                        };
                        console.log('💾 Saved recommended page (Marketplace):', window.marketplaceConversationContext.recommendedPage);
                        
                        addAIMessage(response, false);
                        return; // STOP HERE - We showed price comparison
                        
                        // OLD CODE - Remove automatic preview:
                        // Add page preview after comparison
                        if (false && lowerMessage.includes('הכי זול')) {
                            response += `\n\n📱 **תצוגה מקדימה של הדף הזול ביותר:**\n`;
                            response += `![${cheapest.pageTitle}](${cheapest.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>📱 תצוגה מקדימה: ${cheapest.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${cheapest.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        } else if (lowerMessage.includes('הכי יקר')) {
                            response += `\n\n📱 **תצוגה מקדימה של הדף היקר ביותר:**\n`;
                            response += `![${mostExpensive.pageTitle}](${mostExpensive.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>📱 תצוגה מקדימה: ${mostExpensive.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${mostExpensive.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        } else {
                            response += `\n\n📱 **תצוגה מקדימה של הדף הזול ביותר:**\n`;
                            response += `![${cheapest.pageTitle}](${cheapest.pageUrl})\n`;
                            
                            // Add delay and then show preview
                            setTimeout(() => {
                                const chatContainer = document.querySelector('.ai-chat-messages');
                                if (chatContainer) {
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'page-preview';
                                    previewDiv.innerHTML = `
                                        <div class="preview-header">
                                            <h3>📱 תצוגה מקדימה: ${cheapest.pageTitle}</h3>
                                        </div>
                                        <div class="preview-content">
                                            <iframe src="${cheapest.pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                        </div>
                                    `;
                                    chatContainer.appendChild(previewDiv);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    
                                    // Add animation
                                    previewDiv.style.opacity = '0';
                                    previewDiv.style.transform = 'translateY(20px)';
                                    setTimeout(() => {
                                        previewDiv.style.transition = 'all 0.5s ease';
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 200);
                                }
                            }, 2000);
                        }
                        
                        return response;
                    }
                }
                
                return `❌ **לא מצאתי תוצאות רלוונטיות במערכת שלנו.**\n\n💡 **מה שיש לנו:**\n${allPages.slice(0, 4).map(page => `• ${page.title} - ${page.pageType === 'store' ? 'חנות' : page.pageType === 'course' ? 'קורס' : page.pageType === 'event' ? 'אירוע' : page.pageType === 'messageInBottle' ? 'מסר בבקבוק' : 'שירות'}`).join('\n')}\n\n🔍 **נסה:** "מחירים", "מה יש לכם", או "מחפש שירות"`;
            }
            
            
            
            // Price search - look for specific products
            if (lowerMessage.includes('מחיר') || lowerMessage.includes('כמה') || lowerMessage.includes('עולה') || lowerMessage.includes('₪') || lowerMessage.includes('שקל')) {
                console.log('💰 Price search triggered:', lowerMessage);
                
                // Determine what product they're looking for
                let searchKeyword = '';
                if (lowerMessage.includes('שעון') || lowerMessage.includes('שעונים')) {
                    searchKeyword = 'שעון';
                    console.log('🔍 Detected watch search');
                }
                else if (lowerMessage.includes('לק')) searchKeyword = 'לק';
                else if (lowerMessage.includes('צעצוע') || lowerMessage.includes('צעצועים')) searchKeyword = 'צעצוע';
                else if (lowerMessage.includes('תכשיט') || lowerMessage.includes('תכשיטים')) searchKeyword = 'תכשיט';
                else if (lastSearchContext) {
                    searchKeyword = lastSearchContext;
                    console.log('🔍 Using last search context:', lastSearchContext);
                }
                else if (lastSearchResults.length > 0) {
                    // Use last search results if available
                    relevantPages = lastSearchResults;
                    searchKeyword = lastSearchContext || 'מוצר';
                    console.log('🔍 Using last search results:', relevantPages.length, 'pages');
                }
                else searchKeyword = 'מוצר';
                
                console.log('🔍 Final search keyword:', searchKeyword);
                
                // Filter pages by specific keyword if mentioned - STRICT FILTERING
                let relevantPages = [];
                
                // Only search if we don't have results from previous search
                if (lastSearchResults.length === 0) {
                    relevantPages = allPages.filter(page => {
                    if (searchKeyword === 'מוצר') {
                        return page.pageType === 'store' || page.pageType === 'messageInBottle';
                    }
                    
                    const titleLower = page.title.toLowerCase();
                    const descLower = (page.description || '').toLowerCase();
                    const requestLower = (page.request || '').toLowerCase();
                    
                    // Check for both singular and plural forms
                    const pluralKeyword = searchKeyword + 'ים'; // e.g., שעון -> שעונים
                    
                    // Only show pages that actually contain the keyword in title OR description OR request OR products (singular or plural)
                    const hasKeywordInTitle = titleLower.includes(searchKeyword) || titleLower.includes(pluralKeyword);
                    const hasKeywordInDesc = descLower.includes(searchKeyword) || descLower.includes(pluralKeyword);
                    const hasKeywordInRequest = requestLower.includes(searchKeyword) || requestLower.includes(pluralKeyword);
                    
                    // Check if keyword exists in any product name
                    let hasKeywordInProducts = false;
                    if (page.products && page.products.length > 0) {
                        hasKeywordInProducts = page.products.some(product => 
                            product.name.toLowerCase().includes(searchKeyword) || 
                            product.name.toLowerCase().includes(pluralKeyword)
                        );
                    }
                    
                    // Search in all page types, not just stores
                    const matches = (hasKeywordInTitle || hasKeywordInDesc || hasKeywordInProducts);
                    
                    if (matches) {
                        console.log('✅ Found matching page:', page.title, '(searching for:', searchKeyword, 'or', pluralKeyword + ')');
                    }
                    
                    return matches;
                    });
                } else {
                    // Use previous search results
                    relevantPages = lastSearchResults;
                }
                
                // If no specific keyword found, show all stores and messageInBottle
                if (relevantPages.length === 0 && searchKeyword === 'מוצר') {
                    relevantPages = allPages.filter(page => page.pageType === 'store' || page.pageType === 'messageInBottle');
                }
                
                console.log(`🔍 Searching for "${searchKeyword}" - found ${relevantPages.length} pages`);
                
                    if (relevantPages.length > 0) {
                        // Save search results for context
                        lastSearchResults = relevantPages;
                        
                        let response = `💰 **מחירים עבור ${searchKeyword}:**\n\n`;
                        
                        // Add smart recommendations before showing prices
                        if (searchKeyword === 'מתנה' || searchKeyword === 'מתנות') {
                            response += `🎁 **המלצות מתנות מושלמות:**\n\n`;
                            
                            // Categorize pages by type for better recommendations
                            const storePages = relevantPages.filter(p => p.pageType === 'store');
                            const servicePages = relevantPages.filter(p => p.pageType === 'serviceProvider');
                            const coursePages = relevantPages.filter(p => p.pageType === 'course');
                            const eventPages = relevantPages.filter(p => p.pageType === 'event');
                            const messageInBottlePages = relevantPages.filter(p => p.pageType === 'messageInBottle');
                            
                            if (storePages.length > 0) {
                                response += `🛍️ **מתנות מחנויות:**\n`;
                                storePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `• **${page.title}** - מתנות איכותיות! 🏪\n`;
                                    response += `  [👁️ צפה בדף](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (servicePages.length > 0) {
                                response += `💅 **מתנות חוויה:**\n`;
                                servicePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `• **${page.title}** - חוויה מפנקת! 💅\n`;
                                    response += `  [👁️ צפה בדף](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (coursePages.length > 0) {
                                response += `🎓 **מתנות העשרה:**\n`;
                                coursePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `• **${page.title}** - מתנה שתשנה חיים! 🎓\n`;
                                    response += `  [👁️ צפה בדף](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (eventPages.length > 0) {
                                response += `🎉 **מתנות אירועים:**\n`;
                                eventPages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `• **${page.title}** - חוויה בלתי נשכחת! 🎉\n`;
                                    response += `  [👁️ צפה בדף](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            if (messageInBottlePages.length > 0) {
                                response += `🍾 **מסרים בבקבוק:**\n`;
                                messageInBottlePages.slice(0, 2).forEach(page => {
                                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                    response += `• **${page.name}** - ${page.request} 🍾\n`;
                                    if (page.price) {
                                        response += `  💰 **מחיר:** ₪${page.price} ${page.priceType || 'כללי'}\n`;
                                    }
                                    response += `  [👁️ צפה בדף](${pageUrl})\n`;
                                });
                                response += `\n`;
                            }
                            
                            response += `💡 **טיפ:** לכל מתנה יש מחירים שונים - כתוב "מחירים" כדי לראות את כל המחירים!\n\n`;
                        }
                        
                        for (const page of relevantPages.slice(0, 3)) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        
                        if (page.pageType === 'messageInBottle') {
                            response += `• **${page.name}** 🍾\n`;
                            response += `  **${page.request}**\n`;
                            response += `  📍 **אזור:** ${page.area}\n`;
                            if (page.price) {
                                response += `  💰 **מחיר:** ₪${page.price} ${page.priceType || 'כללי'}\n`;
                            }
                            response += `  [👁️ צפה בדף](${pageUrl})\n\n`;
                        } else {
                        response += `• **${page.title}** 🏪\n`;
                        response += `  [👁️ צפה בדף](${pageUrl})\n`;
                        
                        // Use products from metadata if available - ENHANCED PRODUCT INFO
                        if (page.products && page.products.length > 0) {
                            response += `\n  **🛍️ מוצרים זמינים:**\n`;
                            
                            // Sort products by price for better recommendations
                            const sortedProducts = [...page.products].sort((a, b) => 
                                parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                            );
                            
                            sortedProducts.slice(0, 5).forEach((product, index) => {
                                const price = parseInt(product.price.replace(',', ''));
                                let priceEmoji = '💰';
                                if (price < 100) priceEmoji = '💚';
                                else if (price < 500) priceEmoji = '💛';
                                else if (price < 1000) priceEmoji = '🧡';
                                else priceEmoji = '❤️';
                                
                                response += `  ${priceEmoji} **${product.name}** - ₪${product.price}`;
                                
                                // Add availability status
                                if (index === 0) response += ` ⭐ **הכי זול!**`;
                                if (index === sortedProducts.length - 1) response += ` 💎 **פרימיום**`;
                                
                                response += `\n`;
                            });
                            
                            // Smart recommendations based on user intent
                            if (lowerMessage.includes('זול') || lowerMessage.includes('הכי זול')) {
                                const cheapest = sortedProducts[0];
                                response += `\n  🎯 **המלצה חכמה:** ${cheapest.name} - הכי משתלם! ₪${cheapest.price}\n`;
                            } else if (lowerMessage.includes('יקר') || lowerMessage.includes('יוקרה')) {
                                const mostExpensive = sortedProducts[sortedProducts.length - 1];
                                response += `\n  💎 **המלצה יוקרה:** ${mostExpensive.name} - הכי איכותי! ₪${mostExpensive.price}\n`;
                            } else if (lowerMessage.includes('מתנה') || lowerMessage.includes('מתנת')) {
                                const midRange = sortedProducts[Math.floor(sortedProducts.length / 2)];
                                response += `\n  🎁 **מתנה מושלמת:** ${midRange.name} - איזון מושלם! ₪${midRange.price}\n`;
                            }
                            
                            // Add total products count
                            if (page.products.length > 5) {
                                response += `\n  📊 **סה"כ ${page.products.length} מוצרים זמינים** - [👁️ צפה בכולם](${pageUrl})\n`;
                            }
                            
                            response += `\n`;
                            }
                        }
                        
                        response += `\n💡 **טיפ:** כתוב "מחירים" כדי לראות את כל המחירים או "הכי זול" למחיר הטוב ביותר!\n`;
                    }
                    
                    if (searchKeyword !== 'מוצר') {
                        response += `🔍 **רוצה חיפוש ספציפי?** כתוב "שעון" או "תכשיט" ואני אחפש עבורך!`;
                    }
                    
                    // Add page preview after recommendations
                    if (relevantPages.length > 0) {
                        const firstPage = relevantPages[0];
                        const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                        response += `\n\n📱 **תצוגה מקדימה:**\n`;
                        response += `![${firstPage.title}](${pageUrl})\n`;
                        
                        // Add delay and then show preview
                        setTimeout(() => {
                            const chatContainer = document.querySelector('.ai-chat-messages');
                            if (chatContainer) {
                                const previewDiv = document.createElement('div');
                                previewDiv.className = 'page-preview';
                                previewDiv.innerHTML = `
                                    <div class="preview-header">
                                        <h3>📱 תצוגה מקדימה: ${firstPage.title}</h3>
                                    </div>
                                    <div class="preview-content">
                                        <iframe src="${pageUrl}" width="100%" height="400" frameborder="0" sandbox="allow-scripts allow-same-origin"></iframe>
                                    </div>
                                `;
                                chatContainer.appendChild(previewDiv);
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                                
                                // Add animation
                                previewDiv.style.opacity = '0';
                                previewDiv.style.transform = 'translateY(20px)';
                                setTimeout(() => {
                                    previewDiv.style.transition = 'all 0.5s ease';
                                    previewDiv.style.opacity = '1';
                                    previewDiv.style.transform = 'translateY(0)';
                                }, 100);
                            }
                        }, 2000); // Wait 2 seconds before showing preview
                    }
                    
                    return response;
                }
                
                return `❌ **לא מצאתי תוצאות רלוונטיות במערכת שלנו.**\n\n💡 **מה שיש לנו:**\n${allPages.slice(0, 4).map(page => `• ${page.title} - ${page.pageType === 'store' ? 'חנות' : page.pageType === 'course' ? 'קורס' : page.pageType === 'event' ? 'אירוע' : page.pageType === 'messageInBottle' ? 'מסר בבקבוק' : 'שירות'}`).join('\n')}\n\n🔍 **נסה:** "מחירים", "מה יש לכם", או "מחפש שירות"`;
            }
            
            
            // Check for specific keywords and search
            const keywords = {
                'מתנה': 'store',
                'מתנות': 'store',
                'לק': 'serviceProvider',
                'מניקור': 'serviceProvider', 
                'פדיקור': 'serviceProvider',
                'צעצוע': 'store',
                'ילד': 'store',
                'חנות': 'store',
                'קורס': 'course',
                'לימוד': 'course',
                'אירוע': 'event',
                'חתונה': 'event',
                'שעון': 'store',
                'שעונים': 'store',
                'תכשיט': 'store',
                'תכשיטים': 'store',
                'זהב': 'store',
                'כסף': 'store',
                'יהלום': 'store',
                'יהלומים': 'store',
                'עגיל': 'store',
                'עגילים': 'store',
                'צמיד': 'store',
                'צמידים': 'store',
                'שרשרת': 'store',
                'שרשראות': 'store',
                'טבעת': 'store',
                'טבעות': 'store'
            };
            
            // Check for specific needs and provide focused recommendations
            const specificNeeds = {
                'זול': { type: 'price', focus: 'cheapest' },
                'יקר': { type: 'price', focus: 'expensive' },
                'מתנה לילד': { type: 'gift', focus: 'child' },
                'מתנה לאישה': { type: 'gift', focus: 'woman' },
                'מתנה לגבר': { type: 'gift', focus: 'man' },
                'מתנה לזוג': { type: 'gift', focus: 'couple' },
                'מתנה ליום הולדת': { type: 'gift', focus: 'birthday' },
                'מתנה לחג': { type: 'gift', focus: 'holiday' },
                'מתנה מיוחדת': { type: 'gift', focus: 'special' },
                'מתלבט': { type: 'help', focus: 'undecided' },
                'לא יודע': { type: 'help', focus: 'undecided' },
                'מה לבחור': { type: 'help', focus: 'undecided' },
                'איזה': { type: 'help', focus: 'choice' },
                'איך לבחור': { type: 'help', focus: 'choice' }
            };
            
            // Smart keyword matching - find related words
            const smartKeywords = {
                'מתנה': ['מתנה', 'מתנות', 'מתנת', 'מתנות', 'מתנה ל', 'מתנה לילד', 'מתנה לאישה', 'מתנה לגבר', 'מתנה ליום הולדת', 'מתנה לחג', 'מתנה מיוחדת'],
                'שעון': ['שעון', 'שעונים', 'זמן', 'זמנים', 'יד', 'ידיים', 'מבוגר', 'מבוגרים', 'קלאסי', 'ספורט', 'יוקרה', 'סמארט'],
                'תכשיט': ['תכשיט', 'תכשיטים', 'זהב', 'כסף', 'יהלום', 'יהלומים', 'עגיל', 'עגילים', 'צמיד', 'צמידים', 'שרשרת', 'שרשראות', 'טבעת', 'טבעות'],
                'צעצוע': ['צעצוע', 'צעצועים', 'ילד', 'ילדים', 'משחק', 'משחקים', 'בובה', 'בובות', 'רכב', 'מכונית'],
                'לק': ['לק', 'מניקור', 'פדיקור', 'ציפורניים', 'יופי', 'יופי', 'ספא', 'טיפוח'],
                'קורס': ['קורס', 'קורסים', 'לימוד', 'לימודים', 'הדרכה', 'הדרכות', 'סמינר', 'סמינרים']
            };
            
            // Check for specific needs first - DISABLED TO PREVENT INVENTING
            let specificNeed = null;
            // for (const [need, config] of Object.entries(specificNeeds)) {
            //     if (lowerMessage.includes(need)) {
            //         specificNeed = config;
            //         break;
            //     }
            // }
            
            // Smart search - check for any related keywords
            for (const [mainKeyword, relatedWords] of Object.entries(smartKeywords)) {
                const hasRelatedWord = relatedWords.some(word => lowerMessage.includes(word));
                if (hasRelatedWord) {
                    const type = keywords[mainKeyword] || 'store';
                    
                    // Remember search context for future price queries
                    lastSearchContext = mainKeyword;
                    
                    // More precise search - look in title and description with better matching
                    let matchingPages = allPages.filter(page => {
                        const titleLower = page.title.toLowerCase();
                        const descLower = (page.description || '').toLowerCase();
                        
                        // Check if any related word appears in title or description
                        const titleMatch = relatedWords.some(word => titleLower.includes(word));
                        const descMatch = relatedWords.some(word => descLower.includes(word));
                        
                        // Also check for partial matches and synonyms
                        const partialMatch = relatedWords.some(word => {
                            const wordParts = word.split(' ');
                            return wordParts.some(part => 
                                titleLower.includes(part) || descLower.includes(part)
                            );
                        });
                        
                        return page.pageType === type && (titleMatch || descMatch || partialMatch);
                    });
                    
                    // DISABLED - No more inventing recommendations
                    // Apply specific filtering based on user needs
                    // if (specificNeed) { ... }
                    
                    console.log(`🔍 Searching for "${mainKeyword}" in type "${type}"`, { matchingPages: matchingPages.length, allPages: allPages.length });
                    
                    if (matchingPages.length > 0) {
                        let response = '';
                        
                        // Simple response - no more inventing
                        response = `🎯 **מצאתי ${matchingPages.length} דפים רלוונטיים ל"${mainKeyword}":**\n\n`;
                        
                        // Add smart recommendations for gifts
                        if (mainKeyword === 'מתנה' || mainKeyword === 'מתנות') {
                            response += `🎁 **מתנות מושלמות! בואו נמצא את המתנה המושלמת:**\n\n`;
                            
                            // Show specific products with prices for children
                            if (lowerMessage.includes('ילד') || lowerMessage.includes('ילדים') || lowerMessage.includes('ילדה') || lowerMessage.includes('ילדות')) {
                                response += `👶 **מתנות מושלמות לילדים - הנה המלצה ספציפית:**\n\n`;
                                
                                // Find toy pages specifically - exclude services
                                const toyPages = matchingPages.filter(p => 
                                    p.pageType === 'store' && 
                                    p.pageType !== 'serviceProvider' &&
                                    (p.title.toLowerCase().includes('צעצוע') || 
                                     p.title.toLowerCase().includes('toy') ||
                                     p.description?.toLowerCase().includes('צעצוע') ||
                                     p.title.toLowerCase().includes('משחק') ||
                                     p.description?.toLowerCase().includes('משחק') ||
                                     p.title.toLowerCase().includes('בובה') ||
                                     p.description?.toLowerCase().includes('בובה') ||
                                     p.title.toLowerCase().includes('רכב') ||
                                     p.description?.toLowerCase().includes('רכב') ||
                                     p.title.toLowerCase().includes('יניב') ||
                                     p.description?.toLowerCase().includes('ילדים') ||
                                     p.description?.toLowerCase().includes('ילד')) &&
                                    !p.title.toLowerCase().includes('לק') &&
                                    !p.title.toLowerCase().includes('גל') &&
                                    !p.title.toLowerCase().includes('שעון') &&
                                    !p.title.toLowerCase().includes('תכשיט')
                                );
                                
                                if (toyPages.length > 0) {
                                    // Show ONLY ONE specific product with price
                                    const firstPage = toyPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `🧸 **${firstPage.title}**\n`;
                                    
                                    // Try to get real product info - only show if we have real data
                                    if (firstPage.products && firstPage.products.length > 0) {
                                        const sortedProducts = [...firstPage.products].sort((a, b) => 
                                            parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                                        );
                                        
                                        // Show only the cheapest product as recommendation
                                        const cheapestProduct = sortedProducts[0];
                                        const price = parseInt(cheapestProduct.price.replace(',', ''));
                                        let priceEmoji = '💰';
                                        if (price < 100) priceEmoji = '💚';
                                        else if (price < 500) priceEmoji = '💛';
                                        else if (price < 1000) priceEmoji = '🧡';
                                        else priceEmoji = '❤️';
                                        
                                        response += `🎯 **המלצה שלי - מוצר אחד מושלם:**\n`;
                                        response += `  ${priceEmoji} **${cheapestProduct.name}** - ₪${cheapestProduct.price} ⭐ **הכי זול!**\n`;
                                        response += `  📊 **סה"כ ${sortedProducts.length} מוצרים זמינים**\n`;
                                    } else if (firstPage.description) {
                                        // Try to extract product info from description
                                        const productInfo = await extractProductInfo(firstPage.description, 'צעצוע', pageUrl);
                                        if (productInfo && productInfo.price) {
                                            response += `🎯 **המלצה שלי - מוצר אחד מושלם:**\n`;
                                            response += `  💰 **${productInfo.name || 'צעצוע מיוחד'}** - ${productInfo.price}\n`;
                                        } else {
                                            response += `🎯 **המלצה שלי - מוצר אחד מושלם:**\n`;
                                            response += `  🧸 **צעצועים חכמים ומהנים** - מחיר לפי בקשה\n`;
                                        }
                                    } else {
                                        response += `🎯 **המלצה שלי - מוצר אחד מושלם:**\n`;
                                        response += `  🧸 **צעצועים חכמים ומהנים** - מחיר לפי בקשה\n`;
                                    }
                                    
                                    response += `🏪 **חנות:** ${firstPage.title}\n`;
                                    response += `🔗 [👁️ צפה בדף](${pageUrl})\n\n`;
                                    
                                    response += `💡 **רוצה לראות עוד?** כתוב "מחירים" או "הכי זול"!\n\n`;
                                    
                                    // Add iframe preview after recommendations
                                    response += `📱 **תצוגה מקדימה של ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                } else {
                                    // Fallback to general pages
                                    response += `🎯 **המלצות כלליות לילדים:**\n`;
                                    matchingPages.slice(0, 2).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `• **${page.title}** - מתנה מושלמת! 🎁\n`;
                                        response += `  [👁️ צפה בדף](${pageUrl})\n`;
                                    });
                                }
                                
                            } else if (lowerMessage.includes('אישה') || lowerMessage.includes('נשים') || lowerMessage.includes('אישה') || lowerMessage.includes('נשים')) {
                                response += `👩 **מתנות מושלמות לנשים - הנה המלצות ספציפיות:**\n\n`;
                                
                                // Find beauty/service pages
                                const beautyPages = matchingPages.filter(p => 
                                    p.pageType === 'serviceProvider' || 
                                    (p.title.toLowerCase().includes('לק') || 
                                     p.title.toLowerCase().includes('גל') ||
                                     p.title.toLowerCase().includes('יופי') ||
                                     p.title.toLowerCase().includes('שיער') ||
                                     p.title.toLowerCase().includes('עיצוב') ||
                                     p.title.toLowerCase().includes('חגית') ||
                                     p.title.toLowerCase().includes('ניילס') ||
                                     p.description?.toLowerCase().includes('יופי') ||
                                     p.description?.toLowerCase().includes('שיער') ||
                                     p.description?.toLowerCase().includes('לק') ||
                                     p.description?.toLowerCase().includes('גל'))
                                );
                                
                                if (beautyPages.length > 0) {
                                    // Show specific services with prices
                                    for (const page of beautyPages.slice(0, 2)) {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `💅 **${page.title}**\n`;
                                        
                                        // Try to extract service info
                                        if (page.description) {
                                            const serviceInfo = await extractProductInfo(page.description, 'לק', pageUrl);
                                            if (serviceInfo && serviceInfo.price) {
                                                response += `🎯 **המלצה שלי:**\n`;
                                                response += `  💰 **${serviceInfo.name || 'שירות יופי'}** - ${serviceInfo.price}\n`;
                                            } else {
                                                response += `🎯 **המלצה שלי:**\n`;
                                                response += `  💅 **שירותי יופי מפנקים** - מחיר לפי בקשה\n`;
                                            }
                                        } else {
                                            response += `🎯 **המלצה שלי:**\n`;
                                            response += `  💅 **שירותי יופי מפנקים** - מחיר לפי בקשה\n`;
                                        }
                                        
                                        response += `🏪 **חנות:** ${page.title}\n`;
                                        response += `🔗 [👁️ צפה בדף](${pageUrl})\n\n`;
                                    }
                                } else {
                                    // Fallback to general pages
                                    response += `🎯 **המלצות כלליות לנשים:**\n`;
                                    matchingPages.slice(0, 2).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `• **${page.title}** - מתנה מושלמת! 🎁\n`;
                                        response += `  [👁️ צפה בדף](${pageUrl})\n`;
                                    });
                                }
                                
                                response += `💡 **רוצה לראות עוד?** כתוב "מחירים" או "הכי זול"!\n\n`;
                                
                            } else if (lowerMessage.includes('גבר') || lowerMessage.includes('גברים') || lowerMessage.includes('אב') || lowerMessage.includes('אבא')) {
                                response += `👨 **מתנות מושלמות לגברים - הנה המלצה ספציפית:**\n\n`;
                                
                                // Find tech/accessory pages
                                const techPages = matchingPages.filter(p => 
                                    p.pageType === 'store' && 
                                    (p.title.toLowerCase().includes('טכנולוגיה') || 
                                     p.title.toLowerCase().includes('שעון') ||
                                     p.title.toLowerCase().includes('תכשיט') ||
                                     p.title.toLowerCase().includes('גאדג\'ט') ||
                                     p.title.toLowerCase().includes('רובוט') ||
                                     p.title.toLowerCase().includes('red') ||
                                     p.title.toLowerCase().includes('ציפי') ||
                                     p.description?.toLowerCase().includes('שעון') ||
                                     p.description?.toLowerCase().includes('תכשיט') ||
                                     p.description?.toLowerCase().includes('רובוט') ||
                                     p.description?.toLowerCase().includes('טכנולוגיה'))
                                );
                                
                                if (techPages.length > 0) {
                                    // Show ONLY ONE specific product with price
                                    const firstPage = techPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    response += `⌚ **${firstPage.title}**\n`;
                                    
                                    // Try to get real product info - only show if we have real data
                                    if (firstPage.products && firstPage.products.length > 0) {
                                        const sortedProducts = [...firstPage.products].sort((a, b) => 
                                            parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                                        );
                                        
                                        // Show only the cheapest product as recommendation
                                        const cheapestProduct = sortedProducts[0];
                                        const price = parseInt(cheapestProduct.price.replace(',', ''));
                                        let priceEmoji = '💰';
                                        if (price < 100) priceEmoji = '💚';
                                        else if (price < 500) priceEmoji = '💛';
                                        else if (price < 1000) priceEmoji = '🧡';
                                        else priceEmoji = '❤️';
                                        
                                        response += `🎯 **המלצה שלי - מוצר אחד מושלם:**\n`;
                                        response += `  ${priceEmoji} **${cheapestProduct.name}** - ₪${cheapestProduct.price} ⭐ **הכי זול!**\n`;
                                        response += `  📊 **סה"כ ${sortedProducts.length} מוצרים זמינים**\n`;
                                    } else if (firstPage.description) {
                                        // Try to extract product info from description
                                        const productInfo = await extractProductInfo(firstPage.description, 'שעון', pageUrl);
                                        if (productInfo && productInfo.price) {
                                            response += `🎯 **המלצה שלי - מוצר אחד מושלם:**\n`;
                                            response += `  💰 **${productInfo.name || 'גאדג\'ט מיוחד'}** - ${productInfo.price}\n`;
                                        } else {
                                            response += `🎯 **המלצה שלי - מוצר אחד מושלם:**\n`;
                                            response += `  ⌚ **גאדג\'טים וטכנולוגיה מתקדמת** - מחיר לפי בקשה\n`;
                                        }
                                    } else {
                                        response += `🎯 **המלצה שלי - מוצר אחד מושלם:**\n`;
                                        response += `  ⌚ **גאדג\'טים וטכנולוגיה מתקדמת** - מחיר לפי בקשה\n`;
                                    }
                                    
                                    response += `🏪 **חנות:** ${firstPage.title}\n`;
                                    response += `🔗 [👁️ צפה בדף](${pageUrl})\n\n`;
                                    
                                    response += `💡 **רוצה לראות עוד?** כתוב "מחירים" או "הכי זול"!\n\n`;
                                } else {
                                    // Fallback to general pages
                                    response += `🎯 **המלצות כלליות לגברים:**\n`;
                                    matchingPages.slice(0, 3).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        response += `• **${page.title}** - מתנה מושלמת! 🎁\n`;
                                        response += `  [👁️ צפה בדף](${pageUrl})\n`;
                                    });
                                }
                                
                                response += `💡 **רוצה לראות עוד?** כתוב "מחירים" או "הכי זול"!\n\n`;
                                
                                // Add iframe preview after recommendations
                                if (techPages.length > 0) {
                                    const firstPage = techPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `📱 **תצוגה מקדימה של ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                    
                                    // Open fullscreen modal after delay
                                    setTimeout(() => {
                                        openPagePreviewModal(pageUrl, firstPage.title);
                                    }, 1500);
                                }
                                
                            } else {
                                // General gift recommendations - only show real pages
                                response += `🎯 **איזה סוג מתנה אתם מחפשים?**\n\n`;
                                
                                // Show only real pages from matchingPages
                                if (matchingPages.length > 0) {
                                    response += `🎁 **הדפים הזמינים במערכת:**\n`;
                                    matchingPages.slice(0, 5).forEach(page => {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        const emoji = page.pageType === 'store' ? '🛍️' : page.pageType === 'event' ? '🎉' : page.pageType === 'course' ? '🎓' : page.pageType === 'serviceProvider' ? '🔧' : '📄';
                                        response += `• **${page.title}** ${emoji} - ${page.description || 'מתנה מושלמת'}\n`;
                                        response += `  [👁️ צפה בדף](${pageUrl})\n`;
                                    });
                                    response += `\n`;
                                    
                                    // Add iframe preview for first page
                                    const firstPage = matchingPages[0];
                                    const pageUrl = `/users/${firstPage.userId}/${firstPage.pageId}_html`;
                                    
                                    response += `📱 **תצוגה מקדימה של ${firstPage.title}:**\n`;
                                    response += `![${firstPage.title}](${pageUrl})\n\n`;
                                    
                                    // Open fullscreen modal after delay
                                    setTimeout(() => {
                                        openPagePreviewModal(pageUrl, firstPage.title);
                                    }, 1500);
                                } else {
                                    response += `❌ **לא מצאתי דפים במערכת שלנו.**\n\n`;
                                }
                                
                                response += `❓ **עזור לי להמליץ לך:**\n`;
                                response += `• **למי המתנה?** (ילד, אישה, גבר, זוג) 👥\n`;
                                response += `• **איזה סוג?** (צעצועים, יופי, טכנולוגיה, קורסים) 🎯\n`;
                                response += `• **תקציב?** (זול, בינוני, פרימיום) 💰\n\n`;
                            }
                            
                            response += `💡 **רוצה לראות מחירים?** כתוב "מחירים" או "כמה זה עולה"!\n`;
                            response += `🎁 **רוצה המלצה ספציפית?** תגיד לי יותר פרטים!\n\n`;
                            
                        } else {
                            // Show actual available pages with specific recommendations
                            response += `📋 **המלצות ספציפיות:**\n\n`;
                        }
                        
                        // Only show pages if it's not a gift search (gift search shows questions instead)
                        if (mainKeyword !== 'מתנה' && mainKeyword !== 'מתנות') {
                            // Show more results if user asks for specific number
                            let maxResults = 3;
                            if (lowerMessage.includes('כמה') || lowerMessage.includes('הרבה') || lowerMessage.includes('כל')) {
                                maxResults = Math.min(matchingPages.length, 5);
                            }
                            
                            for (const page of matchingPages.slice(0, maxResults)) {
                            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                            // Use real page preview with iframe
                            const emoji = page.pageType === 'store' ? '🏪' : page.pageType === 'event' ? '🎉' : page.pageType === 'course' ? '🎓' : page.pageType === 'serviceProvider' ? '🔧' : '📄';
                            response += `• **${page.title}** ${emoji}\n`;
                            response += `  [👁️ צפה בדף](${pageUrl})\n`;
                            
                            // Add specific product info if available
                            if (page.pageType === 'store' && page.products && page.products.length > 0) {
                                response += `\n  **🛍️ מוצרים זמינים:**\n`;
                                
                                // Sort products by price for better recommendations
                                const sortedProducts = [...page.products].sort((a, b) => 
                                    parseInt(a.price.replace(',', '')) - parseInt(b.price.replace(',', ''))
                                );
                                
                                sortedProducts.slice(0, 3).forEach((product, index) => {
                                    const price = parseInt(product.price.replace(',', ''));
                                    let priceEmoji = '💰';
                                    if (price < 100) priceEmoji = '💚';
                                    else if (price < 500) priceEmoji = '💛';
                                    else if (price < 1000) priceEmoji = '🧡';
                                    else priceEmoji = '❤️';
                                    
                                    response += `  ${priceEmoji} **${product.name}** - ₪${product.price}`;
                                    
                                    if (index === 0) response += ` ⭐ **הכי זול!**`;
                                    if (index === sortedProducts.length - 1) response += ` 💎 **פרימיום**`;
                                    
                                    response += `\n`;
                                });
                                
                                // Smart recommendations
                                if (lowerMessage.includes('זול') || lowerMessage.includes('הכי זול')) {
                                    const cheapest = sortedProducts[0];
                                    response += `\n  🎯 **המלצה חכמה:** ${cheapest.name} - הכי משתלם! ₪${cheapest.price}\n`;
                                }
                                
                                response += `\n`;
                            } else if (page.pageType === 'serviceProvider') {
                                // Enhanced service provider info
                                response += `\n  **🔧 שירותים זמינים:**\n`;
                                
                                // Check for appointment availability
                                if (page.description && page.description.includes('תור')) {
                                    response += `  📅 **תורים פנויים** - זמין להזמנה!\n`;
                                }
                                
                                // Check for pricing info
                                if (page.description && page.description.includes('₪')) {
                                    const priceMatch = page.description.match(/₪(\d+)/);
                                    if (priceMatch) {
                                        response += `  💰 **מחיר:** ₪${priceMatch[1]}\n`;
                                    }
                                }
                                
                                // Check for location
                                if (page.description && (page.description.includes('רחוב') || page.description.includes('עיר') || page.description.includes('כתובת'))) {
                                    response += `  📍 **מיקום:** זמין באזור\n`;
                                }
                                
                                // Add service description
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  📝 **תיאור:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  🎯 **רוצה להזמין?** [👁️ צפה בדף](${pageUrl}) או התקשר ישירות!\n\n`;
                            } else if (page.pageType === 'event') {
                                // Enhanced event info
                                response += `\n  **🎉 פרטי האירוע:**\n`;
                                
                                if (page.expectedGuests && page.expectedGuests > 0) {
                                    response += `  👥 **מקומות פנויים:** ${page.expectedGuests} מקומות\n`;
                                }
                                
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  📝 **תיאור:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  🎯 **רוצה להצטרף?** [👁️ צפה בדף](${pageUrl}) והרשם!\n\n`;
                            } else if (page.pageType === 'course') {
                                // Enhanced course info
                                response += `\n  **🎓 פרטי הקורס:**\n`;
                                
                                if (page.expectedGuests && page.expectedGuests > 0) {
                                    response += `  👥 **מקומות פנויים:** ${page.expectedGuests} מקומות\n`;
                                }
                                
                                if (page.description) {
                                    const shortDesc = page.description.substring(0, 100) + '...';
                                    response += `  📝 **תיאור:** ${shortDesc}\n`;
                                }
                                
                                response += `\n  🎯 **רוצה להירשם?** [👁️ צפה בדף](${pageUrl}) והתחל ללמוד!\n\n`;
                            } else if (page.pageType === 'store' && page.description) {
                                const productInfo = await extractProductInfo(page.description, mainKeyword, pageUrl);
                                if (productInfo) {
                                    if (productInfo.price) {
                                        response += `  💰 **מחיר:** ${productInfo.price}\n`;
                                    }
                                    if (productInfo.name) {
                                        response += `  🏷️ **מוצר:** ${productInfo.name}\n`;
                                    }
                                    if (productInfo.location) {
                                        response += `  📍 **מיקום:** ${productInfo.location}\n`;
                                    }
                                }
                            }
                            
                            response += `  <div style="margin: 8px 0; border: 2px solid #e5e7eb; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1); position: relative; width: 100vw !important; max-width: 100% !important; height: 300px !important; margin-left: calc(-50vw + 50%) !important; text-align: right !important; direction: rtl !important;">`;
                            response += `    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c);"></div>`;
                            response += `    <iframe src="${pageUrl}" style="width: 200%; height: 600px; border: none; transform: scale(0.5); transform-origin: top left; position: absolute; top: 0; left: 0;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>`;
                            response += `  </div>\n\n`;
                        }
                        } // Close the if statement for non-gift searches
                        
                        if (matchingPages.length > 3) {
                            response += `ועוד ${matchingPages.length - 3} דפים...`;
                        }
                        
                        // DISABLED - No more inventing help messages
                        
                        // Add price information request
                        if (type === 'store') {
                            response += `\n💰 **רוצה לדעת על מחירים?** כתוב "מחירים" או "כמה זה עולה" ואני אחפש עבורך!`;
                        }
                        
                        return {
                            message: response,
                            action: { type: 'change_category_and_highlight', category: type, highlight_pages: matchingPages.slice(0, 3).map(p => p.pageId) }
                        };
                    } else {
                        // NO PAGES FOUND - Don't invent pages!
                        return {
                            message: `😔 **לא מצאתי דפים רלוונטיים ל"${mainKeyword}".**\n\nאבל יש לנו דפים אחרים שיכולים לעניין אותך:\n\n🏪 **חנויות:** ${allPages.filter(p => p.pageType === 'store').length} דפים\n🎓 **קורסים:** ${allPages.filter(p => p.pageType === 'course').length} דפים\n🔧 **שירותים:** ${allPages.filter(p => p.pageType === 'serviceProvider').length} דפים\n🎉 **אירועים:** ${allPages.filter(p => p.pageType === 'event').length} דפים\n\n**רוצה לראות הכל?** לחץ על "הכל" למעלה!`,
                            action: { type: 'none' }
                        };
                    }
                }
            }
            
            // Search by title
            const matchingPages = allPages.filter(page => 
                page.title.toLowerCase().includes(lowerMessage)
            );
            
            if (matchingPages.length > 0) {
                let response = `מצאתי ${matchingPages.length} דפים עם "${message}":\n\n`;
                
                matchingPages.slice(0, 3).forEach(page => {
                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                    // Use real page preview with iframe
                    const emoji = page.pageType === 'store' ? '🏪' : page.pageType === 'event' ? '🎉' : page.pageType === 'course' ? '🎓' : page.pageType === 'serviceProvider' ? '🔧' : '📄';
                    response += `• **${page.title}** ${emoji}\n`;
                    response += `  [👁️ צפה בדף](${pageUrl})\n`;
                    response += `  <div style="margin: 8px 0; border: 2px solid #e5e7eb; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1); animation: fadeInUp 0.6s ease-out, pulse 2s infinite; position: relative; width: 100vw !important; max-width: 100% !important; height: 200px !important; margin-left: calc(-50vw + 50%) !important; text-align: right !important; direction: rtl !important;">`;
                    response += `    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #f5576c); animation: shimmer 2s infinite;"></div>`;
                    response += `    <iframe src="${pageUrl}" style="width: 200%; height: 400px; border: none; transform: scale(0.5); transform-origin: top left; transition: all 0.3s ease; position: absolute; top: 0; left: 0;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>`;
                    response += `  </div>\n\n`;
                });
                
                if (matchingPages.length > 3) {
                    response += `ועוד ${matchingPages.length - 3} דפים...`;
                }
                
                return {
                    message: response,
                    action: { type: 'change_category_and_highlight', category: matchingPages[0].pageType, highlight_pages: matchingPages.slice(0, 3).map(p => p.pageId) }
                };
            }
            
            // If no local match, prepare real data for N8N
            const realData = {
                availablePages: allPages.map(p => ({
                    title: p.title,
                    type: p.pageType,
                    products: p.products || []
                }))
            };
            
            return null; // No quick response, send to N8N with real data
        }
        
        // Function to extract product info from page content
        async function extractProductInfo(description, keyword, pageUrl) {
            console.log('🔍 extractProductInfo called with:', { description: description?.substring(0, 100), keyword, pageUrl });
            
            if (!description && !pageUrl) return null;
            
            const lowerKeyword = keyword.toLowerCase();
            
            // If we have a page URL, fetch the actual content
            if (pageUrl) {
                console.log('🔍 Fetching HTML for:', pageUrl);
                try {
                    const response = await fetch(pageUrl);
                    if (response.ok) {
                        const html = await response.text();
                        console.log('📄 HTML fetched, length:', html.length);
                        
                        // Extract all prices from HTML
                        const pricePatterns = [
                            /₪\s*(\d+(?:[.,]\d+)?)/g,
                            /מ-?\s*(\d+(?:[.,]\d+)?)\s*₪/g,
                            /(\d+(?:[.,]\d+)?)\s*₪/g,
                            /מחיר[^<]*?(\d+(?:[.,]\d+)?)/gi
                        ];
                        
                        let allPrices = [];
                        pricePatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            allPrices.push(...matches.map(m => m[1] || m[0]));
                        });
                        
                        // Remove duplicates and sort
                        allPrices = [...new Set(allPrices)].sort((a, b) => parseFloat(a) - parseFloat(b));
                        
                        console.log('💰 All prices found:', allPrices);
                        
                        // Extract service/product names
                        const namePatterns = [
                            /<h[1-6][^>]*>([^<]+)<\/h[1-6]>/gi,
                            /<div[^>]*class="[^"]*title[^"]*"[^>]*>([^<]+)<\/div>/gi,
                            /<span[^>]*class="[^"]*name[^"]*"[^>]*>([^<]+)<\/span>/gi
                        ];
                        
                        let allNames = [];
                        namePatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            allNames.push(...matches.map(m => m[1].trim()));
                        });
                        
                        // Filter names that contain the keyword
                        const relevantNames = allNames.filter(name => 
                            name.toLowerCase().includes(lowerKeyword)
                        );
                        
                        console.log('🏷️ Relevant names found:', relevantNames);
                        
                        // Extract location
                        const locationPatterns = [
                            /(?:בכתובת|כתובת|מיקום|באזור|בנתניה|בתל אביב|בירושלים)[^<]*?([א-ת\s]+)/gi,
                            /<meta[^>]*name="[^"]*location[^"]*"[^>]*content="([^"]+)"/gi
                        ];
                        
                        let location = null;
                        locationPatterns.forEach(pattern => {
                            const match = html.match(pattern);
                            if (match && !location) {
                                location = match[1].trim();
                            }
                        });
                        
                        // Extract descriptions
                        const descPatterns = [
                            /<p[^>]*class="[^"]*desc[^"]*"[^>]*>([^<]+)<\/p>/gi,
                            /<div[^>]*class="[^"]*description[^"]*"[^>]*>([^<]+)<\/div>/gi
                        ];
                        
                        let descriptions = [];
                        descPatterns.forEach(pattern => {
                            const matches = [...html.matchAll(pattern)];
                            descriptions.push(...matches.map(m => m[1].trim()));
                        });
                        
                        return {
                            prices: allPrices.length > 0 ? allPrices : null,
                            names: relevantNames.length > 0 ? relevantNames : null,
                            location: location,
                            descriptions: descriptions.length > 0 ? descriptions : null,
                            allNames: allNames.length > 0 ? allNames : null
                        };
                    }
                } catch (error) {
                    console.error('❌ Error fetching HTML:', error);
                }
            }
            
            // Fallback to description parsing
            if (description) {
                const lowerDesc = description.toLowerCase();
                
                // Look for price patterns in description
                const priceRegex = /[\d,]+₪|[\d,]+ ש"ח|[\d,]+ שקל|[\d,]+ ₪/g;
                const prices = [];
                let match;
                while ((match = priceRegex.exec(description)) !== null) {
                    prices.push(match[0]);
                }
                
                console.log('💰 Prices found in description:', prices);
                
                if (prices.length > 0) {
                    // Try to find product name near the keyword
                    const keywordIndex = lowerDesc.indexOf(lowerKeyword);
                    if (keywordIndex !== -1) {
                        const start = Math.max(0, keywordIndex - 50);
                        const end = Math.min(description.length, keywordIndex + 50);
                        const context = description.substring(start, end);
                        
                        return {
                            name: context.trim(),
                            price: prices[0]
                        };
                    }
                }
            }
            
            return null;
        }
        
        // 🧠 CONVERSATION CONTEXT MEMORY for Marketplace (global variable)
        if (!window.stavConversationContext) {
            window.stavConversationContext = {
                lastSearchCategory: null,      // Last category user searched for (e.g., "צעצוע")
                lastShownPages: [],            // Last pages we showed
                rejectedCategories: [],        // Categories user said "no" to
                conversationHistory: [],       // Conversation history (last 10 messages)
                recommendedPage: null,         // Page we recommended for user to visit
                currentPage: null              // Currently displayed page
            };
        }
        // Keep old reference for compatibility
        if (!window.marketplaceConversationContext) {
            window.marketplaceConversationContext = window.stavConversationContext;
        }

        // Enhanced sendAIMessage with smart search
        async function sendAIMessageEnhanced() {
            try {
                const input = document.getElementById('aiChatInput');
                const userMessage = input.value.trim();
                
                if (!userMessage) return;
                
                // ✅ CHECK if user is confirming to visit a recommended page (e.g., "כן", "אוקיי", "בטח")
                const confirmations = ['כן', 'בטח', 'אוקיי', 'אוקי', 'ok', 'yes', 'יאללה', 'בוא', 'תראה', 'תראי', 'הצג', 'הציגי'];
                const isConfirmation = confirmations.some(c => userMessage.toLowerCase().trim() === c || userMessage.toLowerCase().includes(c));
                
                // 🌐 IF USER CONFIRMED and we have a recommended page - OPEN IT!
                if (isConfirmation && window.marketplaceConversationContext.recommendedPage) {
                    console.log('✅ USER CONFIRMED - Opening recommended page:', window.marketplaceConversationContext.recommendedPage);
                    
                    const recommendedPage = window.marketplaceConversationContext.recommendedPage;
                    
                    // Display user message
                    addAIMessage(userMessage, true);
                    input.value = '';
                    
                    // Show a confirmation message
                    addAIMessage(`✅ **פותח את "${recommendedPage.title}"...**`, false);
                    
                    // Show the preview with animation
                    const chatMessages = document.getElementById('aiChatMessages');
                    if (chatMessages) {
                        const previewDiv = document.createElement('div');
                        previewDiv.className = 'ai-message bot';
                        previewDiv.style.cssText = `
                            margin: 16px 0;
                            border: 2px solid #e5e7eb;
                            border-radius: 12px;
                            overflow: hidden;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            width: 100%;
                            max-width: 100%;
                            height: 500px;
                            opacity: 0;
                            transform: translateY(20px);
                            transition: all 0.5s ease;
                        `;
                        
                        previewDiv.innerHTML = `
                            <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 12px 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                <span>🌐</span>
                                <span>${recommendedPage.title}</span>
                            </div>
                            <div style="position: relative; height: 450px; overflow: hidden;">
                                <iframe src="` + recommendedPage.url + `" style="width: 200%; height: 900px; border: none; transform: scale(0.5); transform-origin: top right; position: absolute; top: 0; right: 0; opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';"></iframe>
                            </div>
                        `;
                        
                        chatMessages.appendChild(previewDiv);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        
                        setTimeout(() => {
                            previewDiv.style.opacity = '1';
                            previewDiv.style.transform = 'translateY(0)';
                        }, 100);
                    }
                    
                    // Clear the recommended page from context
                    window.marketplaceConversationContext.recommendedPage = null;
                    
                    return; // STOP HERE
                }
                
                // Display user message
                addAIMessage(userMessage, true);
                input.value = '';
                
                // Show typing indicator
                addAIMessage('🤖 סתיו מקלידה<span class="typing-dots">...</span>', false);
                
                // Always reload pages to get latest pages
                console.log('🔄 Reloading pages to get latest...');
                await loadPages();
                
                // Try smart search first for real page results
                try {
                    // FORCE LIVE DATA SEARCH - NO FIXED MESSAGES
                    console.log('🔍 FORCING LIVE SEARCH for:', userMessage);
                    const liveResults = await searchLivePages(userMessage);
                    
                    if (liveResults.length > 0) {
                        // Remove typing indicator
                        removeTypingIndicator();
                        
                        // Display live results
                        let response = `מצאתי ${liveResults.length} דפים רלוונטיים:\n\n`;
                        liveResults.forEach(page => {
                            response += `🏪 **${page.title}**\n`;
                            if (page.description) {
                                response += `${page.description}\n`;
                            }
                            
                            // Show live product data if available
                            if (page.liveProducts && page.liveProducts.length > 0) {
                                response += `💰 מוצרים חיים:\n`;
                                page.liveProducts.forEach(product => {
                                    response += `• ${product.name} - ₪${product.price}\n`;
                                });
                            }
                            
                            response += `🔗 [צפה בדף](/users/${page.userId}/${page.pageId}_html)\n\n`;
                        });
                        
                        addAIMessage(response, false);
                        return;
                    }
                } catch (error) {
                    console.error('Error in live search:', error);
                }
                
                // If no smart search result, send to N8N with REAL DATA
                try {
                    // Prepare real data context for N8N
                    const realDataContext = `אתה עוזר במרקטפלייס. ענה על שאלות בצורה ידידותית בהתבסס על הנתונים האמיתיים הבאים:

**דפים זמינים במערכת:**
${allPages.map(page => {
    let pageInfo = `- ${page.title} (${page.pageType === 'store' ? 'חנות' : page.pageType === 'course' ? 'קורס' : page.pageType === 'event' ? 'אירוע' : 'שירות'})`;
    if (page.products && page.products.length > 0) {
        pageInfo += '\n  מוצרים:';
        page.products.forEach(product => {
            pageInfo += `\n  * ${product.name} - ₪${product.price}`;
        });
    }
    return pageInfo;
}).join('\n')}

**חשוב:** השתמש רק בנתונים אמיתיים מהרשימה למעלה. אל תמציא דפים, חנויות או מוצרים שלא מופיעים ברשימה. אם אין מידע זמין, אמור זאת בכנות.`;

                    const response = await fetch('https://n8n-service-how4.onrender.com/webhook/jhfuhgufkhlkuho8erhf757754jhldkbsjkbmreketpg', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            message: userMessage,
                            context: 'marketplace',
                            contextText: realDataContext
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        removeTypingIndicator();
                        
                        // ✅ Display N8N response
                        addAIMessage(data.message || 'סליחה, קרתה שגיאה. נסה שוב!', false);
                        
                        // 🎁 EXTRACT page names from N8N response and show PREVIEW for each!
                        // Example: "🏪 **יניב צעצוע AI 1760965952188** store page"
                        const pagePattern = /🏪\s+\*\*([^\*]+)\*\*/g;
                        const pageMatches = [...data.message.matchAll(pagePattern)];
                        
                        if (pageMatches.length > 0) {
                            console.log('🎁 Found', pageMatches.length, 'pages in N8N response - showing previews!');
                            
                            const chatMessages = document.getElementById('aiChatMessages');
                            const displayedPages = new Set(); // 🚫 Track displayed pages to avoid duplicates
                            let previewIndex = 0;
                            
                            for (const match of pageMatches) {
                                const pageTitle = match[1].trim();
                                console.log('🔍 Looking for page:', pageTitle);
                                
                                // Find the page in allPages
                                const foundPage = allPages.find(p => 
                                    p.title === pageTitle || 
                                    p.pageId === pageTitle ||
                                    pageTitle.includes(p.pageId)
                                );
                                
                                if (foundPage && chatMessages) {
                                    const pageId = foundPage.pageId;
                                    
                                    // 🚫 SKIP if we already displayed this page
                                    if (displayedPages.has(pageId)) {
                                        console.log('⏭️  Skipping duplicate page:', foundPage.title);
                                        continue;
                                    }
                                    
                                    displayedPages.add(pageId); // Mark as displayed
                                    
                                    const pageUrl = `/users/${foundPage.userId}/${foundPage.pageId}_html`;
                                    console.log('✅ Found page! Creating full-width preview:', foundPage.title);
                                    
                                    // Create full-width page preview (NO header, FULL width)
                                    const previewDiv = document.createElement('div');
                                    previewDiv.className = 'stav-message bot';
                                    previewDiv.style.cssText = `
                                        margin: 16px 0;
                                        padding: 0;
                                        width: 100%;
                                        max-width: 100%;
                                        border-radius: 12px;
                                        overflow: hidden;
                                        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                                        opacity: 0;
                                        transform: translateY(20px);
                                        transition: all 0.5s ease;
                                    `;
                                    
                                    // NO header, just iframe!
                                    previewDiv.innerHTML = `
                                        <div style="position: relative; width: 100%; height: 700px; overflow: hidden; background: white;">
                                            <iframe src="${pageUrl}" style="width: 100%; height: 100%; border: none; display: block;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms" onload="this.style.opacity='1';" onerror="this.style.display='none'"></iframe>
                                        </div>
                                    `;
                                    
                                    chatMessages.appendChild(previewDiv);
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                    
                                    // Animate in with stagger
                                    setTimeout(() => {
                                        previewDiv.style.opacity = '1';
                                        previewDiv.style.transform = 'translateY(0)';
                                    }, 100 * (previewIndex + 1));
                                    
                                    previewIndex++; // Increment for next preview
                                }
                            }
                        }
                        
                        return;
                    }
                } catch (error) {
                    console.error('Error calling N8N:', error);
                }
                
                // Fallback if N8N fails - try to search live pages
                removeTypingIndicator();
                
                // Try to search live pages for the user's query
                console.log(`🔍 Searching for: "${userMessage}"`);
                try {
                    // Auto-reload pages to get latest pages
                    console.log('🔄 Auto-reloading pages to get latest...');
                    await loadPages();
                    
                    const liveSearchResult = await searchLivePages(userMessage);
                    if (liveSearchResult && liveSearchResult.length > 0) {
                        let response = `מצאתי ${liveSearchResult.length} דפים רלוונטיים:\n\n`;
                        liveSearchResult.forEach(page => {
                            response += `🏪 **${page.title}**\n`;
                            if (page.description) {
                                response += `${page.description}\n`;
                            }
                            
                            // Show live product data if available
                            if (page.liveProducts && page.liveProducts.length > 0) {
                                response += `💰 מוצרים חיים:\n`;
                                page.liveProducts.forEach(product => {
                                    response += `• ${product.name} - ₪${product.price}\n`;
                                });
                            }
                            
                            response += `🔗 [צפה בדף](/users/${page.userId}/${page.pageId}_html)\n\n`;
                        });
                        addAIMessage(response, false);
                    } else {
                        addAIMessage("אני כאן לעזור לך! 😊 אם אתה מחפש משהו ספציפי, תוכל לשאול אותי על מתנות, לק, שעונים, צעצועים או קורסים.", false);
                    }
                } catch (error) {
                    console.error('Error in live search:', error);
                    addAIMessage("אני כאן לעזור לך! 😊 אם אתה מחפש משהו ספציפי, תוכל לשאול אותי על מתנות, לק, שעונים, צעצועים או קורסים.", false);
                }
                return;
                
            } catch (error) {
                console.error('❌ Error in sendAIMessageEnhanced:', error);
                removeTypingIndicator();
                addAIMessage('סליחה, קרתה שגיאה. נסה שוב!', false);
            }
        }
        
        // Execute actions
        async function executeAction(action) {
            if (action.type === 'change_category') {
                console.log('🏷️ Changing to category:', action.category);
                
                // Map category names
                const categoryMap = {
                    'store': 'store',
                    'stores': 'store',
                    'חנות': 'store',
                    'חנויות': 'store',
                    'event': 'event',
                    'events': 'event',
                    'אירוע': 'event',
                    'אירועים': 'event',
                    'course': 'course',
                    'courses': 'course',
                    'קורס': 'course',
                    'קורסים': 'course',
                    'serviceProvider': 'serviceProvider',
                    'service': 'serviceProvider',
                    'בעלי מקצוע': 'serviceProvider',
                    'all': 'all',
                    'הכל': 'all'
                };
                
                const mappedCategory = categoryMap[action.category.toLowerCase()] || action.category;
                console.log('📂 Mapped category:', mappedCategory);
                
                // Update UI buttons - use the existing filterByType function
                filterByType(mappedCategory);
                
                // Scroll to top to see results
                setTimeout(() => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    console.log('✅ Category changed to:', mappedCategory);
                    console.log('📊 New filteredPages length:', filteredPages.length);
                    
                    // Show success message
                    addAIMessage(`✅ עברתי לקטגוריית ${getTypeName(mappedCategory)}! מצא ${filteredPages.length} דפים.`, false);
                }, 100);
            } else if (action.type === 'change_category_and_highlight') {
                console.log('🏷️ Changing to category and highlighting pages:', action.category, action.highlight_pages);
                
                // Map category names
                const categoryMap = {
                    'store': 'store',
                    'stores': 'store',
                    'חנות': 'store',
                    'חנויות': 'store',
                    'event': 'event',
                    'events': 'event',
                    'אירוע': 'event',
                    'אירועים': 'event',
                    'course': 'course',
                    'courses': 'course',
                    'קורס': 'course',
                    'קורסים': 'course',
                    'serviceProvider': 'serviceProvider',
                    'service': 'serviceProvider',
                    'בעלי מקצוע': 'serviceProvider',
                    'all': 'all',
                    'הכל': 'all'
                };
                
                const mappedCategory = categoryMap[action.category.toLowerCase()] || action.category;
                console.log('📂 Mapped category:', mappedCategory);
                
                // Update UI buttons - use the existing filterByType function
                filterByType(mappedCategory);
                
                // Scroll to top and highlight pages
                setTimeout(() => {
                    // Highlight matching pages first
                    if (action.highlight_pages && action.highlight_pages.length > 0) {
                        action.highlight_pages.forEach((pageId, index) => {
                            const pageCard = document.querySelector(`[data-page-id="${pageId}"]`);
                            if (pageCard) {
                                pageCard.style.outline = '3px solid #667eea';
                                pageCard.style.transform = 'scale(1.05)';
                                pageCard.style.transition = 'all 0.3s ease';
                                pageCard.style.boxShadow = '0 10px 25px rgba(102, 126, 234, 0.3)';
                                
                                // Scroll to first highlighted page with delay
                                if (index === 0) {
                                    setTimeout(() => {
                                        pageCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    }, 200);
                                }
                                
                                setTimeout(() => {
                                    pageCard.style.outline = '';
                                    pageCard.style.transform = '';
                                    pageCard.style.boxShadow = '';
                                }, 5000);
                            }
                        });
                    }
                    
                    console.log('✅ Category changed to:', mappedCategory);
                    console.log('📊 New filteredPages length:', filteredPages.length);
                    
                    // Show success message
                    addAIMessage(`✅ עברתי לקטגוריית ${getTypeName(mappedCategory)}! מצא ${filteredPages.length} דפים.`, false);
                }, 100);
            } else if (action.type === 'scroll_to_page' && action.page_id) {
                console.log('🔍 Looking for page card with ID:', action.page_id);
                
                // Find the page card and scroll to it
                setTimeout(() => {
                    const pageCard = document.querySelector(`[data-page-id="${action.page_id}"]`);
                    if (pageCard) {
                        pageCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        pageCard.style.outline = '3px solid #667eea';
                        pageCard.style.transform = 'scale(1.05)';
                        pageCard.style.transition = 'all 0.3s ease';
                        pageCard.style.boxShadow = '0 10px 25px rgba(102, 126, 234, 0.3)';
                        
                        setTimeout(() => {
                            pageCard.style.outline = '';
                            pageCard.style.transform = '';
                            pageCard.style.boxShadow = '';
                        }, 3000);
                    } else {
                        console.error('❌ Page card not found for:', action.page_id);
                        addAIMessage('🔍 מצאתי את הדף אבל לא הצלחתי לגלול אליו. חפש אותו ברשימה למעלה!', false);
                    }
                }, 500);
            } else if (action.type === 'show_page' && action.page_id) {
                // Open page in new tab
                const page = allPages.find(p => p.pageId === action.page_id);
                if (page) {
                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                    window.open(pageUrl, '_blank');
                }
            }
        }
        
        // Function to extract prices from page content
        async function extractPricesFromPage(page) {
            try {
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                const response = await fetch(pageUrl);
                if (!response.ok) return null;
                
                const htmlContent = await response.text();
                const priceRegex = /₪\s*(\d+(?:,\d{3})*(?:\.\d{2})?)/g;
                const prices = [];
                let match;
                
                while ((match = priceRegex.exec(htmlContent)) !== null) {
                    prices.push(match[0]);
                }
                
                return prices.length > 0 ? prices : null;
            } catch (error) {
                console.error('Error extracting prices:', error);
                return null;
            }
        }
        
        // Enhanced search with price information - LIVE VERSION
        async function searchWithPrices(message) {
            // Enhanced search that reads from live pages
            const searchResults = [];
            
            for (const page of allPages) {
                if (page.pageType === 'store') {
                    // Always check live page content for products
                    const productInfo = await extractProductInfo(page.description, message, `/users/${page.userId}/${page.pageId}_html`);
                    
                    if (productInfo && productInfo.price) {
                        searchResults.push({
                            ...page,
                            productInfo: productInfo
                        });
                    }
                }
            }
            
            console.log(`🔍 Live search results for "${message}":`, searchResults);
            return searchResults;
        }
        
        // Fix the filterByCategory function
        function filterByCategory(category) {
            currentType = category;
            
            if (category === 'all') {
                filteredPages = [...allPages];
            } else {
                filteredPages = allPages.filter(page => page.pageType === category);
            }
            
            displayPages();
            updatePagesCount();
        }
        
        // 🏷️ SMART CATEGORY MAPPING - Maps search terms to broader categories (MUST BE BEFORE searchLivePages!)
        const categoryMapping = {
            // אופנה ואקססוריז
            'שעונים': ['שעון', 'watch', 'שעונים', 'שעוני', 'זמן', 'time'],
            'תכשיטים': ['תכשיט', 'jewelry', 'תכשיטים', 'שרשרת', 'צמיד', 'טבעת', 'עגיל'],
            'בגדים': ['בגד', 'clothing', 'חולצה', 'מכנס', 'שמלה', 'חצאית', 'סווטשרט'],
            'נעליים': ['נעל', 'shoes', 'נעליים', 'סנדל', 'מגף', 'נעלי'],
            'תיקים': ['תיק', 'bag', 'תיקים', 'ארנק', 'תרמיל', 'תיק גב'],
            
            // צעצועים וילדים
            'צעצועים': ['צעצוע', 'toy', 'משחק', 'צעצועים', 'משחקים', 'ילדים'],
            'בובות': ['בובה', 'doll', 'בובות', 'בובה'],
            'משחקים': ['משחק', 'game', 'משחקים', 'משחקי', 'לוח'],
            
            // אלקטרוניקה
            'מחשבים': ['מחשב', 'computer', 'לפטופ', 'נייד', 'pc', 'מק'],
            'טלפונים': ['טלפון', 'phone', 'סמארטפון', 'אייפון', 'smartphone', 'נייד'],
            'אוזניות': ['אוזני', 'headphones', 'אוזניות', 'earbuds', 'airpods'],
            
            // בית וגינה
            'ריהוט': ['רהיט', 'furniture', 'כסא', 'שולחן', 'ארון', 'ספה', 'מיטה'],
            'מטבח': ['כלי מטבח', 'kitchen', 'סיר', 'מחבת', 'סכום', 'צלחת'],
            'גינה': ['צמח', 'garden', 'עציץ', 'פרח', 'גינון', 'גן'],
            
            // יופי וטיפוח
            'קוסמטיקה': ['קוסמטיקה', 'makeup', 'איפור', 'שפתון', 'מסקרה'],
            'בישום': ['בושם', 'perfume', 'בישום', 'ניחוח', 'parfum'],
            'לק': ['לק', 'nail polish', 'ציפורניים', 'מניקור', 'לק גל'],
            
            // שירותים
            'נגרות': ['נגר', 'carpenter', 'עבודות עץ', 'נגרות', 'רהיטים', 'ארון', 'מטבח', 'ארונות'],
            'אינסטלציה': ['אינסטלטור', 'plumber', 'אינסטלציה', 'שרברב', 'ברז', 'צנרת', 'צינור', 'פיצוץ', 'נזילה', 'איסטלטור', 'אנסטלטור'],
            'חשמל': ['חשמלאי', 'electrician', 'חשמל', 'תאורה', 'בזק', 'קצר'],
            'מספרה': ['מספרה', 'תספורת', 'מעצב שיער', 'עיצוב שיער', 'ספר', 'barber', 'להסתפר', 'הסתפרות', 'מסתפר'],
            
            // רכב
            'חלפים': ['חלק חילוף', 'spare parts', 'חלפים', 'רכב', 'מכונית', 'אוטו'],
            'גלגלים': ['גלגל', 'tire', 'צמיג', 'גלגלים', 'צמיגים']
        };
        
        // 🔍 Expand search terms with category synonyms (MUST BE BEFORE searchLivePages!)
        function expandSearchTerms(searchTerm) {
            const expanded = [searchTerm.toLowerCase()];
            
            // Check each category
            for (const [category, synonyms] of Object.entries(categoryMapping)) {
                // If search term matches category or any synonym
                if (searchTerm.toLowerCase() === category.toLowerCase() || 
                    synonyms.some(syn => searchTerm.toLowerCase().includes(syn.toLowerCase()) || 
                                        syn.toLowerCase().includes(searchTerm.toLowerCase()))) {
                    // Add all synonyms to search
                    expanded.push(...synonyms);
                    console.log(`🏷️ Expanded "${searchTerm}" with category "${category}":`, synonyms);
                    break;
                }
            }
            
            return [...new Set(expanded)]; // Remove duplicates
        }
        
        // New function to search live pages - FORCE LIVE DATA VERSION
        async function searchLivePages(query) {
            try {
                // 🎯 CRITICAL: Clean search query FIRST - remove common prefixes like "מחפש", "רוצה", etc.
                // So "מחפש בובה" becomes "בובה"
                let cleanedQuery = query;
                const searchPrefixPattern = /^(מחפש|מחפשת|רוצה|רוצה את|אני מחפש|אני רוצה|אני רוצה לקנות|רוצה לקנות|לקנות|תן לי|תני לי|תראה|תראי|הראה|הראי|יש לך|יש לכם|איפה|חפש|חיפוש|לחפש)\s+/i;
                if (searchPrefixPattern.test(cleanedQuery)) {
                    cleanedQuery = cleanedQuery.replace(searchPrefixPattern, '').trim();
                    console.log(`🧹 Cleaned search query: "${query}" → "${cleanedQuery}"`);
                }
                
                // 🎯 ALSO: Convert plural to singular for better matching
                // "צעצועים" → "צעצוע", "שעונים" → "שעון"
                const pluralToSingular = {
                    'צעצועים': 'צעצוע',
                    'שעונים': 'שעון',
                    'משחקים': 'משחק',
                    'בובות': 'בובה',
                    'מכוניות': 'מכונית'
                };
                
                for (const [plural, singular] of Object.entries(pluralToSingular)) {
                    if (cleanedQuery.includes(plural)) {
                        cleanedQuery = cleanedQuery.replace(plural, singular);
                        console.log(`🔄 Converted plural to singular: "${plural}" → "${singular}"`);
                    }
                }
                
                query = cleanedQuery; // Use cleaned query for the rest of the function
                
                // 🎯 CRITICAL: Load allPages FIRST before using it!
                const response = await fetch('/api/pages/all/marketplace');
                if (!response.ok) {
                    console.error('❌ Failed to fetch marketplace pages:', response.status);
                    return [];
                }
                const data = await response.json();
                const allPages = data.pages || [];
                
                console.log(`🔍 Got ${allPages.length} fresh pages from server`);
                
                if (allPages.length === 0) {
                    console.warn('⚠️ WARNING: No pages found in marketplace!');
                    return [];
                }
                
                // 🎯 NEW: Fix common typos before search
                const typoFixes = {
                    'שעטנים': 'שעונים',
                    'שעטון': 'שעון',
                    'צעצוטים': 'צעצועים',
                    'צעצטוע': 'צעצוע',
                    'מסעדא': 'מסעדה',
                    'מסדעה': 'מסעדה',
                    // רובוט variations
                    'רוובוט': 'רובוט',
                    'רובוט חברותי': 'רובוט חברתי',
                    'חברותי': 'חברתי',
                    'חברטי': 'חברתי',
                    // בובה variations
                    'בובת פרווה': 'בובת פרווה', // Keep as-is (correct)
                    'בובה פרווה': 'בובת פרווה',
                    // צעצוע variations
                    'צעצע': 'צעצוע',  // Missing ו'
                    'צעצועה': 'צעצוע',  // Wrong suffix
                    'צעצועי': 'צעצוע',
                    'צעצועים': 'צעצועים', // Keep as-is (correct)
                    // אינסטלטור variations
                    'איסטלטור': 'אינסטלטור',
                    'אנסטלטור': 'אינסטלטור',
                    'אינסטלטר': 'אינסטלטור',
                    'איסטלטר': 'אינסטלטור'
                };
                
                let fixedQuery = query;
                for (const [typo, correct] of Object.entries(typoFixes)) {
                    if (fixedQuery.toLowerCase().includes(typo)) {
                        fixedQuery = fixedQuery.replace(new RegExp(typo, 'gi'), correct);
                        console.log(`🔧 Fixed typo: "${typo}" → "${correct}" in query: "${query}" → "${fixedQuery}"`);
                    }
                }
                
                const searchTerm = fixedQuery.toLowerCase();
                
                // 🎯 NEW: Expand search term with synonyms (מעצב שיער → מספרה, תספורת, etc.)
                const expandedTerms = expandSearchTerms(searchTerm);
                console.log(`🔍 Expanded search terms for "${searchTerm}":`, expandedTerms);
                
                let results = []; // Changed from const to let - need to reassign for city filtering
                
                console.log(`🔍 FORCING LIVE DATA SEARCH for: "${searchTerm}"`);
            
            // Extract location from query - expanded city list
            const cities = [
                'תל אביב', 'ירושלים', 'חיפה', 'באר שבע', 'נתניה', 'אשדוד', 'רמת גן', 'פתח תקווה', 
                'בני ברק', 'חולון', 'רחובות', 'כפר סבא', 'אילת', 'רעננה', 'הרצליה', 'בלומפילד', 
                'חדרה', 'קריית ביאליק', 'קריית מוצקין', 'ראשון לציון', 'נהריה', 
                'הוד השרון', 'גבעתיים', 'קריית אתא', 'קריית שמונה', 'בית שאן', 'עפולה',
                'רמת השרון'
            ];
            
            // 🚫 Words that should NEVER be considered city names
            const notCityWords = [
                // שמות אנשים נפוצים
                'חן', 'יניב', 'ברוך', 'דוד', 'משה', 'אברהם', 'שרה',
                // חלקי גוף ושירותים
                'שיער', 'ציפורניים', 'עור', 'פנים', 'גוף',
                // תארים ותכונות
                'אלגנטי', 'אלגנטית', 'יפה', 'יפה', 'מיוחד', 'מיוחדת', 'זול', 'זולה', 'יקר', 'יקרה',
                'קלאסי', 'קלאסית', 'מודרני', 'מודרנית', 'עתיק', 'עתיקה', 'חדש', 'חדשה', 'ישן', 'ישנה',
                // צבעים
                'זהב', 'כסף', 'שחור', 'לבן', 'אדום', 'כחול', 'ירוק', 'צהוב', 'ורוד', 'סגול', 'חום', 'אפור',
                // חומרים
                'עור', 'פלסטיק', 'מתכת', 'עץ', 'זכוכית', 'נייר', 'בד', 'משי', 'כותנה', 'פוליאסטר',
                // סוגים
                'גדול', 'קטן', 'ענק', 'זעיר', 'בינוני', 'ארוך', 'קצר', 'רחב', 'צר',
                // מילות קישור
                'של', 'עם', 'בלי', 'ללא', 'כמו', 'כולל', 'מבלי',
                // מוצרים
                'שעון', 'שעונים', 'צעצוע', 'צעצועים', 'לק', 'מניקור', 'תכשיט', 'תכשיטים',
                'מכונית', 'רכב', 'בובה', 'משחק', 'ספר', 'מחשב', 'טלפון', 'אוזניות',
                // מילות תיאור נוספות
                'מקורי', 'מקורית', 'חדשני', 'חדשנית', 'איכותי', 'איכותית', 'מרשים', 'מרשימה',
                'מושלם', 'מושלמת', 'נהדר', 'נהדרת', 'מעולה', 'מעולה', 'טוב', 'טובה', 'רע', 'רעה'
            ];
            
            // 🎯 CRITICAL: Category words that should NEVER be considered cities!
            const categoryWordsForCityCheck = ['מעצב', 'עיצוב', 'תספורת', 'ספר', 'מספר', 'להסתפר', 'הסתפרות', 'מסתפר', 'ציפורניים', 'לק', 'מניקור', 'פדיקור', 'טיפול', 'קוסמטיקה', 'יופי', 'נגר', 'נגרות', 'ארון', 'מטבח', 'אינסטלטור', 'צנרת', 'צינור', 'פיצוץ', 'נזילה', 'חשמלאי', 'חשמל', 'תאורה', 'קצר', 'צעצוע', 'צעצועים', 'משחק', 'משחקים', 'בובה', 'בובות', 'שעון', 'שעונים'];
            
            // Common typos/variations map
            const cityTypos = {
                'קירית': 'קריית',
                'קרית': 'קריית',
                'קיריית': 'קריית',
                'תל-אביב': 'תל אביב',
                'תלאביב': 'תל אביב',
                'ת"א': 'תל אביב',
                'באר-שבע': 'באר שבע',
                'בארשבע': 'באר שבע',
                'ב"ש': 'באר שבע'
            };
            
            let requiredCity = null;
            
            // Try multiple patterns to extract city
            // Pattern 1: "שירות בנתניה" or "נגר בנתניה" (service ב city)
            const patternWithBe = /([א-ת\s]+)\s+ב([א-ת\s]+)/;
            const matchWithBe = searchTerm.match(patternWithBe);
            if (matchWithBe && matchWithBe[2]) {
                let potentialCity = matchWithBe[2].trim();
                
                // 🎯 FIX: Check for typos first
                for (const [typo, correct] of Object.entries(cityTypos)) {
                    if (potentialCity.includes(typo)) {
                        potentialCity = potentialCity.replace(typo, correct);
                        console.log(`📝 Fixed city typo: "${matchWithBe[2]}" → "${potentialCity}"`);
                        break;
                    }
                }
                
                // Check if it's a known city
                for (const city of cities) {
                    if (city.toLowerCase() === potentialCity.toLowerCase() || 
                        city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                        potentialCity.toLowerCase().includes(city.toLowerCase())) {
                        requiredCity = city;
                        console.log(`✅ Location specified (ב pattern): "${matchWithBe[2]}" → ${city}`);
                        break;
                    }
                }
                // If no match but it looks like a city (Hebrew word 2-15 chars), use it
                // 🚫 BUT: Don't consider product attributes as cities!
                // 🎯 CRITICAL: Check against notCityWords AND category words!
                if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15 && 
                    /^[א-ת\s]+$/.test(potentialCity) && 
                    !notCityWords.includes(potentialCity.toLowerCase()) &&
                    !categoryWordsForCityCheck.includes(potentialCity.toLowerCase())) {
                    requiredCity = potentialCity;
                    console.log(`📍 Location specified (new city from ב pattern): ${potentialCity}`);
                } else if (potentialCity && (notCityWords.includes(potentialCity.toLowerCase()) || categoryWordsForCityCheck.includes(potentialCity.toLowerCase()))) {
                    console.log(`🚫 Rejected "${potentialCity}" as city (it's a product attribute or category word)`);
                }
            }
            
            // Pattern 2: Exact city name in query
            if (!requiredCity) {
                for (const city of cities) {
                    if (searchTerm.includes(city.toLowerCase())) {
                        requiredCity = city;
                        console.log(`📍 Location specified (exact): ${city}`);
                        break;
                    }
                }
            }
            
            // Pattern 3: "(ב|בתוך|בשדה) עיר" pattern
            if (!requiredCity) {
                const cityPattern = /(?:ב|בתוך|בשדה)\s+([א-ת]{2,})/;
                const cityMatch = searchTerm.match(cityPattern);
                if (cityMatch && cityMatch[1]) {
                    const potentialCity = cityMatch[1].trim();
                    // Check if it's a known city (partial match)
                    for (const city of cities) {
                        if (city.toLowerCase().includes(potentialCity.toLowerCase()) || potentialCity.toLowerCase().includes(city.toLowerCase())) {
                            requiredCity = city;
                            console.log(`📍 Location specified (partial): ${potentialCity} → ${city}`);
                            break;
                        }
                    }
                    // If no match found but it's a city query, use it as-is
                    // 🎯 CRITICAL: Don't consider category words as cities!
                    if (!requiredCity && potentialCity.length >= 2 && potentialCity.length <= 15 &&
                        !notCityWords.includes(potentialCity.toLowerCase()) &&
                        !categoryWordsForCityCheck.includes(potentialCity.toLowerCase())) {
                        requiredCity = potentialCity;
                        console.log(`📍 Location specified (new city): ${potentialCity}`);
                    } else if (potentialCity && (notCityWords.includes(potentialCity.toLowerCase()) || categoryWordsForCityCheck.includes(potentialCity.toLowerCase()))) {
                        console.log(`🚫 Pattern 3: Rejected "${potentialCity}" as city (it's a product attribute or category word)`);
                    }
                }
            }
            
            // SMART KEYWORD MAPPING - מילות מפתח לקטגוריות עם הקשרים חכמים
            const smartKeywords = {
                // מתנות
                'מתנה לילד': {categories: ['צעצוע', 'משחק'], excludeTypes: ['serviceProvider']},
                'מתנה לילדים': {categories: ['צעצוע', 'משחק'], excludeTypes: ['serviceProvider']},
                'מתנה לבן': {categories: ['צעצוע', 'משחק'], excludeTypes: ['serviceProvider']},
                'מתנה לבת': {categories: ['צעצוע', 'משחק', 'לק'], excludeTypes: ['serviceProvider']},
                'מתנה לאישה': {categories: ['שעון', 'תכשיט', 'לק', 'מניקור', 'פדיקור', 'קוסמטיקה'], excludeTypes: ['serviceProvider']},
                'מתנה לבחורה': {categories: ['שעון', 'תכשיט', 'לק', 'מניקור', 'פדיקור', 'קוסמטיקה'], excludeTypes: ['serviceProvider']},
                'מתנה לאשה': {categories: ['שעון', 'תכשיט', 'לק', 'מניקור', 'פדיקור', 'קוסמטיקה'], excludeTypes: ['serviceProvider']},
                'מתנה לבעל': {categories: ['שעון', 'טכנולוגיה', 'רובוט', 'גאדגט'], excludeTypes: ['serviceProvider'], excludeWords: ['צעצוע', 'toy', 'לק', 'מניקור', 'חלפים']},
                'מתנה לבעלי': {categories: ['שעון', 'טכנולוגיה', 'רובוט', 'גאדגט'], excludeTypes: ['serviceProvider'], excludeWords: ['צעצוע', 'toy', 'לק', 'מניקור', 'חלפים']},
                'מתנה לגבר': {categories: ['שעון', 'טכנולוגיה', 'רובוט', 'גאדגט'], excludeTypes: ['serviceProvider'], excludeWords: ['צעצוע', 'toy', 'לק', 'מניקור', 'חלפים']},
                'מתנה לבחור': {categories: ['שעון', 'טכנולוגיה', 'רובוט', 'גאדגט'], excludeTypes: ['serviceProvider'], excludeWords: ['צעצוע', 'toy', 'לק', 'מניקור', 'חלפים']},
                'מתנה': {categories: ['שעון', 'תכשיט', 'צעצוע', 'לק'], excludeTypes: ['serviceProvider']},
                
                // ילדים וצעצועים - חובה לסנן!
                'ילד': {
                    categories: ['צעצוע', 'משחק', 'toy', 'game', 'ילד', 'ילדים'], 
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'פדיקור', 'שעון', 'watch', 'חולצ', 'בגד', 'מאמן', 'אימון', 'טיפוח', 'יופי', 'קוסמטיקה'],
                    requireWords: ['צעצוע', 'toy', 'משחק', 'game', 'ילד', 'ילדים', 'בובה', 'מכונית']
                },
                'ילדים': {
                    categories: ['צעצוע', 'משחק', 'toy', 'game', 'ילד', 'ילדים'], 
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'פדיקור', 'שעון', 'watch', 'חולצ', 'בגד', 'מאמן', 'אימון', 'טיפוח', 'יופי', 'קוסמטיקה'],
                    requireWords: ['צעצוע', 'toy', 'משחק', 'game', 'ילד', 'ילדים', 'בובה', 'מכונית']
                },
                'צעצוע': {
                    categories: ['צעצוע', 'משחק', 'toy', 'game'], 
                    preferTypes: ['store'], // ONLY toy stores!
                    excludeWords: ['לק', 'nail', 'מניקור', 'פדיקור', 'שעון', 'watch', 'חולצ', 'חולצה', 'shirt', 'בגד', 'clothing', 'מאמן', 'אימון', 'coaching', 'fitness', 'gym', 'טיפוח', 'יופי', 'beauty', 'קוסמטיקה', 'cosmetic', 'חשמלאי', 'electric', 'נגר', 'carpenter', 'אינסטלטור', 'plumber', 'red', 'מודפסות', 'טכנולוגיה', 'tech']
                    // NO requireWords - let the preferTypes and excludeWords do the filtering
                },
                'צעצועים': {
                    categories: ['צעצוע', 'משחק', 'toy', 'game'], 
                    preferTypes: ['store'], // ONLY toy stores!
                    excludeWords: ['לק', 'nail', 'מניקור', 'פדיקור', 'שעון', 'watch', 'חולצ', 'חולצה', 'shirt', 'בגד', 'clothing', 'מאמן', 'אימון', 'coaching', 'fitness', 'gym', 'טיפוח', 'יופי', 'beauty', 'קוסמטיקה', 'cosmetic', 'חשמלאי', 'electric', 'נגר', 'carpenter', 'אינסטלטור', 'plumber', 'red', 'מודפסות', 'טכנולוגיה', 'tech']
                    // NO requireWords - let the preferTypes and excludeWords do the filtering
                },
                'משחק': {
                    categories: ['צעצוע', 'משחק', 'toy', 'game'], 
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'שעון', 'חולצ', 'בגד', 'מאמן', 'אימון', 'טיפוח'],
                    requireWords: ['צעצוע', 'toy', 'משחק', 'game', 'ילד']
                },
                'משחקים': {
                    categories: ['צעצוע', 'משחק', 'toy', 'game'], 
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'שעון', 'חולצ', 'בגד', 'מאמן', 'אימון', 'טיפוח'],
                    requireWords: ['צעצוע', 'toy', 'משחק', 'game', 'ילד']
                },
                'מכונית': {
                    categories: ['צעצוע', 'משחק', 'toy', 'מכונית', 'רכב'], 
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'פדיקור', 'שעון', 'watch', 'חולצ', 'בגד', 'clothing', 'מאמן', 'אימון', 'coaching', 'טיפוח', 'יופי', 'קוסמטיקה', 'חלפים', 'חלף', 'מוסך'],
                    requireWords: ['צעצוע', 'toy', 'משחק', 'game', 'ילד', 'ילדים', 'מכונית', 'רכב']
                },
                'מכוניות': {
                    categories: ['צעצוע', 'משחק', 'toy', 'מכונית', 'רכב'], 
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'פדיקור', 'שעון', 'watch', 'חולצ', 'בגד', 'clothing', 'מאמן', 'אימון', 'coaching', 'טיפוח', 'יופי', 'קוסמטיקה', 'חלפים', 'חלף', 'מוסך'],
                    requireWords: ['צעצוע', 'toy', 'משחק', 'game', 'ילד', 'ילדים', 'מכונית', 'רכב']
                },
                'מכונית מרוץ': {
                    categories: ['צעצוע', 'משחק', 'toy', 'מכונית', 'רכב', 'מרוץ'], 
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'פדיקור', 'שעון', 'watch', 'חולצ', 'בגד', 'clothing', 'מאמן', 'אימון', 'coaching', 'טיפוח', 'יופי', 'קוסמטיקה', 'חלפים', 'חלף', 'מוסך'],
                    requireWords: ['צעצוע', 'toy', 'משחק', 'game', 'ילד', 'ילדים', 'מכונית', 'רכב']
                },
                'בובה': {
                    categories: ['צעצוע', 'משחק', 'toy', 'בובה', 'בובת', 'doll'], 
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'פדיקור', 'שעון', 'watch', 'חולצ', 'בגד', 'clothing', 'מאמן', 'אימון', 'coaching', 'טיפוח', 'יופי', 'קוסמטיקה']
                    // NO requireWords - בובות יכולות להיות בחנויות צעצועים כלליות
                },
                'בובת': {
                    categories: ['צעצוע', 'משחק', 'toy', 'בובה', 'בובת', 'doll'], 
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'פדיקור', 'שעון', 'watch', 'חולצ', 'בגד', 'clothing', 'מאמן', 'אימון', 'coaching', 'טיפוח', 'יופי', 'קוסמטיקה']
                },
                'בובות': {
                    categories: ['צעצוע', 'משחק', 'toy', 'בובה', 'בובת', 'doll'], 
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'פדיקור', 'שעון', 'watch', 'חולצ', 'בגד', 'clothing', 'מאמן', 'אימון', 'coaching', 'טיפוח', 'יופי', 'קוסמטיקה']
                    // NO requireWords - בובות יכולות להיות בחנויות צעצועים כלליות
                },
                
                // שירותי יופי
                'לק': {
                    categories: ['לק', 'מניקור', 'פדיקור', 'קוסמטיקה', 'ציפורניים', 'טיפול פנים', 'יופי'],
                    preferTypes: ['serviceProvider'], // לק הוא שירות!
                    excludeWords: ['שעון', 'watch', 'טכנולוגיה', 'technology', 'צעצוע', 'toy', 'משחק', 'ילד']
                },
                'טיפול פנים': {
                    categories: ['לק', 'מניקור', 'פדיקור', 'קוסמטיקה', 'טיפול פנים', 'יופי', 'ספא'],
                    preferTypes: ['serviceProvider'], // טיפול פנים הוא שירות!
                    excludeWords: ['שעון', 'watch', 'טכנולוגיה', 'technology', 'צעצוע', 'toy', 'משחק', 'ילד'],
                    // ❌ NO requireWords - שם הדף יכול להיות "סלון יופי" או "מכון טיפוח"
                },
                'קוסמטיקה': {
                    categories: ['לק', 'קוסמטיקה', 'טיפול פנים', 'יופי', 'איפור'],
                    preferTypes: ['serviceProvider', 'store'], // יכול להיות גם חנות קוסמטיקה
                    excludeWords: ['שעון', 'watch', 'טכנולוגיה', 'technology', 'צעצוע', 'toy', 'משחק', 'ילד'],
                },
                'שעון': {
                    categories: ['שעון'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'קוסמטיקה', 'צעצוע', 'toy'], // לא להביא לק או צעצועים
                    requireWords: ['שעון', 'watch']
                },
                'רק שעון': {
                    categories: ['שעון'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'קוסמטיקה', 'צעצוע', 'toy', 'חלפים', 'חלף'], // 🎯 STRICT: exclude toys, car parts, etc.
                    requireWords: ['שעון', 'watch'] // MUST have watch in title/products
                },
                'שעון בלבד': {
                    categories: ['שעון'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'קוסמטיקה', 'צעצוע', 'toy', 'חלפים', 'חלף'], // 🎯 STRICT: exclude toys, car parts, etc.
                    requireWords: ['שעון', 'watch'] // MUST have watch in title/products
                },
                'רק שעונים': {
                    categories: ['שעון'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'קוסמטיקה', 'צעצוע', 'toy', 'חלפים', 'חלף'], // 🎯 STRICT: exclude toys, car parts, etc.
                    requireWords: ['שעון', 'watch'] // MUST have watch in title/products
                },
                'שעונים': {
                    categories: ['שעון'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['לק', 'מניקור', 'קוסמטיקה'],
                    requireWords: ['שעון', 'watch']
                },
                'טלפון': {
                    categories: ['טכנולוגיה'],
                    excludeTypes: [],
                    excludeWords: [],
                    requireWords: ['טלפון', 'phone', 'טכנולוגיה']
                },
                'טכנולוגיה': {
                    categories: ['טכנולוגיה'],
                    excludeTypes: [],
                    excludeWords: [],
                    requireWords: ['טכנולוגיה', 'technology']
                },
                
                // רכב - הקשר חכם!
                'הלך לי הרכב': {categories: ['חלפים', 'מוסך', 'רכבת', 'רכב', 'חלק'], preferTypes: ['store']},
                'הלך לי רכב': {categories: ['חלפים', 'מוסך', 'רכבת', 'רכב', 'חלק'], preferTypes: ['store']},
                'תקלה ברכב': {categories: ['חלפים', 'מוסך', 'רכב', 'חלק'], preferTypes: ['store']},
                'בעיה ברכב': {categories: ['חלפים', 'מוסך', 'רכב', 'חלק'], preferTypes: ['store']},
                'קלקול רכב': {categories: ['חלפים', 'מוסך', 'רכב', 'חלק'], preferTypes: ['store']},
                'צריך חלפים': {categories: ['חלפים', 'רכב', 'חלק'], preferTypes: ['store']},
                'חלפים': {categories: ['חלפים', 'רכב', 'חלק'], preferTypes: ['store']},
                'מוסך': {categories: ['מוסך', 'חלפים', 'רכב'], preferTypes: ['store', 'serviceProvider']},
                'רכבת': {categories: ['חלפים', 'רכבת', 'רכב', 'חלק'], preferTypes: ['store']},
                'חלקי רכב': {categories: ['חלפים', 'רכב', 'חלק'], preferTypes: ['store']},
                'רכב': {categories: ['חלפים', 'רכב', 'חלק', 'מוסך'], preferTypes: ['store']},
                
                // שירותים
                'אינסטלטור': {categories: ['אינסטלטור', 'שירות'], preferTypes: ['serviceProvider']},
                'נגר': {categories: ['נגר', 'נגרות', 'שירות'], preferTypes: ['serviceProvider']},
                'נגרות': {categories: ['נגר', 'נגרות', 'שירות'], preferTypes: ['serviceProvider']},
                'plumber': {categories: ['אינסטלטור', 'שירות'], preferTypes: ['serviceProvider']},
                'electrician': {categories: ['חשמלאי', 'שירות'], preferTypes: ['serviceProvider']},
                'חשמלאי': {categories: ['חשמלאי', 'שירות'], preferTypes: ['serviceProvider']},
                'מספרה': {
                    categories: ['מספרה', 'תספורת', 'barber', 'להסתפר', 'הסתפרות', 'ספרות', 'מסתפר', 'מעצב שיער', 'עיצוב שיער', 'ספר', 'מספר'], 
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'book', 'ספריה', 'ספרייה'] // Exclude books library, but NOT "ספר" (barber)!
                    // ❌ NO requireWords - מספרה can have various titles like "קובי המספר", "ספר גברים", "מעצב שיער", etc.
                },
                'תספורת': {
                    categories: ['מספרה', 'תספורת', 'barber', 'להסתפר'], 
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'book', 'ספריה']
                },
                'להסתפר': {
                    categories: ['מספרה', 'תספורת', 'barber', 'להסתפר'], 
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'book', 'ספריה']
                },
                'ספר גברים': {
                    categories: ['מספרה', 'תספורת', 'barber'], 
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'book']
                },
                'ספר נשים': {
                    categories: ['מספרה', 'תספורת', 'barber'], 
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'book']
                },
                'מעצב שיער': {
                    categories: ['מספרה', 'תספורת', 'עיצוב שיער', 'מעצב שיער'], 
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'book']
                },
                'עיצוב שיער': {
                    categories: ['מספרה', 'תספורת', 'עיצוב שיער', 'מעצב שיער'], 
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'book']
                },
                'קוסמטיקאית': {
                    categories: ['לק', 'קוסמטיקאית', 'שירות'], 
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'מאמן': {
                    categories: ['מאמן', 'מאמנת', 'שירות', 'אימון', 'coaching'], 
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'בובה'],
                    requireWords: ['מאמן', 'מאמנת', 'אימון', 'coaching', 'תעופה']
                },
                'מאמנת': {
                    categories: ['מאמן', 'מאמנת', 'שירות', 'אימון', 'coaching'], 
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'בובה'],
                    requireWords: ['מאמן', 'מאמנת', 'אימון', 'coaching', 'תעופה']
                },
                'צלם': {
                    categories: ['צלם', 'צילום', 'שירות'], 
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'ספרים': {
                    categories: ['ספר', 'ספרים', 'book', 'ספריה'], 
                    preferTypes: ['store'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'מספרה', 'ספרות', 'barber'] // ספרים לא צעצועים ולא מספרות!
                },
                'קורס': {
                    categories: ['קורס'], 
                    preferTypes: ['course'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'חולצה': {
                    categories: ['חולצה', 'חולצות', 'בגד', 'clothing'], 
                    preferTypes: ['store'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'לק', 'מניקור'],
                    requireWords: ['חולצ', 'בגד', 'clothing', 'אופנה', 'הדפס']
                },
                'חולצות': {
                    categories: ['חולצה', 'חולצות', 'בגד', 'clothing'], 
                    preferTypes: ['store'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'לק', 'מניקור'],
                    requireWords: ['חולצ', 'בגד', 'clothing', 'אופנה', 'הדפס']
                },
                'בגדים': {
                    categories: ['בגד', 'clothing', 'אופנה'], 
                    preferTypes: ['store'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'לק', 'מניקור'],
                    requireWords: ['בגד', 'clothing', 'חולצ', 'אופנה']
                },
                // 🪚 נגרות ומטבח
                'נגר': {
                    categories: ['נגר', 'נגרות', 'עץ', 'ארון', 'מטבח', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'נגרות': {
                    categories: ['נגר', 'נגרות', 'עץ', 'ארון', 'מטבח', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'ארון': {
                    categories: ['נגר', 'נגרות', 'ארון', 'מטבח'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'ארון מטבח': {
                    categories: ['נגר', 'נגרות', 'מטבח', 'ארון'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'מטבח': {
                    categories: ['נגר', 'נגרות', 'מטבח', 'ארון'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'ארונות': {
                    categories: ['נגר', 'נגרות', 'ארון', 'מטבח'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                // 🚰 אינסטלטור וצנרת
                'פיצוץ': {
                    categories: ['אינסטלטור', 'צנרת', 'צינור', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'פיצוץ בצינור': {
                    categories: ['אינסטלטור', 'צנרת', 'צינור', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'נזילה': {
                    categories: ['אינסטלטור', 'צנרת', 'צינור', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'נזילת מים': {
                    categories: ['אינסטלטור', 'צנרת', 'צינור', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'בעיה בצינור': {
                    categories: ['אינסטלטור', 'צנרת', 'צינור', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'צנרת': {
                    categories: ['אינסטלטור', 'צנרת', 'צינור', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'צינור': {
                    categories: ['אינסטלטור', 'צנרת', 'צינור', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                // ⚡ חשמלאי
                'חשמל': {
                    categories: ['חשמלאי', 'חשמל', 'תאורה', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'קצר': {
                    categories: ['חשמלאי', 'חשמל', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'בעיה בחשמל': {
                    categories: ['חשמלאי', 'חשמל', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'תאורה': {
                    categories: ['חשמלאי', 'חשמל', 'תאורה', 'שירות'],
                    preferTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                // 🎁 מתנות מורחבות
                'מתנה לאישה': {
                    categories: ['לק', 'תכשיט', 'שעון'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'מתנה לבחורה': {
                    categories: ['לק', 'תכשיט', 'שעון'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד']
                },
                'מתנה לבעל': {
                    categories: ['שעון', 'טכנולוגיה', 'גאדגט'],
                    excludeTypes: ['serviceProvider'],
                    excludeWords: ['צעצוע', 'toy', 'משחק', 'ילד', 'לק']
                },
                'מתנה ליום הולדת': {
                    categories: ['שעון', 'תכשיט', 'צעצוע', 'לק'],
                    excludeTypes: ['serviceProvider']
                },
                'מתנה לחג': {
                    categories: ['שעון', 'תכשיט', 'צעצוע', 'לק'],
                    excludeTypes: ['serviceProvider']
                }
            };
            
            // Initialize searchTermWithoutCity
            let searchTermWithoutCity = searchTerm;
            
            // Check if query is about services/stores in a city - expanded patterns
            // Pattern 1: "איזה שירותים בנתניה", "מה חנויות בנתניה"
            const isCityServiceQueryPattern1 = /(?:איזה|מה|יש)\s*(?:שירותים|עסקים|חנויות|מוצרים|נותני\s+שרות|בעלי\s+מקצוע)\s*(?:ב|בתוך|בשדה)\s*([א-ת]+)/.test(searchTerm);
            
            // Pattern 2: "חנויות בנתניה", "נותני שרות בנתניה", "בעלי מקצוע בנתניה"
            const isCityServiceQueryPattern2 = /^(?:חנויות|נותני\s+שרות|בעלי\s+מקצוע|שירותים|עסקים)\s+ב([א-ת]+)$/.test(searchTerm);
            
            // Pattern 3: "חנויות בנתניה", "נותני שרות בנתניה" (with any text before)
            const isCityServiceQueryPattern3 = /(?:חנויות|נותני\s+שרות|בעלי\s+מקצוע|שירותים|עסקים)\s+ב([א-ת]+)/.test(searchTerm);
            
            // 🎯 IMPROVED Pattern 4: "X בY" (any word + city) - more flexible!
            // This will match: "לק בנתניה", "שעון בחיפה", "נגר בתל אביב", etc.
            const generalCityPattern = /^([א-תa-zA-Z\s]+)\s+ב([א-ת]+)$/;
            const isCityServiceQueryPattern4 = generalCityPattern.test(searchTerm);
            
            const isCityServiceQuery = isCityServiceQueryPattern1 || isCityServiceQueryPattern2 || isCityServiceQueryPattern3 || isCityServiceQueryPattern4;
            
            console.log(`🔍 City service query detection for "${searchTerm}": isCityServiceQuery=${isCityServiceQuery} (P1=${isCityServiceQueryPattern1}, P2=${isCityServiceQueryPattern2}, P3=${isCityServiceQueryPattern3}, P4=${isCityServiceQueryPattern4})`);
            
            // 🎯 IMPROVED: Extract service/product for ANY "X ב..." patterns (Pattern 4)
            // This now works for ANY search term + city combination
            if (isCityServiceQueryPattern4 && !requiredCity) {
                const productCityMatch = searchTerm.match(generalCityPattern);
                if (productCityMatch && productCityMatch[1] && productCityMatch[2]) {
                    const searchWord = productCityMatch[1].trim();
                    const potentialCity = productCityMatch[2].trim();
                    
                    console.log(`🔍 Pattern 4 (flexible) - searching for "${searchWord}" in city "${potentialCity}"`);
                    
                    // Check if it's a known city
                    let foundCity = false;
                    for (const city of cities) {
                        if (city.toLowerCase() === potentialCity.toLowerCase() || 
                            city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                            potentialCity.toLowerCase().includes(city.toLowerCase())) {
                            requiredCity = city;
                            searchTermWithoutCity = searchWord;
                            console.log(`✅ Pattern 4 match - Product/Service: "${searchTermWithoutCity}", City: ${requiredCity}`);
                            foundCity = true;
                            break;
                        }
                    }
                    
                    // If no exact match found, use it anyway if it looks like a city
                    // 🚫 BUT: Don't consider product attributes as cities!
                    if (!foundCity && potentialCity.length >= 2 && potentialCity.length <= 15 && 
                        /^[א-ת\s]+$/.test(potentialCity) &&
                        !notCityWords.includes(potentialCity.toLowerCase())) {
                        requiredCity = potentialCity;
                        searchTermWithoutCity = searchWord;
                        console.log(`✅ Pattern 4 match (new city) - Product/Service: "${searchTermWithoutCity}", City: ${requiredCity}`);
                    } else if (!foundCity && potentialCity && notCityWords.includes(potentialCity.toLowerCase())) {
                        console.log(`🚫 Pattern 4: Rejected "${potentialCity}" as city (it's a product attribute)`);
                    }
                }
            }
            
            // Extract service/product from search term if city was found (and not already extracted by Pattern 4)
            if (requiredCity && searchTermWithoutCity === searchTerm) {
                // Remove city and "ב" from search term
                searchTermWithoutCity = searchTerm
                    .replace(new RegExp(requiredCity.toLowerCase(), 'g'), '')
                    .replace(/\s*ב\s*/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                console.log(`🔍 Search term without city: "${searchTermWithoutCity}" (original: "${searchTerm}", requiredCity: "${requiredCity}")`);
            } else if (requiredCity) {
                console.log(`🔍 Required city: "${requiredCity}", search term without city: "${searchTermWithoutCity}"`);
            }
            
            // Find matching keyword
            let searchVariations = [searchTermWithoutCity, searchTerm];
            
            // 🎯 SMART DETECTION: If search term is 2+ words or seems like a product/service, treat as category search
            // This way we don't need to manually list every possible product!
            // 🎯 CRITICAL: Filter out stop words (common search terms that aren't meaningful)
            const stopWords = ['מחפש', 'מחפשת', 'רוצה', 'רוצה', 'אני', 'את', 'אתה', 'של', 'עם', 'לי', 'להשיג', 'למצוא', 'לקנות', 'איפה', 'יש', 'כמה', 'מה', 'איך', 'למה', 'מי', 'אשמח', 'צריך', 'צריכה'];
            
            // 🔧 Important short words (2 letters) that should NOT be filtered
            const importantShortWords = ['לק'];
            
            const searchTermWords = searchTerm.split(/\s+/)
                .filter(w => {
                    const lower = w.toLowerCase();
                    // Keep if: important short word OR (length > 2 AND not a stop word)
                    return importantShortWords.includes(lower) || (w.length > 2 && !stopWords.includes(lower));
                });
            
            console.log(`🔍 Search words (after filtering stop words): [${searchTermWords.join(', ')}]`);
            
            const looksLikeProductSearch = searchTermWords.length >= 1 && searchTerm.length >= 3;
            const searchesForCategory = looksLikeProductSearch; // Every search for something specific is a category search!
            console.log(`🔍 Searches for category: ${searchesForCategory} (search term: "${searchTerm}", words: ${searchTermWords.length})`);
            
            // 🎯 Fix common typos (before processing)
            const searchTypoFixes = {
                'תצעצועים': 'צעצועים',
                'תצעצוע': 'צעצוע',
                'תשעון': 'שעון',
                'תשעונים': 'שעונים',
                'תלק': 'לק',
                'מיספרה': 'מספרה',
                'מיסתפר': 'להסתפר',
                'מסעפרה': 'מספרה',
                'מספארה': 'מספרה',
                'מספרא': 'מספרה',
                'מעזב': 'מעצב',
                'מעזב שיער': 'מעצב שיער',
                // 🔧 Installer typos
                'איסטלטור': 'אינסטלטור',
                'אנסטלטור': 'אינסטלטור',
                'אינסטלטר': 'אינסטלטור',
                'איסטלטר': 'אינסטלטור'
            };
            
            searchVariations = searchVariations.map(variation => {
                if (variation && typeof variation === 'string') {
                    const lower = variation.toLowerCase().trim();
                    for (const [typo, fix] of Object.entries(searchTypoFixes)) {
                        if (lower.includes(typo)) {
                            const fixed = lower.replace(typo, fix);
                            console.log(`🔧 Fixed typo: "${variation}" -> "${fixed}"`);
                            return fixed;
                        }
                    }
                }
                return variation;
            });
            
            // 🎯 NEW: Add singular form to search variations (e.g., "נגרים" -> also search for "נגר")
            const singularForms = [];
            for (const variation of searchVariations) {
                if (variation && typeof variation === 'string') {
                    let singular = variation.toLowerCase().trim();
                    
                    // Remove "ה" from beginning
                    if (singular.startsWith('ה') && singular.length > 2) {
                        singular = singular.substring(1);
                    }
                    
                    // Remove plural suffixes
                    if (singular.endsWith('ים') && singular.length > 3) {
                        singularForms.push(singular.substring(0, singular.length - 2));
                        console.log(`📝 Added singular form: "${variation}" -> "${singular.substring(0, singular.length - 2)}"`);
                    } else if (singular.endsWith('ות') && singular.length > 3) {
                        singularForms.push(singular.substring(0, singular.length - 2));
                        console.log(`📝 Added singular form: "${variation}" -> "${singular.substring(0, singular.length - 2)}"`);
                    }
                }
            }
            
            // Add singular forms to search variations
            searchVariations = [...searchVariations, ...singularForms];
            
            // 🏷️ NEW: Expand search variations with category synonyms
            const expandedVariations = [];
            for (const variation of searchVariations) {
                const expanded = expandSearchTerms(variation);
                expandedVariations.push(...expanded);
            }
            searchVariations = [...new Set([...searchVariations, ...expandedVariations])]; // Remove duplicates
            console.log(`🔍 Search variations (with singular forms + categories): [${searchVariations.join(', ')}]`);
            
            // 🎯 COMPREHENSIVE: Synonym expansion covering ALL business types, products & services
            const synonymMap = {
                // Coaching & Fitness
                'מאמן': ['מאמנת', 'אימון', 'קואצ\'ינג', 'coaching', 'מאמן אישי', 'מאמן כושר', 'אימון אישי', 'כושר'],
                'מאמנת': ['מאמן', 'אימון', 'קואצ\'ינג', 'coaching', 'מאמן אישי', 'אימון אישי', 'כושר'],
                'אימון': ['מאמן', 'מאמנת', 'קואצ\'ינג', 'coaching', 'אימון אישי', 'כושר'],
                'קואצ\'ינג': ['מאמן', 'מאמנת', 'אימון', 'coaching', 'כושר'],
                'coaching': ['מאמן', 'מאמנת', 'אימון', 'קואצ\'ינג', 'כושר'],
                'כושר': ['מאמן', 'מאמנת', 'אימון', 'כושר אישי', 'מאמן כושר', 'חדר כושר', 'ספורט'],
                
                // Carpentry & Woodwork
                'נגר': ['נגרות', 'נגריה', 'עבודות עץ', 'נגרייה', 'נגר מטבחים', 'ארונות'],
                'נגרות': ['נגר', 'נגריה', 'עבודות עץ', 'ארונות', 'מטבחים'],
                
                // Watches & Jewelry
                'שעון': ['שעונים', 'שעוני יד', 'שעון יד', 'שעוני קיר'],
                'שעונים': ['שעון', 'שעוני יד', 'תכשיטים'],
                'תכשיט': ['תכשיטים', 'תכשיטנות', 'תכשיטן', 'זהב', 'כסף', 'תכשיט זהב'],
                
                // Toys & Games
                'צעצוע': ['צעצועים', 'משחק', 'משחקים', 'צעצועי ילדים'],
                'צעצועים': ['צעצוע', 'משחק', 'משחקים', 'משחקי ילדים'],
                
                // Hairdressing & Barbershops
                'מספרה': ['תספורת', 'תספורות', 'מספר', 'ספר', 'ספר גברים', 'ספר נשים', 'ספרות', 'barber', 'להסתפר', 'מעצב שיער', 'עיצוב שיער'],
                'תספורת': ['מספרה', 'מספר', 'עיצוב שיער', 'ספרות', 'מעצב שיער'],
                'מעצב שיער': ['מספרה', 'תספורת', 'עיצוב שיער', 'ספרות'],
                'עיצוב שיער': ['מספרה', 'תספורת', 'מעצב שיער', 'ספרות'],
                
                // Beauty & Nails
                'לק': ['ציפורניים', 'מניקור', 'פדיקור', 'לק ג\'ל', 'עיצוב ציפורניים'],
                'מניקור': ['לק', 'ציפורניים', 'פדיקור', 'לק ג\'ל'],
                'פדיקור': ['לק', 'ציפורניים', 'מניקור', 'לק ג\'ל'],
                'יופי': ['קוסמטיקה', 'טיפוח', 'מניקור', 'פדיקור', 'איפור', 'עיצוב גבות'],
                'מעצב': ['מעצבת', 'עיצוב', 'מעצב שיער', 'מעצב פנים', 'מעצב גרפי'],
                
                // Restaurants & Food
                'מסעדה': ['מסעדות', 'אוכל', 'אכילה', 'בית קפה', 'מזון', 'אוכל מהיר'],
                'מסעדות': ['מסעדה', 'אוכל', 'אכילה', 'בתי קפה'],
                'קפה': ['בית קפה', 'קפה בוקר', 'קפיטריה'],
                'אוכל': ['מסעדה', 'מזון', 'אכילה', 'מזון מהיר'],
                'פיצה': ['פיצרייה', 'איטלקי', 'מסעדה'],
                'המבורגר': ['המבורגרים', 'בורגר', 'מזון מהיר'],
                'סושי': ['יפני', 'אסייתי', 'סושי בר'],
                
                // Plumbing & Electrician
                'אינסטלטור': ['אינסטלציה', 'שרברב', 'אינסטלטור בשבת', 'שרברבות'],
                'שרברב': ['אינסטלטור', 'אינסטלציה', 'שרברבות'],
                'חשמלאי': ['חשמל', 'חשמלאות', 'תיקון חשמל'],
                
                // Car & Auto
                'רכב': ['מכונית', 'רכבים', 'אוטו', 'מכוניות'],
                'חלפים': ['חלקי חילוף', 'חלפי רכב', 'אביזרים לרכב'],
                'מוסך': ['תיקון רכב', 'מכונאי', 'מוסכים'],
                'מכונאי': ['מוסך', 'תיקון רכב', 'מכונאות'],
                
                // Technology & Robotics
                'רובוט': ['רובוטיקה', 'רובוטים', 'אוטומציה'],
                'רובוטיקה': ['רובוט', 'רובוטים', 'אוטומציה'],
                'טכנולוגיה': ['היי-טק', 'טכנולוגי', 'חדשנות'],
                'מחשב': ['מחשבים', 'לפטופ', 'מחשב נייד', 'קומפיוטר'],
                
                // Courses & Education
                'קורס': ['קורסים', 'השתלמות', 'לימודים', 'הכשרה'],
                'קורסים': ['קורס', 'השתלמות', 'לימודים', 'הכשרה'],
                'לימודים': ['קורס', 'קורסים', 'השתלמות', 'הכשרה'],
                
                // Events & Entertainment
                'אירוע': ['אירועים', 'אירוע חברה', 'אירוע פרטי'],
                'אירועים': ['אירוע', 'חתונה', 'בר מצווה', 'אירוע חברה'],
                'צלם': ['צילום', 'צלמת', 'צילומים', 'צלם אירועים'],
                'צילום': ['צלם', 'צלמת', 'צילומים', 'צילום אירועים'],
                'די ג\'יי': ['dj', 'די.ג\'יי', 'תקליטן', 'מוזיקה'],
                
                // Health & Wellness
                'דיאטה': ['תזונה', 'דיאטן', 'דיאטנית', 'הרזיה'],
                'תזונה': ['דיאטה', 'דיאטן', 'דיאטנית', 'תזונאי'],
                'יוגה': ['יוגה אישית', 'שיעורי יוגה', 'מורת יוגה'],
                'עיסוי': ['מעסה', 'מעסות', 'עיסוי רפואי', 'עיסוי שוודי'],
                'פיזיותרפיה': ['פיזיותרפיסט', 'פיזיו', 'שיקום'],
                
                // Home Services
                'ניקיון': ['ניקיונות', 'מנקה', 'חברת ניקיון', 'שירותי ניקיון'],
                'גינון': ['גנן', 'גינה', 'שירותי גינון', 'עיצוב גינות'],
                'צבע': ['צבעים', 'צבעי', 'צבעי בניין', 'צבאי'],
                'שיפוצים': ['שיפוץ', 'בנייה', 'בניין', 'קבלן'],
                'קבלן': ['קבלנים', 'שיפוצים', 'בנייה'],
                
                // Fashion & Clothing
                'אופנה': ['בגדים', 'ביגוד', 'לבוש', 'אופנת נשים'],
                'בגדים': ['ביגוד', 'אופנה', 'לבוש', 'בגדי נשים'],
                'נעליים': ['נעלים', 'נעל', 'נעלי ספורט', 'נעלי נשים'],
                
                // Pets
                'כלב': ['כלבים', 'בעלי חיים', 'חיות מחמד', 'מזון לכלבים'],
                'חתול': ['חתולים', 'בעלי חיים', 'חיות מחמד', 'מזון לחתולים'],
                'וטרינר': ['וטרינרית', 'וטרינריה', 'רופא וטרינר', 'מרפאה'],
                
                // Gifts & Party
                'מתנה': ['מתנות', 'מתנות לגבר', 'מתנות לאישה', 'מתנת יום הולדת'],
                'מתנות': ['מתנה', 'שי', 'שי לגבר', 'שי לאישה'],
                
                // Books & Print
                'ספרים': ['ספר', 'ספריה', 'חנות ספרים', 'book'],
                'הדפסה': ['מדפסת', 'דפוס', 'הדפסות', 'דיגיטל'],
                
                // Flowers
                'פרחים': ['פרח', 'זרי פרחים', 'זר פרחים', 'פרחי'],
                
                // Insurance & Legal
                'ביטוח': ['ביטוחים', 'סוכן ביטוח', 'חברת ביטוח'],
                'עורך דין': ['עו"ד', 'משרד עורכי דין', 'ייעוץ משפטי'],
                'רואה חשבון': ['רו"ח', 'חשבונאות', 'הנהלת חשבונות'],
                
                // Real Estate
                'נדלן': ['דירות', 'דירה', 'נכסים', 'מתווך'],
                'מתווך': ['מתווכים', 'נדלן', 'דירות', 'נכסים']
            };
            
            const synonymExpansion = [];
            for (const variation of searchVariations) {
                if (variation && typeof variation === 'string') {
                    const varLower = variation.toLowerCase().trim();
                    // Check if this variation has synonyms
                    for (const [key, synonyms] of Object.entries(synonymMap)) {
                        if (varLower === key || varLower.includes(key)) {
                            synonymExpansion.push(...synonyms);
                            console.log(`📚 Added synonyms for "${varLower}": [${synonyms.join(', ')}]`);
                            break;
                        }
                    }
                }
            }
            
            // 🎯 SMART EXPANSION: Use smartKeywords to expand search terms intelligently
            // This helps with queries like "מתנה לילד" → should find toy stores
            let smartExpansion = [];
            let excludeWords = [];
            let requireWords = [];
            let excludeTypes = [];
            let preferTypes = null;
            
            // Check if query matches any smart keyword pattern
            // Sort patterns by length (longest first) to match most specific patterns first
            const sortedSmartKeywords = Object.entries(smartKeywords).sort((a, b) => b[0].length - a[0].length);
            
            for (const [pattern, config] of sortedSmartKeywords) {
                // Check for match - SIMPLE approach that works!
                const searchTermLower = (searchTermWithoutCity || searchTerm).toLowerCase().trim();
                const patternLower = pattern.toLowerCase().trim();
                
                // 🎯 SIMPLE: Just check if the search term contains the pattern
                // This will match "צעצועים", "מחפש צעצועים", "צעצועים בנתניה", etc.
                const matches = searchTermLower.includes(patternLower) || patternLower.includes(searchTermLower);
                
                console.log(`🔍 Checking pattern "${pattern}" against "${searchTermLower}": matches=${matches}`);
                
                if (matches) {
                    console.log(`🎯 Smart keyword match: "${pattern}" → categories: [${config.categories?.join(', ')}]`);
                    if (config.categories) {
                        smartExpansion.push(...config.categories);
                    }
                    if (config.excludeWords) {
                        excludeWords.push(...config.excludeWords);
                    }
                    if (config.requireWords) {
                        requireWords.push(...config.requireWords);
                    }
                    if (config.excludeTypes) {
                        excludeTypes.push(...config.excludeTypes);
                    }
                    if (config.preferTypes) {
                        preferTypes = config.preferTypes;
                    }
                    break; // Use first (most specific) match
                }
            }
            
            // Build search variations: original term + smart expansions
            if (smartExpansion.length > 0) {
                searchVariations = [searchTermWithoutCity, searchTerm, ...smartExpansion];
                console.log(`🔍 Search variations (WITH smart expansion): [${searchVariations.join(', ')}]`);
            } else {
                searchVariations = [searchTermWithoutCity, searchTerm];
                console.log(`🔍 Search variations (NO expansion): [${searchVariations.join(', ')}]`);
            }
            
            // FIRST: Check if query is about products in a specific store (e.g., "מוצרים בחנות ראד")
            // OR about store info (e.g., "מה הטלפון של החנות RED", "באיזה עיר החנות ראד")
            const storeProductPattern = /(?:המוצרים|מוצרים|מה יש|מה יש ל|מה מוכרים|איזה מוצרים)\s*(?:ב|בחנות|של)\s*([א-תa-zA-Z]+)/i;
            const storeInfoPattern = /(?:מה|איזה)\s*(?:הטלפון|הכתובת|העיר|המייל)\s*(?:של|ב)\s*(?:החנות|העסק|הדף)?\s*([א-תa-zA-Z]+)/i;
            const storeCityPattern = /(?:באיזה|איפה)\s+(?:עיר|מיקום)\s+(?:החנות|העסק|הדף)\s*([א-תa-zA-Z]+)/i;
            
            const storeProductMatch = searchTerm.match(storeProductPattern);
            const storeInfoMatch = searchTerm.match(storeInfoPattern) || searchTerm.match(storeCityPattern);
            const storeMatch = storeProductMatch || storeInfoMatch;
            
            if (storeMatch && storeMatch[1]) {
                const storeName = storeMatch[1].trim();
                console.log('🏪 Store query detected for:', storeName);
                
                // Add the store name as primary search term (both Hebrew and English versions)
                searchVariations = [storeName.toLowerCase(), searchTerm];
                
                // If store name is Hebrew, also try English equivalent (e.g., "ראד" -> "red")
                // If store name is English, also try Hebrew (less common)
                if (storeName.match(/[א-ת]/)) {
                    // Hebrew store name - add common English equivalents
                    const hebrewToEnglish = {
                        'ראד': 'red',
                        'יניב': 'yaniv'
                    };
                    if (hebrewToEnglish[storeName.toLowerCase()]) {
                        searchVariations.push(hebrewToEnglish[storeName.toLowerCase()]);
                    }
                } else {
                    // English store name - also try common Hebrew equivalents
                    const englishToHebrew = {
                        'red': 'ראד',
                        'yaniv': 'יניב'
                    };
                    if (englishToHebrew[storeName.toLowerCase()]) {
                        searchVariations.push(englishToHebrew[storeName.toLowerCase()]);
                    }
                    searchVariations.push(storeName.toLowerCase());
                }
                
                // Don't exclude any types, prefer stores
                preferTypes = ['store'];
                console.log('🔍 Store search variations:', searchVariations);
            } else {
                // Regular search flow
                
                // Check if query is about services/stores in a city (already defined above)
                if (isCityServiceQuery) {
                    // Try multiple patterns to extract city
                    let city = null;
                    
                    // Pattern 1: "חנויות בנתניה", "נותני שרות בנתניה"
                    const pattern1 = /(?:חנויות|נותני\s+שרות|בעלי\s+מקצוע|שירותים|עסקים)\s+ב([א-ת]+)/;
                    const match1 = searchTerm.match(pattern1);
                    if (match1 && match1[1]) {
                        city = match1[1].trim();
                    }
                    
                    // Pattern 2: "(איזה|מה|יש) (שירותים|עסקים|חנויות) ב..."
                    if (!city) {
                        const pattern2 = /(?:ב|בתוך|בשדה)\s*([א-ת]+)/;
                        const match2 = searchTerm.match(pattern2);
                        if (match2 && match2[1]) {
                            city = match2[1].trim();
                        }
                    }
                    
                    if (city) {
                        // Check what type of query it is
                        const isStoresQuery = /חנויות/.test(searchTerm);
                        const isServicesQuery = /(?:נותני\s+שרות|בעלי\s+מקצוע|שירותים)/.test(searchTerm);
                        
                        console.log(`🏙️ City query detected: "${city}", stores: ${isStoresQuery}, services: ${isServicesQuery}`);
                        
                        // Set search variations and preferred types based on query
                        if (isStoresQuery) {
                            searchVariations = [city, 'חנות', 'חנויות', 'מוצר'];
                            preferTypes = ['store'];
                            console.log('🏪 Filtering for stores only');
                        } else if (isServicesQuery) {
                            searchVariations = [city, 'שירות', 'נותן שירות', 'בעל מקצוע'];
                            preferTypes = ['serviceProvider'];
                            console.log('🔧 Filtering for services only');
                        } else {
                            // General query - show all
                            searchVariations = [city, 'שירות', 'עסק', 'חנות', 'מוצר'];
                            preferTypes = ['store', 'serviceProvider', 'event', 'course'];
                            console.log('🌍 Showing all types');
                        }
                    }
                }
                
                // If no city query, check for regular keywords
                // 🎯 Check for "תמליצי" / "המלצ" queries first (recommendation queries)
                if (!isCityServiceQuery) {
                    // Check for recommendation queries ("תמליצי", "תמליץ", "המלצ")
                    if (searchTerm.includes('תמליצי') || searchTerm.includes('תמליץ') || searchTerm.includes('המלצ')) {
                        // Check if it's about gifts/products for someone specific
                        if (searchTerm.includes('מתנה') || searchTerm.includes('מוצר')) {
                            // Extract target person (e.g., "לאישה", "לבחורה", "לגבר", "לילד")
                            if (searchTerm.includes('לאישה') || searchTerm.includes('לבחורה') || searchTerm.includes('לאשה')) {
                                // Gift for woman - prefer watches, nail polish, jewelry
                                searchVariations = ['שעון', 'לק', 'תכשיט', 'מניקור', 'פדיקור', 'קוסמטיקה'];
                                excludeTypes = ['serviceProvider'];
                                excludeWords = ['צעצוע', 'toy', 'חלפים', 'חלף']; // Exclude toys, car parts
                            } else if (searchTerm.includes('לגבר') || searchTerm.includes('לבחור') || 
                                       searchTerm.includes('לבעל') || searchTerm.includes('לבעלי')) {
                                // Gift for man/husband - prefer watches, technology, gadgets (NOT toys!)
                                searchVariations = ['שעון', 'טכנולוגיה', 'רובוט', 'גאדגט'];
                                excludeTypes = ['serviceProvider'];
                                excludeWords = ['צעצוע', 'toy', 'לק', 'מניקור', 'פדיקור', 'חלפים', 'חלף']; // 🎯 STRICT: Exclude toys, nail polish, car parts
                            } else if (searchTerm.includes('לילד') || searchTerm.includes('לילדים')) {
                                // Gift for child - prefer toys
                                searchVariations = ['צעצוע', 'משחק', 'בובה', 'מכונית'];
                                excludeTypes = ['serviceProvider'];
                                excludeWords = ['שעון', 'לק', 'חלפים']; // Exclude watches, nail polish, car parts
                            } else {
                                // General gift - prefer watches, jewelry, toys (but exclude services)
                                searchVariations = ['שעון', 'תכשיט', 'צעצוע', 'לק'];
                                excludeTypes = ['serviceProvider'];
                            }
                        } else if (searchTerm.includes('מרקט') || searchTerm.includes('מרקטפלייס')) {
                            // "תמליצי מהמוצרים במרקט" - show all products
                            searchVariations = ['שעון', 'תכשיט', 'צעצוע', 'לק', 'מוצר'];
                            excludeTypes = ['serviceProvider'];
                        } else {
                            // General "תמליצי" - show gifts (watches, jewelry, toys)
                            searchVariations = ['שעון', 'תכשיט', 'צעצוע', 'לק'];
                            excludeTypes = ['serviceProvider'];
                        }
                        console.log(`🔍 Recommendation query detected, searchVariations: ${searchVariations.join(', ')}`);
                    } else {
                        // 🎯 REMOVED: No more smartKeywords - just search for exact words!
                        console.log(`🔍 Pure search mode - no keyword expansion`);
                    }
                }
            }
            
            console.log('🔍 Search variations:', searchVariations);
            console.log('🚫 Exclude types:', excludeTypes);
            console.log('⭐ Prefer types:', preferTypes);
            console.log('🚫 Exclude words:', excludeWords);
            console.log('✅ Require words:', requireWords);
            console.log('🔍 [DEBUG] searchTerm:', searchTerm);
            console.log('🔍 [DEBUG] searchTermWithoutCity:', searchTermWithoutCity);
            
            // Note: allPages was already loaded at the beginning of the function
            
            for (const page of allPages) {
                try {
                    // 🔍 DEBUG: Log barber/hair salon pages
                    if (page.title && (page.title.includes('מספרה') || page.title.includes('לוי') || page.title.includes('ברוך') || page.title.includes('עיצוב שיער'))) {
                        console.log(`🔍 [CHECKING BARBER] "${page.title}" (type: ${page.pageType})`);
                    }
                    
                    let matchScore = 0;
                    
                    // EXCLUDE pages if needed
                    if (excludeTypes.includes(page.pageType)) {
                        console.log(`🚫 Excluded "${page.title}" - wrong type`);
                        continue;
                    }
                    
                    // 🎯 OPTIMIZATION: DON'T load live products yet - it's too slow!
                    // We'll load them ONLY for matching pages later (2-stage search)
                    let liveProducts = [];
                    
                    // Extract business name from query (e.g., "מה הטלפון של דוד חלפים" -> "דוד חלפים")
                    let businessNameFromQuery = null;
                
                // Check for specific question patterns first
                const questionPatterns = [
                    /(?:מה|איפה|היכן|איזה)\s+(?:ה)?טלפון\s+(?:של|ב|בתוך)\s+([א-ת\s]+)/,
                    /(?:מה|איפה|היכן)\s+(?:הכתובת|המייל|הפרטים)\s+(?:של|ב|בתוך)\s+([א-ת\s]+)/,
                    /(?:של|ב|בתוך)\s+([א-ת]{3,})/  // "של דוד חלפים" or "ב יניב"
                ];
                
                for (const pattern of questionPatterns) {
                    const match = searchTerm.match(pattern);
                    if (match && match[1]) {
                        businessNameFromQuery = match[1].trim();
                        // Clean up common words
                        businessNameFromQuery = businessNameFromQuery.replace(/\b(מה|איפה|היכן|איזה|טלפון|כתובת|מייל|פרטים|של|את|על|ב|בתוך)\b/g, '').trim();
                        if (businessNameFromQuery.length >= 2 && businessNameFromQuery.length <= 50) {
                            console.log('🏢 Extracted business name from query:', businessNameFromQuery);
                            break;
                        }
                    }
                }
                
                // If no pattern matched, try to find store/business name from query
                // Special case: "המוצרים בחנות ראד" -> extract "ראד" or "red"
                if (!businessNameFromQuery) {
                    // 🎯 IMPROVED: Use searchTermWithoutCity to avoid extracting city as business name
                    const termToSearch = searchTermWithoutCity || searchTerm;
                    // Try to extract store name from product queries
                    const storeNameMatch = termToSearch.match(/(?:ב|בחנות|של)\s*([א-תa-zA-Z]+)/i);
                    if (storeNameMatch && storeNameMatch[1]) {
                        const extractedName = storeNameMatch[1].trim();
                        // 🎯 IMPROVED: Don't use city as business name
                        if (!requiredCity || extractedName.toLowerCase() !== requiredCity.toLowerCase()) {
                            businessNameFromQuery = extractedName;
                            console.log('🏢 Extracted store name from product query:', businessNameFromQuery);
                        }
                    }
                }
                
                // If still no match, try to find Hebrew/English word sequences
                // 🎯 CRITICAL: Only extract business names, NOT product/service categories!
                if (!businessNameFromQuery) {
                    // 🎯 IMPROVED: Use searchTermWithoutCity to avoid including city
                    const termToSearch = searchTermWithoutCity || searchTerm;
                    const words = termToSearch.match(/[א-תa-zA-Z]+(?:\s+[א-תa-zA-Z]+){0,2}/g);
                    if (words) {
                        // 🎯 CRITICAL: Filter out product/service categories - these are NOT business names!
                        const categoryWords = ['צעצועים', 'צעצוע', 'בובה', 'בובות', 'שעון', 'שעונים', 'מספרה', 'נגר', 'חשמלאי', 'אינסטלטור', 'מאמן', 'מורה', 'לק', 'מניקור', 'פדיקור', 'טיפול', 'תספורת', 'להסתפר', 'מעצב', 'עיצוב', 'שיער', 'ספר', 'מספר', 'מוצרים', 'מוצר', 'מחיר', 'מחירים', 'חנות', 'חנויות', 'עסק', 'עסקים'];
                        const commonWords = ['מה', 'איפה', 'היכן', 'איזה', 'טלפון', 'כתובת', 'מייל', 'פרטים', 'של', 'את', 'על', 'ב', 'בתוך', 'הלך', 'לי', 'הרכב', 'המוצרים', 'בחנות', 'יש', 'מה יש', 'מחפש', 'מחפשת', 'רוצה', 'אני', 'את', 'אתה'];
                        businessNameFromQuery = words
                            .filter(w => {
                                const wLower = w.trim().toLowerCase();
                                // 🎯 CRITICAL: Filter out category words, common words, AND the required city
                                const isCategory = categoryWords.includes(wLower);
                                const isCommon = commonWords.includes(wLower);
                                const isCity = requiredCity && wLower === requiredCity.toLowerCase();
                                const shouldExclude = isCategory || isCommon || isCity;
                                
                                if (shouldExclude) {
                                    console.log(`🚫 Filtered out "${w}" - ${isCategory ? 'category word' : isCommon ? 'common word' : 'city name'}`);
                                }
                                
                                return !shouldExclude;
                            })
                            .sort((a, b) => b.length - a.length)[0];
                        if (businessNameFromQuery && businessNameFromQuery.length >= 2) {
                            businessNameFromQuery = businessNameFromQuery.trim();
                            console.log('🏢 Extracted business name (fallback):', businessNameFromQuery);
                        } else {
                            console.log('🚫 No business name extracted - query seems to be a category/service search, not a business name');
                        }
                    }
                }
                
                // Check if page title or description matches (flexible matching)
                const titleLower = page.title.toLowerCase();
                const descLower = (page.description || '').toLowerCase();
                // 🎯 IMPROVED: Use searchTermWithoutCity when searching with city
                const searchTermLower = (searchTermWithoutCity || searchTerm).toLowerCase();
                
                // 🎯 REMOVED: Old scoring - using new word-based scoring below
                
                // 🎯 REMOVED: No more base scores - pages must match search words to be included!
                
                // 🎯 REMOVED: Old scoring logic - using new simple logic below
                
                // 🎯 REMOVED: allProducts will be defined later, after liveProducts are loaded
                
                // EXACT business name match gets highest priority
                // Also check for partial matches (e.g., "red" matches "RED" or vice versa)
                // 🎯 CRITICAL: Only give business name score if it's actually a business name, not a category!
                if (businessNameFromQuery) {
                    const businessLower = businessNameFromQuery.toLowerCase();
                    let titleLower = page.title.toLowerCase();
                    
                    // 🎯 CRITICAL: Double-check that businessNameFromQuery is NOT a category word
                    // (This should already be filtered, but just in case)
                    const categoryWords = ['צעצועים', 'צעצוע', 'בובה', 'בובות', 'שעון', 'שעונים', 'מספרה', 'נגר', 'חשמלאי', 'אינסטלטור', 'מאמן', 'מורה', 'לק', 'מניקור', 'פדיקור', 'טיפול', 'תספורת', 'להסתפר', 'מעצב', 'עיצוב', 'שיער', 'ספר', 'מספר', 'מוצרים', 'מוצר', 'מחיר', 'מחירים', 'חנות', 'חנויות', 'עסק', 'עסקים'];
                    if (categoryWords.includes(businessLower)) {
                        console.log(`🚫 "${businessNameFromQuery}" is a category word, not a business name - skipping business name scoring`);
                        businessNameFromQuery = null; // Don't use it for scoring
                    }
                }
                
                if (businessNameFromQuery) {
                    const businessLower = businessNameFromQuery.toLowerCase();
                    let titleLower = page.title.toLowerCase();
                    
                    // Hebrew-English name mapping (bidirectional)
                    const nameMappings = {
                        'ראד': 'red',
                        'red': 'ראד',
                        'יניב': 'yaniv',
                        'yaniv': 'יניב'
                    };
                    
                    // Try to find matching name (direct or via mapping)
                    let businessMatch = null;
                    let titleMatch = null;
                    
                    if (nameMappings[businessLower]) {
                        businessMatch = nameMappings[businessLower];
                    }
                    if (nameMappings[titleLower]) {
                        titleMatch = nameMappings[titleLower];
                    }
                    
                    // Check direct match
                    if (titleLower.includes(businessLower) || businessLower.includes(titleLower) || 
                        titleLower === businessLower) {
                        matchScore += 50; // VERY HIGH score for exact business name (highest priority!)
                        console.log('✅ Exact business name match:', businessNameFromQuery, '→', page.title);
                    } 
                    // Check via mapping (e.g., "ראד" -> "red" matches "red" page)
                    else if (businessMatch && (titleLower.includes(businessMatch) || titleLower === businessMatch)) {
                        matchScore += 50; // VERY HIGH score for mapped match
                        console.log('✅ Mapped business name match:', businessNameFromQuery, '→', businessMatch, '→', page.title);
                    }
                    else if (titleMatch && (businessLower.includes(titleMatch) || businessLower === titleMatch)) {
                        matchScore += 50; // VERY HIGH score for reverse mapped match
                        console.log('✅ Reverse mapped business name match:', businessNameFromQuery, '→', titleMatch, '→', page.title);
                    }
                    else {
                        // Check for word-level match (e.g., "ראד" in Hebrew vs "red" in English)
                        const businessWords = businessLower.split(/\s+/);
                        const titleWords = titleLower.split(/\s+/);
                        const hasWordMatch = businessWords.some(bw => 
                            titleWords.some(tw => tw.includes(bw) || bw.includes(tw))
                        ) || (businessMatch && titleWords.some(tw => tw.includes(businessMatch) || businessMatch.includes(tw)));
                        
                        if (hasWordMatch) {
                            matchScore += 40; // High score for word-level match
                            console.log('✅ Word-level business name match:', businessNameFromQuery, '→', page.title);
                        } else {
                            // 🎯 FIX: Don't give heavy penalty if businessName is very short (2-3 chars)
                            // Short names like "גל" are often part of a longer name like "לק גל"
                            if (businessLower.length <= 3) {
                                matchScore -= 5; // Light penalty for short names
                                console.log(`⚠️ Business name mismatch (short name "${businessNameFromQuery}"): ${businessNameFromQuery} ≠ ${page.title} (light penalty -5)`);
                            } else {
                                matchScore -= 30; // Heavy penalty for non-matching pages when specific business was requested
                                console.log('❌ Business name mismatch:', businessNameFromQuery, '≠', page.title);
                            }
                        }
                    }
                }
                
                // 🎯 PURE SCORING: Only check EXACT search words from user (no variations, no expansions!)
                const titleLowerForScore = (page.title || '').toLowerCase();
                const descLowerForScore = (page.description || '').toLowerCase();
                
                console.log(`🔍 Checking "${page.title}" against words: [${searchTermWords.join(', ')}]`);
                console.log(`   Title: "${titleLowerForScore}"`);
                
                // 🎯 CRITICAL: Calculate matchScore FIRST, before checking serviceMatchesQuery!
                // This ensures that pages with partial matches (like "יניב צעצוע" for "צעצועים") get a score
                // Score each search word individually
                for (const word of searchTermWords) {
                    if (word.length < 2) continue; // Skip very short words
                    
                    const wordLower = word.toLowerCase();
                    
                    // Title matches are most important
                    if (titleLowerForScore.includes(wordLower)) {
                        matchScore += 100;
                        console.log(`✅ "${page.title}" - title contains "${word}" (+100)`);
                    } else {
                        // 🎯 NEW: Check partial match - remove plural suffixes
                        // "צעצועים" -> check "צעצוע", "שעונים" -> check "שעון"
                        let baseWord = wordLower;
                        console.log(`   🔍 Checking partial match for "${word}" (baseWord: "${baseWord}")`);
                        if (baseWord.endsWith('ים') && baseWord.length > 3) {
                            baseWord = baseWord.substring(0, baseWord.length - 2);
                            console.log(`   🔍 Removed "ים" suffix, checking "${baseWord}" in title "${titleLowerForScore}"`);
                            if (titleLowerForScore.includes(baseWord)) {
                                matchScore += 100;
                                console.log(`✅ "${page.title}" - title contains "${baseWord}" (from "${word}") (+100)`);
                            } else {
                                console.log(`   ❌ "${baseWord}" NOT found in title "${titleLowerForScore}"`);
                            }
                        } else if (baseWord.endsWith('ות') && baseWord.length > 3) {
                            baseWord = baseWord.substring(0, baseWord.length - 2);
                            console.log(`   🔍 Removed "ות" suffix, checking "${baseWord}" in title "${titleLowerForScore}"`);
                            if (titleLowerForScore.includes(baseWord)) {
                                matchScore += 100;
                                console.log(`✅ "${page.title}" - title contains "${baseWord}" (from "${word}") (+100)`);
                            } else {
                                console.log(`   ❌ "${baseWord}" NOT found in title "${titleLowerForScore}"`);
                            }
                        } else {
                            console.log(`   ❌ "${word}" doesn't end with "ים" or "ות", or too short (length: ${baseWord.length})`);
                        }
                    }
                    
                    // Description matches are moderately important
                    if (descLowerForScore.includes(wordLower)) {
                        matchScore += 30;
                        console.log(`✅ "${page.title}" - description contains "${word}" (+30)`);
                    } else {
                        // 🎯 NEW: Check partial match - remove plural suffixes
                        let baseWord = wordLower;
                        if (baseWord.endsWith('ים') && baseWord.length > 3) {
                            baseWord = baseWord.substring(0, baseWord.length - 2);
                            if (descLowerForScore.includes(baseWord)) {
                                matchScore += 30;
                                console.log(`✅ "${page.title}" - description contains "${baseWord}" (from "${word}") (+30)`);
                            }
                        } else if (baseWord.endsWith('ות') && baseWord.length > 3) {
                            baseWord = baseWord.substring(0, baseWord.length - 2);
                            if (descLowerForScore.includes(baseWord)) {
                                matchScore += 30;
                                console.log(`✅ "${page.title}" - description contains "${baseWord}" (from "${word}") (+30)`);
                            }
                        }
                    }
                }
                
                // For city-based queries, accept ALL pages (we'll filter by city later)
                // For regular queries, need at least some match - BUT also check products!
                // 🎯 CRITICAL FIX: If searching for products, VERY LOW threshold (so pages with 12 base score easily pass)!
                const minScoreForCityQuery = isCityServiceQuery ? 1 : (searchesForCategory ? 0 : 0); // ZERO threshold for category searches!
                
                // 🎯 If we didn't load live products yet, use metadata as fallback
                if (liveProducts.length === 0 && page.products && page.products.length > 0) {
                    liveProducts = page.products;
                    console.log(`📦 Using metadata products for "${page.title}" (${liveProducts.length} products)`);
                }
                
                let contactInfo = {
                    phone: page.phone,
                    phones: page.phones || [],
                    email: page.email,
                    city: page.city,
                    address: page.address
                };
                
                console.log(`📊 Page "${page.title}" - initial metadata: city="${page.city || 'EMPTY'}"`);
                
                // 🎯 CRITICAL: If city is required, ALWAYS try to load it to ensure accuracy
                // Even if we have city in metadata, it might be wrong/outdated
                const needsCityExtraction = requiredCity;
                const needsExtraction = needsCityExtraction || !page.phone || (page.products && page.products.length === 0);
                
                if (needsExtraction) {
                try {
                    const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                    console.log(`🔍 Extracting metadata for page: ${page.title} (needsCity=${needsCityExtraction})`);
                    const response = await fetch(pageUrl);
                    if (response.ok) {
                        const html = await response.text();
                            
                            // Extract live data
                            // 🎯 CRITICAL: If city is required, ALWAYS extract it from HTML (don't trust metadata)
                            const extractedContactInfo = extractLiveContactInfo(html);
                            console.log(`🔍 Extracted contact info: city="${extractedContactInfo.city || 'EMPTY'}", phone="${extractedContactInfo.phone || 'EMPTY'}"`);
                            
                            // If city is required, use extracted city (override metadata)
                            // Otherwise, use metadata as fallback
                            if (requiredCity) {
                                contactInfo = {
                                    ...contactInfo,
                                    phone: contactInfo.phone || extractedContactInfo.phone,
                                    phones: contactInfo.phones.length > 0 ? contactInfo.phones : extractedContactInfo.phones || [],
                                    email: contactInfo.email || extractedContactInfo.email,
                                    city: extractedContactInfo.city || contactInfo.city, // 🎯 PRIORITY: extracted city first!
                                    address: extractedContactInfo.address || contactInfo.address
                                };
                                console.log(`🎯 Using extracted city for "${page.title}": "${contactInfo.city}"`);
                            } else {
                                contactInfo = {
                                    ...contactInfo,
                                    phone: contactInfo.phone || extractedContactInfo.phone,
                                    phones: contactInfo.phones.length > 0 ? contactInfo.phones : extractedContactInfo.phones || [],
                                    email: contactInfo.email || extractedContactInfo.email,
                                    city: contactInfo.city || extractedContactInfo.city,
                                    address: contactInfo.address || extractedContactInfo.address
                                };
                            }
                            
                            // Extract products (only if metadata is missing or empty)
                            if (!liveProducts || liveProducts.length === 0) {
                                liveProducts = extractLiveProducts(html);
                            }
                        }
                    } catch (error) {
                        console.error('Error extracting metadata for old page:', error);
                    }
                }
                
                // 🎯 NOW: Define allProducts AFTER liveProducts are loaded
                const allProducts = [
                    ...(page.products || []),
                    ...(liveProducts || [])
                ];
                
                console.log(`📦 "${page.title}" has ${allProducts.length} total products (${page.products?.length || 0} metadata + ${liveProducts?.length || 0} live)`);
                
                // 🎯 REMOVED: excludeWords/requireWords - using dynamic relevance instead!
                
                // 🎯 SIMPLE: Check if products match ONLY the exact search words
                if (allProducts && allProducts.length > 0) {
                    let productMatches = 0;
                    
                    for (const product of allProducts) {
                        const productNameLower = (product.name || '').toLowerCase();
                        
                        // Check full search term
                        if (productNameLower.includes(searchTermLower)) {
                            productMatches += 30; // Very high score for exact match
                            console.log(`🎯 Product EXACT match: "${product.name}" contains "${searchTermLower}"`);
                        } else {
                            // Check individual words (e.g., "צעצוע", "בובה")
                            for (const word of searchTermWords) {
                                if (word.length < 2) continue;
                                const wordLower = word.toLowerCase();
                                
                                // Check exact match
                                if (productNameLower.includes(wordLower)) {
                                    productMatches += 15; // Good score for word match
                                    console.log(`🛍️ Product word match: "${product.name}" contains "${word}"`);
                                } else {
                                    // 🎯 NEW: Check partial match - remove plural suffixes
                                    let baseWord = wordLower;
                                    if (baseWord.endsWith('ים') && baseWord.length > 3) {
                                        baseWord = baseWord.substring(0, baseWord.length - 2);
                                        if (productNameLower.includes(baseWord)) {
                                            productMatches += 15; // Good score for partial match
                                            console.log(`🛍️ Product word match (partial): "${product.name}" contains "${baseWord}" (from "${word}")`);
                                        }
                                    } else if (baseWord.endsWith('ות') && baseWord.length > 3) {
                                        baseWord = baseWord.substring(0, baseWord.length - 2);
                                        if (productNameLower.includes(baseWord)) {
                                            productMatches += 15; // Good score for partial match
                                            console.log(`🛍️ Product word match (partial): "${product.name}" contains "${baseWord}" (from "${word}")`);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    if (productMatches > 0) {
                        matchScore += productMatches; // Bonus for relevant products
                        console.log(`✅ Page "${page.title}" has matching products, total product score: ${productMatches}, total matchScore: ${matchScore}`);
                    }
                }
                    
                    // 🎯 FIX: Check location if specified - CRITICAL: Must match exactly or exclude
                    let cityMatches = false; // Initialize cityMatches variable
                    
                    console.log(`🔍 Page "${page.title}" has city: "${contactInfo.city || 'unknown'}", required: "${requiredCity || 'none'}", matchScore so far: ${matchScore}`);
                    
                    if (requiredCity) {
                        const pageCityLower = (contactInfo.city || '').toLowerCase().trim();
                        const requiredCityLower = requiredCity.toLowerCase().trim();
                        
                        console.log(`🏙️ City check for "${page.title}": page city="${contactInfo.city || 'EMPTY'}", required="${requiredCity}"`);
                        
                        // 🎯 NEW APPROACH: Pages without city info get LOWER priority, but aren't excluded
                        // This way stores without city info can still appear if relevant
                        if (!pageCityLower || pageCityLower === '') {
                            console.log(`⚠️ "${page.title}" - NO CITY INFO (will have lower priority)`);
                            matchScore -= 20; // Penalty for missing city (but not excluded)
                            page.noCityInfo = true; // Flag for later sorting
                        } else {
                            // Check for exact match or partial match
                            cityMatches = pageCityLower === requiredCityLower || 
                                          pageCityLower.includes(requiredCityLower) || 
                                          requiredCityLower.includes(pageCityLower);
                            
                            // Always save the actual city from contact info
                            page.actualCity = contactInfo.city;
                            
                            if (cityMatches) {
                                matchScore += 50; // BIG bonus for matching location
                                console.log(`✅ City match: ${contactInfo.city} matches ${requiredCity}`);
                            } else {
                                // Wrong city - heavy penalty (but not excluded - might be relevant)
                                console.log(`⚠️ City mismatch: "${contactInfo.city}" ≠ "${requiredCity}" (heavy penalty)`);
                                matchScore -= 40; // Heavy penalty for wrong city
                                page.wrongCity = true;
                            }
                        }
                    } else if (isCityServiceQuery) {
                        // Even if city wasn't extracted before, try to match from contact info
                        const cityFromQuery = searchTerm.match(/(?:ב|בתוך|בשדה)\s*([א-ת]+)/);
                        if (cityFromQuery && cityFromQuery[1]) {
                            const requestedCity = cityFromQuery[1].trim().toLowerCase();
                            const pageCityLower = (contactInfo.city || '').toLowerCase().trim();
                            
                            cityMatches = pageCityLower && (pageCityLower === requestedCity || 
                                pageCityLower.includes(requestedCity) || 
                                requestedCity.includes(pageCityLower));
                            
                            if (cityMatches) {
                                matchScore += 50; // Big bonus
                                console.log(`📍 City match found: ${contactInfo.city} matches ${cityFromQuery[1]}`);
                            } else {
                                // 🎯 CRITICAL: If city was requested, EXCLUDE pages from wrong cities!
                                console.log(`🚫 EXCLUDED "${page.title}" - city "${contactInfo.city || 'לא ידוע'}" doesn't match required "${cityFromQuery[1]}"`);
                                continue; // Skip this page - wrong city
                            }
                        } else if (cityFromQuery && cityFromQuery[1] && !contactInfo.city) {
                            // 🎯 CRITICAL: If city was requested but page has no city info, EXCLUDE
                            console.log(`🚫 EXCLUDED "${page.title}" - city required "${cityFromQuery[1]}" but page has no city info`);
                            continue; // Skip this page - no city info
                        }
                    }
                    
                // Add live data to page
                            page.liveProducts = liveProducts;
                page.liveContactInfo = contactInfo;
                page.matchScore = matchScore;
                
                // 🎯 CRITICAL: ALWAYS check if page matches the search words!
                // Don't use a default "true" - make pages EARN their relevance!
                let serviceMatchesQuery = false; // Default: must prove relevance!
                
                // 🎯 CRITICAL: Define allSearchWords BEFORE if/else so it's available in both branches
                // Include expanded terms (synonyms) for better matching
                const allSearchWords = [...searchTermWords, ...smartExpansion, ...expandedTerms];
                
                // If there's a city in the query, extract the service part
                if (searchTermWithoutCity && searchTermWithoutCity.length > 0 && searchTermWithoutCity !== searchTerm) {
                    // There's a specific service/product in the query (e.g., "לק" from "לק בנתניה")
                    let serviceLower = searchTermWithoutCity.toLowerCase().trim();
                    
                    // 🎯 IMPROVED: Remove definite article "ה" from beginning (e.g., "הנגר" -> "נגר")
                    if (serviceLower.startsWith('ה') && serviceLower.length > 2) {
                        serviceLower = serviceLower.substring(1);
                        console.log(`🔧 Removed definite article: "${searchTermWithoutCity}" -> "${serviceLower}"`);
                    }
                    
                    // 🎯 NEW: Remove plural suffix "ים" or "ות" (e.g., "נגרים" -> "נגר", "מסעדות" -> "מסעד")
                    if (serviceLower.endsWith('ים') && serviceLower.length > 3) {
                        serviceLower = serviceLower.substring(0, serviceLower.length - 2);
                        console.log(`🔧 Removed plural suffix: "${searchTermWithoutCity}" -> "${serviceLower}"`);
                    } else if (serviceLower.endsWith('ות') && serviceLower.length > 3) {
                        serviceLower = serviceLower.substring(0, serviceLower.length - 2);
                        console.log(`🔧 Removed plural suffix: "${searchTermWithoutCity}" -> "${serviceLower}"`);
                    }
                    
                    // Check if page title, description, or products contain the service
                    console.log(`🔍 Checking service match for "${serviceLower}" against page "${page.title}"`);
                    console.log(`   titleLower: "${titleLower}"`);
                    console.log(`   descLower: "${descLower}"`);
                    console.log(`   serviceLower.includes in title: ${titleLower.includes(serviceLower)}`);
                    
                    // 🎯 IMPROVED: Check exact match first, then check partial match (remove plural suffixes)
                    let titleHasService = titleLower.includes(serviceLower);
                    if (!titleHasService) {
                        // Check word-by-word (for multi-word services)
                        titleHasService = serviceLower.split(/\s+/)
                            .filter(word => word && word.length > 1 && /[\u0590-\u05FF]/.test(word)) // Only Hebrew words with 2+ chars
                            .some(word => {
                                // Also remove "ה" from individual words
                                let cleanWord = word.startsWith('ה') && word.length > 2 ? word.substring(1) : word;
                                if (titleLower.includes(cleanWord)) {
                                    console.log(`   ✅ checking word "${cleanWord}" in title: true`);
                                    return true;
                                }
                                
                                // 🎯 NEW: Check partial match - remove plural suffixes
                                if (cleanWord.endsWith('ים') && cleanWord.length > 3) {
                                    const baseWord = cleanWord.substring(0, cleanWord.length - 2);
                                    if (titleLower.includes(baseWord)) {
                                        console.log(`   ✅ checking word "${baseWord}" (from "${cleanWord}") in title: true`);
                                        return true;
                                    }
                                } else if (cleanWord.endsWith('ות') && cleanWord.length > 3) {
                                    const baseWord = cleanWord.substring(0, cleanWord.length - 2);
                                    if (titleLower.includes(baseWord)) {
                                        console.log(`   ✅ checking word "${baseWord}" (from "${cleanWord}") in title: true`);
                                        return true;
                                    }
                                }
                                
                                return false;
                            });
                    } else {
                        console.log(`   ✅ title includes "${serviceLower}"`);
                    }
                    
                    let descHasService = descLower.includes(serviceLower);
                    if (!descHasService) {
                        // Check word-by-word (for multi-word services)
                        descHasService = serviceLower.split(/\s+/)
                            .filter(word => word && word.length > 1 && /[\u0590-\u05FF]/.test(word)) // Only Hebrew words with 2+ chars
                            .some(word => {
                                let cleanWord = word.startsWith('ה') && word.length > 2 ? word.substring(1) : word;
                                if (descLower.includes(cleanWord)) {
                                    return true;
                                }
                                
                                // 🎯 NEW: Check partial match - remove plural suffixes
                                if (cleanWord.endsWith('ים') && cleanWord.length > 3) {
                                    const baseWord = cleanWord.substring(0, cleanWord.length - 2);
                                    if (descLower.includes(baseWord)) {
                                        return true;
                                    }
                                } else if (cleanWord.endsWith('ות') && cleanWord.length > 3) {
                                    const baseWord = cleanWord.substring(0, cleanWord.length - 2);
                                    if (descLower.includes(baseWord)) {
                                        return true;
                                    }
                                }
                                
                                return false;
                            });
                    }
                    
                    // Check if products match the service (use allProducts - both metadata and live!)
                    // 🎯 IMPROVED: Check exact match first, then check partial match
                    let productsMatchService = allProducts && allProducts.length > 0 && 
                        allProducts.some(product => 
                            product.name && product.name.toLowerCase().includes(serviceLower)
                        );
                    
                    if (!productsMatchService && allProducts && allProducts.length > 0) {
                        // 🎯 NEW: Check partial match - remove plural suffixes
                        let baseService = serviceLower;
                        if (baseService.endsWith('ים') && baseService.length > 3) {
                            baseService = baseService.substring(0, baseService.length - 2);
                            productsMatchService = allProducts.some(product => 
                                product.name && product.name.toLowerCase().includes(baseService)
                            );
                        } else if (baseService.endsWith('ות') && baseService.length > 3) {
                            baseService = baseService.substring(0, baseService.length - 2);
                            productsMatchService = allProducts.some(product => 
                                product.name && product.name.toLowerCase().includes(baseService)
                            );
                        }
                    }
                    
                    // Service must match title, description, or products
                    serviceMatchesQuery = titleHasService || descHasService || productsMatchService;
                    
                    console.log(`🔍 Service match check for "${serviceLower}": title=${titleHasService}, desc=${descHasService}, products=${productsMatchService}, RESULT=${serviceMatchesQuery}`);
                    
                    if (!serviceMatchesQuery) {
                        console.log(`❌ Service doesn't match: page "${page.title}" doesn't contain "${serviceLower}" - EXCLUDING`);
                        continue; // Skip this page - it doesn't match the requested service
                    }
                } else {
                    // 🎯 NEW: No city in query - check if page matches ANY of the search words OR smart expansions
                    console.log(`\n🔍 ======== Checking "${page.title}" ========`);
                    console.log(`   Search words: [${searchTermWords.join(', ')}]`);
                    console.log(`   Smart expansions: [${smartExpansion.join(', ')}]`);
                    console.log(`   Title: "${page.title}"`);
                    console.log(`   Description: "${(page.description || '').substring(0, 50)}..."`);
                    console.log(`   Products count: ${allProducts.length}`);
                    console.log(`   ALL search words (original + expanded): [${allSearchWords.join(', ')}]`);
                    
                    const titleMatches = allSearchWords.some(word => {
                        if (word.length < 2) return false;
                        const wordLower = word.toLowerCase();
                        
                        // Check exact match
                        if (titleLowerForScore.includes(wordLower)) {
                            console.log(`   ✅ TITLE MATCH: "${word}" found in title`);
                            return true;
                        }
                        
                        // 🎯 NEW: Check partial match - remove plural suffixes
                        // "צעצועים" -> check "צעצוע", "שעונים" -> check "שעון"
                        let baseWord = wordLower;
                        if (baseWord.endsWith('ים') && baseWord.length > 3) {
                            baseWord = baseWord.substring(0, baseWord.length - 2);
                            if (titleLowerForScore.includes(baseWord)) {
                                console.log(`   ✅ TITLE MATCH (partial): "${word}" -> "${baseWord}" found in title`);
                                return true;
                            }
                        } else if (baseWord.endsWith('ות') && baseWord.length > 3) {
                            baseWord = baseWord.substring(0, baseWord.length - 2);
                            if (titleLowerForScore.includes(baseWord)) {
                                console.log(`   ✅ TITLE MATCH (partial): "${word}" -> "${baseWord}" found in title`);
                                return true;
                            }
                        }
                        
                        return false;
                    });
                    
                    const descMatches = allSearchWords.some(word => {
                        if (word.length < 2) return false;
                        const wordLower = word.toLowerCase();
                        
                        // Check exact match
                        if (descLowerForScore.includes(wordLower)) {
                            console.log(`   ✅ DESC MATCH: "${word}" found in description`);
                            return true;
                        }
                        
                        // 🎯 NEW: Check partial match - remove plural suffixes
                        let baseWord = wordLower;
                        if (baseWord.endsWith('ים') && baseWord.length > 3) {
                            baseWord = baseWord.substring(0, baseWord.length - 2);
                            if (descLowerForScore.includes(baseWord)) {
                                console.log(`   ✅ DESC MATCH (partial): "${word}" -> "${baseWord}" found in description`);
                                return true;
                            }
                        } else if (baseWord.endsWith('ות') && baseWord.length > 3) {
                            baseWord = baseWord.substring(0, baseWord.length - 2);
                            if (descLowerForScore.includes(baseWord)) {
                                console.log(`   ✅ DESC MATCH (partial): "${word}" -> "${baseWord}" found in description`);
                                return true;
                            }
                        }
                        
                        return false;
                    });
                    
                    let productsMatchWords = false;
                    if (allProducts && allProducts.length > 0) {
                        for (const word of allSearchWords) {
                            if (word.length < 2) continue;
                            const wordLower = word.toLowerCase();
                            
                            for (const product of allProducts) {
                                if (!product.name) continue;
                                const productNameLower = product.name.toLowerCase();
                                
                                // Check exact match
                                if (productNameLower.includes(wordLower)) {
                                    console.log(`   ✅ PRODUCT MATCH: "${word}" found in product "${product.name}"`);
                                    productsMatchWords = true;
                                    break;
                                }
                                
                                // 🎯 NEW: Check partial match - remove plural suffixes
                                let baseWord = wordLower;
                                if (baseWord.endsWith('ים') && baseWord.length > 3) {
                                    baseWord = baseWord.substring(0, baseWord.length - 2);
                                    if (productNameLower.includes(baseWord)) {
                                        console.log(`   ✅ PRODUCT MATCH (partial): "${word}" -> "${baseWord}" found in product "${product.name}"`);
                                        productsMatchWords = true;
                                        break;
                                    }
                                } else if (baseWord.endsWith('ות') && baseWord.length > 3) {
                                    baseWord = baseWord.substring(0, baseWord.length - 2);
                                    if (productNameLower.includes(baseWord)) {
                                        console.log(`   ✅ PRODUCT MATCH (partial): "${word}" -> "${baseWord}" found in product "${product.name}"`);
                                        productsMatchWords = true;
                                        break;
                                    }
                                }
                            }
                            if (productsMatchWords) break;
                        }
                    }
                    
                    serviceMatchesQuery = titleMatches || descMatches || productsMatchWords;
                    
                    // 🎯 Apply excludeWords filter (if we have smart keywords)
                    if (serviceMatchesQuery && excludeWords.length > 0) {
                        const hasExcludedWord = excludeWords.some(excludedWord => 
                            titleLowerForScore.includes(excludedWord.toLowerCase()) ||
                            descLowerForScore.includes(excludedWord.toLowerCase()) ||
                            (allProducts && allProducts.some(p => 
                                p.name && p.name.toLowerCase().includes(excludedWord.toLowerCase())
                            ))
                        );
                        
                        if (hasExcludedWord) {
                            console.log(`   🚫 EXCLUDED - contains excluded word from: [${excludeWords.join(', ')}]`);
                            serviceMatchesQuery = false;
                        }
                    }
                    
                    // 🎯 Apply requireWords filter (if we have smart keywords)
                    if (serviceMatchesQuery && requireWords.length > 0) {
                        const hasRequiredWord = requireWords.some(requiredWord => 
                            titleLowerForScore.includes(requiredWord.toLowerCase()) ||
                            descLowerForScore.includes(requiredWord.toLowerCase()) ||
                            (allProducts && allProducts.some(p => 
                                p.name && p.name.toLowerCase().includes(requiredWord.toLowerCase())
                            ))
                        );
                        
                        if (!hasRequiredWord) {
                            console.log(`   🚫 EXCLUDED - missing required word from: [${requireWords.join(', ')}]`);
                            serviceMatchesQuery = false;
                        }
                    }
                    
                    console.log(`   RESULT: title=${titleMatches}, desc=${descMatches}, products=${productsMatchWords}, INCLUDE=${serviceMatchesQuery}`);
                    
                    if (!serviceMatchesQuery) {
                        console.log(`   ❌ EXCLUDED - no match found or failed filters\n`);
                        continue; // Skip this page - it doesn't match the search
                    } else {
                        console.log(`   ✅ INCLUDED - match found and passed filters!\n`);
                    }
                }
                
                // 🎯 IMPROVED: Pages with wrong city get penalty, but aren't excluded
                // This allows fallback message "not found in X, but found in Y"
                // The penalty was already applied above
                
                // Only add to results if score is high enough OR if it has matching products
                // 🎯 CRITICAL: Check with partial matching (remove plural suffixes)
                const hasMatchingProducts = allProducts && allProducts.length > 0 && 
                    allSearchWords.some(word => {
                        if (word.length < 2) return false;
                        const wordLower = word.toLowerCase();
                        
                        // Check exact match
                        const exactMatch = allProducts.some(product => 
                            product.name && product.name.toLowerCase().includes(wordLower)
                        );
                        if (exactMatch) return true;
                        
                        // 🎯 NEW: Check partial match - remove plural suffixes
                        let baseWord = wordLower;
                        if (baseWord.endsWith('ים') && baseWord.length > 3) {
                            baseWord = baseWord.substring(0, baseWord.length - 2);
                            return allProducts.some(product => 
                                product.name && product.name.toLowerCase().includes(baseWord)
                            );
                        } else if (baseWord.endsWith('ות') && baseWord.length > 3) {
                            baseWord = baseWord.substring(0, baseWord.length - 2);
                            return allProducts.some(product => 
                                product.name && product.name.toLowerCase().includes(baseWord)
                            );
                        }
                        
                        return false;
                    });
                
                // 🎯 CRITICAL: Page is ONLY relevant if:
                // 1. serviceMatchesQuery is true (already checked title/desc/products with partial matching)
                // 2. matchScore > 0 (proves there's actual relevance from title/desc/products)
                // 🎯 FIX: If serviceMatchesQuery is true, it means we found a match (exact or partial) in title/desc/products
                // So we should include the page even if matchScore is 0 (because serviceMatchesQuery already proves relevance)
                // BUT: matchScore should also be > 0 if there's a match, so let's check both
                const shouldInclude = serviceMatchesQuery; // If serviceMatchesQuery is true, we found a match - include it!
                
                console.log(`🔍 [FINAL CHECK] "${page.title}":`, {
                    searchWords: searchTermWords,
                    smartExpansion: smartExpansion,
                    allSearchWords: allSearchWords,
                    serviceMatchesQuery,
                    matchScore,
                    shouldInclude
                });
                
                if (shouldInclude) {
                    // 🎯 IMPORTANT: Save city from contactInfo to page before adding to results
                    if (!page.actualCity && contactInfo && contactInfo.city) {
                        page.actualCity = contactInfo.city;
                        console.log(`💾 Saved city "${contactInfo.city}" for "${page.title}"`);
                    }
                    if (!page.city && contactInfo && contactInfo.city) {
                        page.city = contactInfo.city;
                    }
                    
                    results.push(page);
                    console.log(`✅ INCLUDED "${page.title}" - score: ${matchScore}, serviceMatch: ${serviceMatchesQuery}, city: ${page.actualCity || page.city || 'unknown'}`);
                } else {
                    if (matchScore === -1000) {
                        console.log(`🚫 EXCLUDED "${page.title}" - failed filter (score: ${matchScore})`);
                    } else if (!serviceMatchesQuery) {
                        console.log(`🚫 EXCLUDED "${page.title}" - NO MATCH in title/desc/products for words: [${allSearchWords.join(', ')}]`);
                    } else if (matchScore <= 0) {
                        console.log(`🚫 EXCLUDED "${page.title}" - score too low: ${matchScore} (needs > 0)`);
                    } else {
                        console.log(`🚫 EXCLUDED "${page.title}" - unknown reason (serviceMatch=${serviceMatchesQuery}, score=${matchScore})`);
                    }
                }
                } catch (error) {
                    console.error(`❌ Error processing page "${page?.title || 'unknown'}" - skipping:`, error);
                    continue; // Skip to next page
                }
            }
            
            // Sort by match score
            results.sort((a, b) => (b.matchScore || 0) - (a.matchScore || 0));
            
            // 🎯 NEW: Handle city-specific queries - if user searched for "X בY" and no results in Y
            // Show results from other cities with appropriate message
            if (requiredCity && results.length > 0) {
                // 🎯 CRITICAL: Filter out pages without city info OR with wrong city
                const resultsInRequestedCity = results.filter(page => !page.wrongCity && !page.noCityInfo);
                const resultsInOtherCities = results.filter(page => page.wrongCity);
                const resultsWithoutCity = results.filter(page => page.noCityInfo);
                
                console.log(`🏙️ City filter: ${resultsInRequestedCity.length} in ${requiredCity}, ${resultsInOtherCities.length} in other cities, ${resultsWithoutCity.length} without city info`);
                
                // 🔍 DEBUG: Show all results before filtering
                console.log('📋 All results BEFORE city filter:');
                results.forEach((page, i) => {
                    console.log(`  ${i+1}. ${page.title} - city: ${page.actualCity || 'unknown'}, wrongCity: ${page.wrongCity}, score: ${page.matchScore}`);
                });
                
                // 🎯 NEW LOGIC: Always show top result, even if from wrong city
                const topScore = results[0].matchScore;
                const topResult = results[0];
                
                if (resultsInRequestedCity.length === 0 && (resultsInOtherCities.length > 0 || resultsWithoutCity.length > 0)) {
                    // No results in requested city, but found in other cities
                    console.log(`⚠️ No results in ${requiredCity}, but found ${resultsInOtherCities.length} in other cities and ${resultsWithoutCity.length} without city`);
                    
                    // 🎯 Show stores from other cities/without city info with a message
                    // Mark them so the response generator can add appropriate message
                    results.forEach(page => {
                        page.notInRequestedCity = true;
                        page.requestedCity = requiredCity;
                    });
                    
                    // Return all results - the text generator will add "לא מצאתי בX אבל יש..."
                    console.log('📋 Returning results from OTHER cities/unknown cities');
                } else if (resultsInRequestedCity.length > 0) {
                    // Found results in requested city
                    const bestInRequestedCity = resultsInRequestedCity[0];
                    
                    // 🎯 If top result is from another city but MUCH better (score difference > 30), include it
                    if (topResult.wrongCity && topScore > bestInRequestedCity.matchScore + 30) {
                        console.log(`⭐ Top result "${topResult.title}" (score: ${topScore}) is from ${topResult.actualCity}, but much better than best in ${requiredCity} (score: ${bestInRequestedCity.matchScore})`);
                        console.log('📋 Including top result from other city at the beginning');
                        // Keep top result + results from requested city
                        results = [topResult, ...resultsInRequestedCity];
                        topResult.notInRequestedCity = true;
                        topResult.requestedCity = requiredCity;
                    } else {
                        // Filter to only requested city
                        results = resultsInRequestedCity;
                        console.log(`✅ Found ${resultsInRequestedCity.length} results in ${requiredCity}`);
                        console.log('📋 Results AFTER city filter (only in requested city):');
                        results.forEach((page, i) => {
                            console.log(`  ${i+1}. ${page.title} - city: ${page.actualCity || 'unknown'}, score: ${page.matchScore}`);
                        });
                    }
                }
            }
            
            // If there's a specific business name in query, filter to only exact matches or very high scores
            const lowerQuery = searchTerm.toLowerCase();
            const businessNamePattern = /(?:של|את|על|ב|בתוך|מה|איפה|היכן)\s+([א-ת]{2,})/;
            const businessMatch = searchTerm.match(businessNamePattern);
            
            if (businessMatch && businessMatch[1]) {
                const requestedBusiness = businessMatch[1].trim().toLowerCase();
                // Remove common words
                const cleanBusinessName = requestedBusiness.replace(/\b(של|את|על|ב|בתוך|מה|איפה|היכן|טלפון|כתובת|מייל|פרטים)\b/g, '').trim();
                
                if (cleanBusinessName.length >= 2) {
                    // Filter: keep only pages that match the business name OR have very high score
                    const filteredResults = results.filter(page => {
                        const titleMatch = page.title.toLowerCase().includes(cleanBusinessName);
                        const highScore = (page.matchScore || 0) >= 40;
                        return titleMatch || highScore;
                    });
                    
                    if (filteredResults.length > 0) {
                        console.log(`🎯 Filtered results from ${results.length} to ${filteredResults.length} for exact business: "${cleanBusinessName}"`);
                        return filteredResults;
                    }
                }
            }
            
            console.log(`🔍 Found ${results.length} pages (metadata search) for "${searchTerm}"`);
            
            // 🎯 STAGE 2: Load LIVE products from top matching pages for DEEP search
            // Only if we found some pages and it's a category search
            if (searchesForCategory && results.length > 0 && results.length <= 10) {
                try {
                    console.log(`🔍 STAGE 2: Deep product search - loading live products from ${Math.min(results.length, 5)} top pages...`);
                    
                    // Load live products from top 5 results
                    const pagesToDeepSearch = results.slice(0, 5);
                    for (const page of pagesToDeepSearch) {
                        if (page.pageType === 'store') {
                            try {
                                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                const response = await fetch(pageUrl);
                                if (response.ok) {
                                    const html = await response.text();
                                    const liveProducts = extractLiveProducts(html);
                                    page.liveProducts = liveProducts; // Store on page object
                                
                                // 🎯 BOOST score if products match search terms
                                for (const product of liveProducts) {
                                    const productNameLower = (product.name || '').toLowerCase();
                                    
                                    // Check full variations
                                    for (const variation of searchVariations) {
                                        if (productNameLower.includes(variation.toLowerCase())) {
                                            page.matchScore = (page.matchScore || 0) + 20; // BIG boost
                                            console.log(`✅ Product "${product.name}" matches "${variation}" - boosted score to ${page.matchScore}`);
                                            break;
                                        }
                                    }
                                    
                                    // 🎯 ALSO check individual words (e.g., "בובה" matches "בובת פרווה חמודה")
                                    const searchWords = searchTerm.split(/\s+/).filter(w => w.length > 2);
                                    for (const word of searchWords) {
                                        if (productNameLower.includes(word.toLowerCase())) {
                                            page.matchScore = (page.matchScore || 0) + 10; // Good boost
                                            console.log(`✅ Product "${product.name}" contains word "${word}" - boosted score to ${page.matchScore}`);
                                        }
                                    }
                                }
                                
                                console.log(`🛒 Loaded ${liveProducts.length} live products from "${page.title}" (score: ${page.matchScore})`);
                            }
                        } catch (error) {
                            console.log(`⚠️ Failed to load live products for "${page.title}":`, error.message);
                        }
                    }
                }
                
                // Re-sort by updated scores
                results.sort((a, b) => (b.matchScore || 0) - (a.matchScore || 0));
                console.log(`🔍 STAGE 2 complete - re-sorted ${results.length} pages by updated scores`);
                } catch (stage2Error) {
                    console.error('❌ Error in Stage 2 (deep product search):', stage2Error);
                    console.log('⚠️ Continuing with Stage 1 results only');
                    // Don't throw - just continue with Stage 1 results
                }
            }
            
            // 💾 Save the search category for future context (e.g., when user says "בחדרה" next)
            // Extract category from searchTerm (remove city if present)
            if (searchTerm && results.length > 0) {
                let category = searchTerm.toLowerCase().trim();
                // Remove common city patterns like "ב[עיר]"
                category = category.replace(/\s*ב[א-ת]+\s*$/g, '').trim();
                // Remove "ה" prefix
                if (category.startsWith('ה') && category.length > 2) {
                    category = category.substring(1);
                }
                // Only save if it looks like a real category (not just a city)
                if (category.length >= 2 && category.length <= 30) {
                    if (window.stavConversationContext) {
                        window.stavConversationContext.lastSearchCategory = category;
                        console.log(`💾 Saved search category for context: "${category}"`);
                    }
                }
            }
            
            return results;
            } catch (error) {
                console.error('❌❌❌ CRITICAL ERROR in searchLivePages:', error);
                console.error('❌ Error stack:', error.stack);
                console.error('❌ Error message:', error.message);
                console.error('❌ Query was:', query);
                return []; // Return empty array on error
            }
        }
        
        // Extract live description from HTML
        function extractLiveDescription(html) {
            console.log('📝 Extracting description from HTML');
            
            // Try to extract from meta description tag
            const metaDescMatch = html.match(/<meta[^>]*name=["']description["'][^>]*content=["']([^"']{10,300})["']/i);
            if (metaDescMatch && metaDescMatch[1]) {
                const desc = metaDescMatch[1].trim();
                console.log('📝 Found meta description:', desc);
                return desc;
            }
            
            // Try to extract from og:description
            const ogDescMatch = html.match(/<meta[^>]*property=["']og:description["'][^>]*content=["']([^"']{10,300})["']/i);
            if (ogDescMatch && ogDescMatch[1]) {
                const desc = ogDescMatch[1].trim();
                console.log('📝 Found og:description:', desc);
                return desc;
            }
            
            // Try to extract from first paragraph after h1
            const h1Match = html.match(/<h1[^>]*>.*?<\/h1>\s*<p[^>]*>([^<]{20,300})<\/p>/is);
            if (h1Match && h1Match[1]) {
                const desc = h1Match[1].trim().replace(/<[^>]+>/g, '');
                console.log('📝 Found description from first paragraph:', desc);
                return desc;
            }
            
            // Try to extract from any paragraph with class containing "desc" or "about"
            const descParagraphMatch = html.match(/<p[^>]*class=["'][^"']*(?:desc|about|intro)[^"']*["'][^>]*>([^<]{20,300})<\/p>/i);
            if (descParagraphMatch && descParagraphMatch[1]) {
                const desc = descParagraphMatch[1].trim().replace(/<[^>]+>/g, '');
                console.log('📝 Found description from paragraph class:', desc);
                return desc;
            }
            
            // Try to extract from ANY paragraph after header/hero section
            const anyParagraphMatch = html.match(/<(?:header|section|div)[^>]*>[\s\S]*?<p[^>]*>([^<]{30,300})<\/p>/i);
            if (anyParagraphMatch && anyParagraphMatch[1]) {
                const desc = anyParagraphMatch[1].trim().replace(/<[^>]+>/g, '');
                // Make sure it's not navigation or footer text
                if (!desc.match(/זכויות|אודות|צור קשר|תפריט|עלינו|home|about|contact/i)) {
                    console.log('📝 Found description from any paragraph:', desc);
                    return desc;
                }
            }
            
            // Try to extract from h2 or h3 that looks like a description
            const h2Match = html.match(/<h2[^>]*>([^<]{20,300})<\/h2>/i);
            if (h2Match && h2Match[1]) {
                const desc = h2Match[1].trim();
                // Make sure it's descriptive text, not a title
                if (desc.length > 30 && !desc.match(/^[\u0590-\u05FF\s]{2,15}$/)) {
                    console.log('📝 Found description from h2:', desc);
                    return desc;
                }
            }
            
            console.log('⚠️ No description found in HTML');
            return '';
        }
        
        // Extract live contact info from HTML
        function extractLiveContactInfo(html) {
            const contactInfo = {};
            
            console.log('📞 Extracting contact info from HTML');
            
            // Extract phone numbers - SIMPLE approach like email extraction
            // Search entire HTML for Israeli phone number patterns (just like email does)
            const phonePatterns = [
                // International format (+972)
                /\+972[\s\-\)]?\s*5[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /\+972[\s\-\)]?\s*7[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /\+972[\s\-\)]?\s*5[0-9][\s\-]?\d{7}/g,
                // Standard Israeli format (05X/07X) - various separators
                /0?5[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /0?7[0-9][\s\-]?\d{3}[\s\-]?\d{4}/g,
                /0?5[0-9][\s\-]?\d{7}/g,
                /0?7[0-9][\s\-]?\d{7}/g,
                // Dotted formats: 0X2.XXX.XXXX or similar
                /0[57]\d(?:[\.\s\-]?\d){8}/g
            ];
            
            let foundPhones = [];
            let contactAreaPhones = []; // Phones found in contact/footer areas (higher priority)
            const phoneScores = new Map(); // normalizedPhone -> score
            
            // First: Search in contact/footer areas specifically (higher priority)
            const contactAreaPattern = /<(?:section|div|footer)[^>]*(?:class|id)="[^"]*(?:contact|footer|info|details)[^"]*"[^>]*>([\s\S]{500,3000})<\/[^>]+>/gi;
            const contactAreas = [...html.matchAll(contactAreaPattern)];
            
            contactAreas.forEach(areaMatch => {
                const areaHtml = areaMatch[1];
                // Boost any phone found in contact area
                phonePatterns.forEach(pattern => {
                    const matches = areaHtml.match(pattern);
                    if (matches) {
                        matches.forEach(match => {
                            let phone = match.replace(/[\s\-\(\)\.]/g, '');
                            if (phone.startsWith('+972')) {
                                phone = phone.replace('+972', '0');
                            }
                            if (phone.length === 9 && (phone.startsWith('5') || phone.startsWith('7'))) {
                                phone = '0' + phone;
                            }
                            if (phone.length === 10 && phone.startsWith('0') && (phone[1] === '5' || phone[1] === '7')) {
                                const isValidPhone = phone.match(/^0[57][0-9]{8}$/);
                                if (isValidPhone && !phone.match(/^0+$/) && phone !== '0500000000' && phone !== '0700000000') {
                                    const formatted = `${phone.substring(0, 3)}-${phone.substring(3, 6)}-${phone.substring(6)}`;
                                    if (!contactAreaPhones.includes(formatted)) {
                                        contactAreaPhones.push(formatted);
                                        console.log('📞 Found phone (contact area):', formatted);
                                    }
                                    // score boost for contact area
                                    phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 5);
                                }
                            }
                        });
                    }
                });
                // Boost phones in tel: links inside contact area
                const telLinks = [...areaHtml.matchAll(/href\s*=\s*"tel:([^"'>\s]+)/gi)];
                telLinks.forEach(t => {
                    let raw = t[1] || '';
                    raw = decodeURIComponent(raw);
                    let phone = raw.replace(/[^0-9\+]/g, '').replace(/^\+972/, '0');
                    if (phone.length === 9 && (phone.startsWith('5') || phone.startsWith('7'))) phone = '0' + phone;
                    if (/^0[57]\d{8}$/.test(phone)) {
                        const formatted = `${phone.substring(0, 3)}-${phone.substring(3, 6)}-${phone.substring(6)}`;
                        phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 6); // higher weight for explicit tel link
                        if (!contactAreaPhones.includes(formatted)) contactAreaPhones.push(formatted);
                    }
                });
            });
            
            // Then: Search entire HTML for phone numbers (like email - simple and direct!)
            phonePatterns.forEach(pattern => {
                const matches = html.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        let phone = match.replace(/[\s\-\(\)\.]/g, '');
                        if (phone.startsWith('+972')) {
                            phone = phone.replace('+972', '0');
                        }
                        if (phone.length === 9 && (phone.startsWith('5') || phone.startsWith('7'))) {
                            phone = '0' + phone;
                        }
                        if (phone.length === 10 && phone.startsWith('0') && (phone[1] === '5' || phone[1] === '7')) {
                            const isValidPhone = phone.match(/^0[57][0-9]{8}$/);
                            if (isValidPhone && !phone.match(/^0+$/) && phone !== '0500000000' && phone !== '0700000000') {
                                const formatted = `${phone.substring(0, 3)}-${phone.substring(3, 6)}-${phone.substring(6)}`;
                                if (!foundPhones.includes(formatted)) {
                                    foundPhones.push(formatted);
                                    console.log('📞 Found phone:', formatted, 'from pattern:', pattern);
                                }
                                // base score for any appearance
                                phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 1);
                            }
                        }
                    });
                }
            });

            // Boost phones that are near the word "טלפון" or "Phone"
            const proximityMatches = [...html.matchAll(/טלפון[:\s\-]*([^<\n]{0,60})/gi)];
            proximityMatches.forEach(pm => {
                const seg = (pm[1] || '').toString();
                const hits = seg.match(/0[57]\d[\d\s\-\.]{7,}/g) || [];
                hits.forEach(h => {
                    let normalized = h.replace(/[^0-9]/g, '');
                    if (normalized.length === 9 && (normalized.startsWith('5') || normalized.startsWith('7'))) normalized = '0' + normalized;
                    if (/^0[57]\d{8}$/.test(normalized)) {
                        const formatted = `${normalized.substring(0, 3)}-${normalized.substring(3, 6)}-${normalized.substring(6)}`;
                        phoneScores.set(formatted, (phoneScores.get(formatted) || 0) + 3);
                    }
                });
            });
            
            // Prefer phones from contact areas, but fallback to any phone found
            const allPhones = [...contactAreaPhones, ...foundPhones.filter(p => !contactAreaPhones.includes(p))];
            
            if (allPhones.length > 0) {
                // Filter out phones that look like placeholders
                const validPhones = allPhones.filter(phone => {
                    const digits = phone.replace(/-/g, '');
                    const firstDigit = digits[0];
                    const isAllSame = digits.split('').every(d => d === firstDigit);
                    const isPlaceholder = phone.includes('000-000') || phone.includes('111-111') || phone.includes('123-456');
                    return !isAllSame && !isPlaceholder;
                });
                
                if (validPhones.length > 0) {
                    // Rank by score (desc), then by contact-area preference ordering
                    const ranked = [...new Set(validPhones)]
                        .map(p => ({ phone: p, score: phoneScores.get(p) || 0, inContact: contactAreaPhones.includes(p) }))
                        .sort((a, b) => (b.score - a.score) || (b.inContact - a.inContact));
                    contactInfo.phones = ranked.map(r => r.phone);
                    contactInfo.phone = contactInfo.phones[0]; // Primary best-scored
                    console.log('✅ Using phone(s):', validPhones, '(found', allPhones.length, 'total,', contactAreaPhones.length, 'from contact areas)');
                } else if (allPhones.length > 0) {
                    contactInfo.phones = allPhones;
                    contactInfo.phone = allPhones[0];
                    console.log('⚠️ Using phone (fallback):', contactInfo.phone);
                }
            }
            
            // Extract email - SIMPLE approach (search entire HTML)
            const emailMatch = html.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
            if (emailMatch) {
                contactInfo.email = emailMatch[1];
                console.log('📧 Found email:', contactInfo.email);
            }
            
            // Extract address and city (look for common address patterns) - expanded list
            const cities = [
                'תל אביב', 'ירושלים', 'חיפה', 'באר שבע', 'נתניה', 'אשדוד', 'רמת גן', 'פתח תקווה', 
                'בני ברק', 'חולון', 'רחובות', 'כפר סבא', 'אילת', 'רעננה', 'הרצליה', 'חדרה', 
                'קריית ביאליק', 'קריית מוצקין', 'ראשון לציון', 'נהריה', 'הוד השרון', 'גבעתיים', 
                'קריית אתא', 'קריית שמונה', 'בית שאן', 'עפולה'
            ];
            
            // Try exact match first
            for (const city of cities) {
                const cityRegex = new RegExp(city, 'g');
                if (html.match(cityRegex)) {
                    contactInfo.city = city;
                    console.log('🏙️ Found city (exact):', contactInfo.city);
                    break;
                }
            }
            
                // 🎯 IMPROVED: Extract city from page metadata FIRST (title/description)
                // This allows business owners to specify city in their business description without Contact section
                if (!contactInfo.city && (page.title || page.description)) {
                    const titleAndDesc = `${page.title || ''} ${page.description || ''}`.toLowerCase();
                    const knownCities = [
                        'תל אביב', 'ירושלים', 'חיפה', 'באר שבע', 'נתניה', 'אשדוד', 'רמת גן', 'פתח תקווה', 
                        'בני ברק', 'חולון', 'רחובות', 'כפר סבא', 'אילת', 'רעננה', 'הרצליה', 'חדרה', 
                        'קריית ביאליק', 'קריית מוצקין', 'ראשון לציון', 'נהריה', 'הוד השרון', 'גבעתיים', 
                        'קריית אתא', 'קריית שמונה', 'בית שאן', 'עפולה', 'מעלות', 'נצרת', 'עכו', 'טבריה',
                        'צפת', 'קרית גת', 'דימונה', 'אופקים', 'נתיבות', 'קרית מלאכי', 'קרית שמונה',
                        'קרית ארבע', 'בית שמש', 'מודיעין', 'לוד', 'רמלה', 'יבנה', 'גדרה', 'קרית עקרון'
                    ];
                    
                    // Check title and description for city names
                    for (const city of knownCities) {
                        if (titleAndDesc.includes(city.toLowerCase())) {
                            contactInfo.city = city;
                            console.log('🏙️ Found city in title/description:', contactInfo.city);
                            break;
                        }
                    }
                }
                
                // 🎯 FIX: Improve city extraction - use known cities list for accuracy
                if (!contactInfo.city) {
                    // List of common Israeli cities for accurate matching
                    const knownCities = [
                        'תל אביב', 'ירושלים', 'חיפה', 'באר שבע', 'נתניה', 'אשדוד', 'רמת גן', 'פתח תקווה', 
                        'בני ברק', 'חולון', 'רחובות', 'כפר סבא', 'אילת', 'רעננה', 'הרצליה', 'חדרה', 
                        'קריית ביאליק', 'קריית מוצקין', 'ראשון לציון', 'נהריה', 'הוד השרון', 'גבעתיים', 
                        'קריית אתא', 'קריית שמונה', 'בית שאן', 'עפולה', 'מעלות', 'נצרת', 'עכו', 'טבריה',
                        'צפת', 'קרית גת', 'דימונה', 'אופקים', 'נתיבות', 'קרית מלאכי', 'קרית שמונה',
                        'קרית ארבע', 'בית שמש', 'מודיעין', 'לוד', 'רמלה', 'יבנה', 'גדרה', 'קרית עקרון'
                    ];
                
                // Search for cities in contact info areas first (more reliable)
                const contactAreaPattern = /<(?:section|div|footer)[^>]*(?:class|id)="[^"]*(?:contact|footer|info|details)[^"]*"[^>]*>([\s\S]{500,3000})<\/[^>]+>/gi;
                const contactAreas = [...html.matchAll(contactAreaPattern)];
                
                // Check in contact areas first
                for (const areaMatch of contactAreas) {
                    const areaHtml = areaMatch[1].toLowerCase();
                    for (const city of knownCities) {
                        if (areaHtml.includes(city.toLowerCase())) {
                            contactInfo.city = city;
                            console.log('🏙️ Found city in contact area:', contactInfo.city);
                            break;
                        }
                    }
                    if (contactInfo.city) break;
                }
                
                // If not found in contact area, search entire HTML for known cities
                if (!contactInfo.city) {
                    const htmlLower = html.toLowerCase();
                    const citiesFound = [];
                    for (const city of knownCities) {
                        if (htmlLower.includes(city.toLowerCase())) {
                            citiesFound.push(city);
                            if (!contactInfo.city) {
                                contactInfo.city = city;
                                console.log('🏙️ Found city in HTML:', contactInfo.city);
                            }
                        }
                    }
                    if (citiesFound.length > 1) {
                        console.log('⚠️ Multiple cities found in HTML:', citiesFound.join(', '), '- using first:', contactInfo.city);
                    }
                }
                
                // Last resort: try pattern matching (but be more strict)
                if (!contactInfo.city) {
                    const cityPattern = /(?:ב|בתוך|בין|על|ליד|קרוב\s+ל)\s*([א-ת]{2,15})/gi;
                    const matches = [...html.matchAll(cityPattern)];
                    if (matches.length > 0) {
                        for (const match of matches) {
                            const potentialCity = match[1].trim();
                            // Check if it matches a known city
                            for (const city of knownCities) {
                                if (city.toLowerCase().includes(potentialCity.toLowerCase()) || 
                                    potentialCity.toLowerCase().includes(city.toLowerCase())) {
                                    contactInfo.city = city;
                                    console.log('🏙️ Found city by pattern:', contactInfo.city);
                                    break;
                                }
                            }
                            if (contactInfo.city) break;
                        }
                    }
                }
            }
            
            // Extract address - FIRST try navigation button links (Google Maps / Waze)
            // Users add address to navigation buttons, this is the most accurate source
            const navigationButtonPatterns = [
                // Google Maps: href="https://www.google.com/maps?q=..." or href="https://maps.google.com/?q=..."
                /href\s*=\s*["']https?:\/\/(?:www\.)?(?:maps\.)?google\.com\/maps[^"']*q=([^"'\&]+)/gi,
                /href\s*=\s*["']https?:\/\/(?:www\.)?(?:maps\.)?google\.com\/maps[^"']*daddr=([^"'\&]+)/gi,
                // Waze: href="https://waze.com/ul?q=..." or href="https://www.waze.com/ul?q=..."
                /href\s*=\s*["']https?:\/\/(?:www\.)?waze\.com\/ul[^"']*q=([^"'\&]+)/gi,
                /href\s*=\s*["']https?:\/\/(?:www\.)?waze\.com\/ul[^"']*ll=([^"'\&]+)/gi,
                // General navigation link with address in text
                /<a[^>]*href\s*=\s*["'](?:https?:\/\/(?:maps|waze))[^"']*["'][^>]*>([^<]{10,100})<\/a>/gi
            ];
            
            for (const pattern of navigationButtonPatterns) {
                const matches = [...html.matchAll(pattern)];
                if (matches && matches.length > 0) {
                    for (const match of matches) {
                        if (match[1]) {
                            // Decode URL-encoded address
                            let address = decodeURIComponent(match[1].trim());
                            // Clean up address
                            address = address.replace(/\+/g, ' ').replace(/%20/g, ' ').replace(/\s+/g, ' ').trim();
                            // Check if it looks like a real address (contains Hebrew/English, not just coordinates)
                            if (address.length > 5 && (address.match(/[א-ת]/) || address.match(/[a-zA-Z]/))) {
                                // Prioritize addresses with street names
                                if (address.match(/רחוב|street|st\./i) || address.match(/\d+/)) {
                                    contactInfo.address = address;
                                    console.log('📍 Found address from navigation button:', contactInfo.address);
                                    break;
                                } else if (!contactInfo.address) {
                                    // Use this as fallback if no street address found yet
                                    contactInfo.address = address;
                                    console.log('📍 Found address from navigation button (fallback):', contactInfo.address);
                                }
                            }
                        }
                    }
                    if (contactInfo.address) break;
                }
            }
            
            // If no address from navigation button, try text patterns
            if (!contactInfo.address) {
                const addressPatterns = [
                    /([א-ת\s]+,\s*רחוב\s+[א-ת\s\d]+)/g,
                    /([א-ת\s]+,\s*[א-ת\s\d]+\s+\d+)/g,
                    /(רחוב\s+[א-ת\s\d]+,\s*[א-ת\s]+)/g,
                    /כתובת[:\s]*([^<\n]{5,80})/gi
                ];
                
                for (const pattern of addressPatterns) {
                    const matches = html.match(pattern);
                    if (matches && matches[0]) {
                        let address = matches[0].replace(/כתובת[:\s]*/gi, '').trim();
                        if (address.length > 5) {
                            contactInfo.address = address;
                            console.log('📍 Found address from text pattern:', contactInfo.address);
                            break;
                        }
                    }
                }
            }
            
            return contactInfo;
        }
        
        // Extract live products from HTML - ONLY REAL PRODUCTS, NO INVENTIONS
        function extractLiveProducts(html) {
            const products = [];
            
            console.log('🔍 Marketplace extractLiveProducts called, HTML length:', html.length);
            
            // ⛔ STRICT EXCLUSIONS - דברים שהם בוודאות לא מוצרים!
            // Get page title and h1 to exclude them from products (they're not products!)
            const pageTitleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
            const pageH1Match = html.match(/<h1[^>]*>([^<]{3,80})<\/h1>/i);
            const pageTitle = pageTitleMatch ? pageTitleMatch[1].trim() : '';
            const pageH1 = pageH1Match ? pageH1Match[1].trim() : '';
            
            const excludePatterns = [
                'נגישות', 'אודות', 'צור קשר', 'דף הבית', 'עלינו', 'תקנון', 'מדיניות', 
                'פרטיות', 'תנאים', 'שירות', 'משלוחים', 'החזרות', 'איך להזמין',
                'גלרי', 'המוצרים', 'תיאור', 'המיוחדים', 'הכל על', 'כל הזכויות',
                'זכויות יוצרים', 'ברוכים הבאים', 'לקוחות', 'שאלות', 'תשובות',
                'מוצרים שלנו', 'המוצרים שלנו', 'תפריט', 'כותרת', 'כותרת ראשית',
                'למה', 'למה לבחור', 'למה לבחור ב', 'למה לבחור ברובוטים', // 🎯 FIX: Exclude question-style text
                'איך', 'איך ל', 'כיצד', 'מדוע', 'מה היתרונות', 'מה היתרון',
                // 🎯 NEW: Exclude accessibility/design options that are NOT real products
                'ניגודיות', 'גופן', 'קריא', 'הדגש', 'קישורים', 'ריווח', 'שורות', 
                'מוגבר', 'סמן', 'גדול', 'עצור', 'אנימציות', 'תצוגה', 'גדלה',
                'גדלת', 'קטנה', 'קטנת', 'גופן גדול', 'גופן קטן', 'ניגודיות גבוהה',
                'ניגודיות נמוכה', 'גופן קריא', 'גופן גדול', 'גופן קטן',
                pageTitle, pageH1 // Exclude page title and main h1
            ].filter(Boolean); // Remove empty strings
            
            // ⛔ EXCLUDE common non-product words from product names
            const excludeFromName = [
                '₪', 'שקל', 'ש"ח', 'מחיר', 'מחירים', 'מחירון', 'משכורת',
                'טלפון', 'מייל', 'אימייל', 'כתובת', 'עיר', 'ישראל', 'ישראל',
                'שנה', 'חודש', 'יום', 'שעה', 'דקה', 'שנייה',
                'אומנות', 'זמן', 'חיים', 'חיים', 'חוויה', 'חוויות',
                'טוהר', 'יופי', 'איכות', 'השראה', 'חלום', 'אמת', 'נשמה',
                'יעילות', 'חסרת', 'תקדים', 'תקדימים', // 🎯 FIX: Exclude descriptive text like "יעילות חסרת תקדים"
                'ביצועים', 'ביצוע', 'תכונה', 'תכונות', 'יתרון', 'יתרונות',
                'מקצועיות', 'מהירות', 'אמינות', 'סטיגנס', 'סטגנס', 'סטגנל'
            ];
            
            // ⛔ EXCLUDE phrases that are clearly NOT products (taglines, mottos, inspirational text, questions, descriptions)
            const excludePhrases = [
                /זמן\s+(זו|זה)\s+אומנות/,
                /.*אומנות.*/,
                /.*חוויה.*/,
                /.*סטגנס.*/,
                /.*מושלם.*/,
                /^טוהר$/,
                /^יופי$/,
                /^איכות$/,
                /^השראה$/,
                /^חלום$/,
                /^אמת$/,
                /^נשמה$/,
                /^למה.*/, // 🎯 FIX: Exclude questions like "למה לבחור ב..."
                /.*למה.*בחור.*/, // 🎯 FIX: Exclude "למה לבחור ב..." patterns
                /.*למה.*רובוט.*/, // 🎯 FIX: Exclude "למה לבחור ברובוטים..."
                /.*\?$/, // 🎯 FIX: Exclude text ending with question mark (likely a title/question, not product)
                /יעילות\s+(חסרת|חסר).*/, // 🎯 FIX: Exclude "יעילות חסרת תקדים"
                /יעילות.*תקדים/, // 🎯 FIX: Exclude "יעילות חסרת תקדים"
                /.*יעילות.*/, // 🎯 FIX: Exclude descriptive text like "יעילות"
                /.*ביצועים.*/, // 🎯 FIX: Exclude "ביצועים" (performance, not a product)
                /.*תכונה.*/, // 🎯 FIX: Exclude "תכונה" (feature, not a product)
                /.*יתרון.*/, // 🎯 FIX: Exclude "יתרון" (advantage, not a product)
                /.*מקצועיות.*/, // 🎯 FIX: Exclude "מקצועיות" (professionalism, not a product)
                /.*מהירות.*/, // 🎯 FIX: Exclude "מהירות" (speed, not a product)
                /.*אמינות.*/, // 🎯 FIX: Exclude "אמינות" (reliability, not a product)
                // 🎯 NEW: Exclude accessibility/design options that are NOT real products
                /^ניגודיות\s+(גבוהה|נמוכה|מוגברת)$/i,
                /^גופן\s+(קריא|גדול|קטן|מוגבר)$/i,
                /^הדגש\s+קישורים$/i,
                /^ריווח\s+שורות\s+מוגבר$/i,
                /^סמן\s+גדול$/i,
                /^עצור\s+אנימציות$/i,
                /^תצוגה\s+(גדלה|קטנה)$/i,
                /^ניגודיות\s+גבוהה$/i,
                /^גופן\s+קריא$/i,
            ];
            
            // 🎯 Look for products - try multiple strategies for different page structures
            // Strategy 1: Look for product-card elements (common in RED and other stores)
            const productCardPattern = /<div[^>]*class="[^"]*product-card[^"]*"[^>]*>([\s\S]{50,2000})<\/div>/gi;
            const productCardMatches = [...html.matchAll(productCardPattern)];
            
            if (productCardMatches.length > 0) {
                console.log('✅ Found product-card elements:', productCardMatches.length);
                
                productCardMatches.forEach(cardMatch => {
                    const cardHtml = cardMatch[1];
                    
                    // Look for product name - try multiple strategies
                    let nameMatch = null;
                    
                    // Priority 1: h3.product-name or h4.product-name
                    nameMatch = cardHtml.match(/<h[1-6][^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/h[1-6]>/i);
                    
                    // Priority 2: any h3 or h4 (common in stores)
                        if (!nameMatch) {
                        const hMatches = cardHtml.match(/<h[34][^>]*>([^<]{3,100})<\/h[34]>/gi);
                        if (hMatches && hMatches.length > 0) {
                            // Take the first one that looks like a product name
                            for (const hMatch of hMatches) {
                                const text = hMatch.replace(/<[^>]*>/g, '').trim();
                                if (text.length >= 3 && text.length <= 100 && text.match(/[א-ת]/)) {
                                    nameMatch = [null, text];
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Priority 3: any element with class product-name (span, div, p, etc.)
                    if (!nameMatch) {
                        nameMatch = cardHtml.match(/<[^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/[^>]+>/i);
                    }
                    
                    // Priority 4: Look for text that's clearly a product name (standalone text in card)
                    if (!nameMatch) {
                        // Remove HTML tags and find meaningful text blocks
                        const textOnly = cardHtml.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                        const words = textOnly.split(/\s+/);
                        if (words.length >= 2 && words.length <= 10) {
                            // Check if it looks like product name (not price, not button text)
                            const potentialName = words.slice(0, 5).join(' ');
                            if (potentialName.match(/[א-ת]/) && !potentialName.includes('₪') && 
                                !potentialName.includes('הוסף') && !potentialName.includes('עגלה') &&
                                potentialName.length >= 3 && potentialName.length <= 50) {
                                nameMatch = [null, potentialName];
                            }
                        }
                    }
                    
                    // Look for price - try multiple strategies
                    let priceMatch = null;
                    
                    // Priority 1: element with class product-price
                    priceMatch = cardHtml.match(/<[^>]*class="[^"]*product-price[^"]*"[^>]*>.*?₪\s*(\d+(?:[.,]\d+)?)/i);
                    
                    // Priority 2: any ₪ symbol with number in the card (most common)
                        if (!priceMatch) {
                        priceMatch = cardHtml.match(/₪\s*(\d+(?:[.,]\d+)?)|(\d+(?:[.,]\d+)?)\s*₪/);
                    }
                    
                    // Priority 3: Look for number patterns that look like prices (4 digits or more, possibly with comma)
                    if (!priceMatch) {
                        priceMatch = cardHtml.match(/(\d{1,3}(?:,\d{3})+(?:\.\d+)?)/); // e.g., 1,500 or 1,500.00
                        }
                        
                        if (nameMatch && priceMatch) {
                        const name = nameMatch[1].replace(/<[^>]*>/g, '').trim(); // Remove any HTML tags
                        let priceText = priceMatch[1] || priceMatch[2];
                        
                        // Additional validation: ensure price is actually in the same card context
                        const nameIndex = cardHtml.indexOf(nameMatch[0] || nameMatch.input);
                        const priceIndex = cardHtml.indexOf(priceMatch[0]);
                        
                        // Name and price must be reasonably close in the card (within 800 chars)
                        const distance = Math.abs((nameIndex || 0) - (priceIndex || 0));
                        if (distance > 800 && nameIndex !== -1 && priceIndex !== -1) {
                            console.log(`   ⚠️ Skipping - name and price too far apart in card (${distance} chars)`);
                            return; // Skip this card - name and price not related
                        }
                        
                        // Clean price: remove commas and spaces, handle formats like 1,500
                        priceText = priceText.replace(/[,\s]/g, '');
                        const price = parseFloat(priceText);
                        
                        // STRICT validation
                            const isExcluded = excludePatterns.some(pattern => 
                                name.toLowerCase().includes(pattern.toLowerCase())
                            );
                            
                        const hasExcludedWords = excludeFromName.some(ex => name.includes(ex));
                        
                        // Check if name matches excluded phrases (taglines, mottos)
                        const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                        
                        // 🎯 FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        // Only accept prices >= 10 (real product prices like ₪10, ₪60, ₪75)
                        const isValidPrice = price >= 10 && price < 100000 && !isNaN(price);
                        // Exclude single words that are likely taglines/mottos (too short to be a real product name)
                        const isSingleWord = name.trim().split(/\s+/).length === 1;
                        const isShortTagline = isSingleWord && name.length <= 8 && !name.match(/[0-9]/);
                        const isValidName = name.length >= 3 && name.length <= 100 && 
                                           name.match(/[א-ת]/) && 
                                           !name.match(/^[0-9\s-]+$/) &&
                                           !name.includes('₪') &&
                                           !name.includes('!') && // Exclude taglines that end with !
                                           !matchesExcludedPhrase &&
                                           !isShortTagline; // Exclude single short words that are likely taglines
                        
                        if (!isExcluded && !hasExcludedWords && !matchesExcludedPhrase && isValidName && isValidPrice) {
                            // Check for duplicates
                            const isDuplicate = products.some(p => p.name.toLowerCase() === name.toLowerCase());
                            if (!isDuplicate) {
                                products.push({ name, price });
                                console.log(`   ✅ VALID product-card: "${name}" - ₪${price}`);
                            }
                        } else {
                            console.log(`   ❌ EXCLUDED product-card: "${name}" - ₪${price} (isExcluded: ${isExcluded}, hasExcluded: ${hasExcludedWords}, validName: ${isValidName}, validPrice: ${isValidPrice})`);
                        }
                    } else {
                        if (!nameMatch) console.log(`   ⚠️ No name found in product-card`);
                        if (!priceMatch) console.log(`   ⚠️ No price found in product-card`);
                    }
                });
            }
            
            // Strategy 2: Look for ANY div with product-like classes or patterns
            // 🎯 FIX: More comprehensive search for product containers
            const productContainerPatterns = [
                /<div[^>]*(?:class|id)="[^"]*(?:product-grid|product-gallery|store-items|gallery|products|main-content|container|grid|flex|items)[^"]*"[^>]*>([\s\S]*?)<\/div>/gi,
                /<section[^>]*(?:class|id)="[^"]*(?:products|store|gallery|main)[^"]*"[^>]*>([\s\S]*?)<\/section>/gi,
                /<main[^>]*>([\s\S]*?)<\/main>/gi
            ];
            
            let allContentSections = [];
            productContainerPatterns.forEach(pattern => {
                const matches = [...html.matchAll(pattern)];
                matches.forEach(match => {
                    if (match[1] && match[1].length > 100) { // Only add meaningful sections
                        allContentSections.push(match[1]);
                    }
                });
            });
            
            // If no specific sections found, use entire body/main content
            if (allContentSections.length === 0) {
                const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
                if (bodyMatch) {
                    allContentSections.push(bodyMatch[1]);
                }
            }
            
            console.log(`✅ Found ${allContentSections.length} content sections to search`);
            
            allContentSections.forEach((sectionHtml, sectionIndex) => {
                console.log(`🔍 Searching section ${sectionIndex + 1} (${sectionHtml.length} chars)`);
                
                // Strategy 2a: Look for product items with price patterns
                // 🎯 FIX: Look for patterns like: <h2>Product Name</h2>...<p class="product-price">₪XX</p>
                const productPatternWithPrice = /(?:<h[2-6][^>]*>([^<]{3,80})<\/h[2-6]>|<[^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,80})<\/[^>]+>)[\s\S]{0,500}?₪\s*(\d+(?:[.,]\d+)?)/gi;
                const productMatches = [...sectionHtml.matchAll(productPatternWithPrice)];
                
                productMatches.forEach(productMatch => {
                    const name = (productMatch[1] || productMatch[2] || '').trim();
                    const priceText = (productMatch[3] || '').replace(/[,\s]/g, '');
                    const price = parseFloat(priceText);
                    
                    if (name && name.length >= 3 && name.length <= 80 && 
                        !name.includes('₪') && !name.includes('הוסף') && !name.includes('עגלה') &&
                        price > 0 && price < 100000 && !isNaN(price) &&
                        name.match(/[א-ת]/)) {
                        // Check exclusions
                        const isExcluded = excludePatterns.some(pattern => 
                            name.toLowerCase().includes(pattern.toLowerCase())
                        );
                        const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                        const isDuplicate = products.some(p => p.name.toLowerCase() === name.toLowerCase());
                        
                        if (!isExcluded && !matchesExcludedPhrase && !isDuplicate) {
                            products.push({ name, price });
                            console.log(`   ✅ Found product (pattern with price): "${name}" - ₪${price}`);
                        }
                    }
                });
            });
            
            // Strategy 2b: Original gallery search (keep for backward compatibility)
            const galleryPattern = /<div[^>]*(?:class|id)="[^"]*(?:product-grid|product-gallery|store-items|gallery|products|main-content|container)[^"]*"[^>]*>([\s\S]*?)<\/div>/gi;
            const galleryMatches = [...html.matchAll(galleryPattern)];
            
            if (galleryMatches.length > 0) {
                console.log('✅ Found product gallery/content sections:', galleryMatches.length);
                
                galleryMatches.forEach(galleryMatch => {
                    const gallery = galleryMatch[0];
                    
                    // Look for product items inside gallery - try multiple patterns
                    const itemPatterns = [
                        /<div[^>]*class="[^"]*(?:product-item|product-card|gallery-item|store-item)[^"]*"[^>]*>([\s\S]{50,2000})<\/div>/gi,
                        /<div[^>]*id="[^"]*product[^"]*"[^>]*>([\s\S]{50,2000})<\/div>/gi,
                        /<article[^>]*>([\s\S]{50,2000})<\/article>/gi, // Some stores use article tags
                        /<section[^>]*class="[^"]*product[^"]*"[^>]*>([\s\S]{50,2000})<\/section>/gi
                    ];
                    
                    itemPatterns.forEach(pattern => {
                        const itemMatches = [...gallery.matchAll(pattern)];
                        
                        itemMatches.forEach(itemMatch => {
                            const itemHtml = itemMatch[1];
                            
                            // Extract product name - comprehensive search
                            let nameMatch = itemHtml.match(/<h[1-6][^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/h[1-6]>/i);
                    if (!nameMatch) {
                                const hMatches = itemHtml.match(/<h[34][^>]*>([^<]{3,100})<\/h[34]>/gi);
                                if (hMatches && hMatches.length > 0) {
                                    for (const hMatch of hMatches) {
                                        const text = hMatch.replace(/<[^>]*>/g, '').trim();
                                        if (text.length >= 3 && text.length <= 100 && text.match(/[א-ת]/) &&
                                            !text.includes('₪') && !text.includes('הוסף')) {
                                            nameMatch = [null, text];
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!nameMatch) {
                                nameMatch = itemHtml.match(/<[^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]{3,100})<\/[^>]+>/i);
                            }
                            
                            // Extract price - comprehensive search
                            let priceMatch = itemHtml.match(/<[^>]*class="[^"]*product-price[^"]*"[^>]*>.*?₪\s*(\d+(?:[.,]\d+)?)/i);
                    if (!priceMatch) {
                                priceMatch = itemHtml.match(/₪\s*(\d+(?:[.,]\d+)?)|(\d+(?:[.,]\d+)?)\s*₪/);
                            }
                            if (!priceMatch) {
                                priceMatch = itemHtml.match(/(\d{1,3}(?:,\d{3})+(?:\.\d+)?)/); // Formats like 1,500
                    }
                    
                    if (nameMatch && priceMatch) {
                                const name = nameMatch[1].replace(/<[^>]*>/g, '').trim();
                                let priceText = priceMatch[1] || priceMatch[2];
                                // Clean price: remove commas, spaces
                                priceText = priceText.replace(/[,\s]/g, '');
                                const price = parseFloat(priceText);
                        
                        const isExcluded = excludePatterns.some(pattern => 
                            name.toLowerCase().includes(pattern.toLowerCase())
                        );
                                const hasExcludedWords = excludeFromName.some(ex => name.includes(ex));
                                const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                                // 🎯 FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        // Only accept prices >= 10 (real product prices like ₪10, ₪60, ₪75)
                        const isValidPrice = price >= 10 && price < 100000 && !isNaN(price);
                                const isSingleWord = name.trim().split(/\s+/).length === 1;
                                const isShortTagline = isSingleWord && name.length <= 8 && !name.match(/[0-9]/);
                                const isValidName = name.length >= 3 && name.length <= 100 && 
                                                   name.match(/[א-ת]/) && 
                                                   !name.match(/^[0-9\s-]+$/) &&
                                                   !name.includes('!') &&
                                                   !matchesExcludedPhrase &&
                                                   !isShortTagline;
                                
                                if (!isExcluded && !hasExcludedWords && !matchesExcludedPhrase && isValidName && isValidPrice) {
                                    // Check if not duplicate
                                    const isDuplicate = products.some(p => p.name.toLowerCase() === name.toLowerCase());
                                    if (!isDuplicate) {
                            products.push({ name, price });
                                        console.log(`   ✅ VALID gallery product: "${name}" - ₪${price}`);
                                    }
                                }
                            }
                        });
                    });
                });
            }
            
            // Strategy 3: Direct search for product patterns (ALWAYS try, even if we found some)
            // This helps find products that might be in different structures
            console.log(`⚠️ Found ${products.length} products so far, trying additional patterns...`);
            
            // Strategy 3: Look for patterns where h2-h6 appears near a price (within same structural block)
            // 🎯 FIX: More comprehensive search for product blocks
            // Look for ANY block that contains both a product name AND a price
            const blockPatterns = [
                /<(?:div|section|article|li)[^>]*>([\s\S]{30,3000})<\/(?:div|section|article|li)>/gi,
                /<article[^>]*>([\s\S]{30,3000})<\/article>/gi,
                /<li[^>]*>([\s\S]{30,3000})<\/li>/gi
            ];
            
            let allBlocks = [];
            blockPatterns.forEach(pattern => {
                const matches = [...html.matchAll(pattern)];
                matches.forEach(match => {
                    if (match[1] && match[1].length >= 30 && match[1].length <= 3000) {
                        // Only add if it contains Hebrew and potential price
                        // 🎯 FIX: Must catch single digit prices like ₪10 (change \d{2,} to \d{1,})
                        if (match[1].match(/[א-ת]/) && match[1].match(/₪|\d{1,}/)) {
                            allBlocks.push(match[1]);
                        }
                    }
                });
            });
            
            console.log(`🔍 Scanning ${allBlocks.length} blocks for additional products...`);
            
            allBlocks.forEach((blockHtml, blockIndex) => {
                // Skip if block is too generic (navigation, header, footer)
                if (blockHtml.includes('nav') || blockHtml.includes('header') || 
                    blockHtml.includes('footer') || blockHtml.includes('תפריט') ||
                    blockHtml.includes('menu') || blockHtml.includes('navigation')) {
                    return;
                }
                
                // 🎯 FIX: Look for product names in multiple patterns
                // Priority 1: h2-h6 with Hebrew text (potential product name)
                // ⚠️ EXCLUDE h1 - it's usually the page title, not a product!
                let nameMatches = blockHtml.match(/<h[2-6][^>]*>([^<]{3,80})<\/h[2-6]>/gi) || [];
                
                // Priority 2: strong, b, span, p with product-like text
                if (nameMatches.length === 0) {
                    const strongMatches = blockHtml.match(/<(?:strong|b)[^>]*>([^<]{4,60})<\/(?:strong|b)>/gi);
                    if (strongMatches) {
                        strongMatches.forEach(match => {
                            const text = match.replace(/<[^>]*>/g, '').trim();
                            if (text.match(/[א-ת]{4,}/) && !text.includes('₪') && !text.includes('הוסף') && text.length >= 4 && text.length <= 60) {
                                nameMatches.push(`<h3>${text}</h3>`); // Treat as name
                            }
                        });
                    }
                }
                
                // Priority 3: Look for text in divs/spans that could be product names
                if (nameMatches.length === 0) {
                    const textMatches = blockHtml.match(/<(?:p|span|div)[^>]*class="[^"]*[^"]*"[^>]*>([^<]{4,60})<\/(?:p|span|div)>/gi);
                    if (textMatches) {
                        textMatches.forEach(textMatch => {
                            const text = textMatch.replace(/<[^>]*>/g, '').trim();
                            // Check if it looks like a product name (Hebrew, not price, not button)
                            if (text.match(/[א-ת]{4,}/) && !text.includes('₪') && !text.includes('הוסף') && 
                                !text.includes('עגלה') && !text.match(/^\d+$/) && // Not just numbers
                                text.length >= 4 && text.length <= 60 &&
                                !excludePatterns.some(pattern => text.toLowerCase().includes(pattern.toLowerCase()))) {
                                nameMatches.push(`<h3>${text}</h3>`); // Treat as name
                            }
                        });
                    }
                }
                if (nameMatches.length === 0) {
                    // Also try p, span, strong with product-like text
                    const textMatches = blockHtml.match(/<(?:p|span|strong|b)[^>]*>([^<]{4,60})<\/(?:p|span|strong|b)>/gi);
                    if (textMatches) {
                        // Check if any look like product names
                        textMatches.forEach(textMatch => {
                            const text = textMatch.replace(/<[^>]*>/g, '').trim();
                            if (text.match(/[א-ת]{4,}/) && !text.includes('₪') && !text.includes('הוסף')) {
                                nameMatches.push(`<h3>${text}</h3>`); // Treat as name
                            }
                        });
                    }
                }
                
                if (!nameMatches || nameMatches.length === 0) return;
                
                nameMatches.forEach(nameMatch => {
                    const nameText = nameMatch.replace(/<[^>]*>/g, '').trim();
                    
                    // Check if this is the page title or h1 (not a product!)
                    const isPageTitle = pageTitle && nameText.toLowerCase() === pageTitle.toLowerCase();
                    const isPageH1 = pageH1 && nameText.toLowerCase() === pageH1.toLowerCase();
                    
                    // Check excluded phrases
                    const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(nameText));
                    
                    // Check if name looks valid (Hebrew, not excluded, not page title, not tagline)
                    const isSingleWord = nameText.trim().split(/\s+/).length === 1;
                    const isShortTagline = isSingleWord && nameText.length <= 8 && !nameText.match(/[0-9]/);
                    const isValidName = !isPageTitle && !isPageH1 && !matchesExcludedPhrase && !isShortTagline &&
                                       nameText.length >= 3 && nameText.length <= 80 && 
                                       nameText.match(/[א-ת]/) && 
                                       !nameText.match(/^[0-9\s-]+$/) &&
                                       !nameText.includes('!') &&
                                       !excludePatterns.some(pattern => 
                                           nameText.toLowerCase().includes(pattern.toLowerCase())
                                       ) &&
                                       !excludeFromName.some(ex => nameText.includes(ex));
                    
                    if (!isValidName) return;
                    
                    // 🎯 FIX: Look for price in the SAME block (must be nearby) - improved pattern
                    // Must catch low prices like ₪10, ₪60, ₪75, ₪85, ₪90!
                    const pricePatterns = [
                        /₪\s*(\d{1,4}(?:,\d{3})*)/,  // ₪1,500 or ₪1500 or ₪10
                        /(\d{1,4}(?:,\d{3})*)\s*₪/,  // 1,500₪ or 10₪
                        /₪\s*(\d{1,6})/,                  // ₪720 or ₪10 (must catch single digits!)
                        /(\d{1,6})/,                   // 720, 1500, 10 (standalone number - must catch single digits!)
                    ];
                    
                    let priceMatch = null;
                    for (const pattern of pricePatterns) {
                        priceMatch = blockHtml.match(pattern);
                        if (priceMatch && priceMatch[1]) {
                            const testPrice = parseFloat(priceMatch[1].replace(/[,\s]/g, ''));
                            // 🎯 FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                            // (e.g., "יעילות חסרת תקדים - ₪2" - the 2 is probably part of text, not a product price)
                            // Only accept prices >= 10 (real product prices like ₪10, ₪60, ₪75)
                            if (testPrice >= 10 && testPrice < 50000) { // Reasonable price range (includes small prices like 10!)
                                break;
                            }
                            priceMatch = null;
                        }
                    }
                    
                    if (priceMatch) {
                        let priceText = priceMatch[1];
                        priceText = priceText.replace(/[,\s]/g, '');
                        const price = parseFloat(priceText);
                        
                        // Additional validation: price must be reasonable and in the same block as name
                        const nameIndex = blockHtml.indexOf(nameMatch);
                        const priceIndex = blockHtml.indexOf(priceMatch[0]);
                        const distance = Math.abs(nameIndex - priceIndex);
                        
                        // 🎯 FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        // (e.g., "יעילות חסרת תקדים - ₪2" - the price 2 is probably not a product price)
                        // Only accept prices >= 10 (real product prices like ₪10, ₪60, ₪75)
                        const isValidPriceValue = price >= 10 && price < 50000;
                        
                        // 🎯 FIX: Allow low prices like 10, 60, 75, 85, 90 (not just >50!)
                        // Price must be within 800 chars of name (increased from 500 to catch more products)
                        // But exclude very low prices (2, 3, 5, 7) that are likely not product prices
                        if (isValidPriceValue && !isNaN(price) && distance < 800) {
                            // Check if not duplicate and not already found
                            const isDuplicate = products.some(p => p.name.toLowerCase() === nameText.toLowerCase());
                            if (!isDuplicate) {
                                products.push({ name: nameText, price });
                                console.log(`   ✅ VALID additional product: "${nameText}" - ₪${price} (distance: ${distance})`);
                            }
                        }
                    }
                });
            });
            
            // Remove duplicates
            const uniqueProducts = [];
            const seenNames = new Set();
            products.forEach(p => {
                if (!seenNames.has(p.name.toLowerCase())) {
                    seenNames.add(p.name.toLowerCase());
                    uniqueProducts.push(p);
                }
            });
            
            console.log(`✅ Marketplace extractLiveProducts found ${uniqueProducts.length} REAL products:`, uniqueProducts);
            return uniqueProducts;
        }
        
        // Shared smart search function (Same as Stav bot) - ENHANCED WITH AUTO-RELOAD
        async function handleSharedSmartSearch(message, allPages) {
            const lowerMessage = message.toLowerCase();
            
            // Handle greetings and personal questions - NO FIXED MESSAGES
            if (lowerMessage.includes('שלום') || lowerMessage.includes('היי') || lowerMessage.includes('הי') || 
                lowerMessage.includes('שמי') || lowerMessage.includes('קוראים לי') || lowerMessage.includes('אני') ||
                lowerMessage.includes('מה שלומך') || lowerMessage.includes('איך אתה') || lowerMessage.includes('איך את')) {
                return null; // Send to N8N instead of fixed message
            }
            
            // Handle knowledge questions - send to N8N
            if (lowerMessage.includes('מה גודל') || lowerMessage.includes('מה זה') || lowerMessage.includes('איך') || 
                lowerMessage.includes('מתי') || lowerMessage.includes('איפה') || lowerMessage.includes('למה') ||
                lowerMessage.includes('כמה') || lowerMessage.includes('מי') || lowerMessage.includes('איזה')) {
                return null; // Send to N8N for general knowledge questions
            }
            
            // Only search for pages if user is specifically looking for something
            if (!lowerMessage.includes('מתנה') && !lowerMessage.includes('לק') && !lowerMessage.includes('שעון') && !lowerMessage.includes('צעצוע') && !lowerMessage.includes('קורס') && !lowerMessage.includes('חנות') && !lowerMessage.includes('שירות') && !lowerMessage.includes('אירוע') && !lowerMessage.includes('מחיר') && !lowerMessage.includes('כמה') && !lowerMessage.includes('עולה') && !lowerMessage.includes('₪') && !lowerMessage.includes('שקל') && !lowerMessage.includes('הכי זול') && !lowerMessage.includes('הכי יקר') && !lowerMessage.includes('השוואה') && !lowerMessage.includes('נגיד') && !lowerMessage.includes('ולק') && !lowerMessage.includes('ושעון') && !lowerMessage.includes('וצעצוע') && !lowerMessage.includes('צעצועים') && !lowerMessage.includes('שעונים')) {
                // For other general questions, send to N8N
                return null;
            }
            
            // Search for pages with live content - ALWAYS get fresh data
            const liveResults = await searchLivePages(message);
            if (liveResults.length > 0) {
                let response = `מצאתי ${liveResults.length} דפים רלוונטיים:\n\n`;
                liveResults.forEach(page => {
                    response += `🏪 **${page.title}**\n`;
                    if (page.description) {
                        response += `${page.description}\n`;
                    }
                    
                    // Show live product data if available
                    if (page.liveProducts && page.liveProducts.length > 0) {
                        response += `💰 מוצרים חיים:\n`;
                        page.liveProducts.forEach(product => {
                            response += `• ${product.name} - ₪${product.price}\n`;
                        });
                    }
                    
                    response += `🔗 [צפה בדף](/users/${page.userId}/${page.pageId}_html)\n\n`;
                });
                return { message: response, action: { type: 'none' } };
            }
            
            return null;
        }
        
        // Replace the original sendAIMessage with enhanced version
        window.sendAIMessage = sendAIMessageEnhanced;
        
        // Allow Enter key in chat input
        document.getElementById('aiChatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendAIMessage();
            }
        });
        
        // Go to full app function
        function goToFullApp() {
            window.location.href = '/';
        }

        // === STAV CHAT FUNCTIONS ===
        // 🎯 FIX: Make toggleStavChat available globally
        window.toggleStavChat = function toggleStavChat() {
            const chatWindow = document.getElementById('stavChatWindow');
            chatWindow.classList.toggle('active');
            if (chatWindow.classList.contains('active')) {
                document.getElementById('stavChatInput').focus();
            }
        }

        // Process Stav message with REAL data search
        async function processStavMessage(userMessage, allPages) {
            try {
                console.log('🔍 Processing Stav message with REAL data:', userMessage);
                
                // 🎯 FIX: Convert plural to singular BEFORE processing
                // "צעצועים" → "צעצוע", "שעונים" → "שעון"
                const pluralToSingular = {
                    'צעצועים': 'צעצוע',
                    'שעונים': 'שעון',
                    'משחקים': 'משחק',
                    'בובות': 'בובה',
                    'מכוניות': 'מכונית'
                };
                
                for (const [plural, singular] of Object.entries(pluralToSingular)) {
                    if (userMessage.includes(plural)) {
                        userMessage = userMessage.replace(plural, singular);
                        console.log(`🔄 [EARLY FIX] Converted "${plural}" → "${singular}" in query`);
                    }
                }
                
                const lowerMessage = userMessage.toLowerCase().trim();
                
                // 🎯 Check if user is asking to see website/link/page
                const userWantsLink = /תראה.*אתר|תראה.*דף|תראי.*אתר|תראי.*דף|הראה.*אתר|לראות.*אתר|אפשר.*אתר|קישור|פתח.*אתר|לינק|link|אתר.*של|לדף.*של|פתיחת.*אתר|תראו.*אתר|הצג.*אתר/i.test(userMessage);
                
                // 🎯 NEW: Check if user is responding "yes" to previous "want to see website?" question
                // (e.g., "כן", "תראה", "בטח", "אשמח", "הראה", "אשמח לפרטים על X", "רוצה לפתוח")
                let userSaysYes = /^(כן|בטח|אשמח|yes|ok|אוקיי)$/i.test(userMessage.trim()) || 
                                  /אשמח לפרטים|רוצה פרטים|תן פרטים|פרטים נוספים|רוצה לפתוח|אני רוצה לפתוח/i.test(userMessage);
                
                // 🎯 SPECIAL: If user says "אשמח לפרטים על X" where X is in current context, treat as "yes"
                if (!userSaysYes && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    const pageNamesInContext = window.stavCurrentPages.map(p => p.title?.toLowerCase()).filter(Boolean);
                    const hasPageNameInMessage = pageNamesInContext.some(pageName => 
                        userMessage.toLowerCase().includes(pageName) && 
                        /פרטים|מידע|טלפון|כתובת/i.test(userMessage)
                    );
                    if (hasPageNameInMessage) {
                        console.log('✅ User asking for details about page in context - treating as YES');
                        userSaysYes = true;
                    }
                }
                
                const userSaysYesToPreview = window.stavCurrentPages && window.stavCurrentPages.length > 0 && 
                    /^(כן|תראה|תראי|בטח|אשמח|הראה|הראי|בוא|פתח|yes|ok|אוקיי)$/i.test(userMessage.trim());
                
                console.log(`🔍 [LINK CHECK] userMessage: "${userMessage}"`);
                console.log(`🔍 [LINK CHECK] userSaysYes: ${userSaysYes}`);
                console.log(`🔍 [LINK CHECK] userWantsLink: ${userWantsLink}`);
                console.log(`🔍 [LINK CHECK] userSaysYesToPreview: ${userSaysYesToPreview}`);
                console.log(`🔍 [LINK CHECK] window.stavCurrentPages: ${window.stavCurrentPages?.length || 0} pages`);
                
                // 🎯 NEW: If user chose a specific option by number or word (e.g., "1", "2", "ראשון", "שני")
                if (window.stavCurrentPages && window.stavCurrentPages.length > 1) {
                    let selectedIndex = -1;
                    
                    // Check for number (1, 2, 3...)
                    const numberMatch = userMessage.trim().match(/^(\d+)$/);
                    if (numberMatch) {
                        selectedIndex = parseInt(numberMatch[1], 10) - 1; // Convert to 0-based index
                    }
                    
                    // Check for Hebrew ordinal words
                    const hebrewOrdinals = {
                        'ראשון': 0, 'ראשונה': 0, 'אחד': 0,
                        'שני': 1, 'שניה': 1, 'שתיים': 1,
                        'שלישי': 2, 'שלישית': 2, 'שלוש': 2,
                        'רביעי': 3, 'רביעית': 3, 'ארבע': 3,
                        'חמישי': 4, 'חמישית': 4, 'חמש': 4,
                        'שישי': 5, 'שישית': 5, 'שש': 5,
                        'שביעי': 6, 'שביעית': 6, 'שבע': 6,
                        'שמיני': 7, 'שמינית': 7, 'שמונה': 7,
                        'תשיעי': 8, 'תשיעית': 8, 'תשע': 8,
                        'עשירי': 9, 'עשירית': 9, 'עשר': 9
                    };
                    
                    for (const [word, index] of Object.entries(hebrewOrdinals)) {
                        if (userMessage.trim() === word || userMessage.includes(word)) {
                            selectedIndex = index;
                            break;
                        }
                    }
                    
                    // If valid selection, show that specific page
                    if (selectedIndex >= 0 && selectedIndex < window.stavCurrentPages.length) {
                        console.log(`✅ User selected option ${selectedIndex + 1} - showing page`);
                        const selectedPage = window.stavCurrentPages[selectedIndex];
                        
                        // Build message with LIVE description - will be fetched when displaying
                        // For now, just pass the page and let the display function fetch the description
                        return {
                            type: 'pages',
                            pages: [selectedPage], // Only the selected page
                            message: `בבקשה, הנה הדף של ${selectedPage.title}`, // Description will be added during display
                            includeLinks: false, // 🎯 NO links - just iframe
                            needsPreview: true // Show iframe preview
                        };
                    }
                    
                    // 🎯 NEW: Check if user mentioned a page name (e.g., "יניב צעצוע")
                    const lowerUserMessage = userMessage.toLowerCase().trim();
                    for (let i = 0; i < window.stavCurrentPages.length; i++) {
                        const page = window.stavCurrentPages[i];
                        const pageNameLower = (page.title || '').toLowerCase();
                        
                        // Check if user message contains the page name
                        if (lowerUserMessage.includes(pageNameLower) || pageNameLower.includes(lowerUserMessage)) {
                            console.log(`✅ User mentioned page name "${page.title}" - showing page`);
                            return {
                                type: 'pages',
                                pages: [page],
                                message: `בבקשה, הנה הדף של ${page.title}`,
                                includeLinks: false, // 🎯 NO links - just iframe
                                needsPreview: true // Show iframe preview
                            };
                        }
                    }
                }
                
                // 🎯 NEW: If user says "כן" (yes) and we have pages in context, show PAGE (not just contact info)
                if (userSaysYes && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    console.log('✅ User said YES - showing PAGE for pages in context');
                    
                    // Show the page with iframe ONLY (no link)
                    return { 
                        type: 'pages', 
                        pages: window.stavCurrentPages,
                        message: window.stavCurrentPages.length === 1 
                            ? `בבקשה, הנה הדף של ${window.stavCurrentPages[0].title}` 
                            : `הנה ${window.stavCurrentPages.length} הדפים:`,
                        includeLinks: false, // 🎯 NO links - just iframe
                        needsPreview: true // Show iframe preview in chat
                    };
                }
                
                // If user wants link OR says yes to preview, check if we have pages in context
                if ((userWantsLink || userSaysYesToPreview) && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    console.log('🔗 ✅ User EXPLICITLY wants link/preview - showing pages with PREVIEW + LINKS');
                    
                    // 🎯 IMPROVED: Show both preview AND links when user explicitly asks
                    return { 
                        type: 'pages', 
                        pages: window.stavCurrentPages,
                        message: window.stavCurrentPages.length === 1 
                            ? `הנה דף ${window.stavCurrentPages[0].title}:` 
                            : `הנה ${window.stavCurrentPages.length} הדפים:`,
                        includeLinks: true, // Show links
                        needsPreview: true // Show iframe preview in chat
                    };
                } else {
                    console.log('ℹ️ User did NOT request to see page - NO preview will be shown');
                }
                
                // 🎯 SMART: Check if it's a marketplace query
                // 1. Starts with search words ("מחפש", "רוצה", etc.)
                // 2. Single/short word that's likely a product (3-15 chars, not a greeting)
                const searchPrefixes = ['מחפש', 'מחפשת', 'רוצה', 'איפה', 'יש', 'מוכרים', 'חנות', 'עסק', 'שירות', 'מחיר'];
                const hasSearchPrefix = searchPrefixes.some(prefix => lowerMessage.startsWith(prefix) || lowerMessage.includes(` ${prefix} `));
                
                // If it's a short query (3-20 chars) and not a greeting, treat as product search
                const greetings = ['שלום', 'היי', 'הי', 'מה שלומך', 'תודה', 'ביי', 'להתראות'];
                const isGreeting = greetings.some(g => lowerMessage.includes(g));
                const trimmedQuery = lowerMessage.trim();
                const isShortProductQuery = !isGreeting && trimmedQuery.length >= 3 && trimmedQuery.length <= 30 && !trimmedQuery.includes('?');
                
                const mentionsProduct = hasSearchPrefix || isShortProductQuery;
                
                // If user mentions a product category, treat as marketplace query (even with "יש?" or "ו" prefix)
                if (mentionsProduct) {
                    console.log('🎯 Product category mentioned - treating as marketplace query:', lowerMessage);
                    // Continue to marketplace search below (don't return null to N8N)
                }
                
                // Handle greetings and small talk - return null to send to N8N (already defined above)
                
                // Handle questions about bot itself or general chat
                const botQuestions = ['מה שלומך', 'איך את', 'מי את', 'מה את', 'מה אתה', 'מי אתה'];
                const isBotQuestion = botQuestions.some(q => lowerMessage.includes(q));
                
                // Handle self-introduction (e.g., "אני יניב", "אני ציפי", "שמי דוד", "קוראים לי שירה")
                const selfIntroPatterns = [
                    /^אני\s+[א-ת]+/,
                    /^שמי\s+[א-ת]+/,
                    /^קוראים\s+לי\s+[א-ת]+/,
                    /^השם\s+שלי\s+[א-ת]+/,
                    /^אני\s+ה[א-ת]+/
                ];
                const isSelfIntro = selfIntroPatterns.some(pattern => pattern.test(userMessage.trim()));
                
                // Handle general knowledge questions (like "מה גודל הודו", "איך ל...", etc.)
                const generalKnowledgePatterns = [
                    /^מה\s+(גודל|שטח|אוכלוסיה|אורך|רוחב|גובה|עומק|משקל|טמפרטורה|מהירות|מרחק)/,
                    /^(איך\s+ל|כיצד\s+ל|מדריך|תהליך|שלבים)/,
                    /^(מה\s+זה|מה\s+פירוש|מה\s+משמעות)/,
                    /^(מתי\s+הוקם|מתי\s+נוסד|מתי\s+נבנה|תאריך|שנה)/,
                    /^(למה|מדוע|מאיזה\s+סיבה)/
                ];
                const isGeneralKnowledge = generalKnowledgePatterns.some(pattern => pattern.test(userMessage.trim()));
                
                // Handle general questions that don't need page previews (price info, statistics, etc.)
                const generalInfoPatterns = [
                    /(?:יודעת|מה|איזה|כמה)\s*(?:מחיר|מחירים)/,
                    /מה\s+(המוצר|המוצרים)\s*(?:הכי|ה)?\s*(?:זול|יקר|טוב)/,
                    /(?:כמה|מה)\s*(?:נותני|מספקי|בעלי)\s*(?:שרות|שירות|מקצוע)/,
                    /(?:כמה|מה)\s*(?:דפים|עסקים|חנויות)\s*(?:יש|קיימים)/,
                    /באיזה\s+עיר|מה\s+הטלפון\s+של/i
                ];
                const isGeneralInfo = generalInfoPatterns.some(pattern => pattern.test(userMessage.trim()));
                
                // 🔧 Helper function: Fix common typos in Hebrew (defined early for reuse)
                function fixCommonTypos(text) {
                    const typoMap = {
                        'שעוז': 'שעון',
                        'שעןן': 'שעון',
                        'שעונ': 'שעון',
                        'מכונוית': 'מכונית',
                        'זהנב': 'זהב',
                        'כסםף': 'כסף',
                        'צעצןע': 'צעצוע',
                        'בןבה': 'בובה'
                    };
                    
                    let fixed = text.toLowerCase();
                    for (const [typo, correct] of Object.entries(typoMap)) {
                        fixed = fixed.replace(new RegExp(typo, 'g'), correct);
                    }
                    return fixed;
                }
                
                // 🔧 Helper function: Calculate similarity between two strings (typo tolerance)
                function stringSimilarity(str1, str2) {
                    const longer = str1.length > str2.length ? str1 : str2;
                    const shorter = str1.length > str2.length ? str2 : str1;
                    
                    if (longer.length === 0) return 1.0;
                    
                    // Count matching characters
                    let matches = 0;
                    for (let i = 0; i < shorter.length; i++) {
                        if (longer[i] === shorter[i]) matches++;
                    }
                    
                    return matches / longer.length;
                }
                
                // 🎯 NEW: Check for specific product price queries (e.g., "כמה עולה שעון הולוגרמה", "מה מחיר מכונית מרוץ")
                const specificPricePattern = /(?:כמה|מה)\s+(?:עולה|מחיר|עולה ה|מחיר ה|עולים|מחירי)\s+(.+)/i;
                const specificPriceMatch = userMessage.match(specificPricePattern);
                
                if (specificPriceMatch && specificPriceMatch[1]) {
                    const productName = specificPriceMatch[1].trim();
                    console.log('💰 Specific price query detected for product:', productName);
                    
                    // 🔧 Fix common typos in product name
                    const fixedProductName = fixCommonTypos(productName);
                    if (fixedProductName !== productName.toLowerCase()) {
                        console.log(`🔧 Fixed typo in early search: "${productName}" → "${fixedProductName}"`);
                    }
                    
                    // Search for product in all pages
                    for (const page of allPages) {
                        if (page.products && page.products.length > 0) {
                            for (const product of page.products) {
                                const productNameLower = product.name.toLowerCase();
                                const searchProductLower = fixedProductName; // Use fixed name
                                
                                // Check if product name matches (exact or partial)
                                if (productNameLower.includes(searchProductLower) || 
                                    searchProductLower.includes(productNameLower) ||
                                    productNameLower === searchProductLower) {
                                    console.log(`✅ Found product "${product.name}" with price ₪${product.price}`);
                                    
                                    // 🎯 Return page with iframe preview + price info
                                    return {
                                        type: 'pages',
                                        pages: [page],
                                        message: `${product.name} עולה ₪${product.price} ב${page.title}.`,
                                        needsPreview: true, // Show iframe
                                        includeLinks: false // Don't show "click here" link
                                    };
                                }
                            }
                        }
                    }
                    
                    // If not found in metadata, try searching in live pages
                    console.log('🔍 Product not found in metadata, searching live pages...');
                    for (const page of allPages) {
                        try {
                            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                            const response = await fetch(pageUrl);
                            if (response.ok) {
                                const html = await response.text();
                                const liveProducts = extractLiveProducts(html);
                                
                                for (const product of liveProducts) {
                                    const productNameLower = product.name.toLowerCase();
                                    const searchProductLower = productName.toLowerCase();
                                    
                                    if (productNameLower.includes(searchProductLower) || 
                                        searchProductLower.includes(productNameLower)) {
                                        console.log(`✅ Found product "${product.name}" with price ₪${product.price} (from live page)`);
                                        
                                        // 🎯 Return page with iframe preview + price info
                                        return {
                                            type: 'pages',
                                            pages: [page],
                                            message: `${product.name} עולה ₪${product.price} ב${page.title}.`,
                                            needsPreview: true, // Show iframe
                                            includeLinks: false // Don't show "click here" link
                                        };
                                    }
                                }
                            }
                        } catch (error) {
                            console.error(`Error fetching live products from ${page.title}:`, error);
                        }
                    }
                    
                    // Product not found
                    console.log('❌ Product not found:', productName);
                    return {
                        type: 'message',
                        message: `מצטער, לא מצאתי את "${productName}" במערכת. אולי תרצה לחפש משהו אחר?`
                    };
                }
                
                // 🧠 Check for context-aware follow-up questions (e.g., "איזה מוצרים יש שם", "מה מחירי השעטנים")
                // These refer to previously mentioned pages/stores
                const contextFollowUpPatterns = [
                    /(?:איזה|מה)\s*(?:מוצרים|פריטים)\s*(?:יש|קיימים|זמינים)\s*(?:שם|בחנות|ב|בתוכה)/i,
                    /(?:שם|בחנות|ב|בתוכה)\s*(?:יש|קיימים|זמינים)/i
                ];
                const isContextFollowUp = contextFollowUpPatterns.some(pattern => pattern.test(userMessage));
                
                // Check if query is about prices of products mentioned before (e.g., "מה מחירי השעטנים")
                const isPriceQuery = /מה\s+(?:מחיר|מחירים|מחירי)/i.test(userMessage);
                const hasProductReference = /(?:שעטנים|שעונים|שעון|מוצרים|פריטים)/i.test(userMessage);
                const isPriceFollowUp = isPriceQuery && (hasProductReference || isContextFollowUp);
                
                // Get last mentioned page from conversation context (if available)
                let lastMentionedPage = null;
                if (typeof window !== 'undefined' && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                    lastMentionedPage = window.stavCurrentPages[0]; // Get the first/last page shown
                    console.log('🧠 Context follow-up detected - last mentioned page:', lastMentionedPage?.title);
                }
                
                // If this is a context follow-up or price query about products mentioned before
                if ((isContextFollowUp || isPriceFollowUp) && lastMentionedPage) {
                    console.log('🧠 Handling context follow-up - searching page:', lastMentionedPage.title);
                    const liveResults = await searchLivePages(lastMentionedPage.title);
                    if (liveResults && liveResults.length > 0) {
                        return { 
                            type: 'pages', 
                            pages: liveResults,
                            message: `מצאתי את המידע על ${liveResults[0].title}`,
                            needsPreview: false // Don't show preview for follow-up questions
                        };
                    }
                }
                
                // If it's a price query about watches but no context, search for watches
                if (isPriceQuery && /שעטנים|שעונים/i.test(userMessage) && !lastMentionedPage) {
                    console.log('💰 Price query about watches detected - searching for watches');
                    const liveResults = await searchLivePages('שעון');
                    if (liveResults && liveResults.length > 0) {
                        return { 
                            type: 'pages', 
                            pages: liveResults,
                            message: `מצאתי ${liveResults.length} דפים עם שעונים`,
                            needsPreview: false
                        };
                    }
                }
                
                // ⚠️ IMPORTANT: Don't send product/store queries to N8N - they invent data!
                // Check if query is about products in a specific store or general product query
                // But be more specific - only count as marketplace query if it's clearly about marketplace
                const storeProductPattern = /(?:המוצרים|מוצרים|מה יש|מה יש ל|מה מוכרים|איזה מוצרים)\s*(?:ב|בחנות|בחנות|של)\s*([א-תa-zA-Z]+)/i;
                const storeProductMatch = userMessage.match(storeProductPattern);
                
                // Only consider it a product query if it's clearly about marketplace items
                // Exclude general questions like "מה זה מוצר?" which should go to N8N
                // Check for general question patterns first
                const isGeneralQuestion = /^מה\s+(זה|פירוש|משמעות)/.test(userMessage.trim()) || 
                                         /^איך\s+ל/.test(userMessage.trim()) ||
                                         /^למה|^מדוע/.test(userMessage.trim());
                
                // 🎯 IMPROVED: Check if the query matches any page in the marketplace
                // This allows single-word queries like "נגר", "לק", "צעצועים" to be recognized as marketplace queries
                let matchesPageInMarketplace = false;
                const cleanQuery = lowerMessage.trim();
                
                console.log('🔍 [MARKETPLACE CHECK] cleanQuery:', cleanQuery, 'length:', cleanQuery.length, 'isGeneralQuestion:', isGeneralQuestion);
                console.log('🔍 [MARKETPLACE CHECK] allPages count:', allPages?.length || 0);
                
                // If query is a single word or short phrase (not a question), check if it matches pages
                if (!isGeneralQuestion && cleanQuery.length > 1 && cleanQuery.length < 30) {
                    // Check if query matches any page title, description, or product name
                    for (const page of (allPages || [])) {
                        const pageTitle = (page.title || '').toLowerCase();
                        const pageDesc = (page.description || '').toLowerCase();
                        const pageProducts = (page.products || []).map(p => (p.name || '').toLowerCase()).join(' ');
                        
                        // 🎯 IMPROVED: Check word-by-word matching
                        // Extract words from query (removing "ב" prefix for city queries like "נגר בנתניה")
                        const queryWords = cleanQuery.split(/\s+/)
                            .map(w => w.replace(/^ב/, '').replace(/^של/, '').replace(/^ה/, '')) // Remove leading ב, של, or ה
                            .filter(w => w.length > 1); // Keep words with at least 2 chars
                        
                        // Check if any query word matches title/description/products
                        const hasMatch = queryWords.some(word => 
                            pageTitle.includes(word) || 
                            pageDesc.includes(word) || 
                            pageProducts.includes(word)
                        ) || pageTitle.includes(cleanQuery) || 
                           pageDesc.includes(cleanQuery) || 
                           pageProducts.includes(cleanQuery) ||
                           cleanQuery.includes(pageTitle.split(' ')[0]); // Check if query matches first word of title
                        
                        if (hasMatch) {
                            matchesPageInMarketplace = true;
                            console.log(`✅ [MARKETPLACE CHECK] Query "${cleanQuery}" matches page "${page.title}" - treating as marketplace query`);
                            console.log(`✅ [MARKETPLACE CHECK] queryWords:`, queryWords);
                            break;
                        }
                    }
                    
                    if (!matchesPageInMarketplace) {
                        console.log(`❌ [MARKETPLACE CHECK] Query "${cleanQuery}" does NOT match any pages`);
                    }
                }
                
                // 🎯 FIX: Make search more focused - exclude vague queries like "מה ש" or single letters
                const isVagueQuery = cleanQuery.length <= 2 || 
                                     cleanQuery === 'מה ש' || 
                                     cleanQuery === 'מה' ||
                                     cleanQuery === 'ש' ||
                                     /^[א-ת]\s*$/.test(cleanQuery); // Single Hebrew letter
                
                // 🎯 NEW: If user mentions product category, it's a marketplace query
                const isProductQuery = !isGeneralQuestion && !isVagueQuery && (
                    matchesPageInMarketplace || // NEW: If query matches a page, it's a marketplace query
                    mentionsProduct || // 🎯 FIX: If mentions ANY product category (from list above), it's marketplace!
                    // 🎯 FIX: Also catch "מה המוצר הכי זול" / "מה המוצר הכי יקר" / "מה המתנה הכי זולה" variations
                    lowerMessage.includes('מה המוצר הכי זול') || lowerMessage.includes('מה המוצר הכי יקר') ||
                    lowerMessage.includes('מה המתנה הכי זולה') || lowerMessage.includes('מה המתנה הכי יקרה') ||
                    lowerMessage.includes('המוצר הכי זול') || lowerMessage.includes('המוצר הכי יקר') ||
                    lowerMessage.includes('המתנה הכי זולה') || lowerMessage.includes('המתנה הכי יקרה') ||
                    (lowerMessage.includes('מוצר') && (lowerMessage.includes('יש') || lowerMessage.includes('מוכר') || lowerMessage.includes('חנות') || lowerMessage.includes('דף'))) ||
                    (lowerMessage.includes('מתנה') && (lowerMessage.includes('יש') || lowerMessage.includes('מוכר') || lowerMessage.includes('חנות') || lowerMessage.includes('דף') || lowerMessage.includes('זולה') || lowerMessage.includes('זול'))) ||
                    lowerMessage.includes('חנות') ||
                    lowerMessage.includes('מרקטפלייס') ||
                    lowerMessage.includes('נותן שירות') ||
                    lowerMessage.includes('בעל מקצוע')
                );
                
                console.log('🎯 [DECISION] isProductQuery:', isProductQuery, '| matchesPageInMarketplace:', matchesPageInMarketplace, '| includes נגר:', lowerMessage.includes('נגר'));
                
                // Check if query is about specific store/business info (phone, city, etc.)
                const businessInfoPatterns = [
                    /(?:מה|איזה)\s*(?:הטלפון|הכתובת|העיר|המייל)\s*(?:של|ב)\s*([א-תa-zA-Z]+)/i,
                    /(?:באיזה|איפה)\s+(?:עיר|מיקום)\s+(?:החנות|העסק|הדף)\s*([א-תa-zA-Z]+)/i
                ];
                let requestedBusiness = null;
                for (const pattern of businessInfoPatterns) {
                    const match = userMessage.match(pattern);
                    if (match && match[1]) {
                        requestedBusiness = match[1].trim();
                        console.log('🏪 Business info query detected for:', requestedBusiness);
                        break;
                    }
                }
                
                // 🎯 FIX: Handle "מה המוצר הכי זול" / "מה המוצר הכי יקר" locally - don't send to N8N!
                // BUT: "רשימת מחירים" / "רשימת מוצרים" / "תראי מוצרים" SHOULD show price list!
                const isPriceListQuery = lowerMessage.includes('רשימת מחירים') || lowerMessage.includes('רשימת מוצרים') ||
                                         lowerMessage.includes('תראי מוצרים') || lowerMessage.includes('תראי מחירים') ||
                                         lowerMessage.includes('מוצרים ומחירים') || lowerMessage.includes('מוצרים מחירים') ||
                                         (lowerMessage.includes('תראי') && (lowerMessage.includes('מוצר') || lowerMessage.includes('מחיר'))) ||
                                         lowerMessage.includes('הראי מוצרים') || lowerMessage.includes('הראי מחירים') ||
                                         lowerMessage.includes('רשימה של מוצרים') || lowerMessage.includes('רשימה של מחירים') ||
                                         lowerMessage.includes('תני רשימת') || lowerMessage.includes('תני לי רשימת') ||
                                         lowerMessage.includes('תני את רשימת') || lowerMessage.includes('כל המוצרים') ||
                                         /(?:ה)?(?:מחירים|יש\s+מחירים)\s+של\s+([א-ת\s]{2,20})/.test(userMessage); // "מחירים של צעצועים" OR "המחירים של צעצועים"
                
                // 🎯 NEW: Extract category from "מחירים של X" or "המחירים של X" query
                let priceListCategory = null;
                if (isPriceListQuery) {
                    const categoryMatch = userMessage.match(/(?:ה)?(?:מחירים|יש\s+מחירים)\s+של\s+([א-ת\s]{2,20})/i);
                    if (categoryMatch && categoryMatch[1]) {
                        priceListCategory = categoryMatch[1].trim();
                        console.log(`📋 Price list query for category: "${priceListCategory}"`);
                    }
                    
                    // 🎯 SPECIAL: If user asks for product list and we have pages in context, show products from those pages
                    const asksForProductListOfCurrentContext = /תני.*רשימת|תני.*את.*רשימת|רשימת.*מוצרים.*ב|מוצרים.*בחנות|בחנות.*הזאת|באתר.*הזה/i.test(userMessage);
                    if (asksForProductListOfCurrentContext && window.stavCurrentPages && window.stavCurrentPages.length > 0) {
                        console.log('📋 User asking for product list from current context pages');
                        const textResponse = await generateTextResponseWithRealData(window.stavCurrentPages, userMessage, false);
                        return {
                            type: 'text',
                            message: textResponse
                        };
                    }
                }
                
                // 🎯 NEW: Handle "שעונים עד 2000ש" / "מוצרים עד X שקל" queries - filter by max price
                const maxPricePattern = /(?:עד|עד\s+)?(\d+)\s*(?:ש|שקל|ש"ח|₪)/i;
                const maxPriceMatch = userMessage.match(maxPricePattern);
                const maxPrice = maxPriceMatch ? parseFloat(maxPriceMatch[1]) : null;
                
                // 🎯 NEW: Handle "מה המחיר של X" or "מחיר של X" or "כמה עולה X" queries locally - find specific product and return price
                // BUT: Skip if it's "מחירים של X" (plural) - that's a price list query!
                const isGeneralPriceListQuery = /מחירים\s+של|יש\s+מחירים/.test(userMessage);
                
                // Try multiple patterns for price queries - ordered by specificity
                let specificProductPriceMatch = null;
                if (!isGeneralPriceListQuery) {
                    // Pattern 1: "מה המחיר של X" or "מה המחיר של X"
                    const pattern1 = /(?:מה|איזה)\s+(?:ה)?מחיר\s+(?:של|ב)\s+([א-ת\s]{3,50})/i;
                    specificProductPriceMatch = userMessage.match(pattern1);
                    
                    // Pattern 2: "מחיר של X" (without "מה")
                    if (!specificProductPriceMatch) {
                        const pattern2 = /^מחיר\s+(?:של|ב)\s+([א-ת\s]{3,50})/i;
                        specificProductPriceMatch = userMessage.match(pattern2);
                    }
                    
                    // Pattern 3: "כמה עולה X"
                    if (!specificProductPriceMatch) {
                        const pattern3 = /כמה\s+עולה\s+([א-ת\s]{3,50})/i;
                        specificProductPriceMatch = userMessage.match(pattern3);
                    }
                    
                    // Pattern 4: "כמה עולה ה-X" (with definite article)
                    if (!specificProductPriceMatch) {
                        const pattern4 = /כמה\s+עולה\s+ה([א-ת\s]{3,50})/i;
                        specificProductPriceMatch = userMessage.match(pattern4);
                    }
                    
                    if (specificProductPriceMatch) {
                        console.log(`💰 Matched product price query with pattern, extracted: "${specificProductPriceMatch[1]}"`);
                    }
                }
                
                // 🎯 NEW: Also handle "מחיר של X הכי זול" queries
                const cheapestProductPricePattern = /(?:מה|איזה)?\s*(?:המחיר|מחיר)\s*(?:של|ב)?\s*([א-ת\s]{3,30})\s*(?:הכי\s*זול|הכי\s*זולה)/i;
                const cheapestProductPriceMatch = userMessage.match(cheapestProductPricePattern);
                
                // Handle "מחיר של X הכי זול" - find cheapest product matching the category
                if (cheapestProductPriceMatch && cheapestProductPriceMatch[1]) {
                    const categoryName = cheapestProductPriceMatch[1].trim();
                    console.log(`💰 Cheapest product in category query detected: "${categoryName}"`);
                    
                    // Search all store pages for products in this category
                    const storePages = (allPages || []).filter(page => page.pageType === 'store');
                    let allProducts = [];
                    
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            const liveProducts = extractLiveProducts(html);
                            
                            // Check if page title or products match the category
                            const pageTitleLower = (page.title || '').toLowerCase();
                            const categoryNameLower = categoryName.toLowerCase();
                            
                            if (pageTitleLower.includes(categoryNameLower) || categoryNameLower.includes(pageTitleLower)) {
                                liveProducts.forEach(product => {
                                    const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                    if (price >= 10 && price < 100000) {
                                        allProducts.push({
                                            ...product,
                                            pageTitle: page.title,
                                            pageUrl: pageUrl,
                                            userId: page.userId,
                                            pageId: page.pageId
                                        });
                                    }
                                });
                            } else {
                                // Check if products match the category
                                for (const product of liveProducts) {
                                    const productNameLower = (product.name || '').toLowerCase();
                                    if (productNameLower.includes(categoryNameLower) || categoryNameLower.includes(productNameLower.split(' ')[0])) {
                                        const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                        if (price >= 10 && price < 100000) {
                                            allProducts.push({
                                                ...product,
                                                pageTitle: page.title,
                                                pageUrl: pageUrl,
                                                userId: page.userId,
                                                pageId: page.pageId
                                            });
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('Error searching for product:', error);
                        }
                    }
                    
                    if (allProducts.length > 0) {
                        // Sort by price and get cheapest
                        allProducts.sort((a, b) => {
                            const priceA = parseFloat(String(a.price || 0).replace(/[,\s]/g, ''));
                            const priceB = parseFloat(String(b.price || 0).replace(/[,\s]/g, ''));
                            return priceA - priceB;
                        });
                        
                        const cheapest = allProducts[0];
                        const price = parseFloat(String(cheapest.price || 0).replace(/[,\s]/g, ''));
                        
                        return {
                            type: 'message',
                            message: `💰 **${cheapest.name}** ב-${cheapest.pageTitle} עולה **₪${price.toLocaleString()}**\n\nזה הצעצוע הכי זול בקטגוריה "${categoryName}"\n\n🔗 [צפה בדף](${cheapest.pageUrl})`
                        };
                    } else {
                        return {
                            type: 'message',
                            message: `מצטער, לא מצאתי צעצועים בקטגוריה "${categoryName}" במערכת.`
                        };
                    }
                }
                
                if (specificProductPriceMatch && specificProductPriceMatch[1]) {
                    const productName = specificProductPriceMatch[1].trim();
                    console.log(`💰 Specific product price query detected: "${productName}"`);
                    
                    // 🔧 Fix common typos
                    const fixedProductName = fixCommonTypos(productName);
                    if (fixedProductName !== productName.toLowerCase()) {
                        console.log(`🔧 Fixed typo: "${productName}" → "${fixedProductName}"`);
                    }
                    
                    // Search all store pages for this specific product
                    const storePages = (allPages || []).filter(page => page.pageType === 'store');
                    let foundProduct = null;
                    let foundPage = null;
                    
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            const liveProducts = extractLiveProducts(html);
                            
                            // Find product that matches the query - improved matching for partial names
                            const productNameLower = fixedProductName; // Use fixed name
                            // Remove common words that might interfere
                            const cleanProductName = productNameLower.replace(/\s+(של|ב|אבל|אם|או|עם)\s+/g, ' ').trim();
                            
                            for (const product of liveProducts) {
                                const productNameLower2 = (product.name || '').toLowerCase().trim();
                                
                                // Check exact match
                                if (productNameLower2 === productNameLower || productNameLower2 === cleanProductName) {
                                    const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                    if (price >= 10 && price < 100000) {
                                        foundProduct = product;
                                        foundPage = page;
                                        break;
                                    }
                                }
                                
                                // Check if query contains all key words from product name (flexible matching)
                                const productWords = productNameLower2.split(/\s+/).filter(w => w.length >= 2);
                                const queryWords = cleanProductName.split(/\s+/).filter(w => w.length >= 2);
                                
                                // If query contains 2+ words and most of them match product
                                if (queryWords.length >= 2) {
                                    const matchingWords = queryWords.filter(qw => 
                                        productWords.some(pw => pw.includes(qw) || qw.includes(pw))
                                    );
                                    // If at least 50% of query words match, or if all key words match
                                    if (matchingWords.length >= Math.min(2, queryWords.length) || 
                                        (queryWords.length >= 3 && matchingWords.length >= Math.ceil(queryWords.length * 0.5))) {
                                        const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                        if (price >= 10 && price < 100000) {
                                            foundProduct = product;
                                            foundPage = page;
                                            break;
                                        }
                                    }
                                }
                                
                                // Check if product name includes query or vice versa (partial match)
                                // Also handle typos/variations like "מרוץ" vs "מירוץ"
                                const normalizedProductName = productNameLower2.replace(/מירוץ|מרוץ/g, 'מירוץ').replace(/מירוץ/g, 'מירוץ');
                                const normalizedQuery = productNameLower.replace(/מירוץ|מרוץ/g, 'מירוץ').replace(/מירוץ/g, 'מירוץ');
                                
                                if (normalizedProductName.includes(normalizedQuery) || normalizedQuery.includes(normalizedProductName) ||
                                    productNameLower2.includes(productNameLower) || productNameLower.includes(productNameLower2)) {
                                    const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                    if (price >= 10 && price < 100000) {
                                        foundProduct = product;
                                        foundPage = page;
                                        break;
                                    }
                                }
                            }
                            if (foundProduct) break;
                        } catch (error) {
                            console.error('Error searching for product:', error);
                        }
                    }
                    
                    if (foundProduct && foundPage) {
                        const price = parseFloat(String(foundProduct.price || 0).replace(/[,\s]/g, ''));
                        
                        // 🎯 Save page for "כן" response
                        window.stavCurrentPages = [{
                            title: foundPage.title,
                            userId: foundPage.userId,
                            pageId: foundPage.pageId,
                            phone: foundPage.phone,
                            email: foundPage.email,
                            city: foundPage.city,
                            pageType: 'store'
                        }];
                        
                        return {
                            type: 'message',
                            message: `💰 **${foundProduct.name}** ב-${foundPage.title} עולה **₪${price.toLocaleString()}**\n\nרוצה לראות את הדף?`
                        };
                    } else {
                        // 🔧 FALLBACK: Try fuzzy matching with similarity check (for typos)
                        console.log('🔍 No exact match found, trying fuzzy matching...');
                        let bestMatch = null;
                        let bestSimilarity = 0;
                        
                        for (const page of storePages) {
                            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                            try {
                                const response = await fetch(pageUrl);
                                if (!response.ok) continue;
                                
                                const html = await response.text();
                                const liveProducts = extractLiveProducts(html);
                                
                                for (const product of liveProducts) {
                                    const productNameLower2 = (product.name || '').toLowerCase().trim();
                                    
                                    // Calculate similarity for each word in query
                                    const queryWords = cleanProductName.split(/\s+/).filter(w => w.length >= 2);
                                    const productWords = productNameLower2.split(/\s+/).filter(w => w.length >= 2);
                                    
                                    let totalSimilarity = 0;
                                    let matchCount = 0;
                                    
                                    for (const qw of queryWords) {
                                        let bestWordMatch = 0;
                                        for (const pw of productWords) {
                                            const sim = stringSimilarity(qw, pw);
                                            if (sim > bestWordMatch) bestWordMatch = sim;
                                        }
                                        totalSimilarity += bestWordMatch;
                                        matchCount++;
                                    }
                                    
                                    const avgSimilarity = matchCount > 0 ? totalSimilarity / matchCount : 0;
                                    
                                    // If similarity > 70% (tolerates 1-2 letter differences), consider it a match
                                    if (avgSimilarity >= 0.7 && avgSimilarity > bestSimilarity) {
                                        const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                        if (price >= 10 && price < 100000) {
                                            bestMatch = { product, page, pageUrl };
                                            bestSimilarity = avgSimilarity;
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('Error in fuzzy search:', error);
                            }
                        }
                        
                        if (bestMatch) {
                            console.log(`✅ Found fuzzy match with ${(bestSimilarity * 100).toFixed(0)}% similarity: "${bestMatch.product.name}"`);
                            const price = parseFloat(String(bestMatch.product.price || 0).replace(/[,\s]/g, ''));
                            return {
                                type: 'message',
                                message: `💰 **${bestMatch.product.name}** ב-${bestMatch.page.title} עולה **₪${price.toLocaleString()}**\n\n🔗 [צפה בדף](${bestMatch.pageUrl})\n\n💡 (התאמה קרובה ל-"${productName}")`
                            };
                        }
                        
                        return {
                            type: 'message',
                            message: `מצטער, לא מצאתי את המוצר "${productName}" במערכת. נסה לחפש באופן אחר.`
                        };
                    }
                }
                
                // 🎯 FIX: Handle "מה הצעצוע הכי זול" / "שעון הכי זול" / "מה המוצר הכי זול" / "מה המתנה הכי זולה" - return DIRECT answer!
                // Also handle simple queries like "שעון הכי זול" or "צעצוע הכי זול" or "מתנה" (without "מה")
                if ((lowerMessage.includes('מה הצעצוע הכי זול') || lowerMessage.includes('מה הצעצוע הכי יקר') ||
                    lowerMessage.includes('מה המוצר הכי זול') || lowerMessage.includes('מה המוצר הכי יקר') ||
                    lowerMessage.includes('מה המתנה הכי זולה') || lowerMessage.includes('מה המתנה הכי יקרה') ||
                    lowerMessage.includes('הצעצוע הכי זול') || lowerMessage.includes('הצעצוע הכי יקר') ||
                    lowerMessage.includes('המוצר הכי זול') || lowerMessage.includes('המוצר הכי יקר') ||
                    lowerMessage.includes('המתנה הכי זולה') || lowerMessage.includes('המתנה הכי יקרה') ||
                    lowerMessage.includes('שעון הכי זול') || lowerMessage.includes('שעון הכי יקר') ||
                    lowerMessage.includes('לק הכי זול') || lowerMessage.includes('לק הכי יקר') ||
                    (lowerMessage.includes('הכי זול') && (lowerMessage.includes('מוצר') || lowerMessage.includes('מתנה') || lowerMessage.includes('צעצוע') || lowerMessage.includes('שעון') || lowerMessage.includes('לק'))) ||
                    (lowerMessage.includes('הכי יקר') && (lowerMessage.includes('מוצר') || lowerMessage.includes('מתנה') || lowerMessage.includes('צעצוע') || lowerMessage.includes('שעון') || lowerMessage.includes('לק')))) &&
                    !isPriceListQuery) { // Don't handle locally if it's a "list prices" query
                    console.log('💰 Price comparison query detected - handling locally, NOT sending to N8N!');
                    
                    // Search all store pages for products
                    const storePages = (allPages || []).filter(page => page.pageType === 'store');
                    let allProducts = [];
                    
                    for (const page of storePages) {
                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                        try {
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            const liveProducts = extractLiveProducts(html);
                            
                            liveProducts.forEach(product => {
                                allProducts.push({
                                    ...product,
                                    pageTitle: page.title,
                                    pageUrl: pageUrl,
                                    userId: page.userId,
                                    pageId: page.pageId
                                });
                            });
                        } catch (error) {
                            console.error('Error extracting products from', pageUrl, ':', error);
                        }
                    }
                    
                    if (allProducts.length > 0) {
                        // 🎯 FIX: Filter out invalid products (questions, taglines, etc.)
                        // Define exclude patterns (same as in extractLiveProducts)
                        const excludePatterns = [
                            'נגישות', 'אודות', 'צור קשר', 'דף הבית', 'עלינו', 'תקנון', 'מדיניות', 
                            'פרטיות', 'תנאים', 'שירות', 'משלוחים', 'החזרות', 'איך להזמין',
                            'גלרי', 'המוצרים', 'תיאור', 'המיוחדים', 'הכל על', 'כל הזכויות',
                            'זכויות יוצרים', 'ברוכים הבאים', 'לקוחות', 'שאלות', 'תשובות',
                            'מוצרים שלנו', 'המוצרים שלנו', 'תפריט', 'כותרת', 'כותרת ראשית',
                            'למה', 'למה לבחור', 'למה לבחור ב', 'למה לבחור ברובוטים',
                            'איך', 'איך ל', 'כיצד', 'מדוע', 'מה היתרונות', 'מה היתרון',
                            // 🎯 NEW: Exclude accessibility/design options that are NOT real products
                            'ניגודיות', 'גופן', 'קריא', 'הדגש', 'קישורים', 'ריווח', 'שורות', 
                            'מוגבר', 'סמן', 'גדול', 'עצור', 'אנימציות', 'תצוגה', 'גדלה',
                            'גדלת', 'קטנה', 'קטנת', 'גופן גדול', 'גופן קטן', 'ניגודיות גבוהה',
                            'ניגודיות נמוכה', 'גופן קריא', 'גופן גדול', 'גופן קטן'
                        ].filter(Boolean);
                        
                        const excludePhrases = [
                            /זמן\s+(זו|זה)\s+אומנות/,
                            /.*אומנות.*/,
                            /.*חוויה.*/,
                            /.*סטגנס.*/,
                            /.*מושלם.*/,
                            /^טוהר$/,
                            /^יופי$/,
                            /^איכות$/,
                            /^השראה$/,
                            /^חלום$/,
                            /^אמת$/,
                            /^נשמה$/,
                            /^למה.*/,
                            /.*למה.*בחור.*/,
                            /.*למה.*רובוט.*/,
                            /.*\?$/,
                        ];
                        
                        const validProducts = allProducts.filter(product => {
                            const name = product.name || '';
                            // Exclude questions, taglines, etc.
                            const isQuestion = name.includes('?') || name.includes('למה') || 
                                               name.includes('איך') || name.match(/^למה\s+.*/) ||
                                               name.includes('למה לבחור') || name.includes('למה לבחור ב');
                            const matchesExcludedPhrase = excludePhrases.some(phrase => phrase.test(name));
                            const isExcluded = excludePatterns.some(pattern => 
                                name.toLowerCase().includes(pattern.toLowerCase())
                            );
                            
                            // Must have valid price (>= 10, not 2, 3, 5, 7 which are likely not product prices)
                            const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                            // 🎯 FIX: Exclude very low prices (2, 3, 5, 7) that are likely not product prices
                            // Only accept prices >= 10 (real product prices like ₪10, ₪60, ₪75)
                            const hasValidPrice = price >= 10 && price < 100000 && !isNaN(price);
                            
                            // Must have valid name (not question, not excluded, reasonable length)
                            const hasValidName = name.length >= 3 && name.length <= 100 && 
                                               !isQuestion && !matchesExcludedPhrase && !isExcluded &&
                                               name.match(/[א-ת]/); // Must contain Hebrew
                            
                            return hasValidName && hasValidPrice;
                        });
                        
                        console.log(`✅ Filtered products: ${validProducts.length} valid out of ${allProducts.length} total`);
                        console.log(`🔍 Valid products:`, validProducts.map(p => `${p.name} - ₪${p.price}`));
                        
                        if (validProducts.length === 0) {
                            return { type: 'message', message: 'מצטער, לא מצאתי מידע על מוצרים זמינים כרגע במרקטפלייס.' };
                        }
                        
                        // 🎯 FIX: Filter products by category if query specifies category (e.g., "מה הצעצוע הכי זול", "שעון הכי זול")
                        let filteredProducts = validProducts;
                        
                        // Filter by toy category
                        if (lowerMessage.includes('צעצוע')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                return pageTitle.includes('צעצוע') || productName.includes('צעצוע') || 
                                       productName.includes('מכונית') || productName.includes('בובה') ||
                                       productName.includes('קובייה') || productName.includes('משחק') ||
                                       productName.includes('רכבת') || productName.includes('דינוזאור');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        // Filter by watch category - handle "רק שעון" / "שעון בלבד" queries
                        else if (lowerMessage.includes('שעון') || lowerMessage.includes('רק שעון') || lowerMessage.includes('שעון בלבד')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                
                                // For "רק שעון" - be very strict, only watches!
                                if (lowerMessage.includes('רק שעון') || lowerMessage.includes('שעון בלבד') || lowerMessage.includes('רק שעונים')) {
                                    // Only accept pages with "שעון" in title OR products with "שעון" in name
                                    // Exclude everything else (toys, etc.)
                                    return (pageTitle.includes('שעון') && !pageTitle.includes('צעצוע')) || 
                                           (productName.includes('שעון') && !productName.includes('צעצוע'));
                                }
                                
                                // Regular "שעון" query - accept watches
                                return pageTitle.includes('שעון') || productName.includes('שעון');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        // Filter by nail polish category
                        else if (lowerMessage.includes('לק')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                return pageTitle.includes('לק') || productName.includes('לק') ||
                                       productName.includes('מניקור') || productName.includes('פדיקור');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        // Filter by gift/present category - exclude services (like barber shop, numbera)
                        else if (lowerMessage.includes('מתנה')) {
                            filteredProducts = validProducts.filter(product => {
                                const pageTitle = (product.pageTitle || '').toLowerCase();
                                const productName = (product.name || '').toLowerCase();
                                
                                // Exclude services (מספרה, שירותים)
                                if (pageTitle.includes('מספרה') || pageTitle.includes('שירות') || 
                                    productName.includes('מספרה') || productName.includes('שירות')) {
                                    return false;
                                }
                                
                                // Include gift-worthy products: toys, watches, jewelry, etc.
                                return pageTitle.includes('צעצוע') || pageTitle.includes('שעון') || 
                                       pageTitle.includes('תכשיט') || pageTitle.includes('מתנה') ||
                                       productName.includes('צעצוע') || productName.includes('שעון') ||
                                       productName.includes('תכשיט') || productName.includes('מכונית') ||
                                       productName.includes('בובה') || productName.includes('קובייה') ||
                                       productName.includes('רכבת') || productName.includes('דינוזאור');
                            });
                            if (filteredProducts.length === 0) filteredProducts = validProducts;
                        }
                        
                        // 🎯 NEW: Filter by max price if query specifies "עד X שקל" (e.g., "שעונים עד 2000ש")
                        if (maxPrice !== null && maxPrice > 0) {
                            console.log(`🔍 Filtering products by max price: ₪${maxPrice}`);
                            const beforeCount = filteredProducts.length;
                            filteredProducts = filteredProducts.filter(product => {
                                const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                return price <= maxPrice;
                            });
                            console.log(`✅ Filtered ${filteredProducts.length} products (from ${beforeCount}) under ₪${maxPrice}`);
                            
                            // If query includes category word, keep filtering by category
                            if (lowerMessage.includes('שעון')) {
                                filteredProducts = filteredProducts.filter(product => {
                                    const pageTitle = (product.pageTitle || '').toLowerCase();
                                    const productName = (product.name || '').toLowerCase();
                                    return pageTitle.includes('שעון') || productName.includes('שעון');
                                });
                            }
                        }
                        
                        // Sort by price
                        filteredProducts.sort((a, b) => {
                            const priceA = parseFloat(String(a.price).replace(/[,\s]/g, ''));
                            const priceB = parseFloat(String(b.price).replace(/[,\s]/g, ''));
                            return priceA - priceB;
                        });
                        
                        if (filteredProducts.length === 0) {
                            return { type: 'message', message: 'מצטער, לא מצאתי מידע על מוצרים זמינים כרגע במרקטפלייס.' };
                        }
                        
                        const cheapest = filteredProducts[0];
                        const mostExpensive = filteredProducts[filteredProducts.length - 1];
                        const cleanPageTitle = cheapest.pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                        const fullPageUrl = `${window.location.origin}${cheapest.pageUrl}`;
                        
                        let response = '';
                        
                        // 🎯 NEW: Handle "עד X שקל" queries (e.g., "שעונים עד 2000ש")
                        if (maxPrice !== null && maxPrice > 0) {
                            if (filteredProducts.length === 0) {
                                return { 
                                    type: 'message', 
                                    message: `מצטער, לא מצאתי ${lowerMessage.includes('שעון') ? 'שעונים' : 'מוצרים'} עד ₪${maxPrice.toLocaleString()} במרקטפלייס.`
                                };
                            }
                            
                            // Show all products under max price, sorted by price
                            response = `💰 **מצאתי ${filteredProducts.length} ${lowerMessage.includes('שעון') ? 'שעונים' : 'מוצרים'} עד ₪${maxPrice.toLocaleString()}:**\n\n`;
                            filteredProducts.slice(0, 10).forEach((product, idx) => {
                                const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                const productPageTitle = product.pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                                const productPageUrl = `${window.location.origin}${product.pageUrl}`;
                                response += `${idx + 1}. **${product.name}** ב-${productPageTitle} - ₪${price.toLocaleString()}\n`;
                                response += `   🔗 [צפה בדף](${productPageUrl})\n\n`;
                            });
                            if (filteredProducts.length > 10) {
                                response += `...ועוד ${filteredProducts.length - 10} ${lowerMessage.includes('שעון') ? 'שעונים' : 'מוצרים'} נוספים`;
                            }
                        }
                        else if (lowerMessage.includes('הכי זול') || lowerMessage.includes('זול')) {
                            let categoryText = '';
                            if (lowerMessage.includes('צעצוע')) categoryText = ' בקטגוריית צעצועים';
                            else if (lowerMessage.includes('שעון')) categoryText = ' בקטגוריית שעונים';
                            else if (lowerMessage.includes('לק')) categoryText = ' בקטגוריית לק ג\'ל';
                            else if (lowerMessage.includes('מתנה')) categoryText = ' בקטגוריית מתנות';
                            
                            // 🎯 Save page to context for "כן" follow-up
                            const pageTitleForSearch = cheapest.pageTitle || cleanPageTitle;
                            const pageFromList = allPages.find(p => 
                                p.title === pageTitleForSearch || 
                                p.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === cleanPageTitle
                            );
                            if (pageFromList) {
                                window.stavCurrentPages = [pageFromList];
                                console.log('💾 Saved page to context for follow-up:', cleanPageTitle);
                            }
                            
                            response = `${cheapest.name} ב-${cleanPageTitle} עולה ₪${parseFloat(String(cheapest.price).replace(/[,\s]/g, '')).toLocaleString()}\n`;
                            response += `זה המוצר הכי זול${categoryText} במרקטפלייס.\n`;
                            response += `רוצה לפתוח את הדף?`;
                        } else if (lowerMessage.includes('הכי יקר') || lowerMessage.includes('יקר')) {
                            const mostExpensiveFullUrl = `${window.location.origin}${mostExpensive.pageUrl}`;
                            const mostExpensiveCleanTitle = mostExpensive.pageTitle.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ');
                            
                            // 🎯 Save page to context for "כן" follow-up
                            const pageFromList = allPages.find(p => 
                                p.title === mostExpensive.pageTitle || 
                                p.title.replace(/_\d{13}(_html)?$/, '').replace(/_/g, ' ') === mostExpensiveCleanTitle
                            );
                            if (pageFromList) {
                                window.stavCurrentPages = [pageFromList];
                                console.log('💾 Saved page to context for follow-up:', mostExpensiveCleanTitle);
                            }
                            
                            response = `${mostExpensive.name} ב-${mostExpensiveCleanTitle} עולה ₪${parseFloat(String(mostExpensive.price).replace(/[,\s]/g, '')).toLocaleString()}\n`;
                            response += `זה המוצר הכי יקר במרקטפלייס.\n`;
                            response += `רוצה לפתוח את הדף?`;
                        } else {
                            response = `🤖 **מצאתי ${filteredProducts.length} מוצרים!**\n\n`;
                            response += `🥇 **הכי זול:** ${cheapest.name} - ₪${parseFloat(String(cheapest.price).replace(/[,\s]/g, '')).toLocaleString()}\n`;
                            response += `💎 **הכי יקר:** ${mostExpensive.name} - ₪${parseFloat(String(mostExpensive.price).replace(/[,\s]/g, '')).toLocaleString()}\n\n`;
                        }
                        
                        console.log(`✅ Returning response with ${filteredProducts.length} products (all fetched LIVE from pages)`);
                        return { type: 'message', message: response };
                    } else {
                        return { type: 'message', message: 'מצטער, לא מצאתי מידע על מוצרים זמינים כרגע במרקטפלייס.' };
                    }
                }
                
                // 🧠 NEW: Check if user mentions ONLY a city (e.g., "בחדרה") without any product/service
                // If so, AND we have lastSearchCategory, combine them and search!
                const knownCities = [
                    'תל אביב', 'ירושלים', 'חיפה', 'באר שבע', 'נתניה', 'אשדוד', 'רמת גן', 'פתח תקווה',
                    'בני ברק', 'חולון', 'רחובות', 'כפר סבא', 'אילת', 'רעננה', 'הרצליה', 'חדרה',
                    'קריית ביאליק', 'קריית מוצקין', 'ראשון לציון', 'נהריה', 'הוד השרון', 'גבעתיים',
                    'קריית אתא', 'קריית שמונה', 'בית שאן', 'עפולה', 'טבריה', 'עכו', 'צפת', 'דימונה',
                    'בת ים', 'כרמיאל', 'מעלה אדומים', 'יבנה', 'שדרות'
                ];
                
                // Check if the query is ONLY a city (with or without "ב" prefix)
                const cleanedQuery = lowerMessage.trim().replace(/^ב/, '').replace(/^בתוך/, '').replace(/^ל/, '').trim();
                const isCityOnly = knownCities.some(city => city === cleanedQuery || city === lowerMessage.trim());
                
                console.log(`🧠 [CONTEXT CHECK] isCityOnly: ${isCityOnly}, cleanedQuery: "${cleanedQuery}", lastSearchCategory: "${window.stavConversationContext?.lastSearchCategory || 'none'}"`);
                
                if (isCityOnly && window.stavConversationContext?.lastSearchCategory) {
                    // User mentioned ONLY a city - use last search category!
                    const lastCategory = window.stavConversationContext.lastSearchCategory;
                    const cityName = cleanedQuery;
                    
                    console.log(`🧠 User mentioned ONLY city "${cityName}" - combining with last category "${lastCategory}"`);
                    
                    // Combine city + category and search again
                    const combinedQuery = `${lastCategory} ב${cityName}`;
                    console.log(`🔍 Combined query: "${combinedQuery}"`);
                    
                    const liveResults = await searchLivePages(combinedQuery);
                    
                    if (liveResults && liveResults.length > 0) {
                        console.log(`✅ Found ${liveResults.length} results for "${combinedQuery}"`);
                        return {
                            type: 'pages',
                            pages: liveResults,
                            message: liveResults.length === 1
                                ? `מצאתי את ${liveResults[0].title}. רוצה פרטים נוספים?`
                                : `מצאתי ${liveResults.length} אפשרויות ב${cityName}:`,
                            needsPreview: false,
                            includeLinks: true
                        };
                    } else {
                        console.log(`❌ No results found for "${combinedQuery}" in ${cityName}`);
                        return {
                            type: 'message',
                            message: `מצטער, לא מצאתי ${lastCategory} ב${cityName}. אולי תנסה עיר אחרת או שירות אחר?`
                        };
                    }
                }
                
                // Determine if this is a marketplace query (products, stores, services)
                // BUT exclude general knowledge questions, greetings, bot questions, etc.
                // 🎯 IMPROVED: If query matches a page, it's definitely a marketplace query
                const isMarketplaceQuery = (matchesPageInMarketplace || storeProductMatch || isProductQuery || requestedBusiness) && 
                                          !isGeneralKnowledge && 
                                          !isBotQuestion && 
                                          !isGreeting && 
                                          !isSelfIntro;
                
                // 🎯 IMPORTANT: Check if user mentions a product category FIRST (even if it looks like a general question)
                // E.g., "שעונים יש?" should be treated as marketplace query, not general question
                if (mentionsProduct) {
                    console.log('🎯 Product mentioned - skipping N8N, treating as marketplace query');
                    // Continue to marketplace search below (don't send to N8N)
                } else if (isGeneralKnowledge || isBotQuestion || isGreeting || isSelfIntro) {
                    // If it's a general question (knowledge, bot question, greeting, etc.) - send to N8N
                    console.log('💬 General question detected (knowledge/bot/greeting), sending to N8N');
                    return null; // Return null to send to N8N webhook
                } else if (!isMarketplaceQuery) {
                    // NOT a marketplace query - send directly to N8N for intelligent response
                    console.log('💬 Not a marketplace query, sending to N8N for intelligent response');
                    return null; // Return null to send to N8N webhook
                }
                
                // This IS a marketplace query - search in pages
                console.log('🔍 Query about products/store/business info - will search in pages');
                console.log('🎯 User message:', userMessage);
                
                // 🎯 IMPROVED: If this is "מחירים של X", search for X (the category) not the whole query
                // BUT: Keep the original userMessage for later use in generateTextResponseWithRealData
                let searchQuery = userMessage;
                const originalUserMessage = userMessage; // Save original for price list detection
                if (priceListCategory) {
                    searchQuery = priceListCategory;
                    console.log(`📋 Price list query - searching for category: "${priceListCategory}" instead of "${userMessage}"`);
                }
                
                // 🎯 NEW: Clean search query - remove common prefixes like "מחפש", "רוצה", etc.
                // So "מחפש בובה" becomes "בובה"
                const searchPrefixPattern = /^(מחפש|מחפשת|רוצה|רוצה את|אני מחפש|אני רוצה|אני רוצה לקנות|רוצה לקנות|לקנות|תן לי|תני לי|תראה|תראי|הראה|הראי|יש לך|יש לכם|איפה|חפש|חיפוש|לחפש)\s+/i;
                if (searchPrefixPattern.test(searchQuery)) {
                    const cleanedQuery = searchQuery.replace(searchPrefixPattern, '').trim();
                    console.log(`🧹 Cleaned search query: "${searchQuery}" → "${cleanedQuery}"`);
                    searchQuery = cleanedQuery;
                }
                
                // 🎯 ALSO: Remove trailing words like "למיטב", "לילד שלי", etc. after "מתנה"
                // So "מתנה למיטב הילד שלי" becomes "מתנה"
                if (searchQuery.includes('מתנה')) {
                    searchQuery = searchQuery.replace(/\s+(ל[א-ת]+|לילד\s+שלי|לבן\s+שלי|לבת\s+שלי).*$/i, '').trim();
                    console.log(`🧹 Cleaned "מתנה" query: "${searchQuery}"`);
                }
                
                // First, try to search in REAL pages
                console.log('🔍 Starting search with', allPages?.length || 0, 'total pages available');
                console.log('🎯 Calling searchLivePages with query:', searchQuery);
                
                let liveResults = [];
                try {
                    liveResults = await searchLivePages(searchQuery);
                console.log('🔍 Search completed, found:', liveResults?.length || 0, 'results');
                if (liveResults && liveResults.length > 0) {
                    console.log('✅ Found pages:', liveResults.map(p => p.title).join(', '));
                } else {
                    console.log('❌ No pages found for query:', userMessage);
                    }
                } catch (searchError) {
                    console.error('❌ Error in searchLivePages:', searchError);
                    console.error('❌ Error stack:', searchError.stack);
                    console.error('❌ Search query was:', searchQuery);
                    liveResults = []; // Empty array on error
                }
                
                if (liveResults && liveResults.length > 0) {
                    console.log('✅ Found', liveResults.length, 'pages from search');
                    
                    // 🎯 REMOVED: Don't filter by matchScore - if a page passed serviceMatchesQuery, it's relevant!
                    // Pages are already filtered by searchLivePages() based on title/desc/products matching
                    console.log(`✅ All ${liveResults.length} pages are relevant (already filtered by searchLivePages)`);
                }
                
                if (liveResults && liveResults.length > 0) {
                    console.log('✅ Found', liveResults.length, 'RELEVANT pages');
                    
                    // 🚫 REMOVED: Old auto-preview logic
                    // Preview should ONLY be shown when user explicitly requests it (handled at top of function)
                    // NOT when they just search for a service/product
                    const needsPreview = false; // ❌ NEVER auto-show preview - user must explicitly ask
                    
                    console.log('ℹ️ Search results will NOT show preview automatically (needsPreview = false)');
                    
                    // 🎯 Check if this is a "price list" or "show products" query - if so, return text directly
                    const lowerUserMessage = userMessage.toLowerCase();
                    const isPriceListOrShowQuery = priceListCategory || // "מחירים של X"
                                                   lowerUserMessage.includes('תראי מוצרים') || 
                                                   lowerUserMessage.includes('תראי מחירים') ||
                                                   lowerUserMessage.includes('מוצרים ומחירים') ||
                                                   lowerUserMessage.includes('רשימת מחירים') ||
                                                   lowerUserMessage.includes('רשימת מוצרים') ||
                                                   lowerUserMessage.includes('תני רשימת') ||
                                                   lowerUserMessage.includes('תני לי רשימת') ||
                                                   lowerUserMessage.includes('תני את רשימת') ||
                                                   lowerUserMessage.includes('כל המוצרים') ||
                                                   (lowerUserMessage.includes('תראי') && 
                                                    (lowerUserMessage.includes('מוצר') || lowerUserMessage.includes('מחיר'))) ||
                                                   (lowerUserMessage.includes('תמליצי') && lowerUserMessage.includes('מתנה'));
                    
                    // If this is a "show products/prices" query, generate text response directly
                    if (isPriceListOrShowQuery) {
                        console.log('📝 Price list/show products query - generating text response directly');
                        
                        // 🎯 IMPORTANT: Save pages to context so "כן" will work correctly!
                        window.stavCurrentPages = liveResults;
                        console.log('💾 Saved', liveResults.length, 'pages to context for follow-up questions');
                        
                        // 🎯 Check if user wants link in this query
                        const includeLinks = /תראה.*אתר|תראה.*דף|קישור|פתח.*אתר|לינק|link/i.test(userMessage);
                        // 🎯 IMPORTANT: Use originalUserMessage (not searchQuery) so "מחירים של X" is detected correctly
                        const textResponse = await generateTextResponseWithRealData(liveResults, originalUserMessage, includeLinks);
                        
                        // Return pages type with text, so context is preserved
                        return {
                            type: 'pages',
                            pages: liveResults,
                            message: textResponse,
                            showAsText: true, // Flag to show as text (not buttons)
                            needsPreview: false
                        };
                    }
                    
                    // Return the pages themselves (not text) so we can display them properly
                    return { 
                        type: 'pages', 
                        pages: liveResults,
                        message: `מצאתי ${liveResults.length} דפים רלוונטיים`,
                        needsPreview: needsPreview // Flag to indicate if preview should be shown
                    };
                }
                
                // 🎯 SMART FALLBACK: If no direct results, search for products or related stores!
                console.log('🔍 No direct results - trying SMART fallback...');
                
                // 🎯 STAGE 1: Try to find products across ALL stores (even if page title doesn't match)
                // Define searchesForCategory for fallback
                // 🎯 CRITICAL: Filter out stop words from search query!
                const stopWords = ['מחפש', 'מחפשת', 'רוצה', 'רוצה', 'אני', 'את', 'אתה', 'של', 'עם', 'לי', 'להשיג', 'למצוא', 'לקנות', 'איפה', 'יש', 'כמה', 'מה', 'איך', 'למה', 'מי', 'אשמח', 'צריך', 'צריכה'];
                const searchWords = searchQuery.split(/\s+/)
                    .filter(w => w.length > 2 && !stopWords.includes(w.toLowerCase()));
                const looksLikeProductSearch = searchWords.length >= 1 && searchQuery.length >= 3;
                const searchesForCategoryFallback = looksLikeProductSearch;
                
                console.log(`🔍 Fallback search words (after filtering stop words): [${searchWords.join(', ')}]`);
                
                if (searchesForCategoryFallback) {
                    console.log('🛒 Searching for products across stores...');
                    const storePages = (allPages || []).filter(page => page.pageType === 'store');
                    let foundProducts = [];
                    
                    // Load products from stores (limit to 10 to avoid overload)
                    const storesToSearch = storePages.slice(0, 10);
                    console.log(`🔍 Checking ${storesToSearch.length} stores for products...`);
                    
                    for (const page of storesToSearch) {
                        try {
                            const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                            const response = await fetch(pageUrl);
                            if (!response.ok) continue;
                            
                            const html = await response.text();
                            const liveProducts = extractLiveProducts(html);
                            
                            // Check if ANY product matches the search
                            for (const product of liveProducts) {
                                const productNameLower = (product.name || '').toLowerCase();
                                
                                // Check if product matches ANY search word
                                const matchesSearch = searchWords.some(word => 
                                    productNameLower.includes(word.toLowerCase())
                                );
                                
                                if (matchesSearch) {
                                    foundProducts.push({
                                        ...product,
                                        pageTitle: page.title,
                                        pageUrl: `/users/${page.userId}/${page.pageId}_html`,
                                        userId: page.userId,
                                        pageId: page.pageId,
                                        phone: page.phone,
                                        city: page.city
                                    });
                                }
                            }
                        } catch (error) {
                            console.log(`⚠️ Error loading products from "${page.title}":`, error.message);
                        }
                    }
                    
                    // If found products, show them with prices!
                    if (foundProducts.length > 0) {
                        console.log(`✅ Found ${foundProducts.length} matching products across stores!`);
                        
                        // Group by page
                        const productsByPage = {};
                        foundProducts.forEach(product => {
                            if (!productsByPage[product.pageTitle]) {
                                productsByPage[product.pageTitle] = [];
                            }
                            productsByPage[product.pageTitle].push(product);
                        });
                        
                        // Build response
                        let message = `🎯 מצאתי ${foundProducts.length} מוצרים מתאימים!\n\n`;
                        
                        for (const [pageTitle, products] of Object.entries(productsByPage)) {
                            message += `**${pageTitle}**:\n`;
                            products.forEach(product => {
                                const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                message += `  • ${product.name} - ₪${price.toLocaleString()}\n`;
                            });
                            message += `\n`;
                        }
                        
                        // Get unique pages
                        const uniquePages = [...new Map(foundProducts.map(p => [p.pageTitle, {
                            title: p.pageTitle,
                            userId: p.userId,
                            pageId: p.pageId,
                            phone: p.phone,
                            city: p.city,
                            pageType: 'store'
                        }])).values()];
                    
                    return { 
                            type: 'pages',
                            pages: uniquePages,
                            message: message,
                            showAsText: true,
                            needsPreview: false
                        };
                    }
                    
                    // 🎯 STAGE 2: If no specific products found, try to find relevant services OR stores
                    console.log('🏪 No specific products found - trying to find relevant businesses...');
                    
                    // 🎯 SMART: Look for relevant stores OR services based on query
                    let relevantPages = [];
                    
                    // Check if query is more likely a service (מספרה, נגר, etc.) or a product (צעצועים, שעון)
                    const serviceKeywords = ['מספרה', 'תספורת', 'להסתפר', 'מעצב שיער', 'עיצוב שיער', 'ספר', 'נגר', 'חשמלאי', 'אינסטלטור', 'מאמן', 'מורה', 'ספרות', 'לק', 'מניקור', 'פדיקור', 'טיפול'];
                    const isServiceQuery = serviceKeywords.some(keyword => searchQuery.toLowerCase().includes(keyword));
                    
                    if (isServiceQuery) {
                        // Look for service providers
                        const servicePages = (allPages || []).filter(page => page.pageType === 'serviceProvider');
                        console.log(`🔧 Service query detected - checking ${servicePages.length} service providers...`);
                        
                        // Try to find services that match the query
                        for (const page of servicePages) {
                            const titleLower = (page.title || '').toLowerCase();
                            const descLower = (page.description || '').toLowerCase();
                            
                            // Check if title/description contains query words
                            const queryMatches = searchWords.some(word => 
                                titleLower.includes(word) || descLower.includes(word)
                            );
                            
                            if (queryMatches) {
                                relevantPages.push(page);
                            }
                        }
                        
                        console.log(`✅ Found ${relevantPages.length} matching service providers`);
                    } else {
                        // 🎯 CRITICAL: Look for stores (products) - but ONLY if they're actually relevant!
                        console.log(`🛒 Product query detected - checking ${storePages.length} stores for relevance...`);
                        
                        // Check each store to see if it's relevant to the search
                        for (const page of storePages) {
                            const titleLower = (page.title || '').toLowerCase();
                            const descLower = (page.description || '').toLowerCase();
                            
                            // Check if title/description contains ANY of the search words
                            const titleMatches = searchWords.some(word => 
                                word.length >= 2 && titleLower.includes(word.toLowerCase())
                            );
                            const descMatches = searchWords.some(word => 
                                word.length >= 2 && descLower.includes(word.toLowerCase())
                            );
                            
                            // Only include if title or description matches
                            if (titleMatches || descMatches) {
                                relevantPages.push(page);
                                console.log(`   ✅ Relevant: "${page.title}" (title: ${titleMatches}, desc: ${descMatches})`);
                            } else {
                                console.log(`   ❌ Not relevant: "${page.title}" - doesn't contain search words: [${searchWords.join(', ')}]`);
                            }
                        }
                        
                        console.log(`🛒 Found ${relevantPages.length} relevant stores (out of ${storePages.length} total)`);
                    }
                    
                    if (relevantPages.length > 0) {
                        let message = relevantPages.length === 1
                            ? `מצאתי את ${relevantPages[0].title}. רוצה לראות את הדף?`
                            : `מצאתי ${relevantPages.length} ${isServiceQuery ? 'ספקי שירות' : 'חנויות'} שעשויים לעניין אותך:\n\n`;
                        
                        if (relevantPages.length > 1) {
                            for (const page of relevantPages.slice(0, 5)) {
                                message += `• **${page.title}**`;
                                if (page.city) message += ` - ${page.city}`;
                                message += `\n`;
                            }
                            message += `\nרוצה שאציג אחד מהם?`;
                        }
                        
                        return {
                            type: 'pages',
                            pages: relevantPages.slice(0, 5),
                            message: message,
                            showAsText: true,
                            needsPreview: relevantPages.length === 1 ? false : false
                        };
                    }
                }
                
                // Final fallback
                return { 
                    type: 'message',
                    message: 'לא מצאתי את מה שחיפשת. 😔\n\nאולי תנסה לחפש באופן אחר או שירות אחר? אני כאן לעזור! 😊'
                };
            } catch (error) {
                console.error('❌❌❌ Error in processStavMessage:', error);
                console.error('❌ Error stack:', error.stack);
                console.error('❌ Error message:', error.message);
                return { 
                    type: 'message',
                    message: 'מצטער, אירעה שגיאה. נסה שוב.'
                };
            }
        }

        // 🎤 Speech Recognition & Text-to-Speech
        let recognition = null;
        let isListening = false;
        let isSpeaking = false;
        let lastInputWasVoice = false; // Track if user used voice input
        let speechSynthesis = window.speechSynthesis;

        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.log('⚠️ Speech recognition not supported');
                return null;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'he-IL';
            recognition.continuous = false;
            recognition.interimResults = false;

            recognition.onstart = function() {
                console.log('🎤 Listening...');
                isListening = true;
                const micButton = document.getElementById('micButton');
                if (micButton) {
                    micButton.style.background = '#ef4444';
                    micButton.textContent = '🔴';
                }
                // Update main button icon
                const mainIcon = document.getElementById('stavMainIcon');
                if (mainIcon) {
                    mainIcon.textContent = '🔴';
                }
            };

            recognition.onresult = function(event) {
                let transcript = event.results[0][0].transcript;
                console.log('📝 Heard (RAW):', transcript);
                
                // 🎯 CLEAN: Remove punctuation marks from voice input
                transcript = transcript.replace(/[.,!?;:،؛]/g, '').trim();
                console.log('📝 Heard (CLEAN):', transcript);
                
                lastInputWasVoice = true; // Mark that user used voice
                const input = document.getElementById('stavChatInput');
                if (input) {
                    input.value = transcript;
                    sendStavMessage();
                }
            };

            recognition.onerror = function(event) {
                console.error('❌ Speech recognition error:', event.error);
                isListening = false;
                const micButton = document.getElementById('micButton');
                if (micButton) {
                    micButton.style.background = '#667eea';
                    micButton.textContent = '🎤';
                }
                // Update main button icon
                const mainIcon = document.getElementById('stavMainIcon');
                if (mainIcon) {
                    mainIcon.textContent = '🤖';
                }
            };

            recognition.onend = function() {
                console.log('🎤 Stopped listening');
                isListening = false;
                const micButton = document.getElementById('micButton');
                if (micButton) {
                    micButton.style.background = '#667eea';
                    micButton.textContent = '🎤';
                }
                // Update main button icon
                const mainIcon = document.getElementById('stavMainIcon');
                if (mainIcon) {
                    mainIcon.textContent = '🤖';
                }
            };

            return recognition;
        }

        function toggleSpeechRecognition() {
            // If currently speaking, stop the speech
            if (isSpeaking) {
                stopSpeaking();
                return;
            }

            if (!recognition) {
                recognition = initSpeechRecognition();
                if (!recognition) {
                    alert('הדפדפן שלך לא תומך בזיהוי קולי');
                    return;
                }
            }

            if (isListening) {
                recognition.stop();
            } else {
                recognition.start();
            }
        }

        function stopSpeaking() {
            speechSynthesis.cancel();
            isSpeaking = false;
            
            // 🤖 Stop Google TTS audio
            if (window.currentAudio) {
                window.currentAudio.pause();
                window.currentAudio = null;
                console.log('🤖 Google TTS audio stopped');
            }
            
            const micButton = document.getElementById('micButton');
            if (micButton) {
                micButton.style.background = '#667eea';
                micButton.textContent = '🎤';
            }
            console.log('🔇 Speech stopped');
        }

        async function speakText(text) {
            // Remove emojis, asterisks, HTML, parentheses, and clean text for speech
            const cleanText = text
                .replace(/<[^>]*>/g, '') // Remove HTML tags
                .replace(/&[^;]+;/g, '') // Remove HTML entities
                .replace(/[😊💡📍📞📧🏠💰✅❌🔗📄🏪🎉🎓🔧👁️🎯🔍📚📝🔊🎤🔴]/g, '')
                .replace(/\*\*/g, '')
                .replace(/\*/g, '')
                .replace(/\([^)]*\)/g, '') // Remove parentheses
                .replace(/\.{2,}/g, '') // Remove multiple dots
                .replace(/\n\n+/g, '. ')
                .replace(/\n/g, '. ')
                .replace(/•/g, '')
                .replace(/\|/g, '')
                .replace(/\s+/g, ' ')
                .trim();

            if (!cleanText) return;

            // Cancel any ongoing speech and audio
            speechSynthesis.cancel();
            if (window.currentAudio) {
                window.currentAudio.pause();
                window.currentAudio = null;
            }

            const micButton = document.getElementById('micButton');
            if (micButton) {
                micButton.style.background = '#10b981';
                micButton.textContent = '🔊';
            }
            // Update main button icon
            const mainIcon = document.getElementById('stavMainIcon');
            if (mainIcon) {
                mainIcon.textContent = '🔊';
            }

            try {
                // 🤖 Google Cloud Text-to-Speech API
                const API_KEY = 'AIzaSyBexR71l9bdJ28OKx8P7QhyQDQpqTPa56o';
                
                console.log('🤖 Calling Google TTS API...');
                
                // 🎯 Add timeout to prevent hanging (10 seconds max)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${API_KEY}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        input: { text: cleanText },
                        voice: {
                            languageCode: 'he-IL',
                            name: 'he-IL-Wavenet-A', // Female robotic voice (Wavenet = highest quality available for Hebrew)
                            ssmlGender: 'FEMALE'
                        },
                        audioConfig: {
                            audioEncoding: 'MP3',
                            pitch: -5.0,        // Lower pitch for robotic effect
                            speakingRate: 1.35, // Fast (as requested - kept the same)
                            volumeGainDb: 0.0,  // Normal volume
                            effectsProfileId: ['small-bluetooth-speaker-class-device'] // Robotic effect
                        }
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);

                const data = await response.json();
                
                if (data.error) {
                    console.error('❌ Google TTS error:', data.error);
                    throw new Error(data.error.message);
                }
                
                if (data.audioContent) {
                    console.log('✅ Received audio from Google TTS');
                    
                    // Convert base64 to audio and play
                    const audio = new Audio('data:audio/mp3;base64,' + data.audioContent);
                    window.currentAudio = audio;
                    
                    audio.onplay = () => {
                        isSpeaking = true;
                        console.log('🔊 Speaking (Google TTS):', cleanText.substring(0, 50) + '...');
                    };
                    
                    audio.onended = () => {
                        isSpeaking = false;
                        if (micButton) {
                            micButton.style.background = '#667eea';
                            micButton.textContent = '🎤';
                        }
                        // Update main button icon
                        const mainIcon = document.getElementById('stavMainIcon');
                        if (mainIcon) {
                            mainIcon.textContent = '🤖';
                        }
                        console.log('✅ Speech finished');
                        
                        // 🎤 Auto-start microphone for continuous conversation
                        setTimeout(() => {
                            if (!recognition) {
                                recognition = initSpeechRecognition();
                            }
                            if (recognition && !isListening) {
                                console.log('🔄 Auto-starting microphone for continuous conversation...');
                                recognition.start();
                            }
                        }, 500); // Small delay to ensure smooth transition
                    };
                    
                    audio.onerror = (e) => {
                        console.error('❌ Audio playback error:', e);
                        isSpeaking = false;
                        if (micButton) {
                            micButton.style.background = '#667eea';
                            micButton.textContent = '🎤';
                        }
                    };
                    
                    await audio.play();
                } else {
                    throw new Error('No audio content received');
                }
            } catch (error) {
                console.error('❌ Google TTS error:', error);
                console.error('❌ Error details:', error.message);
                console.error('❌ Error name:', error.name);
                
                // 🎯 Check error type
                if (error.name === 'AbortError') {
                    console.warn('⚠️ Google TTS request timed out (>10s)');
                } else if (error.message && (error.message.includes('quota') || error.message.includes('429'))) {
                    console.warn('⚠️ Google TTS quota exceeded or rate limit hit');
                } else if (error.message && error.message.includes('API key')) {
                    console.warn('⚠️ Google TTS API key issue');
                } else if (error.message && error.message.includes('network')) {
                    console.warn('⚠️ Network error - no internet connection?');
                }
                
                // Fallback to browser TTS if Google fails
                console.log('⚠️ Falling back to browser TTS');
                
                try {
                    const utterance = new SpeechSynthesisUtterance(cleanText);
                    utterance.lang = 'he-IL';
                    utterance.rate = 1.35; // Match the Google TTS rate
                    utterance.pitch = 0.6;
                    
                    utterance.onstart = () => {
                        isSpeaking = true;
                        console.log('🔊 Browser TTS started (fallback)');
                    };
                    
                    utterance.onend = () => {
                        isSpeaking = false;
                        if (micButton) {
                            micButton.style.background = '#667eea';
                            micButton.textContent = '🎤';
                        }
                        // Update main button icon
                        const mainIcon = document.getElementById('stavMainIcon');
                        if (mainIcon) {
                            mainIcon.textContent = '🤖';
                        }
                        console.log('✅ Browser TTS finished (fallback)');
                        
                        // 🎤 Auto-start microphone for continuous conversation
                        setTimeout(() => {
                            if (!recognition) {
                                recognition = initSpeechRecognition();
                            }
                            if (recognition && !isListening) {
                                console.log('🔄 Auto-starting microphone for continuous conversation...');
                                recognition.start();
                            }
                        }, 500); // Small delay to ensure smooth transition
                    };
                    
                    utterance.onerror = (e) => {
                        console.error('❌ Browser TTS error:', e);
                        isSpeaking = false;
                        if (micButton) {
                            micButton.style.background = '#667eea';
                            micButton.textContent = '🎤';
                        }
                    };
                    
                    speechSynthesis.speak(utterance);
                } catch (fallbackError) {
                    console.error('❌ Browser TTS fallback also failed:', fallbackError);
                    // Reset mic button
                    isSpeaking = false;
                    if (micButton) {
                        micButton.style.background = '#667eea';
                        micButton.textContent = '🎤';
                    }
                }
            }
        }

        async function sendStavMessage() {
            const input = document.getElementById('stavChatInput');
            const userMessage = input.value.trim();
            
            if (!userMessage) return;
            
            // 🎯 FIX: Store user message in window for later use (for price list detection)
            window.lastUserMessage = userMessage;
            console.log('💾 Stored user message:', userMessage);
            
            // Check if this was a typed message (not voice)
            const wasVoice = lastInputWasVoice;
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('📨 INPUT METHOD:', wasVoice ? '🎤 VOICE' : '⌨️ TEXT');
            console.log('📝 MESSAGE:', userMessage);
            console.log('🔍 MESSAGE LENGTH:', userMessage.length);
            console.log('🔤 MESSAGE CHARS:', Array.from(userMessage).map(c => c.charCodeAt(0)));
            console.log(wasVoice ? '🔊 Response will be SPOKEN + TEXT' : '📝 Response will be TEXT ONLY');
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            
            // Display user message
            addStavMessage(userMessage, true);
            input.value = '';
            
            // Reset voice flag after sending (for next message)
            // Don't reset here - wait for response to be added
            // lastInputWasVoice = false;
            
            // Show typing indicator with animation
            const typingMessageDiv = document.createElement('div');
            typingMessageDiv.className = 'stav-message bot stav-typing-indicator';
            typingMessageDiv.id = 'stav-typing-indicator';
            typingMessageDiv.innerHTML = `
                <div class="stav-loader">
                    <div class="inner one"></div>
                    <div class="inner two"></div>
                    <div class="inner three"></div>
                </div>
                <span>סתיו מקלידה...</span>
            `;
            const messagesDiv = document.getElementById('stavChatMessages');
            messagesDiv.appendChild(typingMessageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            try {
                // Get all pages for Stav
                const response = await fetch('/api/pages/all');
                if (!response.ok) {
                    console.error('❌ Failed to fetch pages:', response.status, response.statusText);
                    addStavMessage('מצטער, בעיה בטעינת הדפים מהשרת. נסה שוב מאוחר יותר.', false);
                    return;
                }
                const data = await response.json();
                const allPages = data.pages || data || [];
                
                console.log('📊 All pages for Stav:', allPages.length, 'pages');
                if (allPages.length === 0) {
                    console.warn('⚠️ No pages returned from API!');
                }
                
                // Process the message and get response
                const botResponse = await processStavMessage(userMessage, allPages);
                
                // 🎯 FIX: Handle text responses (like "מה המוצר הכי זול") FIRST - don't send to N8N!
                if (botResponse && (botResponse.type === 'text' || botResponse.type === 'message') && botResponse.message) {
                    console.log('✅ Found text response, displaying directly:', botResponse.message);
                
                // Remove typing indicator
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) {
                        typingIndicator.remove();
                    }
                    
                    // Display the message
                    addStavMessage(botResponse.message, false);
                    return; // Don't send to N8N
                }
                
                // If we have pages to display, show them as TEXT ONLY (no buttons!)
                // 🎯 User wants ONLY text conversation - NO buttons/preview!
                if (botResponse && botResponse.type === 'pages' && botResponse.pages && botResponse.pages.length > 0) {
                    console.log('✅ Found pages, displaying as TEXT ONLY (no buttons):', botResponse.pages.length);
                    
                    // 🎯 Save pages in context for later use (if user asks for link)
                    window.stavCurrentPages = botResponse.pages;
                    
                    // Remove typing indicator
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) typingIndicator.remove();
                    
                    // 🎯 NEW: If user explicitly requested to see the page, show preview WITHOUT repeating text!
                    console.log('📊 [PREVIEW DEBUG] needsPreview:', botResponse.needsPreview);
                    console.log('📊 [PREVIEW DEBUG] includeLinks:', botResponse.includeLinks);
                    console.log('📊 [PREVIEW DEBUG] pages count:', botResponse.pages?.length);
                    
                    if (botResponse.needsPreview === true) {
                        console.log('🖼️✅ SHOWING IFRAME ONLY (no text!) because needsPreview=true');
                        // Show short polite message with LIVE description before iframe
                        const bestPage = botResponse.pages[0];
                        if (bestPage) {
                            let shortMessage = `בבקשה, הנה הדף של ${bestPage.title}`;
                            
                            // Fetch the page to extract LIVE description
                            const pageUrl = `/users/${bestPage.userId}/${bestPage.pageId}_html`;
                            try {
                                const pageResponse = await fetch(pageUrl);
                                if (pageResponse.ok) {
                                    const html = await pageResponse.text();
                                    const liveDesc = extractLiveDescription(html);
                                    
                                    if (liveDesc && liveDesc.length > 0) {
                                        // Use full description - don't cut it!
                                        shortMessage += ` - ${liveDesc}`;
                                    }
                                }
                            } catch (error) {
                                console.error('❌ Error fetching live description:', error);
                            }
                            
                            addStavMessage(shortMessage, false);
                            console.log('✅ Added short intro message with LIVE description:', shortMessage);
                        }
                        // Show iframe after short delay
                        setTimeout(async () => {
                            if (bestPage) {
                                // 🧠 Save current page to context
                                window.stavConversationContext.currentPage = {
                                    title: bestPage.title,
                                    userId: bestPage.userId,
                                    pageId: bestPage.pageId,
                                    url: `/users/${bestPage.userId}/${bestPage.pageId}_html`,
                                    phone: bestPage.phone,
                                    email: bestPage.email,
                                    city: bestPage.city,
                                    address: bestPage.address
                                };
                                console.log('🧠 Saved current page to context:', window.stavConversationContext.currentPage);
                                
                                // Detect specific requests and navigate to relevant section
                                const options = {};
                                const lowerMessage = userMessage.toLowerCase();
                                
                                // Check for appointment/booking request
                                if (lowerMessage.includes('תור') || lowerMessage.includes('קביעה') || 
                                    lowerMessage.includes('פגישה') || lowerMessage.includes('זימון')) {
                                    options.anchor = 'appointment-section';
                                    console.log('📅 Detected appointment request, will scroll to booking section');
                                }
                                
                                // Check for specific product request
                                if (lowerMessage.includes('מוצר') || lowerMessage.includes('הראה לי') || 
                                    lowerMessage.includes('עוד על')) {
                                    // Try to extract product name/ID from message
                                    options.anchor = 'products-section';
                                    console.log('🛍️ Detected product request, will scroll to products section');
                                }
                                
                                // Check for contact request
                                if (lowerMessage.includes('צור קשר') || lowerMessage.includes('פרטי התקשרות') || 
                                    lowerMessage.includes('טלפון') || lowerMessage.includes('כתובת')) {
                                    options.anchor = 'contact-section';
                                    console.log('📞 Detected contact request, will scroll to contact section');
                                }
                                
                                await displayPagePreview(bestPage, 'stavChatMessages', options);
                                console.log('✅ Displayed page preview for:', bestPage.title, 'with options:', options);
                            }
                        }, 100); // Show immediately
                    } else {
                        console.log('📝 Showing text response (no preview) because needsPreview=false');
                        // 🎯 CRITICAL: Show ONLY text response - NO buttons!
                        // Generate text response with real data and display it directly
                        const messageToPass = userMessage || botResponse.message || `מצאתי ${botResponse.pages.length} דפים רלוונטיים`;
                        const includeLinks = botResponse.includeLinks || false;
                        const textResponse = await generateTextResponseWithRealData(botResponse.pages, messageToPass, includeLinks);
                        if (textResponse && textResponse.trim().length > 0) {
                            addStavMessage(textResponse, false);
                            console.log('✅ Added text response with real data (NO buttons)');
                            
                            // 🧠 Save ALL pages to window.stavCurrentPages (so user can choose by number/name!)
                            if (botResponse.pages && botResponse.pages.length > 0) {
                                window.stavCurrentPages = botResponse.pages;
                                console.log('💾 Saved', botResponse.pages.length, 'pages to window.stavCurrentPages for selection');
                                
                                // Also save first page to conversation context for follow-up questions
                                const firstPage = botResponse.pages[0];
                                window.stavConversationContext.currentPage = {
                                    title: firstPage.title,
                                    userId: firstPage.userId,
                                    pageId: firstPage.pageId,
                                    url: `/users/${firstPage.userId}/${firstPage.pageId}_html`,
                                    phone: firstPage.phone,
                                    email: firstPage.email,
                                    city: firstPage.city,
                                    address: firstPage.address
                                };
                                console.log('🧠 Saved first page to context for follow-up:', firstPage.title);
                            }
                        }
                    }
                    
                    // 🎯 IMPROVED: DON'T send to N8N when we have successful local results!
                    // This prevents timeout/errors and makes the bot faster
                    console.log('✅ Local search successful - NOT sending to N8N (prevents timeout)');
                    stavFirstReplySent = true;
                    return; // Exit - don't send to N8N!
                } else if (botResponse && botResponse.type === 'message') {
                    // Just a text message, display it directly
                    // Remove typing indicator before displaying message
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) typingIndicator.remove();
                    
                    addStavMessage(botResponse.message, false);
                    stavFirstReplySent = true;
                    return; // Don't send to N8N for simple messages
                } else if (botResponse === null) {
                    // botResponse is null - this means send to N8N (general questions, etc.)
                    console.log('💬 botResponse is null - sending to N8N for intelligent response');
                    // Keep typing indicator until N8N responds
                } else {
                    // Unknown response type - remove typing indicator and send to N8N
                    const typingIndicator = document.getElementById('stav-typing-indicator');
                    if (typingIndicator) typingIndicator.remove();
                    console.log('⚠️ Unknown botResponse type, sending to N8N');
                }
                
                // Send to N8N for conversational response (for general questions or context)
                console.log('💬 Sending to N8N webhook for conversational response');
                try {
                    const webhookUrl = '/api/n8n-webhook'; // Use proxy route instead of direct N8N
                    
                    // CRITICAL: Reload pages if allPages is empty or not loaded yet
                    if (!allPages || allPages.length === 0) {
                        console.log('⚠️ allPages is empty! Reloading pages...');
                        await loadPages();
                        console.log(`✅ Reloaded pages: ${allPages.length} pages available`);
                    }
                    
                    // Check if this is a question about service providers - include ALL serviceProvider pages
                    const isServiceProviderQuestion = /(?:כמה|מה|יש|מחפש|צריך|איזה|מי)\s*(?:נותני|מספקי|בעלי|בעל)?\s*(?:שרות|שירות|מקצוע)/.test(userMessage.toLowerCase()) || 
                                                      /בעלי\s*מקצוע|בעל\s*מקצוע/.test(userMessage.toLowerCase());
                    
                    // 🎯 NEW: Check if query looks like a marketplace search (single words like "נגר", "לק", "צעצועים")
                    // Even if processStavMessage didn't catch it, we should find matching pages and send them
                    let matchingPagesForBody = [];
                    const userMessageLower = userMessage.toLowerCase().trim();
                    const isShortQuery = userMessageLower.length > 1 && userMessageLower.length < 30 && 
                                        !userMessageLower.includes('?') && 
                                        !userMessageLower.match(/^(מה|איך|למה|מדוע|מתי|איפה)/);
                    
                    // If it's a short query (likely marketplace search), try to find matching pages
                    if (isShortQuery && allPages && allPages.length > 0) {
                        console.log(`🔍 Short query detected - checking for matching pages: "${userMessageLower}"`);
                        
                        for (const page of allPages) {
                            const pageTitle = (page.title || '').toLowerCase();
                            const pageDesc = (page.description || '').toLowerCase();
                            const pageProducts = (page.products || []).map(p => (p.name || '').toLowerCase()).join(' ');
                            const pageCity = (page.city || '').toLowerCase();
                            
                            // Check if query matches page (title, description, products, or city)
                            if (pageTitle.includes(userMessageLower) || 
                                pageDesc.includes(userMessageLower) || 
                                pageProducts.includes(userMessageLower) ||
                                userMessageLower.includes(pageTitle.split(' ')[0]) ||
                                pageTitle.split(' ').some(word => word.length > 2 && userMessageLower.includes(word)) ||
                                // Also check if query is in city (e.g., "נתניה")
                                (pageCity && pageCity.includes(userMessageLower))) {
                                
                                // 🎯 FIX: Extract products from live page if not in metadata
                                let products = page.products || [];
                                
                                // 🎯 FIX: ALWAYS extract products from live page to get latest prices
                                // User said "אם אני משנה בדפים מחירים הבוט אמור לזהות את זה" - so we need LIVE data!
                                const alwaysExtractProducts = true; // Always get live data for latest prices!
                                if (alwaysExtractProducts || !products || products.length === 0) {
                                    try {
                                        const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                                        const response = await fetch(pageUrl);
                                        if (response.ok) {
                                            const html = await response.text();
                                            const liveProducts = extractLiveProducts(html);
                                            // Always use live products if found (to get latest prices)
                                            if (liveProducts && liveProducts.length > 0) {
                                                products = liveProducts;
                                                console.log(`🛒 Extracted ${products.length} LIVE products from page for "${page.title}":`, products.map(p => `${p.name} - ₪${p.price}`));
                                            } else if (!page.products || page.products.length === 0) {
                                                // Fallback to metadata if live extraction failed
                                                products = page.products || [];
                                            }
                                        }
                                    } catch (error) {
                                        console.error(`Error extracting products for "${page.title}":`, error);
                                        // Fallback to metadata if extraction fails
                                        if (!products || products.length === 0) {
                                            products = page.products || [];
                                        }
                                    }
                                }
                                
                                // Add page to matching pages for body
                                const phone = page.phone || null;
                                const phones = page.phones || [];
                                const email = page.email || null;
                                const city = page.city || null;
                                const address = page.address || null;
                                
                                matchingPagesForBody.push({
                                    title: page.title,
                                    type: page.pageType || 'unknown',
                                    userId: page.userId,
                                    pageId: page.pageId,
                                    description: page.description || '',
                                    url: `/users/${page.userId}/${page.pageId}_html`,
                                    phone: phone,
                                    phones: phones,
                                    email: email,
                                    city: city,
                                    address: address,
                                    products: products.map(prod => ({ name: prod.name, price: prod.price }))
                                });
                                
                                console.log(`✅ Found matching page for body: ${page.title} (${products.length} products)`);
                            }
                        }
                        
                        if (matchingPagesForBody.length > 0) {
                            console.log(`📋 Found ${matchingPagesForBody.length} matching pages for body`);
                        }
                    }
                    
                    // Prepare pages to send - ALWAYS send ALL pages to N8N so it knows what exists
                    // CRITICAL: Include REAL contact info (phone, city, address) so N8N can use REAL data
                    let pagesToSend = [];
                    if (botResponse && botResponse.type === 'pages' && botResponse.pages && botResponse.pages.length > 0) {
                        // Send the actual found pages WITH REAL CONTACT INFO
                        pagesToSend = botResponse.pages.slice(0, 20).map(p => {
                            // Use metadata FIRST, fallback to liveContactInfo
                            const phone = p.phone || (p.liveContactInfo && p.liveContactInfo.phone) || null;
                            const phones = p.phones || (p.liveContactInfo && p.liveContactInfo.phones) || [];
                            const email = p.email || (p.liveContactInfo && p.liveContactInfo.email) || null;
                            const city = p.city || (p.liveContactInfo && p.liveContactInfo.city) || null;
                            const address = p.address || (p.liveContactInfo && p.liveContactInfo.address) || null;
                            const products = p.products || p.liveProducts || [];
                            
                            return {
                                title: p.title,
                                type: p.pageType || 'unknown',
                                userId: p.userId,
                                pageId: p.pageId,
                                description: p.description || '',
                                url: `/users/${p.userId}/${p.pageId}_html`,
                                // Include REAL contact info (from metadata or live data)
                                phone: phone,
                                phones: phones,
                                email: email,
                                city: city,
                                address: address,
                                products: products.map(prod => ({ name: prod.name, price: prod.price }))
                            };
                        });
                        console.log(`📤 Sending ${pagesToSend.length} found pages to N8N WITH REAL CONTACT INFO`);
                    } else {
                        // No specific results OR general question - send ALL pages to N8N so it knows what exists
                        // CRITICAL: Always send all pages, not just 20, so N8N has full context
                        if (allPages && allPages.length > 0) {
                            pagesToSend = allPages.map(p => {
                                const phone = p.phone || null;
                                const phones = p.phones || [];
                                const email = p.email || null;
                                const city = p.city || null;
                                const address = p.address || null;
                                const products = p.products || [];
                                
                                return {
                                    title: p.title,
                                    type: p.pageType || 'unknown',
                                    userId: p.userId,
                                    pageId: p.pageId,
                                    description: p.description || '',
                                    url: `/users/${p.userId}/${p.pageId}_html`,
                                    // Include REAL contact info from metadata
                                    phone: phone,
                                    phones: phones,
                                    email: email,
                                    city: city,
                                    address: address,
                                    products: products.map(prod => ({ name: prod.name, price: prod.price }))
                                };
                            });
                            console.log(`📤 Sending ALL ${pagesToSend.length} pages to N8N WITH REAL CONTACT INFO`);
                        } else {
                            console.error('❌ ERROR: allPages is still empty! Cannot send pages to N8N.');
                        }
                    }
                    
                    // If service provider question, filter to service providers WITH REAL CONTACT INFO
                        if (isServiceProviderQuestion && allPages) {
                            const serviceProviderPages = allPages.filter(p => p.pageType === 'serviceProvider');
                            console.log(`🔧 Found ${serviceProviderPages.length} service provider pages to send to N8N`);
                        pagesToSend = serviceProviderPages.slice(0, 20).map(p => {
                            const phone = p.phone || null;
                            const phones = p.phones || [];
                            const email = p.email || null;
                            const city = p.city || null;
                            const address = p.address || null;
                            const products = p.products || [];
                            
                            return {
                                title: p.title,
                                type: p.pageType || 'serviceProvider',
                                userId: p.userId,
                                pageId: p.pageId,
                                description: p.description || '',
                                url: `/users/${p.userId}/${p.pageId}_html`,
                                // Include REAL contact info from metadata
                                phone: phone,
                                phones: phones,
                                email: email,
                                city: city,
                                address: address,
                                products: products.map(prod => ({ name: prod.name, price: prod.price }))
                            };
                        });
                        console.log(`📤 Sending ${pagesToSend.length} service provider pages WITH REAL CONTACT INFO`);
                        }
                        
                        // 🎯 IMPROVED: If we found matching pages for body, include them even if pagesToSend is empty
                        // This ensures N8N always gets relevant pages for marketplace queries like "נגר", "לק", "צעצועים"
                        if (matchingPagesForBody.length > 0 && pagesToSend.length === 0) {
                            console.log(`📋 Using ${matchingPagesForBody.length} matching pages for body instead of empty pagesToSend`);
                            pagesToSend = matchingPagesForBody;
                        }
                        
                        console.log('📤 Sending to N8N:', {
                            message: userMessage,
                            context: 'stav-marketplace',
                            hasPages: (allPages?.length || 0) > 0,
                            pagesCount: allPages?.length || 0,
                        foundPagesCount: botResponse && botResponse.type === 'pages' ? (botResponse.pages?.length || 0) : 0,
                        pagesToSend: pagesToSend.length,
                        matchingPagesForBody: matchingPagesForBody.length,
                        isServiceProviderQuestion: isServiceProviderQuestion,
                        pagesToSendSample: pagesToSend.slice(0, 3).map(p => ({ title: p.title, type: p.type, city: p.city }))
                        });
                        
                        // 🧠 Get conversation history (last 6 messages for context)
                        const conversationHistory = window.stavConversationContext?.conversationHistory?.slice(-6) || [];
                        console.log('🧠 Sending conversation history:', conversationHistory.length, 'messages');
                        
                        // 🧠 Get current page context
                        const currentPageContext = window.stavConversationContext?.currentPage || null;
                        if (currentPageContext) {
                            console.log('🧠 Current page context:', currentPageContext.title);
                        }
                        
                        const webhookResponse = await fetch(webhookUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                message: userMessage,
                                context: 'stav-marketplace',
                                conversationHistory: conversationHistory, // 🧠 Send last 6 messages for context
                                currentPage: currentPageContext, // 🧠 Send current displayed page
                                availablePages: allPages?.length || 0,
                                pages: pagesToSend.length > 0 ? pagesToSend : (matchingPagesForBody.length > 0 ? matchingPagesForBody : []), // 🎯 Use matching pages if pagesToSend is empty
                            foundPages: botResponse && botResponse.type === 'pages' ? botResponse.pages : [],
                            hasSearchResults: !!(botResponse && botResponse.type === 'pages' && botResponse.pages && botResponse.pages.length > 0) || matchingPagesForBody.length > 0,
                                serviceProviders: isServiceProviderQuestion ? (pagesToSend.length > 0 ? pagesToSend : matchingPagesForBody) : [],
                                matchingPages: matchingPagesForBody // 🎯 NEW: Include matching pages in body
                            })
                        });
                        
                        console.log('📥 N8N response status:', webhookResponse.status);
                        
                        if (webhookResponse.ok) {
                            const webhookData = await webhookResponse.json();
                            console.log('📥 N8N response data:', webhookData);
                            // Try multiple response formats
                            let responseMessage = webhookData.message || 
                                                   webhookData.response || 
                                                   webhookData.text || 
                                                   webhookData.output?.message ||
                                                   webhookData.output?.response ||
                                                   (typeof webhookData.output === 'string' ? webhookData.output : null) ||
                                                   (webhookData.data?.message) ||
                                                   'מצטער, לא הצלחתי לענות על זה. נסה לחפש משהו במרקטפלייס!';
                            
                            // Clean and translate to pure Hebrew - AGGRESSIVE cleaning
                            if (typeof responseMessage === 'string') {
                                // Split into sentences (by periods, exclamation marks, question marks, or line breaks)
                                const sentences = responseMessage.split(/[.!?\n]\s*/);
                                
                                // Filter: keep only sentences that contain Hebrew characters
                                const hebrewSentences = sentences.filter(sentence => {
                                    const trimmed = sentence.trim();
                                    if (!trimmed) return false; // Skip empty
                                    // Keep if contains Hebrew OR is just punctuation/emojis/numbers
                                    return /[א-ת]/.test(trimmed) || /^[\s\*\-\d\s\.\,\:\(\)😊💜✨🎯🏪💰⭐🏆👁️🔗📞📧📍🏙️🚀\-\s]+$/.test(trimmed);
                                });
                                
                                // Reconstruct message from Hebrew sentences only
                                responseMessage = hebrewSentences
                                    .map(s => s.trim())
                                    .filter(s => s.length > 0)
                                    .join('. ')
                                    .replace(/\.\s*\./g, '.') // Remove double periods
                                    .trim();
                                
                                // Additional cleanup - remove common English patterns anywhere in text
                                responseMessage = responseMessage
                                    .replace(/silently[^א-ת]*/gi, '')
                                    .replace(/The\s+user[^א-ת]*/gi, '')
                                    .replace(/for\s+the\s+[^א-ת\.]*/gi, '')
                                    .replace(/after\s+I['ve]*\s+[^א-ת\.]*/gi, '')
                                    .replace(/I['ve]*\s+tried[^א-ת\.]*/gi, '')
                                    .replace(/[A-Z][a-z]+\s+[^א-ת\.]{10,}/g, '') // Remove long English sentences
                                    .replace(/["'][^"']*["']/g, ''); // Remove quoted English text
                                
                                // Replace English/Arabic greetings with Hebrew
                                responseMessage = responseMessage
                                    .replace(/\bהיי\b/g, 'שלום')
                                    .replace(/\bhi\b/gi, 'שלום')
                                    .replace(/\bhello\b/gi, 'שלום')
                                    .replace(/\bhey\b/gi, 'שלום');
                                
                                // Final cleanup - remove any remaining English-only words/phrases
                                const words = responseMessage.split(/\s+/);
                                const hebrewWords = words.filter(word => {
                                    // Keep if contains Hebrew OR is punctuation/number/emoji
                                    return /[א-ת]/.test(word) || /^[\*\-\d\.\,\:\(\)😊💜✨🎯🏪💰⭐🏆👁️🔗📞📧📍🏙️\-\s]*$/.test(word);
                                });
                                responseMessage = hebrewWords.join(' ').trim();
                                
                                // Clean up multiple spaces and fix punctuation
                                responseMessage = responseMessage
                                    .replace(/\s+/g, ' ')
                                    .replace(/\s*([\.\,\:\!])\s*/g, '$1 ')
                                    .trim();
                                
                                // If result is empty or mostly English, don't use fallback - N8N should handle it
                                // Only use minimal fallback if completely empty
                                if (!responseMessage || responseMessage.length === 0) {
                                    // Try one more time to get response - maybe it's in a different format
                                    responseMessage = webhookData?.text || webhookData?.toString() || null;
                                }
                            }
                            
                            // Remove typing indicator right before displaying N8N response
                            const typingIndicator = document.getElementById('stav-typing-indicator');
                            if (typingIndicator) typingIndicator.remove();
                            
                            // ⚠️ IMPORTANT: Filter out invented contact info from N8N response
                            // N8N sometimes invents phone numbers, addresses, etc.
                            // We should only display REAL data from pages, not invented data
                            const hasInventedContactInfo = /(?:טלפון|טלפונים|📞|phone).*?(?:\d{3}[-.\s]?\d{3}[-.\s]?\d{4}|\d{10})/.test(responseMessage) ||
                                                         /(?:כתובת|address|🏠).*?(?:רחוב|street|בית)/i.test(responseMessage) ||
                                                         /(?:אימייל|email|📧).*?@/.test(responseMessage);
                            
                            // 🎯 FIX: Check if N8N response has missing prices - improved pattern matching
                            // Match patterns like: "מוצר - *" or "מוצר -" or "מוצר - *" or "* מוצר - *"
                            const hasMissingPrices = /[א-ת]+\s*-\s*\*\s*$/.test(responseMessage) ||  // "מוצר - *"
                                                     /[א-ת]+\s*-\s*\*/.test(responseMessage) ||      // "מוצר - *"
                                                     /[א-ת]+\s*-\s*$/.test(responseMessage) ||         // "מוצר -" (end of line)
                                                     /\*\s*[א-ת]+\s*-\s*\*/.test(responseMessage) ||  // "* מוצר - *"
                                                     /\*\s*[א-ת]+\s*-\s*$/.test(responseMessage);       // "* מוצר -"
                            
                            // If N8N returned pages to display, ALWAYS use displayPageOptions with REAL data
                            // Don't display N8N's text if it contains invented contact info OR missing prices
                            if (webhookData && webhookData.pages && Array.isArray(webhookData.pages) && webhookData.pages.length > 0) {
                                console.log('📄 N8N returned pages - using displayPageOptions with REAL data');
                                console.log('🔍 Checking for missing prices:', hasMissingPrices);
                                
                                // 🎯 IMPORTANT: Save pages to context so "כן" will work!
                                window.stavCurrentPages = webhookData.pages;
                                console.log('💾 Saved', webhookData.pages.length, 'pages from N8N to context');
                                
                                // 🎯 FIX: Check if user asked for price list - if so, DON'T show page buttons!
                                const userAskedForPriceList = window.lastUserMessage && (
                                    /(?:מחירים|מחיר|רשימת)\s+(?:של\s+)?[א-ת]+/.test(window.lastUserMessage.toLowerCase()) ||
                                    window.lastUserMessage.toLowerCase().includes('רשימת מחירים') ||
                                    window.lastUserMessage.toLowerCase().includes('רשימת מוצרים') ||
                                    window.lastUserMessage.toLowerCase().includes('תראי מוצרים') ||
                                    window.lastUserMessage.toLowerCase().includes('תראי מחירים') ||
                                    window.lastUserMessage.toLowerCase().includes('מוצרים ומחירים')
                                );
                                
                                if (userAskedForPriceList) {
                                    console.log('💰 User asked for price list - showing ONLY text with prices, NO page buttons');
                                    // Just show text response with prices, no buttons
                                    const textResponse = await generateTextResponseWithRealData(webhookData.pages, window.lastUserMessage, false);
                                    if (textResponse && textResponse.trim().length > 0) {
                                        addStavMessage(textResponse, false);
                                    }
                                } else {
                                // Display pages with REAL data from metadata/HTML (not invented)
                                // If N8N has missing prices, don't show its text - displayPageOptions will show correct prices
                                // 🎯 FIX: Pass userMessage to detect if user wants full price list
                                const messageToPass = hasMissingPrices ? null : (window.lastUserMessage || userMessage || responseMessage);
                                console.log('📤 Passing message to displayPageOptions:', messageToPass, 'hasMissingPrices:', hasMissingPrices);
                                await displayPageOptions(webhookData.pages, messageToPass);
                                }
                                
                                // 🎯 REMOVED: Don't let N8N automatically show preview
                                // Preview should ONLY be shown when user explicitly requests it
                                // by saying "תראה לי את האתר" or similar
                                console.log('ℹ️ N8N sent pages, but NOT showing preview automatically (user must request)');
                                stavFirstReplySent = true;
                            } else if (responseMessage && responseMessage.length > 0 && !hasInventedContactInfo) {
                                // 🎯 FIX: Check if user asked for price list - if so, ALWAYS show pages with prices!
                                const userAskedForPriceList = window.lastUserMessage && (
                                    window.lastUserMessage.toLowerCase().includes('רשימת מחירים') ||
                                    window.lastUserMessage.toLowerCase().includes('רשימת מוצרים') ||
                                    window.lastUserMessage.toLowerCase().includes('תראי מוצרים') ||
                                    window.lastUserMessage.toLowerCase().includes('תראי מחירים') ||
                                    window.lastUserMessage.toLowerCase().includes('מוצרים ומחירים') ||
                                    (window.lastUserMessage.toLowerCase().includes('תראי') && 
                                     (window.lastUserMessage.toLowerCase().includes('מוצר') || window.lastUserMessage.toLowerCase().includes('מחיר'))) ||
                                    window.lastUserMessage.toLowerCase().includes('מחירים של') ||
                                    window.lastUserMessage.toLowerCase().includes('כל המחירים') ||
                                    window.lastUserMessage.toLowerCase().includes('כל המוצרים')
                                );
                                
                                // 🎯 FIX: Check if N8N response has missing prices - improved pattern matching
                                const hasMissingPricesInText = /[א-ת]+\s*-\s*\*\s*$/.test(responseMessage) ||  // "מוצר - *"
                                                                /[א-ת]+\s*-\s*\*/.test(responseMessage) ||      // "מוצר - *"
                                                                /[א-ת]+\s*-\s*$/.test(responseMessage) ||         // "מוצר -" (end of line)
                                                                /\*\s*[א-ת]+\s*-\s*\*/.test(responseMessage) ||  // "* מוצר - *"
                                                                /\*\s*[א-ת]+\s*-\s*$/.test(responseMessage) ||   // "* מוצר -"
                                                                /אין.*מחיר/i.test(responseMessage) ||              // "אין מחירים"
                                                                /לא.*מחיר/i.test(responseMessage);                // "לא מחירים"
                                
                                // 🎯 FIX: If user asked for price list OR N8N says no prices, show pages with prices anyway!
                                if (userAskedForPriceList || hasMissingPricesInText) {
                                    console.log('🔍 User asked for price list or N8N says no prices - showing pages with REAL prices');
                                    console.log('🔍 userAskedForPriceList:', userAskedForPriceList, 'hasMissingPricesInText:', hasMissingPricesInText);
                                    console.warn('⚠️ N8N response has missing prices - will extract and display from LIVE data');
                                    console.log('🔍 Response message:', responseMessage);
                                    console.log('🔍 All pages:', (allPages || []).map(p => p.title));
                                    
                                    // Try to find pages mentioned in the response and display them with REAL prices
                                    const pageTitlesMentioned = (allPages || []).filter(p => {
                                        const titleInMessage = responseMessage.includes(p.title);
                                        console.log(`🔍 Checking "${p.title}": ${titleInMessage}`);
                                        return titleInMessage;
                                    });
                                    
                                    console.log(`📋 Found ${pageTitlesMentioned.length} pages mentioned in response`);
                                    
                                    if (pageTitlesMentioned.length > 0) {
                                        console.log('✅ Displaying pages with REAL prices - TEXT ONLY (no buttons):', pageTitlesMentioned.map(p => p.title));
                                        
                                        // 🎯 IMPORTANT: Save pages to context so "כן" will work!
                                        window.stavCurrentPages = pageTitlesMentioned;
                                        console.log('💾 Saved', pageTitlesMentioned.length, 'pages to context from N8N text response');
                                        
                                        // 🎯 Show ONLY text - NO buttons!
                                        const input = document.getElementById('stavChatInput');
                                        const currentUserMessage = input ? input.value.trim() : (window.lastUserMessage || null);
                                        // 🎯 Check if user wants link
                                        const includeLinks = currentUserMessage && /תראה.*אתר|תראה.*דף|קישור|פתח.*אתר|לינק|link/i.test(currentUserMessage);
                                        const textResponse = await generateTextResponseWithRealData(pageTitlesMentioned, currentUserMessage || 'רשימת מחירים', includeLinks);
                                        if (textResponse && textResponse.trim().length > 0) {
                                            addStavMessage(textResponse, false);
                                        }
                                    } else {
                                        // Can't find pages - try to search by keywords from user's query
                                        // Extract keywords from user's message (e.g., "צעצועים", "חלפים", etc.)
                                        const userMessageWords = (window.lastUserMessage || '').toLowerCase().split(/\s+/);
                                        const commonKeywords = ['צעצוע', 'צעצועים', 'חלפים', 'שעון', 'שעונים', 'לק', 'מניקור', 'נגר', 'נגרות', 'אינסטלטור'];
                                        const searchKeywords = [];
                                        
                                        // Add keywords from user's message
                                        userMessageWords.forEach(word => {
                                            if (commonKeywords.some(kw => word.includes(kw) || kw.includes(word))) {
                                                searchKeywords.push(word);
                                            }
                                        });
                                        
                                        // Add default keywords if none found
                                        if (searchKeywords.length === 0) {
                                            searchKeywords.push(...['צעצוע', 'חלפים', 'שעון']);
                                        }
                                        
                                        console.log('🔍 Searching pages by keywords:', searchKeywords);
                                        
                                        const pagesByKeywords = (allPages || []).filter(p => 
                                            searchKeywords.some(keyword => 
                                                p.title.toLowerCase().includes(keyword.toLowerCase()) ||
                                                (p.description && p.description.toLowerCase().includes(keyword.toLowerCase()))
                                            )
                                        );
                                        
                                        if (pagesByKeywords.length > 0) {
                                            console.log('✅ Found pages by keywords:', pagesByKeywords.map(p => p.title));
                                            // 🎯 FIX: Get userMessage from window context
                                            const currentUserMessage = window.lastUserMessage || 'רשימת מחירים';
                                            await displayPageOptions(pagesByKeywords, currentUserMessage);
                                        } else {
                                            // Still can't find - search for all store pages
                                            const allStorePages = (allPages || []).filter(p => p.pageType === 'store');
                                            if (allStorePages.length > 0) {
                                                console.log('✅ Found store pages:', allStorePages.map(p => p.title));
                                                // 🎯 FIX: Get userMessage from window context
                                                const currentUserMessage = window.lastUserMessage || 'רשימת מחירים';
                                                await displayPageOptions(allStorePages, currentUserMessage);
                                            } else {
                                                // Still can't find - show a helpful message
                                                console.warn('⚠️ Could not find pages mentioned in response');
                                                addStavMessage('אני עובדת על להביא לך את כל המחירים... 😊', false);
                                            }
                                        }
                                    }
                                } else if (!userAskedForPriceList) {
                                    // Only display N8N response if it doesn't contain invented contact info OR missing prices
                                    // AND user didn't ask for price list
                                    addStavMessage(responseMessage, false);
                                } else {
                                    // User asked for price list but we couldn't find pages - show N8N response anyway
                                    console.warn('⚠️ User asked for price list but could not find pages');
                                    addStavMessage(responseMessage, false);
                                }
                                stavFirstReplySent = true;
                            } else if (responseMessage && responseMessage.length > 0 && hasInventedContactInfo) {
                                // N8N response contains invented contact info - filter it out
                                console.warn('⚠️ N8N response contains invented contact info - filtering out');
                                // Remove phone numbers, addresses, emails from response
                                let filteredMessage = responseMessage
                                    .replace(/(?:טלפון|טלפונים|📞|phone).*?(?:\d{3}[-.\s]?\d{3}[-.\s]?\d{4}|\d{10})/gi, '')
                                    .replace(/(?:כתובת|address|🏠).*?(?:רחוב|street|בית)[^\.]*/gi, '')
                                    .replace(/(?:אימייל|email|📧)[^\.]*/gi, '')
                                    .replace(/\*\*כתובת[^:]*:[^\.]*/gi, '')
                                    .replace(/\*\*טלפון[^:]*:[^\.]*/gi, '')
                                    .replace(/\*\*אימייל[^:]*:[^\.]*/gi, '')
                                    .replace(/\s+/g, ' ')
                                    .trim();
                                
                                if (filteredMessage && filteredMessage.length > 10) {
                                    addStavMessage(filteredMessage, false);
                                    stavFirstReplySent = true;
                                } else {
                                    // Response was mostly invented contact info - don't display it
                                    console.warn('⚠️ N8N response was mostly invented contact info - skipping display');
                                    stavFirstReplySent = true;
                                }
                            }
                        } else {
                            // webhookResponse is not ok - handle error
                            const errorText = await webhookResponse.text().catch(() => '');
                            console.error('❌ N8N webhook error:', webhookResponse.status, errorText);
                            // Remove typing indicator on error
                            const typingIndicator = document.getElementById('stav-typing-indicator');
                            if (typingIndicator) typingIndicator.remove();
                            // Only minimal error message - no fallback
                            addStavMessage('אופס, יש בעיה עם השרת. נסה/י שוב בעוד רגע 😊', false);
                            stavFirstReplySent = true;
                        }
                    } catch (webhookError) {
                        console.error('❌ Webhook error:', webhookError);
                        console.error('Error details:', webhookError.message, webhookError.stack);
                        // Remove typing indicator on error
                        const typingIndicator = document.getElementById('stav-typing-indicator');
                        if (typingIndicator) typingIndicator.remove();
                        // Only minimal error message - no fallback
                        addStavMessage('אופס, יש בעיה עם החיבור. נסה/י שוב בעוד רגע 😊', false);
                        stavFirstReplySent = true;
                }
                    
                    // No more built-in responses - everything goes through N8N
                
            } catch (error) {
                console.error('❌ Error processing Stav message:', error);
                console.error('❌ Error type:', error.name);
                console.error('❌ Error message:', error.message);
                console.error('❌ Error stack:', error.stack);
                
                // Remove typing indicator (safely)
                const typingIndicator = document.getElementById('stav-typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                } else {
                    // Fallback: remove by text content
                const messagesDiv = document.getElementById('stavChatMessages');
                const lastMessage = messagesDiv.lastElementChild;
                    if (lastMessage && (lastMessage.textContent.includes('מקלידה') || lastMessage.id === 'stav-typing-indicator')) {
                    lastMessage.remove();
                    }
                }
                
                // 🎯 More specific error messages
                let errorMessage = 'אופס, משהו השתבש. נסה שוב.';
                
                if (error.name === 'TypeError' || error.message.includes('fetch')) {
                    errorMessage = 'בעיה בחיבור לשרת. בדוק את האינטרנט ונסה שוב.';
                } else if (error.message.includes('API') || error.message.includes('TTS')) {
                    errorMessage = 'בעיה עם שירות הדיבור. ההודעה תוצג בטקסט בלבד.';
                } else if (error.message.includes('timeout')) {
                    errorMessage = 'השרת לא הגיב. נסה שוב בעוד רגע.';
                }
                
                addStavMessage(errorMessage, false);
            }
        }

        function addStavMessage(message, isUser = false) {
            const messagesDiv = document.getElementById('stavChatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `stav-message ${isUser ? 'user' : 'bot'}`;
            
            // Remove emojis, asterisks, excessive punctuation, parentheses, dots, and HTML
            const cleanMessage = message
                .replace(/<[^>]*>/g, '') // Remove ALL HTML tags
                .replace(/&[^;]+;/g, '') // Remove HTML entities
                .replace(/[😊💡📍📞📧🏠💰✅❌🔗📄🏪🎉🎓🔧👁️🎯🔍📚📝🔊🎤🔴]/g, '')
                .replace(/\*\*/g, '')
                .replace(/\*/g, '')
                .replace(/\([^)]*\)/g, '') // Remove parentheses and content
                .replace(/\.{2,}/g, '') // Remove multiple dots
                .replace(/!+/g, '.') // Replace multiple ! with single .
                .replace(/\s+/g, ' ') // Replace multiple spaces with single
                .trim();
            
            // 🧠 Save to conversation history (keep last 10 messages for context)
            if (!window.stavConversationContext) {
                window.stavConversationContext = { conversationHistory: [] };
            }
            window.stavConversationContext.conversationHistory.push({
                role: isUser ? 'user' : 'assistant',
                content: cleanMessage,
                timestamp: Date.now()
            });
            // Keep only last 10 messages
            if (window.stavConversationContext.conversationHistory.length > 10) {
                window.stavConversationContext.conversationHistory = 
                    window.stavConversationContext.conversationHistory.slice(-10);
            }
            
            // If bot message, add avatar image
            if (!isUser) {
                const avatar = document.createElement('img');
                avatar.src = '/stav-avatar.png';
                avatar.alt = 'סתיו';
                avatar.className = 'bot-avatar';
                avatar.onerror = function() { this.style.display = 'none'; };
                
                const textDiv = document.createElement('div');
                textDiv.className = 'bot-text';
                textDiv.textContent = cleanMessage;
                
                messageDiv.appendChild(textDiv);
                messageDiv.appendChild(avatar);
            } else {
                messageDiv.textContent = cleanMessage;
            }
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // If this is a bot message AND user used voice input, speak it
            if (!isUser && cleanMessage && lastInputWasVoice) {
                setTimeout(() => {
                    speakText(cleanMessage);
                    // Reset voice flag after speaking starts (ready for next input)
                    lastInputWasVoice = false;
                }, 300);
            } else if (!isUser) {
                // Bot message but user didn't use voice - reset flag
                lastInputWasVoice = false;
            }
        }
        
        // Generate dialogue before showing results - asks clarifying questions
        function generateDialogueBeforeShowing(pages, userQuery) {
            if (!pages || pages.length === 0) return null;
            
            const query = userQuery.toLowerCase();
            const hasMultipleOptions = pages.length > 1;
            
            // If query is vague and has multiple results, ask clarifying question
            if (hasMultipleOptions && (
                query.includes('מתנה') || 
                query.includes('משהו') || 
                query.includes('מוצר') || 
                query.length < 10
            )) {
                const firstPage = pages[0];
                return `מצאתי לך ${pages.length} אפשרויות מעולות! 🎯\n\nלמשל: **${firstPage.title}** ${firstPage.description ? `- ${firstPage.description.substring(0, 60)}...` : ''}\n\nמה בדיוק את/ה מחפש/ת? (מוצר ספציפי, מחיר, מיקום, וכו') 😊`;
            }
            
            // If query is about specific business, verify it's the right one
            const businessPattern = /(?:מה|איפה|איזה|של|את)\s+([א-ת]{2,})/;
            const businessMatch = userQuery.match(businessPattern);
            if (businessMatch && pages.length > 1) {
                const businessName = businessMatch[1].trim();
                const exactMatch = pages.find(p => p.title.toLowerCase().includes(businessName.toLowerCase()));
                if (exactMatch) {
                    return null; // Already have exact match, show it directly
                }
            }
            
            return null; // No dialogue needed
        }
        
        // Generate smart recommendations with selling points
        function generateSmartRecommendation(pages, userQuery) {
            if (!pages || pages.length === 0) return null;
            
            const topPage = pages[0];
            const query = userQuery.toLowerCase();
            
            let recommendation = '';
            
            // Detect user intent
            const isCarProblem = query.includes('רכב') || query.includes('הלך') || query.includes('קלקול') || query.includes('תקלה');
            const isGift = query.includes('מתנה') || query.includes('מתנות');
            const isService = query.includes('שירות') || query.includes('צריך');
            const isPriceSearch = query.includes('כמה') || query.includes('מחיר') || query.includes('₪');
            
            // Build smart recommendation based on intent
            if (isCarProblem) {
                recommendation = `🔧 **המלצה שלי:** ${topPage.title} נראה הכי מתאים לבעיה שלך! `;
                if (topPage.liveProducts && topPage.liveProducts.length > 0) {
                    const carProducts = topPage.liveProducts.filter(p => 
                        p.name.toLowerCase().includes('חלף') || 
                        p.name.toLowerCase().includes('פנס') || 
                        p.name.toLowerCase().includes('מצבר') ||
                        p.name.toLowerCase().includes('בלם') ||
                        p.name.toLowerCase().includes('צמיג')
                    );
                    if (carProducts.length > 0) {
                        recommendation += `יש להם ${carProducts.length} מוצרים רלוונטיים לבעיה שלך, כולל: ${carProducts.slice(0, 2).map(p => p.name).join(', ')}. `;
                    }
                }
                if (topPage.liveContactInfo && topPage.liveContactInfo.phone) {
                    recommendation += `📞 **טלפון:** ${topPage.liveContactInfo.phone} - אתה יכול להתקשר עכשיו!`;
                }
            } else if (isGift) {
                recommendation = `🎁 **המלצה מושלמת:** ${topPage.title} מציעים מתנות מעולות! `;
                if (topPage.liveProducts && topPage.liveProducts.length > 0) {
                    const cheapest = topPage.liveProducts.reduce((min, p) => p.price < min.price ? p : min, topPage.liveProducts[0]);
                    const expensive = topPage.liveProducts.reduce((max, p) => p.price > max.price ? p : max, topPage.liveProducts[0]);
                    recommendation += `יש להם ${topPage.liveProducts.length} מוצרים, מתחיל מ-₪${cheapest.price} ועד ₪${expensive.price}. `;
                }
                if (pages.length > 1) {
                    recommendation += `💡 **טיפ:** יש עוד ${pages.length - 1} עסקים שאפשר להשוות - תראה את כל האופציות למטה!`;
                }
            } else if (isPriceSearch) {
                recommendation = `💰 **המחירים הטובים ביותר:** `;
                const prices = pages.slice(0, 3).flatMap(p => 
                    (p.liveProducts || []).map(prod => ({ page: p.title, product: prod.name, price: prod.price }))
                ).sort((a, b) => a.price - b.price).slice(0, 3);
                
                if (prices.length > 0) {
                    prices.forEach((item, idx) => {
                        recommendation += `${idx + 1}. ${item.product} ב-${item.page} - ₪${item.price} | `;
                    });
                    recommendation = recommendation.slice(0, -3) + '.';
                }
            } else {
                // General recommendation - friendlier tone
                recommendation = `✨ **מצאתי לך משהו מעולה!** ${topPage.title} נראה הכי מתאים למה שאת/ה מחפש/ת! `;
                if (topPage.description) {
                    recommendation += `${topPage.description.substring(0, 80)}... `;
                }
                if (topPage.liveContactInfo && topPage.liveContactInfo.city) {
                    recommendation += `📍 ממוקם ב-${topPage.liveContactInfo.city}. `;
                }
                if (topPage.liveProducts && topPage.liveProducts.length > 0) {
                    recommendation += `יש להם ${topPage.liveProducts.length} מוצרים זמינים עכשיו! 😊`;
                }
            }
            
            return recommendation || null;
        }
        
        // 🎯 NEW: Generate text response with REAL data from pages
        async function generateTextResponseWithRealData(pages, userMessage, includeLinks = false, showFullDescription = false) {
            if (!pages || pages.length === 0) return '';
            
            let textResponse = '';
            const pageCount = Math.min(pages.length, 5); // Limit to top 5
            
            // 🎯 Check if user is asking to see website/link
            const userWantsLink = includeLinks || (userMessage && (
                /תראה.*אתר|תראה.*דף|תראי.*אתר|תראי.*דף|הראה.*אתר|לראות.*אתר|אפשר.*אתר|קישור|פתח.*אתר|לינק|link|אתר.*של|לדף.*של|פתיחת.*אתר|תראו.*אתר|הצג.*אתר/i.test(userMessage)
            ));
            
            // 🎯 NEW: Check if user explicitly asked for product list (show ALL products, not summary)
            const userAskedForProductList = userMessage && (
                /תני?.*רשימת.*מוצרים|תני?.*את.*רשימת.*מוצרים|תראי.*מוצרים|תראי.*מחירים|רשימת.*מחירים|מוצרים.*ומחירים|הראי.*מוצרים|(?:ה)?מחירים\s+של|מה.*המוצרים|איזה.*מוצרים|כל.*המוצרים/i.test(userMessage)
            );
            
            // 🎯 NEW: Check if results are from different city than requested
            const notInRequestedCity = pages[0]?.notInRequestedCity;
            const requestedCity = pages[0]?.requestedCity;
            const actualCity = pages[0]?.actualCity;
            
            // 🎯 Check if user is asking for contact details specifically
            // 🔧 FIX: Don't match "מספרה" (hairdresser) as "מספר" (phone number)!
            // Only match "מספר" in context: "מספר טלפון", "מה המספר", "תן מספר" etc. NOT "מספרה"!
            const userWantsContactInfo = userMessage && (
                /טלפון|מספר\s+טלפון|מה\s+המספר|תן\s+מספר|איזה\s+מספר|המספר\s+של|איך לפנות|איך ליצור קשר|כתובת|מייל|פרטי קשר|פרטים נוספים|איך\s+מתקשרים/i.test(userMessage)
            );
            console.log(`🔍 [CONTACT INFO CHECK] userMessage: "${userMessage}", userWantsContactInfo: ${userWantsContactInfo}`);
            
            // Helper function: Convert number to Hebrew words
            const numberToHebrewWords = (num) => {
                const hebrewNumbers = {
                    2: 'שתי',
                    3: 'שלוש',
                    4: 'ארבע',
                    5: 'חמש',
                    6: 'שש',
                    7: 'שבע',
                    8: 'שמונה',
                    9: 'תשע',
                    10: 'עשר'
                };
                return hebrewNumbers[num] || num.toString(); // Fallback to number if > 10
            };
            
            // Friendly opening message - VERY SHORT and conversational
            if (notInRequestedCity && requestedCity) {
                // Results found, but not in requested city
                // 🎯 NEW: Get unique cities from results - check liveContactInfo too!
                const uniqueCities = [...new Set(pages.map(p => {
                    // Try multiple sources for city
                    return p.actualCity || 
                           p.city || 
                           (p.liveContactInfo && p.liveContactInfo.city) || 
                           null;
                }).filter(c => c && c !== 'לא ידוע' && c.trim().length > 0))];
                
                console.log('🏙️ Found unique cities:', uniqueCities);
                
                if (uniqueCities.length > 0) {
                    if (uniqueCities.length === 1) {
                        textResponse += `לא מצאתי ב${requestedCity}, אבל יש ב${uniqueCities[0]}:\n\n`;
                    } else {
                        textResponse += `לא מצאתי ב${requestedCity}, אבל יש ב${uniqueCities.slice(0, 3).join(', ')}:\n\n`;
                    }
                } else {
                    // No cities found - just say "but there is"
                    textResponse += `לא מצאתי ב${requestedCity}, אבל מצאתי:\n\n`;
                }
            }
            
            // 🎯 Build business list FIRST, then add header with correct count
            let businessListText = ''; // Temporary storage for business list
            let successCount = 0; // Count only pages that successfully loaded
            let firstSuccessfulPageTitle = ''; // Track first successful page name
            
            // For each page, extract REAL data and format as text
            for (let i = 0; i < pageCount; i++) {
                const page = pages[i];
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                
                try {
                    // Fetch live data
                    const pageResponse = await fetch(pageUrl);
                    if (!pageResponse.ok) {
                        console.log(`⚠️ Failed to fetch page: ${page.title}`);
                        continue;
                    }
                    
                    const html = await pageResponse.text();
                    const contactInfo = extractLiveContactInfo(html);
                    const products = extractLiveProducts(html);
                    
                    successCount++; // Increment only for successful pages
                    if (successCount === 1) {
                        firstSuccessfulPageTitle = page.title; // Save first successful page name
                    }
                    
                    // Build text response - SUPER SHORT like talking to a friend
                    if (pageCount === 1) {
                        // Single result - name is already in "מצאתי את X"
                        // Only show description if showFullDescription is true (e.g., after user says "yes")
                        if (showFullDescription) {
                            const liveDesc = extractLiveDescription(html);
                            if (liveDesc && liveDesc.length > 0) {
                                businessListText += `${liveDesc}\n`;
                            }
                        }
                    } else {
                        // Multiple results - numbered list of names ONLY (no description!)
                        businessListText += `${successCount}. ${page.title}`; // Use successCount for correct numbering
                        
                        // 🎯 NO DESCRIPTION! Keep it super clean and simple.
                        // User complained: "למה המלה מגוון" - they don't want verbose descriptions
                    }
                    
                    businessListText += `\n`;
                    
                    // 🎯 ONLY show contact info if user specifically asked for it
                    if (userWantsContactInfo) {
                        let contactLine = [];
                        if (contactInfo.phone) {
                            contactLine.push(contactInfo.phone);
                        }
                        if (contactInfo.city && !businessListText.includes(contactInfo.city)) {
                            contactLine.push(contactInfo.city);
                        }
                        if (contactLine.length > 0) {
                            businessListText += `   ${contactLine.join(', ')}\n`;
                        }
                    }
                    
                    // 🎯 ONLY show products if user explicitly asked for them or for product list
                    if (userAskedForProductList && products && products.length > 0) {
                        // 🎯 FIX: Filter products by category if user specified one
                        let filteredProducts = [...products];
                        const lowerMessage = userMessage ? userMessage.toLowerCase() : '';
                        
                        // Extract category from query (e.g., "מחירים של בובות" → "בובות")
                        const categoryMatch = lowerMessage.match(/(?:מחירים|מחיר|רשימת)\s+(?:של\s+)?([א-ת]+)/);
                        if (categoryMatch && categoryMatch[1]) {
                            const requestedCategory = categoryMatch[1];
                            console.log(`🎯 Filtering products by category: "${requestedCategory}"`);
                            
                            // Filter products by category
                            filteredProducts = products.filter(product => {
                                const productNameLower = (product.name || '').toLowerCase();
                                
                                // Category-specific filters
                                if (requestedCategory === 'בובות' || requestedCategory === 'בובה') {
                                    return productNameLower.includes('בובה') || productNameLower.includes('בובת') || productNameLower.includes('doll');
                                } else if (requestedCategory === 'מכוניות' || requestedCategory === 'מכונית') {
                                    return productNameLower.includes('מכונית') || productNameLower.includes('רכב') || productNameLower.includes('car') || productNameLower.includes('מירוץ') || productNameLower.includes('מרוץ');
                                } else if (requestedCategory === 'צעצועים' || requestedCategory === 'צעצוע') {
                                    // צעצועים - הכל (don't filter)
                                    return true;
                                } else if (requestedCategory === 'שעונים' || requestedCategory === 'שעון') {
                                    return productNameLower.includes('שעון') || productNameLower.includes('watch');
                                } else if (requestedCategory === 'קוביות' || requestedCategory === 'קובייה') {
                                    return productNameLower.includes('קוב') || productNameLower.includes('קובי') || productNameLower.includes('cube');
                                } else if (requestedCategory === 'רובוט' || requestedCategory === 'רובוטים') {
                                    return productNameLower.includes('רובוט') || productNameLower.includes('robot');
                                } else {
                                    // Generic filter - check if product name includes category
                                    return productNameLower.includes(requestedCategory);
                                }
                            });
                            
                            if (filteredProducts.length === 0) {
                                console.log(`⚠️ No products found for category "${requestedCategory}", showing all`);
                                filteredProducts = [...products]; // Fallback to all if nothing found
                            } else {
                                console.log(`✅ Filtered to ${filteredProducts.length} products for category "${requestedCategory}"`);
                            }
                        }
                        
                        // Sort products by price
                        const sortedProducts = filteredProducts.sort((a, b) => {
                            const priceA = parseFloat(String(a.price || 0).replace(/[,\s]/g, ''));
                            const priceB = parseFloat(String(b.price || 0).replace(/[,\s]/g, ''));
                            return priceA - priceB;
                        });
                        
                        // Filter valid products
                        const validProducts = sortedProducts.filter(product => {
                            const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                            return price >= 10 && price < 100000;
                        });
                        
                        if (validProducts.length > 0) {
                            businessListText += `\nמוצרים:\n`;
                            validProducts.forEach((product) => {
                                const price = parseFloat(String(product.price || 0).replace(/[,\s]/g, ''));
                                businessListText += `   • ${product.name} - ₪${price.toLocaleString()}\n`;
                            });
                        }
                    }
                    
                    // 🎯 ONLY show link if user explicitly asked for it AND not showing preview
                    // (Don't show "click here" when iframe is already open!)
                    if (userWantsLink && includeLinks !== 'preview') {
                        businessListText += `🔗 [לחץ כאן לצפייה באתר](${pageUrl})\n`;
                    }
                    
                    businessListText += `\n`;
                } catch (error) {
                    console.error(`❌ Error generating text response for "${page.title}":`, error);
                }
            }
            
            // 🎯 Now add the correct header based on successCount, then add the business list
            if (successCount === 1) {
                textResponse += `מצאתי את ${firstSuccessfulPageTitle}.\n\n`;
            } else if (successCount > 1) {
                textResponse += `מצאתי ${numberToHebrewWords(successCount)} עסקים:\n`;
            }
            
            // Add the business list content
            textResponse += businessListText;
            
            // 🎯 Add SHORT friendly hint at the end - ONLY if NOT showing link/contact/products
            console.log('🔍 [HINT CHECK] userWantsLink:', userWantsLink, 'userWantsContactInfo:', userWantsContactInfo, 'userAskedForProductList:', userAskedForProductList, 'pageCount:', pageCount);
            if (!userWantsLink && !userWantsContactInfo && !userAskedForProductList && pageCount > 0) {
                if (pageCount > 1) {
                    textResponse += `\n\nאיזה דף תרצה לראות?`;
                    console.log('✅ Added hint: "איזה דף תרצה לראות?"');
                } else {
                    textResponse += `\n\nרוצה לראות את הדף?`;
                    console.log('✅ Added hint: "רוצה לראות את הדף?"');
                }
            } else {
                console.log('⚠️ Skipped hint - one of conditions failed');
            }
            
            return textResponse.trim();
        }
        
        // Display page options list (without previews) - ALWAYS fetch fresh data, ORGANIZED BY CATEGORIES
        // message can be the user's query to detect if they want full price list
        // showTextResponseFirst: if true, show text response with real data before buttons
        async function displayPageOptions(pages, message, showTextResponseFirst = false) {
            const messagesDiv = document.getElementById('stavChatMessages');
            
            // 🎯 FIX: If showTextResponseFirst is true, generate and show text response with real data FIRST
            if (showTextResponseFirst) {
                console.log('📝 Generating text response with real data first...');
                // 🎯 Check if user wants link
                const includeLinks = message && /תראה.*אתר|תראה.*דף|קישור|פתח.*אתר|לינק|link/i.test(message);
                const textResponse = await generateTextResponseWithRealData(pages, message, includeLinks);
                if (textResponse && textResponse.trim().length > 0) {
                    addStavMessage(textResponse, false);
                    console.log('✅ Added text response with real data');
                }
            }
            
            // 🎯 CRITICAL: ALWAYS fetch LIVE data from pages - NO cached metadata!
            // User requirement: "שום נתון לא מובנה הכל צריך להיות דינמי"
            // All data must be DYNAMIC from the actual live HTML pages
            console.log('🔍 ALWAYS fetching LIVE data (dynamic) for', pages.length, 'pages - NO cached metadata!');
            for (let i = 0; i < Math.min(pages.length, 5); i++) {
                const page = pages[i];
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                
                // 🎯 ALWAYS fetch live HTML and extract data dynamically (NO metadata!)
                let contactInfo = { phone: null, phones: [], email: null, city: null, address: null };
                let products = [];
                
                try {
                    console.log(`🔍 Fetching LIVE data for "${page.title}" from ${pageUrl}`);
                    const pageResponse = await fetch(pageUrl);
                    if (pageResponse.ok) {
                        const html = await pageResponse.text();
                        // Extract LIVE contact info from HTML (dynamic, not cached)
                        contactInfo = extractLiveContactInfo(html);
                        // Extract LIVE products from HTML (dynamic, not cached)
                        products = extractLiveProducts(html);
                        console.log(`✅ Extracted LIVE data for "${page.title}":`, {
                            phone: contactInfo.phone,
                            city: contactInfo.city,
                            productsCount: products.length
                        });
                    } else {
                        console.warn(`⚠️ Failed to fetch live data for "${page.title}"`);
                    }
                } catch (error) {
                    console.error(`❌ Error fetching live data for "${page.title}":`, error);
                }
                
                // Store live data in page object for later use
                pages[i].liveContactInfo = contactInfo;
                pages[i].liveProducts = products;
            }
            
            // 🎯 FIX: Sort pages by relevance score (if available) to show best recommendations first
            // Limit to top 5 pages for accurate recommendations (not all pages!)
            const sortedPages = [...pages].sort((a, b) => {
                // Sort by matchScore if available (from searchLivePages)
                const scoreA = a.matchScore || 0;
                const scoreB = b.matchScore || 0;
                if (scoreB !== scoreA) return scoreB - scoreA;
                
                // If same score, prefer pages with products
                const productsA = (a.liveProducts || []).length;
                const productsB = (b.liveProducts || []).length;
                if (productsB !== productsA) return productsB - productsA;
                
                // If same products count, prefer pages with contact info
                const contactA = (a.liveContactInfo?.phone ? 1 : 0) + (a.liveContactInfo?.city ? 1 : 0);
                const contactB = (b.liveContactInfo?.phone ? 1 : 0) + (b.liveContactInfo?.city ? 1 : 0);
                return contactB - contactA;
            });
            
            // Limit to top 5 pages for accurate recommendations
            const topPages = sortedPages.slice(0, 5);
            
            // Categorize top pages by type for better organization
            const categories = {
                stores: topPages.filter(p => p.pageType === 'store' || p.pageType === 'onlineStore'),
                services: topPages.filter(p => p.pageType === 'serviceProvider'),
                courses: topPages.filter(p => p.pageType === 'course'),
                events: topPages.filter(p => p.pageType === 'event'),
                other: topPages.filter(p => !['store', 'onlineStore', 'serviceProvider', 'course', 'event'].includes(p.pageType))
            };
            
            // Create options message with categories
            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'stav-message bot';
            optionsDiv.style.cssText = `
                background: #f3f4f6;
                border-radius: 12px;
                padding: 16px;
                margin: 12px 0;
            `;
            
            // 🎯 FIX: Show accurate count - only top 5 recommendations
            const totalPages = topPages.length;
            const messageText = message || (totalPages > 0 ? `המלצות מדויקות - מצאתי ${totalPages} ${totalPages === 1 ? 'דף' : 'דפים'} הכי רלוונטיים:` : 'לא מצאתי דפים רלוונטיים');
            let optionsHtml = `<div style="font-weight: 600; font-size: 16px; margin-bottom: 16px; color: #1f2937;">${messageText}</div>`;
            
            // Display by categories
            const categoryLabels = {
                stores: { emoji: '🏪', label: 'חנויות', pages: categories.stores },
                services: { emoji: '🔧', label: 'שירותים', pages: categories.services },
                courses: { emoji: '🎓', label: 'קורסים', pages: categories.courses },
                events: { emoji: '🎉', label: 'אירועים', pages: categories.events },
                other: { emoji: '📄', label: 'אחר', pages: categories.other }
            };
            
            // 🎯 FIX: Show only top 5 recommendations, not all pages (for accuracy!)
            let pageIndex = 0;
            const maxPagesToShow = 5; // Show only top 5 recommendations for accuracy
            
            Object.entries(categoryLabels).forEach(([key, category]) => {
                if (category.pages.length > 0 && pageIndex < maxPagesToShow) {
                    optionsHtml += `<div style="margin-bottom: 16px;">`;
                    // Show count only if there are more pages in this category than we're showing
                    const showingCount = Math.min(category.pages.length, maxPagesToShow - pageIndex);
                    const countText = category.pages.length > showingCount ? ` (${showingCount} מתוך ${category.pages.length})` : ` (${category.pages.length})`;
                    optionsHtml += `<div style="font-weight: 600; font-size: 14px; color: #667eea; margin-bottom: 8px;">${category.emoji} ${category.label}${countText}</div>`;
                    
                    category.pages.forEach((page) => {
                        if (pageIndex >= maxPagesToShow) return;
                        
                        const index = pageIndex++;
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                // ALWAYS use fresh live data (just fetched above, not invented)
                const contact = page.liveContactInfo || {};
                const products = page.liveProducts || [];
                
                optionsHtml += `<div style="background: white; border-radius: 8px; padding: 12px; margin: 8px 0; border: 1px solid #e5e7eb;">`;
                optionsHtml += `<div style="font-weight: 600; font-size: 16px; color: #1f2937; margin-bottom: 8px;">${index + 1}. ${page.title}</div>`;
                
                // Only show description if it's from the actual page metadata (not invented)
                // Don't show fake descriptions
                if (page.description && page.description.length > 0 && !page.description.includes('page')) {
                    optionsHtml += `<div style="color: #6b7280; font-size: 14px; margin-bottom: 8px;">${page.description.substring(0, 100)}${page.description.length > 100 ? '...' : ''}</div>`;
                }
                
                // Show contact info ONLY if available from REAL metadata (not invented)
                // NEVER show invented contact info - only show if we have REAL data
                const hasRealContactInfo = (contact.phone && contact.phone.length > 0) || 
                                          (contact.city && contact.city.length > 0) || 
                                          (contact.email && contact.email.length > 0 && contact.email.includes('@')) ||
                                          (contact.address && contact.address.length > 0);
                
                if (hasRealContactInfo) {
                    optionsHtml += `<div style="font-size: 13px; color: #1e40af; margin-top: 8px; font-weight: 600;">`;
                    if (contact.phone && contact.phone.length > 0) {
                        optionsHtml += `📞 ${contact.phone}`;
                        // Add clickable tel link
                        optionsHtml += ` <a href="tel:${contact.phone.replace(/-/g, '')}" style="background: #10b981; color: white; padding: 4px 8px; border-radius: 4px; text-decoration: none; margin-right: 4px; font-size: 11px;">📞 התקשר</a>`;
                    }
                    // Don't show additional phones - only show the main phone number
                    if (contact.city && contact.city.length > 0) {
                        optionsHtml += ` 📍 ${contact.city}`;
                    }
                    if (contact.email && contact.email.length > 0 && contact.email.includes('@')) {
                        optionsHtml += ` 📧 ${contact.email}`;
                    }
                    if (contact.address && contact.address.length > 0) {
                        optionsHtml += ` 🏠 ${contact.address}`;
                    }
                    optionsHtml += `</div>`;
                } else {
                    // No real contact info available - don't display anything (not even placeholder)
                    console.log(`⚠️ No real contact info for "${page.title}" - skipping display`);
                }
                
                // Show product count and highlights ONLY if available from live data (REAL products only)
                if (products && Array.isArray(products) && products.length > 0) {
                    // Validate products are real (have name and price)
                    const validProducts = products.filter(p => p && p.name && p.price && p.price > 0);
                    
                    if (validProducts.length > 0) {
                        // 🎯 FIX: Check if user asked for full price list - if so, show ALL products with prices
                        const messageToCheck = message || window.lastUserMessage || '';
                        const isPriceListQuery = messageToCheck && (
                            messageToCheck.toLowerCase().includes('רשימת מחירים') ||
                            messageToCheck.toLowerCase().includes('תראי מוצרים') ||
                            messageToCheck.toLowerCase().includes('תראי מחירים') ||
                            messageToCheck.toLowerCase().includes('מוצרים ומחירים') ||
                            (messageToCheck.toLowerCase().includes('תראי') && 
                             (messageToCheck.toLowerCase().includes('מוצר') || messageToCheck.toLowerCase().includes('מחיר'))) || 
                            messageToCheck.toLowerCase().includes('רשימת מוצרים') ||
                            messageToCheck.toLowerCase().includes('מחירים של') ||
                            messageToCheck.toLowerCase().includes('כל המחירים') ||
                            messageToCheck.toLowerCase().includes('כל המוצרים')
                        );
                        
                        console.log('🔍 Checking for price list query:', {
                            message: message,
                            lastUserMessage: window.lastUserMessage,
                            messageToCheck: messageToCheck,
                            isPriceListQuery: isPriceListQuery
                        });
                        
                        if (isPriceListQuery) {
                            // Show ALL products with prices (sorted by price)
                            const sortedByPrice = [...validProducts].sort((a, b) => {
                                const getNumericPrice = (price) => {
                                    if (typeof price === 'number') return price;
                                    const priceStr = String(price).replace(/[₪,\s]/g, '');
                                    const numPrice = parseFloat(priceStr) || 0;
                                    return numPrice;
                                };
                                return getNumericPrice(a.price) - getNumericPrice(b.price);
                            });
                            
                            optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 8px; margin-bottom: 8px;">💰 ${validProducts.length} מוצרים זמינים:</div>`;
                            optionsHtml += `<div style="margin-top: 4px; margin-bottom: 8px;">`;
                            sortedByPrice.forEach((product, idx) => {
                                optionsHtml += `<div style="font-size: 12px; color: #374151; margin-top: 4px; padding: 4px 0; border-bottom: 1px solid #e5e7eb;">
                                    <span style="font-weight: 600;">${idx + 1}.</span> ${product.name} - <span style="color: #059669; font-weight: 600;">₪${product.price}</span>
                                </div>`;
                            });
                            optionsHtml += `</div>`;
                            
                            // Still show cheapest as highlight
                            const cheapestProduct = sortedByPrice[0];
                            if (cheapestProduct && cheapestProduct.name && cheapestProduct.price) {
                                optionsHtml += `<div style="font-size: 12px; color: #059669; margin-top: 4px; font-weight: 600; padding: 4px 8px; background: #ecfdf5; border-radius: 4px; display: inline-block;">⭐ הכי זול: ${cheapestProduct.name} - ₪${cheapestProduct.price}</div>`;
                            }
                        } else {
                            // Normal display - show only cheapest product
                            optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 4px;">💰 ${validProducts.length} מוצרים זמינים</div>`;
                            
                            // Show cheapest product as selling point
                            // Sort by price (numeric) to find the ACTUAL cheapest
                            // 🎯 FIX: Always show cheapest, even if only 1 product
                            const sortedByPrice = [...validProducts].sort((a, b) => {
                                // Extract numeric price value - handle multiple formats
                                const getNumericPrice = (price) => {
                                    if (typeof price === 'number') return price;
                                    const priceStr = String(price).replace(/[₪,\s]/g, '');
                                    const numPrice = parseFloat(priceStr) || 0;
                                    return numPrice;
                                };
                                
                                const priceA = getNumericPrice(a.price);
                                const priceB = getNumericPrice(b.price);
                                return priceA - priceB;
                            });
                            
                            const cheapestProduct = sortedByPrice[0];
                            if (cheapestProduct && cheapestProduct.name && cheapestProduct.price) {
                                // 🎯 FIX: Always show cheapest product, even if only one product
                                optionsHtml += `<div style="font-size: 12px; color: #059669; margin-top: 4px; font-weight: 600;">⭐ הכי זול: ${cheapestProduct.name} - ₪${cheapestProduct.price}</div>`;
                            }
                        }
                    } else {
                        // No valid products found (empty array or invalid data)
                        optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 4px; font-style: italic;">💡 לחץ על "צפה בדף" כדי לראות פרטים נוספים</div>`;
                    }
                } else {
                    // No products array or empty - DON'T invent products
                    optionsHtml += `<div style="font-size: 13px; color: #9ca3af; margin-top: 4px; font-style: italic;">💡 לחץ על "צפה בדף" כדי לראות פרטים נוספים</div>`;
                }
                        
                        // Add selling point badges
                        if (pageIndex === 1) {
                            optionsHtml += `<div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; margin-top: 8px; display: inline-block;">🏆 מומלץ ביותר</div>`;
                        }
                        
                        // 🎯 FIX: User wants ONLY text conversation - NO preview buttons!
                        // Only show "צפה בדף" link
                        const fullPageUrl = `${window.location.origin}${pageUrl}`;
                        optionsHtml += `<div style="margin-top: 12px;">
                            <a href="${fullPageUrl}" target="_blank" style="
                                display: inline-block;
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                color: white;
                                padding: 8px 16px;
                                border-radius: 6px;
                                text-decoration: none;
                                font-weight: 600;
                                font-size: 14px;
                                cursor: pointer;
                            ">👁️ צפה בדף</a>
                        </div>`;
                        
                        optionsHtml += `</div>`;
                    });
                    
                    optionsHtml += `</div>`; // Close category section
                }
            });
            
            optionsDiv.innerHTML = optionsHtml;
            messagesDiv.appendChild(optionsDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // Store pages in window for preview function
            window.stavCurrentPages = pages;
        }
        
        // Open page preview when user clicks button
        function openPagePreview(index, userId, pageId) {
            const messagesDiv = document.getElementById('stavChatMessages');
            const pages = window.stavCurrentPages || [];
            
            if (pages[index]) {
                const page = pages[index];
                
                // Add confirmation message
                addStavMessage(`פותח את "${page.title}"...`, false);
                
                // Display the preview (async)
                setTimeout(async () => {
                    await displayPagePreview(page, 'stavChatMessages');
                }, 300);
            }
        }
        
        // Ask user if they want to see the website BEFORE showing it
        function askToShowWebsite(pages) {
            const messagesDiv = document.getElementById('stavChatMessages');
            
            const askDiv = document.createElement('div');
            askDiv.className = 'stav-message bot';
            askDiv.style.cssText = `
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border-radius: 12px;
                padding: 16px;
                margin: 12px 0;
            `;
            
            let askHtml = `<div style="font-weight: 600; font-size: 16px; margin-bottom: 12px;">👁️ האם תרצה לראות את הדף?</div>`;
            askHtml += `<div style="font-size: 14px; opacity: 0.95; margin-bottom: 16px;">אפשר לראות פרטים נוספים, מוצרים ותצוגה מקדימה של הדף</div>`;
            
            pages.slice(0, 3).forEach((page, index) => {
                askHtml += `<button onclick="confirmShowPage(${index})" style="
                    background: rgba(255,255,255,0.2);
                    color: white;
                    border: 2px solid white;
                    border-radius: 8px;
                    padding: 10px 16px;
                    margin: 4px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 14px;
                    transition: all 0.2s;
                    width: calc(33% - 8px);
                " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">${page.title}</button>`;
            });
            
            askHtml += `<div style="margin-top: 12px; font-size: 12px; opacity: 0.9;">💡 או לחץ על "צפה בדף" בתמונה למעלה</div>`;
            
            askDiv.innerHTML = askHtml;
            messagesDiv.appendChild(askDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // Store pages for confirmShowPage function
            window.stavCurrentPages = pages;
        }
        
        // Confirm and show page when user clicks - FIRST show text details, THEN ask about preview
        async function confirmShowPage(index) {
            const pages = window.stavCurrentPages || [];
            if (pages[index]) {
                const page = pages[index];
                
                // FIRST: Display text details (already extracted in displayPageOptions)
                // Remove the "ask to show" message
                const messagesDiv = document.getElementById('stavChatMessages');
                const askDivs = messagesDiv.querySelectorAll('.stav-message.bot');
                askDivs.forEach(div => {
                    if (div.innerHTML.includes('האם תרצה לראות את הדף')) {
                        div.remove();
                    }
                });
                
                // Show text details (fetch fresh if needed)
                await displayPagePreview(page, 'stavChatMessages');
                
                // THEN ask if they want to open the actual website
                const openDiv = document.createElement('div');
                openDiv.className = 'stav-message bot';
                openDiv.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border-radius: 12px;
                    padding: 16px;
                    margin: 12px 0;
                `;
                const pageUrl = `/users/${page.userId}/${page.pageId}_html`;
                openDiv.innerHTML = `
                    <div style="font-weight: 600; font-size: 16px; margin-bottom: 12px;">👁️ האם תרצה לפתוח את האתר?</div>
                    <div style="font-size: 14px; opacity: 0.95; margin-bottom: 16px;">אפשר לפתוח את הדף המלא בדפדפן</div>
                    <button onclick="window.open('${pageUrl}', '_blank')" style="
                        background: rgba(255,255,255,0.2);
                        color: white;
                        border: 2px solid white;
                        border-radius: 8px;
                        padding: 10px 16px;
                        cursor: pointer;
                        font-weight: 600;
                        font-size: 14px;
                        transition: all 0.2s;
                        margin-right: 8px;
                    " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">פתח באתר</button>
                    <button onclick="this.parentElement.remove()" style="
                        background: rgba(255,255,255,0.1);
                        color: white;
                        border: 1px solid rgba(255,255,255,0.5);
                        border-radius: 8px;
                        padding: 10px 16px;
                        cursor: pointer;
                        font-size: 14px;
                    ">לא עכשיו</button>
                `;
                messagesDiv.appendChild(openDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        }
        
        // Helper: Scroll iframe to main title or hero section
        function scrollIframeToMainTitle(iframe) {
            try {
                if (!iframe) return;
                const doc = iframe.contentDocument || iframe.contentWindow?.document;
                if (!doc) return;
                const selectors = [
                    '[data-main-title]',
                    '[role="heading"][aria-level="1"]',
                    'header h1',
                    'main h1',
                    'h1',
                    'main h2',
                    'h2',
                    'h3', // Added h3 as fallback
                    '[itemprop="name"]',
                    '[data-title], [data-page-title]',
                    "[id*='title' i]", "[class*='title' i]",
                    "[id*='header' i] h1, [class*='header' i] h1",
                    "[id*='hero' i]", "[class*='hero' i]", // More hero selectors
                    '#hero h1, .hero h1, #hero, .hero',
                    "[id*='main' i]", "[class*='main' i]", // More main selectors
                    '#main, main',
                    '.container h1', '.container h2', // Container selectors
                    '#content, .content', // Content area
                    'article h1', 'article h2', 'article' // Article selectors
                ];
                let target = null;
                for (const sel of selectors) {
                    const el = doc.querySelector(sel);
                    if (el) { target = el; break; }
                }
                // Heuristic: find first prominent heading-like element by font-size/weight near top
                if (!target) {
                    try {
                        const walkerRoot = doc.body || doc.documentElement;
                        const candidates = Array.from(walkerRoot.querySelectorAll('h1, h2, h3, h4, div, p, span, [class*="title" i], [class*="heading" i], [class*="hero" i]'));
                        const scored = candidates.map(el => {
                            const cs = iframe.contentWindow.getComputedStyle(el);
                            const fontSize = parseFloat(cs.fontSize) || 0;
                            const fontWeight = parseInt(cs.fontWeight, 10) || 400;
                            const rect = el.getBoundingClientRect();
                            const distance = Math.max(0, rect.top);
                            const textLength = (el.textContent || '').trim().length;
                            // Prefer large, bold, near top, with reasonable text length (10-100 chars)
                            const textScore = (textLength >= 10 && textLength <= 100) ? 15 : 0;
                            const score = fontSize * 3 + (fontWeight >= 600 ? 30 : 0) + textScore - distance * 0.02;
                            return { el, score, fontSize, distance };
                        }).filter(x => {
                            const rect = x.el.getBoundingClientRect();
                            return x.el && x.score > 0 && rect.top >= 0 && rect.top < 1400 && x.fontSize >= 16;
                        });
                        if (scored.length > 0) {
                            scored.sort((a,b) => b.score - a.score);
                            target = scored[0].el;
                            console.log('✅ Found title via smart scoring:', target.tagName, 'fontSize:', scored[0].fontSize, 'score:', scored[0].score);
                        }
                    } catch (_) {}
                }
                // Try match og:title to a heading text
                if (!target) {
                    const og = doc.querySelector('meta[property="og:title"]')?.content || '';
                    const titleTag = doc.querySelector('title')?.textContent || '';
                    const expected = (og || titleTag || '').trim();
                    if (expected) {
                        const headings = Array.from(doc.querySelectorAll('h1, h2, [role="heading"]'));
                        target = headings.find(h => (h.textContent || '').trim().includes(expected)) || null;
                    }
                }
                // Compute sticky header offset if exists
                let offset = 10; // Very small offset to show more content
                try {
                    const sticky = doc.querySelector('header, .sticky, .fixed');
                    if (sticky) {
                        const rect = sticky.getBoundingClientRect();
                        if (rect && rect.height) offset = Math.min(40, Math.max(10, rect.height + 5));
                    }
                } catch (_) {}
                let y = 0;
                if (target) {
                    const rect = target.getBoundingClientRect();
                    y = rect.top + (iframe.contentWindow?.pageYOffset || 0) - offset;
                    console.log('✅ Found title element:', target.tagName, ', scrolling to:', y);
                } else {
                    // If no title found, scroll to a fixed position that shows content
                    y = 400; // Scroll to 400px - should show main content
                    console.log('⚠️ No title found, scrolling to fallback position:', y);
                }
                // 🎬 Smooth auto-scroll: scroll directly from top to the main title
                const targetY = Math.max(0, y);
                iframe.contentWindow?.scrollTo({ top: 0, behavior: 'instant' }); // Start from top
                iframe.style.opacity = '1';
                
                // 🎬 Auto-scroll smoothly to the main title (faster, 2 seconds)
                setTimeout(() => {
                    let currentY = 0;
                    const duration = 2000; // 2 seconds (faster!)
                    const startTime = performance.now();
                    
                    function animateScroll(currentTime) {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Ease-in-out function for smooth acceleration/deceleration
                        const easeInOut = progress < 0.5
                            ? 2 * progress * progress
                            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                        
                        currentY = targetY * easeInOut;
                        iframe.contentWindow?.scrollTo({ top: currentY, behavior: 'auto' });
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateScroll);
                        }
                    }
                    
                    requestAnimationFrame(animateScroll);
                }, 300); // Start scrolling faster (300ms delay instead of 500ms)
            } catch (_) {
                if (iframe) iframe.style.opacity = '1';
            }
        }
        
        // Display page preview in Stav chat - ALWAYS fetch fresh data from page
        // Options: { anchor: 'section-id', queryParams: {key: value}, scrollTo: 'selector' }
        async function displayPagePreview(page, containerId, options = {}) {
            console.log('🖼️ displayPagePreview() called for:', page?.title, 'options:', options);
            
            const container = document.getElementById(containerId);
            if (!container) {
                console.error('❌ Container not found:', containerId);
                return;
            }
            
            // Build URL with optional query params and anchor
            let pageUrl = `/users/${page.userId}/${page.pageId}_html`;
            
            // Add query parameters if provided
            if (options.queryParams && Object.keys(options.queryParams).length > 0) {
                const params = new URLSearchParams(options.queryParams);
                pageUrl += `?${params.toString()}`;
            }
            
            // Add anchor/hash if provided (for navigation to specific section)
            if (options.anchor) {
                pageUrl += `#${options.anchor}`;
            }
            
            console.log('📍 Final iframe URL:', pageUrl);
            
            // ALWAYS fetch fresh data from the actual page HTML (without query params/anchor)
            const basePageUrl = `/users/${page.userId}/${page.pageId}_html`;
            console.log('🔍 Fetching fresh page data for preview:', basePageUrl);
            try {
                const pageResponse = await fetch(basePageUrl);
                if (pageResponse.ok) {
                    const html = await pageResponse.text();
                    
                    // Extract live data from HTML
                    const liveContactInfo = extractLiveContactInfo(html);
                    const liveProducts = extractLiveProducts(html);
                    
                    // Update page with live data
                    page.liveContactInfo = liveContactInfo;
                    page.liveProducts = liveProducts;
                    
                    console.log('✅ Loaded live data:', {
                        contact: liveContactInfo,
                        productsCount: liveProducts.length
                    });
                } else {
                    console.error('❌ Failed to fetch page:', pageResponse.status);
                }
            } catch (error) {
                console.error('❌ Error fetching page data:', error);
            }
            
            // 🎯 Just show the iframe preview - NO text repetition!
            
            // AUTOMATICALLY show iframe preview at the end - Stav opens it herself
            // Using the SAME style as page-preview class
            const previewDiv = document.createElement('div');
            previewDiv.className = 'page-preview';
            previewDiv.style.cssText = `
                opacity: 0;
                transform: translateY(20px);
                transition: all 0.5s ease;
            `;
            
            previewDiv.innerHTML = `
                <div class="preview-header">
                    <h3>📱 תצוגה מקדימה: ${page.title || 'הדף'}</h3>
                </div>
                <div class="preview-content">
                    <iframe id="stav-preview-iframe" src="${pageUrl}" width="100%" height="500" frameborder="0" style="opacity: 0; transition: opacity 0.8s ease;" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
                </div>
            `;
            
            container.appendChild(previewDiv);
            container.scrollTop = container.scrollHeight;
            
            // Animate iframe in after a delay
            setTimeout(() => {
                previewDiv.style.opacity = '1';
                previewDiv.style.transform = 'translateY(0)';
            }, 500);

            // After iframe mounts, adjust height to content and scroll to main heading/center
            setTimeout(() => {
                const iframe = previewDiv.querySelector('#stav-preview-iframe');
                if (!iframe) {
                    console.error('❌ Iframe not found!');
                    return;
                }
                
                console.log('🎬 Iframe element found, waiting for load...');
                
                // Handle iframe load
                iframe.addEventListener('load', () => {
                    console.log('✅ Iframe loaded successfully!');
                    // Fade in the iframe
                    iframe.style.opacity = '1';
                    
                    try {
                        // 🎯 FIX: Check if iframe is accessible before accessing contentDocument
                        if (!iframe.contentWindow) {
                            console.warn('⚠️ Iframe contentWindow not accessible (CORS or not loaded)');
                            return;
                        }
                        
                        const doc = iframe.contentDocument || iframe.contentWindow?.document;
                        if (!doc) {
                            console.warn('⚠️ Iframe document not accessible (CORS or not loaded)');
                            return;
                        }
                        
                        console.log('✅ Can access iframe document - injecting styles');
                        // Inject compact preview styles to reduce visual length
                        const style = doc.createElement('style');
                        style.textContent = `
                            html, body { overscroll-behavior: none; }
                            body { padding-top: min(24px, 4vh); }
                            #hero, .hero { margin-bottom: 12px !important; }
                            section { margin-block: 12px !important; }
                            img, video { max-height: 48vh; object-fit: cover; }
                            header.sticky, header.fixed { position: sticky; top: 0; }
                        `;
                        doc.head && doc.head.appendChild(style);
                        console.log('✅ Styles injected into iframe');
                    } catch (error) {
                        console.warn('⚠️ Cannot inject styles into iframe:', error.message);
                    }
                    
                    // Scroll to specific section if anchor provided, otherwise scroll to main title
                    if (options.anchor) {
                        console.log('🎯 Attempting to scroll to anchor:', options.anchor);
                        try {
                            // 🎯 FIX: Check if iframe is accessible before accessing contentDocument
                            if (!iframe.contentWindow) {
                                console.warn('⚠️ Iframe contentWindow not accessible (CORS or not loaded)');
                                scrollIframeToMainTitle(iframe);
                                return;
                            }
                            
                            const doc = iframe.contentDocument || iframe.contentWindow?.document;
                            if (!doc) {
                                console.warn('⚠️ Iframe document not accessible (CORS or not loaded)');
                                scrollIframeToMainTitle(iframe);
                                return;
                            }
                            
                            if (doc) {
                                const targetElement = doc.getElementById(options.anchor) || 
                                                     doc.querySelector(`[id*="${options.anchor}"]`) ||
                                                     doc.querySelector(`section:has(h2:contains("${options.anchor}"))`);
                                
                                if (targetElement) {
                                    console.log('✅ Found target element, scrolling...');
                                    setTimeout(() => {
                                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                    }, 300);
                                } else {
                                    console.warn('⚠️ Target element not found, falling back to main title scroll');
                                    scrollIframeToMainTitle(iframe);
                                }
                            }
                        } catch (error) {
                            console.warn('⚠️ Cannot scroll to anchor:', error.message);
                            scrollIframeToMainTitle(iframe);
                        }
                    } else {
                        // Default: scroll to main title using robust helper
                    scrollIframeToMainTitle(iframe);
                    // Retry scroll after components/styles settle
                    setTimeout(() => scrollIframeToMainTitle(iframe), 250);
                    setTimeout(() => scrollIframeToMainTitle(iframe), 900);
                    }
                }, { once: true });
                
                // Handle iframe errors
                iframe.addEventListener('error', (e) => {
                    console.error('❌ Iframe failed to load:', e);
                    // Show error message in iframe
                    iframe.style.display = 'none';
                    const errorMsg = document.createElement('div');
                    errorMsg.style.cssText = 'padding: 40px; text-align: center; color: #dc2626; background: #fef2f2; border-radius: 8px; margin: 20px;';
                    errorMsg.innerHTML = `
                        <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
                        <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">שגיאה בטעינת הדף</div>
                        <div style="font-size: 14px; color: #991b1b;">לא הצלחנו לטעון את תצוגת הדף. נסה ללחוץ על הקישור למעלה.</div>
                    `;
                    iframe.parentElement.appendChild(errorMsg);
                });
            }, 50);
        }

        // Open fullscreen page preview modal
        function openPagePreviewModal(pageUrl, pageTitle) {
            console.log('🎬 Opening fullscreen modal:', pageTitle);
            const modal = document.getElementById('page-preview-modal');
            const iframe = document.getElementById('modal-page-iframe');
            const titleEl = document.getElementById('modal-page-title');
            const linkEl = document.getElementById('modal-page-link');
            
            if (modal && iframe && titleEl && linkEl) {
                titleEl.textContent = pageTitle;
                iframe.src = pageUrl;
                linkEl.href = pageUrl;
                modal.style.display = 'block';
                document.body.style.overflow = 'hidden';
            }
        }

        // Close fullscreen page preview modal
        function closePagePreviewModal() {
            console.log('🎬 Closing fullscreen modal');
            const modal = document.getElementById('page-preview-modal');
            const iframe = document.getElementById('modal-page-iframe');
            
            if (modal && iframe) {
                modal.style.display = 'none';
                iframe.src = '';
                document.body.style.overflow = 'auto';
            }
        }

        // Close modal with ESC key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closePagePreviewModal();
            }
        });

        // Handle Enter key in Stav input
        // Check Stav status and hide if inactive
        async function checkStavStatus() {
            try {
                const response = await fetch('/api/stav/status');
                const data = await response.json();
                
                // Hide Stav if not active or not enabled
                if (!data.active || !data.enabled) {
                    // Hide Stav button
                    const stavButton = document.querySelector('button[onclick="toggleStavChat()"]');
                    if (stavButton) {
                        stavButton.style.display = 'none';
                    }
                    
                    // Hide Stav chat window
                    const stavWindow = document.getElementById('stavChatWindow');
                    if (stavWindow) {
                        stavWindow.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Error checking Stav status:', error);
                // If error, show Stav by default (fail open)
            }
        }
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Check Stav status first
            await checkStavStatus();
            
            const stavInput = document.getElementById('stavChatInput');
            if (stavInput) {
                stavInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendStavMessage();
                    }
                });
            }
            // Open Stav in fullscreen when toggled
            const win = document.getElementById('stavChatWindow');
            if (win) {
                const origToggle = window.toggleStavChat;
                window.toggleStavChat = function() {
                    if (typeof origToggle === 'function') origToggle();
                    win.classList.add('fullscreen');
                }
            }
        });
      </script>
  </body>
</html>